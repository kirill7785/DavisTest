unit MainUnit;
// Цели.
// Не нужно гнаться за наращиванием функциональности,
// надо стремиться писать небольшой по объёму код,
// хорошо отлаженый, прошедший тестирование и
// решающий свою задачу на должном уровне.

// главный модуль программы
// Консервация: 19 августа 09.
// Среда Программирования Delphi 6.
// Текст программы очищен  от устаревшего кода и содержит порядка 4000 строк.
// Настало время консервации и дальнейшего пересмотра всей
// логики программы, чтобы её можно было продолжать писать после перерыва или в свободное время.
// Код готов к распечатке и анализу.
// Замечания:
// Хорошо бы повозится с дискретным аналогом и улучшить его:
// добавить нестационарность, Обербека-Буссинеска ускорение свободного падения в виде
// гармонической функции времени.
// также возможно имеет смысл предусмотреть другие геометрии (например Чохральского)
// и неравномерность секи по способу 2.
// Решатели дискретных аналогов самая сложная тема для рассмотрения:
// градиентные итерационные методы (применимы ли они ?).
// больной вопрос уравнение для поправки давления как его корректно решить и как составить.

// Универсальность требует применения универсальных вычислительных процедур.
// Не нужно писать двадцать функций делающих примерно одно и тоже с незначительными изменениями
// Нужно писать одну универсальную функцию. Объём сопровождаемого года должен быть невысок.
// Однако если универсальность кода сильно препятствует его простоте следует от неё отказаться
// или написать высококачественные коментарии из которых ясен принцип действия универсальной процедуры.
// Создание матричных солверов путь к универсальности.
// Здесь встаёт задача эффективного использования технологии разреженных матриц.

// 11 июня 2010 .
// Задачи: 1. реализация алгоритма SIMPLER. 2. VOF метод.
// Динамическая сетка по прежнему не работает. Надо исправить.
// переписать ядро солвера на чистый С с использованием Open MP в Visual Studio 2010.


interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ExtCtrls, Menus, Math, ShellAPI, ComCtrls;

type
   //Float = Real;
   Float = Extended;

  // тип динамический массив вещественных чисел
  TmyDynArray = array of Float;

  TmyNode = record
     // структура одного узла
     // 0 - пустой узел не принадлежащий расчётной сетке (hollow point).
     itype : Integer; // тип узла ( 1 - внутренний, 2 - граничный узел)
     i,j : Integer; // координаты узла
     // для узла также возможно имеет смысл хранить и другую информацию:
     // объём контрольного объёма, длина стенки контрольного объёма по x,
     // длина стенки контрольного объёма по y. и т.д.
     dx, dy, dV : Float;
     dxe, dxw, dyn, dys : Float;
     // Для граничного условия Неймана
     iboundary : Integer; // уникальный номер границы к которой принадлежит эта точка.
     chnormal : Char; // внутренняя нормаль к границе
     // виды угловых точек
     // 0 - не угловая
     // 1 - левый нижний угол,
     // 2 - правый нижний угол,
     // 3 - левый верхний угол,
     // 4 - правый верхний угол
     // 5 - угол пятиточечный крест.
     iugol : Integer;
     // в уравнении для поправки давления
     // важно знать соседние с угловыми точками
     // это можно определить без дополнительной структуры данных

  end;

  TdynArraymyNode = array of TmyNode;

  MatrixCoef = record
     // структура данных со значением
     // коэффициентов для одного уравнения системы
     // на пятиточечном шаблоне.
     // Данная структура используется
     // в уравнениях для каждой из компонент скорости
     // а также в уравнении для поправки давления.
     dae : Float; // восток
     daw : Float; // запад
     dan : Float; // север
     das : Float; // юг
     dap : Float; // центральная точка
  end; // MatrixCoef

  InitializeValue = record
     // Данная структура данных используется
     // для начальной инициализации
     // полевых величин являющихся искомыми функциями:
     // поля температуры,
     // скорости, давления и т.д.
     TempInit : Float; // начальное значение поля температур
     XvelInit : Float; // начальное поле горизонтальной скорости
     YvelInit : Float; // начальное поле вертикальной скорости
  end; // InitializeValue

  MaterialProperties = record
      // данная структура
      // содежит постоянные параметры
      // материалов
      drho : Float; // плотность
      dlambda : Float; // теплопроводность
      dcp : Float; // теплоёмкость
      dmu : Float; // динамическая вязкость
      beta : Float; // коэффициент линейного температурного расширения
  end; // MaterialProperties

  SourceInEquation = record
      // линеаризованный источниковый
      // член в уравнении
      dSc : Float; // постоянная составляющая
      dSp : Float; // линеаризованная
  end; // SourceInEquation

  // Этот тип данных введён, но
  // код программы на него ещё пока не перешёл.
  MySource = record
     // источниковые члены всех уравнений
     Temperature : SourceInEquation; // источниковый член уравнения теплопроводности
     VxVelocity  : SourceInEquation; // для горизонтальной скорости
     VyVelocity  : SourceInEquation; // для вертикальной скорости
     Omega : SourceInEquation; // для вихря
  end; // MySource

  // структура данных для алгоритма
  // ТОМАСА (трёхдиагональной матрицы или
  // метода прогонки).
  TOMASelem = record
       // коэффициенты одного уравнения
       // СЛАУ с трёхдиагональной матрицей
       // обозначения в соответствии
       //  с книжкой Патанкара стр. 47
       a : Float;
       b : Float;
       c : Float;
       d : Float;
       // прогоночные коэффициенты
       P : Float;
       Q : Float;
  end; // TOMASelem

  // структура данных
  // для параметров релаксации
  TRelaxFactors = record
     // параметры релаксации  для алгоритма SIMPLE
     xVelRelax : Float; // для горизонтальной компоненты скорости
     yVelRelax : Float; // для вертикальной компоненты скорости
     PressureRelax : Float; // для давления
     // параметр релаксации для SOR:
     // последовательной верхней релаксации.
     // используется при нахождении поправки давления методом Гаусса-Зейделя
     pSORPressure : Float;
     pSORpresr : Float; // для давления в алгоритме SIMPLER
     // для поля температур
     pSORTempreture : Float;
     // скорость
     pSORVelocityVx : Float;
     pSORVelocityVy : Float;
     // иногда требуется замедлить скорость изменения
     // источникового члена от итерации к итерации.
     // Это может потребоваться при моделировании естественной конвекции
     // при очень больших числах Рэлея.
     prelaxBodyForce : Float; // для естественной конвекции при очень больших числах Рэлея.
  end; // TRelaxFactors

  // структура данных с количеством итераций
  // внутри одной итерации алгоритма SIMPLE
  TIterCountSIMPLE = record
      // количество итераций
      // внутри одной итерации
      // алгоритма SIMPLE

      // количество итераций для преодоления нелинейности
      iterVxNonLin : Integer;  // для Vx
      iterVyNonLin : Integer;  // для Vy
      // количество итераций для решения номинально линейной системы
      iterVxLin : Integer; // для Vx
      iterVyLin : Integer; // для Vy
      // решать ли нелинейные уравнения для
      // компонент скорости совместно ?
      bCoupledVelocitySolver : Boolean;

      // количество итераций для
      //  уравнения поправки давления
      iterPamendment : Integer;
      // количество итераций для давления в алгоритме SIMPLER
      iterPressure : Integer;

      // для задач с учётом естественной конвекции
      // внутри одной итерации алгоритма SIMPLE
      // требуется решать также уравнение теплопроводности
      // с учётом конвективного члена.
      iterTemperature : Integer;  // поле температур

      // количество итераций для
      // определения функции тока
      iterStreamFunction : Integer;  // функция тока

  end; // TIterCountSIMPLE

  // структура данных позволяющая
  // индивидуально выбрать солвер к каждому уравнению
  TMyiTypeSolver = record
     // перечислим типы солверов
     // 1 - последовательный поточечный метод Гаусса-Зейделя (ГЗ)
     // 2 - метод переменных направлений (гибрид ГЗ и алгоритма ТОМАСА)
     // 3 - прямой метод исключения Гаусса
     // 4 - метод сопряжённых градиентов Хестенса и Штифеля
     // 5 - алгоритм Ю.Г. Соловейчика [1993]

     // для температуры
     itemperature : Integer; // солвер для поля температур
     // солвер для компонент скорости
     ivelocity : Integer;
     // солвер для поправки давления
     ipamendment : Integer;
     // для функции тока
     istreamfunction : Integer;

  end; // TMyiTypeSolver

  // структура данных для
  // формирования разреженной матрицы
  // в формате CRS для метода Сопряжённых Градиентов
  TmyNonZeroElemMatrix = record
     // нужно хранить индексы
     // i,j определяющие местоположение
     // элемента в массиве
     i : Integer;
     j : Integer;
     // значение ненулевого элемента
     aij : Float;
     // специальный ключ для упорядочивания
     // по строкам
     key : Integer;

  end; // TmyNonZeroElemMatrix

  // структура со значением невязок
  // для контроля сходимости вычислительного
  // процесса
  TmyResidualControlSolution = record
     // здесь задаётся пороговое
     // значение невязки по
     // достижению которого
     // решение считается сошедшимся
     temp : Float; // невязка по температуре
     Vx, Vy : Float; // невязки по компонентам скорости
     Pamendment : Float; // невязка для поправки давления
     continity : Float; // нескомпенсированные источники массы
     streamfunction : Float; // невязка для функции тока
     Pressure : Float; // невязка для давления в алгоритме SIMPLER
  end; // TmyResidualControlSolution

  // структура с вибрационными параметрами при
  // ускорении свободного падения меняющемуся
  // по гармоническому закону.
  TGravityVibrations = record
     bOn : Boolean; // Булево значение показывающее включены ли вибрации
     // по умолчанию вибрации выключены, см. метод FormCreate.
     // В случае вибраций сила
     // тяжести меняется по гармоническому закону:
     // g_vibr = -4*((MPI*Frequency)^2)*Amplitude*Sin(2*MPI*Frequency*realFlowTime);
     Amplitude : Float; // амплитуда вибраций
     Frequency : Float; // частота вибраций
     // Информация о направлении вибраций содержится в следующей переменной:
     // chDirect принимающей только два значения: x или y. Они указывают на направление вибраций.
     chDirect : Char; // направление вибраций
  end; // TGravityVibrations

  // структура с параметрами вибрации погруженного вибратора
  TVibrations = record
      bOn : Boolean; // Включены ли вибрации
      Amplitude : Float; // амплитуда вибраций
      Frequency : Float; // частота вибраций
      // Метод послойной упругой деформации
      // начальная фиксированная граница
      jdstart : Integer; // нижнего деформируемого блока
      // подвижная верхняя граница
      jdend : Integer; // нижнего деформируемого блока
      // начальная подвижная граница
      jupstart : Integer; // верхнего деформируемого блока
      // конечная фиксированная граница
      jupend : Integer;  // верхнего деформируемого блока
      // уникальный идентификатор вибрирующей границы
      unicalidentifire : Integer;
      bOn2 : Boolean; // прорисовывать ли вибрирующее тело
      // уникальный номер вибрирующего блока
      unickbricknum : Integer;
      // уникальный номер контактирующего с подвижным блока
      // он расположен сверху подвижного блока как в методе Бриджмена.
      bBridshmen : Boolean;
      uniccontacktupbricknum : Integer;
  end;

  // Построение графика невязки
  TResidualPlot = record
      temperature : Float; // невязка температуры
      continity : Float; // нескомпенсированные источники массы
      Vx,Vy : Float; // невязка - скорость
  end;

  TForm1 = class(TForm)
    // здесь перечислены  различные пункты меню.
    MainMenu1: TMainMenu;  // главное меню программы
    File1: TMenuItem; // операции с файлами
    Mesh1: TMenuItem; // меню генерации расчётной сетки
    Define1: TMenuItem;
    Solve1: TMenuItem;  // вызывает солвер
    Display1: TMenuItem;
    Mesh2: TMenuItem;
    General1: TMenuItem;
    Animate1: TMenuItem; // заголовок меню анимации
    empreture2: TMenuItem;
    Library1: TMenuItem;
    MARENAtest1: TMenuItem;
    N2Dplot1: TMenuItem;
    UseInterpolate1: TMenuItem;
    mainMemo: TMemo;
    // выбор решателя для каждого из
    // решаемых уравнений
    SelectSolver1: TMenuItem;
    // выбор схемы аппроксимации
    // конвективного члена
    ApproxConvection1: TMenuItem;
    // выбор решаемого набора уравнений
    // или уравнения
    Equation1: TMenuItem;
    // меню задания свойств материалов
    Materials1: TMenuItem;
    // меню задания граничных условий
    BoundaryCondition1: TMenuItem;
    // меню где можно задать источниковый член
    Source1: TMenuItem;
    Controls1: TMenuItem;
    Solution1: TMenuItem;
    RelaxationFactors1: TMenuItem;
    // задаёт параметры инициализации
    // которые потом используются для инициализации решения
    // перед расчётом
    Initialize1: TMenuItem;
    // вызывает меню
    // из которого потом можно будет запустить вычисление
    Run1: TMenuItem;
    // пункт меню где можно настроить
    // метод сопряжённых градиентов
    SoprGrad1: TMenuItem;
    // пункт меню где можно задать ускорение свободного падения
    Gravity1: TMenuItem;
    CreateGeom1: TMenuItem;
    TreeView1: TTreeView;
    DynamicMesh1: TMenuItem;
    MainPaintBox: TPaintBox;
    SIMPLE1: TMenuItem;
    Pressure1: TMenuItem;
    initialize2: TMenuItem;
    Patch1: TMenuItem;
    Read1: TMenuItem;
    Write1: TMenuItem;
    Export1: TMenuItem;
    Close1: TMenuItem;
    ecplot1: TMenuItem;
    Mesh3: TMenuItem;
    Mesh4: TMenuItem;
    OpenDialog1: TOpenDialog;
    // закрывает главное приложение
    procedure Close1Click(Sender: TObject);
    // вызывает простейший генератор сеток
    procedure Mesh2Click(Sender: TObject);
    procedure empreture2Click(Sender: TObject);
    // загружает МАРЕНА тест
    procedure MARENAtest1Click(Sender: TObject);
    // вызывает меню где можно настроить солвер
    procedure General1Click(Sender: TObject);
    // данный метод вызывается при создании
    // главной экранной формы приложения
    procedure FormCreate(Sender: TObject);
    // вызывает модуль с графической оболочкой
    // в котором производится высокоуровневое
    // управление решением
    procedure Run1Click(Sender: TObject);
    // вызывает менюшку где можно
    // изменить или задать параметры материалов
    procedure Materials1Click(Sender: TObject);
    // вызывает меню где можно передать картинку
    // в программу tecplot
    procedure ecplot1Click(Sender: TObject);
    // вызывает меню где можно изменить
    // или задать граничные условия
    procedure BoundaryCondition1Click(Sender: TObject);
    // вызывает меню где можно изменить или задать источниковые члены
    procedure Source1Click(Sender: TObject);
    // вызывает меню где можно вызвать реализованную визуализацию
    procedure N2Dplot1Click(Sender: TObject);
    // выбор способа интерполяции
    procedure UseInterpolate1Click(Sender: TObject);
    // выбор решателя: ГЗ или гибрид-ГЗ-Томас
    // также есть прямой метод исключения Гаусса и
    // метод сопряжённых градиентов.
    // Предусмотрена возможность выбора отдельного решателя
    // для каждого из уравнений.
    procedure SelectSolver1Click(Sender: TObject);
    // параметры релаксации
    procedure RelaxationFactors1Click(Sender: TObject);
    // выбор аппроксимации конвективных членов
    procedure ApproxConvection1Click(Sender: TObject);
    // выбор набора решаемых уравнений
    procedure Equation1Click(Sender: TObject);
    // вызывает меню где выставляются пороговые значения
    // невязок по достижению которых решение считается сошедшимся.
    procedure Solution1Click(Sender: TObject);
    // позволяет настроить солвер сопряжённых градиентов
    procedure SoprGrad1Click(Sender: TObject);
    // вызывает меню где можно задать ускорение свободного падения
    procedure Gravity1Click(Sender: TObject);
    procedure CreateGeom1Click(Sender: TObject);
    // доступ к менюшкам по древовидному дереву
    procedure TreeView1DblClick(Sender: TObject);
    // здесь задаются параметры динамической сетки
    procedure DynamicMesh1Click(Sender: TObject);
    // прорисовка графиков невязок
    procedure FormPaint(Sender: TObject);
    // задаёт структуру однй итерации алгоритма simple
    procedure SIMPLE1Click(Sender: TObject);
    // настройки для поправки давления:
    // выбор условий Неймана или подхода Патанкара.
    procedure Pressure1Click(Sender: TObject);
    // вызывает меню где можно изменить
    // или задать параметры инициализации
    // искомых величин
    procedure initialize2Click(Sender: TObject);
    procedure Patch1Click(Sender: TObject);
    procedure Mesh4Click(Sender: TObject);
    procedure Mesh3Click(Sender: TObject);
    


  private
    { Private declarations }

  public
    { Public declarations }
    // к данным можно получить доступ из других модулей
    // а методы можно вызывать из других модулей

    // данные

    // для исследования сходимости гидродинамических
    // алгоритмов SIMPLE
    freport : TStrings;
    // Последовательность узлов сетки (контрольных объёмов)
    mapPT : TdynArraymyNode;  // карта для обычных переменных T и P.
    mapVx : TdynArraymyNode;  // карта для горизонтальной скорости
    mapVy : TdynArraymyNode;  // карта для вертикальной скорости
    // максимальное количество контрольных объёмов
    // для обыкновенных переменных
    imaxnumbernode : Integer;
    // для шахматной сетки.
    imaxnumbernodeVx : Integer; // горизонтальная скорость
    imaxnumbernodeVy : Integer; // вертикальная скорость
    // для управления солвером
    bweShouldContinue : Boolean; // для преостановки вычислений как только становится false
    // для выполнения инициализации:
    // 1 - чистая теплопроводность,
    // 2 - теплопроводность с учётом конвективного члена на основе MARENA тест,
    // 3 - чистый Навье-Стокс без теплопроводности,
    // 4 - Навье-Стокс с учётом теплопроводности.
    // 5 - VOF метод.
    bweShouldInitialize : array [1..5] of Boolean; // проверка нужно ли инициализировать переменные и выделить память перед началом счёта.
    // индивидуальный выбор солвера для каждого уравнения в отдельности
    // 1 <=> Гаусса-Зейделя, 2 <=> метод переменных направлений.
    // 3 <=> прямой метод исключения Гаусса, 4 <=> метод сопряжённых градиентов Хестенса и Штифеля
    itypesolver : TMyiTypeSolver;

    // Метод сопряжённых градиентов Хестенса и Штифеля требует от матрицы
    // только реализации умножения её на некоторый вектор.
    // более эффективной реализацией метода сопряжённых градиентов
    // как  по памяти так и по быстродействию является его
    // реализация на основе технологии хранения матрицы CRS.
    // В данной программе метод сопряжённых градиентов реализован с учётом CRS технологии хранения разреженной матрицы.
    // для реализации такого подхода требуется сортировка.
    // Здесь реализована быстрая сортировка Хоара и Пирамидальная сортировка.
    // у пользователя должна быть возможность выбора алгоритма сортировки.
    itypesorter : Integer; // 1 - quick sort, 2 - Heap sort.
    // контроль сходимости
    // пороговые значения невязок.
    rcs : TmyResidualControlSolution;
    // какую норму использовать ?
    // 1 - евклидову, 2 - кубическую норму, 3 - октаэдрическую норму
    ibasenorma : Integer;

    myrelaxfactors : TRelaxFactors; // параметры релаксации
    iterSimple :  TIterCountSIMPLE; // структура одной итерации алгоритма SIMPLE
    btimedepend : Boolean; // стационарная или нестационарная разностная схема
    // для алгоритма SIMPLEC возможно могут потребоваться
    // совсем другие параметры релаксации.
    bsimplec : Boolean; // применять ли алгоритм SIMPLEC ?
    bsimpler : Boolean; // применять ли алгоритм SIMPLER ?
    ishconv : Integer; // тип схемы для конвективного члена
    // выбор граничного условия на выходной границе потока
    // 0 - условия Патанкара, 1 - F[i]=2*F[i-1]-F[i-2];
    ioutflow : Integer;
    // выбор мат модели (набора уравнений и граничных, начальных условий)
    // значения переменной imodelEquation:
    // 1 - чистая теплопроводность,
    // 2 - теплопроводность с учётом конвекции на основе МАРЕНА тест,
    // 3 - чистая гидродинамика,
    // 4 - гидродинамика с учётом теплопроводности.
    // 5 - гидродинамика и VOF метод.
    imodelEquation : Integer; // уравнения и их комбинации  которые подвержены решению сейчас
    itercount : Integer; // количество итераций
    iglobalnumberiteration : Integer; // глобальный номер итерации
    dTimeStep : Float; // постоянный шаг по времени
    inumbertimestep : Integer; // количество шагов по времени
    // текущее расчётное время при нестационарном расчёте
    realFlowTime : Float; // оно устанавливается при инициализации решения, а так сохраняется
    // число шагов за период при периодических процессах
    inumberTimeStepDivisionPeriod : Integer;
    // количество периодов
    inumberPeriod : Integer;

    // Некоторые параметры расчётной сетки.
    // При создании (первом запуске) приложения желательно, чтобы
    // избежать сбоев программы вызванных попыткой
    // выполнить расчёт на непостроенной сетке,
    // генерировать некую расчётную сетку по умолчанию:
    // например, равномерную 10 на 10.
    // сейчас это реализовано сразу при создании главной формы.
    dLx,dLy : Float; // размеры расчётной области
    inx, iny : Integer; // количество узлов расчётной сетки по x и y
    xpos, ypos : array of Float; // координаты узлов сетки

    // запись с начальными значениями
    // искомых полевых величин:
    // содержатся начальные значения для
    // температуры, компонент скорости и т.д.
    InitVal : InitializeValue;

    // это одномерное представление двумерного массива [i][j]
    // в соответствии с отображением k=i+(j-1)*inx;
    T      : array of Float; // поле температур
    TOldIteration : array of Float; // поле температур с предыдущей итерации
    ToldTimeStep : array of Float; // поле температур с предыдущего временного слоя
    SF     : array of Float; // функция тока
    Omega  : array of Float; // Вихрь
    OmegaoldTimeStep : array of Float; // вихрь с предыдущего шага по времени
    // скорости рассчитываются на смещённой шахматной сетке
    Vx, Vy : array of Float; // горизонтальная и вертикальная компоненты скорости
    VxOld  : array of Float; // поле скорости Vx с предыдущей итерации
    VyOld  : array of Float; // поле скорости Vy с предыдущей итерации
    VxOldTimeStep : array of Float; // поле скорости Vx с предыдущего временного шага
    VyOldTimeStep : array of Float; // поле скорости Vy с предыдущего временного шага
    P      : array of Float; // давление
    Pamendment : array of Float; // поправка давления
    VOF : array of Float; // VOF метод
    DensityOldTimeStep : array of Float; // значение плотности с предыдущего временного слоя

    kstreamdivision : Integer; // для глобальной средней функции тока
    // массив горизонтальных координат
    // на невозмущённой сетке.
    // используется при анимации движения сетки
    // и при расчёте с вибрацией
    yposfix : array of Float;
    // функция тока
    meanSF1T : array of Float; // средняя функция тока на одном периоде.
    meanSFGl : array of Float; // глобальная средняя функция тока
    meanSF : array of Float; // математическое ожидание функции тока
    // вихрь
    meanOmega1T : array of Float; // средний вихрь на одном периоде
    meanOmegaGl : array of Float; // глобальный средний вихрь
    meanOmega : array of Float;  // математическое ожидание от вихря
    // давление
    meanPressure1T : array of Float; // среднее давление за период
    meanPressureGl : array of Float; // глобальное среднее давление
    meanPressure : array of Float; // математическое ожидание от давления
    // поле температур
    meanT1T : array of Float; // среднеее от температуры на одном периоде
    meanTGl : array of Float; // глобальная средняя температура
    meanT : array of Float; // математическое ожидание от температуры
    // горизонтальная скорость
    meanVx1T : array of Float; // среднее от горизонтальной скорости на одном периоде
    meanVxGl : array of Float; // глобальная средняя горизонтальная скорость
    meanVx : array of Float; // мат. ожидание от горизонтальной компоненты скорости
    // вертикальная скорость
    meanVy1T : array of Float; // среднее от вертикальной скорости на одном периоде
    meanVyGl : array of Float; // глобальная средняя вертикальная скорость
    meanVy : array of Float; // мат. ожидание от  вертикальной компонены скорости


    // значения источниковых членов уравнений
    // используется в специальном меню для
    // изменения или задания источниковых членов
    defmysource : MySource; // источниковые члены уравнений

    // Источниковые члены
    // источниковый член для темперауры
    dSc : array of Float; // постоянная составляющая источникового члена
    dSp : Float; // второй член при линеаризации источникового члена
    // источниковый член для Vx компоненты скорости
    dScVx : Float; // постоянная составляющая (например Буссинесковская dbeta*drho*dgravityx*T)
    dSpVx : Float; // линеаризованная составляющая (в большинстве случаев отсутствует)
    // источниковый член для Vy компоненты скорости
    dScVy : Float; // постоянная составляющая (например Буссинесковская dbeta*drho*dgravityy*T)
    dSpVy : Float; // линеаризованная составляющая (в большинстве случаев отсутствует)


    // постоянные параметры материалов
    // хранятся в структуре MaterialProperties.
    // Схема работы такая:
    // при создании главной формы MainUnit
    // полям этой структуры присваиваются определённые
    // значения.
    // если нужно изменить параметры материалов
    // то это делается в отдельной экраной  форме
    // после посещения которой параметры материалов
    // будут записаны в эту стрктуру.
    // при реализации численных процедур пока правда используются
    // параметры материалов из полей данных приведённых ниже.
    // Полное взаимодействие этих двух представлений пока не налажено.
    matprop : array [0..1] of MaterialProperties;

    // параметры материалов
    lambda : array of Float; // теплопроводность
    drho   : Float; // постоянная плотность
    dcp    : Float; // постоянная теплоёмкость
    dmu    : array of Float; // динамическая вязкость жидкости
    // приближение Буссинеска
    bBussinesk : Boolean; // нужно ли учитывать приближение Буссинеска.
    dgx, dgy : Float; // ускорение свободного падения
    dbeta : Float; // коэффициент температурного расширения
    // Сила тяжести является гармонической функцией времени
    rgravVib : TGravityVibrations; // параметры вибрационного воздействия
    actiVibr : TVibrations; // вибрации погруженного активатора

    imarker : Integer; // маркер конца для отображения графика невязок
    myresplot : array of TResidualPlot; // массив со значениями невязки

    // Граничные условия в уравнении для поправки давления:
    // если = true значит нет влияния от точки на границе как у Патанкара в книжке,
    // а если = false значит условие Неймана равенство нулю нормальной производной.
    bPatankarPressure : Boolean;
    // фиксировать ли уровень поправки давления в одной точке ?
    // true - надо, false - не надо ( только если это допускается методом
    // решения СЛАУ).
    // Например метод Гаусса - Зейделя это допускает, а прямой метод Гаусса нет.
    bipifixpamendment : Boolean;

    // методы
    // используется для уравнения теплопроводности
    // передаёт параметры из формы в программу,
    // задаёт постоянные параметры материалов,
    // задаёт постоянные источникового члена,
    // выделяет память под массивы использующиеся
    // при решениии уравнения теплопроводности
    procedure initparam;
    // используется для решения уравнений Навье-Стокса
    // передаёт параметры из формы в программу
    // задаёт парамеры материалов,
    // выделяет память под массивы для компонент скорости
    // и для давления
    procedure initparam2;
    // инициализация материалов
    // инициализация коэффициента теплопроводности
    procedure initlambda;
    // инициализация коэффициента динамической вязкости
    procedure initmu;
    // инициализация поля температур
    procedure initTemp;
    // инициализация постоянной составляющей источникового члена
    procedure initdSc;
    // инициализация распределения давления
    procedure initPressure;
    // инициализация распределения поправки давления
    // О важности начального распеределения поправки давления
    // в данном случае:
    // Любой итерационный метод решения алгебраических
    // уравнений даёт сходимость решения, абсолютное значение
    // которого определяется начальным приближением.
    procedure initPamendmentZero;
    // инициализация горизонтальной
    // компоненты скорости
    procedure initXvel;
    // инициализация вертикальной
    // компоненты скорости
    procedure initYvel;
    // задание граничных условий для поля температур
    procedure initBoundaryConditionTempreture;
    // задание граничных условий
    // первого рода
    // для горизонтальной компоненты скорости
    procedure initBoundaryConditionVx;
    // задание граничных условий
    // первого рода
    // для вертикальной компоненты скорости
    procedure initBoundaryConditionVy;
    // вызывает визуализатор для функции D
    procedure myDisp;
    // запоминание поля температуры
    // для того чтобы использовать эти значения
    // на следующем временном слое
    // В случае если передаваемый параметр bcopyoldtimetempreture принимает значение true.
    // Если этот параметр принимает значение false то копируется поле температур с предыдущей итерации.
    // Это нужно для сильно нелинейных задач для применения нижней релаксации.
    procedure RememberTOldTimeStep(bcopyoldtimetempreture : Boolean);
    // возвращает наибольшую из величин da, db.
    // используется при аппроксимации конвективного члена
    function maxoper(da,db : Float) : Float;
    // функция A(|P|) для различных схем
    // ishconvection - номер схемы
    // используется при аппроксимации конвективного члена
    function ApproxConvective(fp : Float; ishconvection : Integer) : Float;
    // данная процедура по позиции i,j в матрице для Vx
    // возвращает значения коэффициентов на пятиточечном шаблоне
    procedure Vxcoef(i, j : Integer; var m : MatrixCoef);
    // данная процедура по позиции i,j в матрице для Vx
    // возвращает значения коэффициентов на пятиточечном шаблоне
    // для данного узла i,j в случае когда этот узел находится на правой выходной границе
    procedure VxcoefRight(i, j : Integer; var m : MatrixCoef);
    // данная процедура по позиции i,j в матрице для Vx
    // возвращает значения коэффициентов на пятиточечном шаблоне
    // для данного узла i,j
    // в случае когда выходная граница находится слева
    procedure VxcoefLeft(i, j : Integer; var m : MatrixCoef);
    // для верхней границы
    procedure VxcoefTop(i, j : Integer; var m : MatrixCoef);
    // для нижней границы
    procedure VxcoefBottom(i, j : Integer; var m : MatrixCoef);
    // коэффициенты дискретного аналога для
    // горизонтальной компоненты скорости
    procedure VxGlobalCoef(var mglobal : array of MatrixCoef;  // все коэффициенты дискретного аналога
                           var dbglobal : array of Float);  // часть источникового члена
    // решение нелинейного уравнения для горизонтальной скорости
    // на основе метода переменных направлений.
    procedure SolveVx;
    // данная процедура по позиции i,j в матрице для Vy
    // возвращает значения коэффициентов на пятиточечном шаблоне
    // для данного узла i,j
    procedure Vycoef(i, j : Integer; var m : MatrixCoef);
    // для верхней границы
    procedure VycoefTop(i, j : Integer; var m : MatrixCoef);
    // нижняя граница
     procedure VycoefBottom(i, j : Integer; var m : MatrixCoef);
     // левая стенка
     procedure VycoefLeft(i, j : Integer; var m : MatrixCoef);
     // правая стенка.
     procedure VycoefRight(i, j : Integer; var m : MatrixCoef);
    // коэффициенты дискретного аналога для
    // вертикальной компоненты скорости
    procedure VyGlobalCoef(var mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
                           var dbglobal : array of Float); // часть источникового члена
    // решение нелинейного уравнения для вертикальной скорости
    // методом переменных направлений.
    // в стационарном случае
    procedure SolveVy;
    // совместное решение уравнений для горизонтальной
    // и вертикальной компонент скорости
    // по-моему это несколько улучшит скорость сходимости
    // нелинейных уравнений для компонент скорости
    procedure SolveVxVyCoupled;
    // загружает основной тест
    // программного комплекса МАРЕНА
    // загрузка должна производится только после генерации сетки
    // эти функции можно использовать для инициализации
    // всех обрабатываемых матриц.
    // Такая инициализация сделана при загрузке программы.
    procedure MARENAload;
    // Делает одну иерацию методом Гаусса - Зейделя
    // для универсальной искомой функции U.
    procedure GZUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         var db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // решение СЛАУ с трёхдиагональной матрицей
    // при вертикальной прошивке расчётной области
    procedure TDMAGibridGZUniversalVertical(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           boncond : Integer; // тип граничных условий снизу
                           bonconup : Integer; // тип граничных условий сверху
                           jstart, jend : Integer; // маркеры начала и конца прогонки
                           i : Integer; // номер вертикальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // решение СЛАУ с трёхдиагональной матрицей
    // при горизонтальной прошивке расчётной области
    procedure TDMAGibridGZUniversalGorizontal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           bonconl : Integer; // тип граничных условий слева
                           bonconr : Integer; // тип граничных условий справа
                           istart, iend : Integer; // маркеры на чала и конца прогонки
                           j : Integer; // номер горизонтальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // делает одну итерацию методом переменных направлений
    // для универсальной полевой величины U.
    // За тип граничных условий отвечает переменная iboncon.
    // этому методу передаются на вход коэффициенты дискретного аналога
    procedure TDMAGibridGZUniversal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           const map : array of TmyNode; // карта
                           chvariable : Char; // какая переменная рассматривается
                           var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           var db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // Граничное условие II рода на левой стенке
    procedure TempBoundaryCoefLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                   var db : array of Float; // правая часть
                                   qbleft : Float; // заданный тепловой поток на границе
                                   place : TmyNode); // место на карте
    // Граничное условие II рода на правой стенке
    procedure TempBoundaryCoefRight(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                    var db : array of Float; // правая часть
                                    qbright : Float; // заданный тепловой поток на границе
                                    place : TmyNode); // место на карте
    // Граничное условие II рода на нижней стенке
    procedure TempBoundaryCoefBottom(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                     var db : array of Float; // правая часть
                                     qbbottom : Float; // заданный тепловой поток на границе
                                     place : TmyNode); // место на карте
    // Граничное условие II рода на верхней стенке
    procedure TempBoundaryCoefTop(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                  var db : array of Float; // правая часть
                                  qbtop : Float; // заданный тепловой поток на границе
                                  place : TmyNode); // место на карте
    // вычисление коэффициентов дискретного аналога для уравнения
    // теплопроводности.
    procedure TempCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                          var db : array of Float); // правая часть
    // Граничное условие II рода на левой стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                       var db : array of Float; // правая часть
                                       qbleft : Float; // заданный тепловой поток на границе
                                       place : TmyNode); // место на карте
    // Граничное условие II рода на правой стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvRight(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                        var db : array of Float; // правая часть
                                        qbright : Float; // заданный тепловой поток на границе
                                        place : TmyNode); // место на карте
    // Граничное условие II рода на нижней стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvBottom(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                         var db : array of Float; // правая часть
                                         qbbottom : Float; // заданный тепловой поток на границе
                                         place : TmyNode); // место на карте
    // Граничное условие II рода на верхней стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvTop(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                      var db : array of Float; // правая часть
                                      qbtop : Float; // заданный тепловой поток на границе
                                      place : TmyNode); // место на карте
    // вычисляет коэффициенты дискретного аналога для
    // уравнения теплопроводности с учётом конвективного члена
    // Внимание: перед использованием этой процедуры массиву
    // ToldTimeStep должна быть выделена оперативная память и
    //  он должен быть проинициализирован.
    procedure TempConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                            var db : array of Float);   // правая часть
    // Решает задачу стационарной теплопроводности
    // с учётом конвекции или без учёта конвекции
    // в зависимости от параметра bconv: true - с конвективным членом,
    // false - без конвективного члена.
    // Все операции по вычислению коэффициентов
    // дискретного аналога вынесены за пределы цикла.
    // Это можно сделать потому, что значения этих
    // коэффициентов зависят только от координат x и y
    // а сетка неизменна, зависимости коэффициентов
    // дискретного аналога от искомой функции тоже нет,
    // так что задача линейна.
    // недостатком является использование несколько большего
    // количества оперативной памяти.
    // В эту универсальную процедуру включены два решателя:
    // первый на основе метода Гауса-Зейделя, а второй
    // на основе процедуры TDMAGibridGZforT.
    procedure SolveTempSteady(bmessage : Boolean; kfinish : Integer; bconv : Boolean);
    // нестационарный температурный солвер
    // с учётом или без учёта конвективного члена
    // в зависимости от булева параметра bconv: true - с учётом конвективного члена
    // false - чистая теплопроводность.
    procedure SolveTempUnsteady(bconv : Boolean);
    // преобразованные коэффициенты дискретного аналога
    // компонент скорости (см. idirect : 1 - x, 2 - y)
    // которые используются в уравнении для поправки давления.
    function Vcoefpam(i : Integer; j : Integer; idirect : Integer) : Float;
    // решает линейное уравнение для поправки давления
    // ускоренным методом Гаусса-Зейделя
    // ускорение достигается за счёт того, что коэффициенты
    // дискретного аналога не зависят от искомой функции
    // т.е. уравнение линейно и эти коэффициенты можно
    // вычислить только один раз и запомнить.
    procedure SolveGZPamendment(bipifix : Boolean; // фиксировать ли уровень поправки давления  ?
                                   var rescontinity : Float); // нескомпенсированные источники массы
    // коррекция Давления
    procedure CorrectNewPressure;
    // поправочная формула для горизонтальной скорости
    procedure CorrectVx;
    // поправочная формула для вертикальной скорости
    procedure CorrectVy;
    // решает стационарную задачу чистой теплопроводности
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    procedure RunCleanThermalConductionSteady;
    // решает стационарную задачу теплопроводности с учётом конвекции
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    procedure RunConvectiveThermalConductionSteady;
    // алгоритм SIMPLE
    // стационарный алгоритм SIMPLE
    // если bposttemperature = true то с учётом теплопроводности,
    // но без учёта приближения Буссинеска,
    // т.е. гидродинамика не зависит от теплопроводности,
    // а теплопроводность зависит.
    // Приближение Буссинеска также реализовано, за него
    // отвечает глобальный параметр bBussinesk
    procedure myVersionSIMPLEAlgorithm(bposttemperature : Boolean);
    // запоминание горизонтальной компоненты скорости
    // удовлетворяющей уравнению неразрывности
    procedure RememberXvel(var U : array of Float);
    // запоминание вертикальной
    // компоненты скорости
    // удовлетворяющей уравнению неразрывности
    procedure RememberYvel(var U : array of Float);
    // норма внутренности универсальной полевой величины U по аналогии с
    // пространством C
    function mySupNorma(const U : array of Float;
                        icolx : Integer;
                        icoly : Integer): Float;
    // норма разности внутренностей двух универсальных полевых
    // величин U1 и U2 по аналогии с
    // пространством C
    function mySupNorma2(const U1 : array of Float; // первая полевая величина
                         const U2 : array of Float; // вторая полевая величина
                                icolx : Integer;
                                icoly : Integer): Float;
    // функция вычисляет невязку уравнения
    function myResidual( const U : array of Float;
                           icolx : Integer;
                           icoly : Integer;
                           const map : TdynArraymyNode; // карта обхода
                           chvariable : Char; // для какой переменной решается
                           const m : array of MatrixCoef;
                           const db : array of Float) : Float;
    // решает нестационарную задачу чистой теплопроводности
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    // Перед вызовом данного сценария, в модуле myRunModule
    // обязательно должно быть задано количество итераций,
    // шаг по времени, количество шагов по времени, начальное время.
    procedure RunCleanThermalConductionUnsteady;
    // решает нестационарную задачу теплопроводности с учётом конвекции
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    // Перед вызовом данного сценария, в модуле myRunModule
    // обязательно должно быть задано количество итераций на временном слое
    // начальное время, шаг по времени и количество шагов по времени.
    procedure RunConvectiveThermalConductionUnsteady;
    // Реализация прямого метода исключения Гаусса.
    // задача решить СЛАУ Ax = b
    // Дано A и b. Найти x.
    // Алгоритм прямого исключения Гаусса портит матрицу СЛАУ
    // изменяя её элементы, так что после Алгоритма Гаусса этой матрицей
    // пользоваться уже нельзя. Матрица передаётся по ссылке, чтобы избежать
    // потерь памяти и быстродействия на копирование такой большой матрицы.
    procedure GaussAlgorithm(isize : Integer; // размер квадратной матрицы
                                var dA : array  of TmyDynArray; // матрица СЛАУ
                                icolx : Integer; // количество узлов по горизонтали
                                icoly : Integer; // количество узлов по вертикали
                                const move : array of Integer; // для ленточной матрицы
                                var dV : array of Float; // вектор правой части
                                var dx : array of Float; // вектор результата
                                bmessage : Boolean);
    // скалярное произведение двух векторов
    function Scal(isize : Integer;
                    const dV1 : array of Float;
                    const dV2 : array of Float) : Float;
    // умножение матрицы на вектор
    // результат содержится в векторе dx.
    procedure MatrixByVector(isize : Integer;
                                const dH : array of TmyDynArray;
                                const dV : array of Float;
                                var dx : array of Float);
    // норма вектора
    function NormaV(isize : Integer;
                       const dV : array of Float) : Float;
    // Метод Сопряжённых градиентов
    // Хестенса и Штифеля
    // см. например, диссертацию Н.Г. Бураго
    procedure SoprGrad(isize : Integer; // размер квадратной матрицы
                          const dA : array of TmyDynArray; // матрица СЛАУ
                          const dV : array of Float;  // вектор правой части
                          const dX0 : array of Float; // вектор начального приближения
                          var dres : array of Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение сверху на количество итераций
                          epsilon : Float); // точность вычисления
    // Решает задачу прямым методом исключения Гаусса
    // для универсальной искомой функции U.
    procedure GaussUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // выводить ли диагностические сообщения на консоль
    // Решает задачу методом сопряжённых градиентов
    // для универсальной искомой функции U.
    // Для того чтобы вычислительный процесс
    // сходился необходимо потребовать от матрицы dA
    // составленной по матрице U
    // положительной определённости и самосопряжённости.
    // Положительная определённость и самосопряжённость присущи
    // задаче с чистой теплопроводностью без учёта конвективного члена.
    // Как только мы учитываем конвективный член (а он нужен в подовляющем большинстве случаев)
    // приходится по-видимому использовать Трансформацию Гаусса.
    procedure SoprGradUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль
    // трансформация Гаусса.
    // выполняется и над матрицей СЛАУ dA и над вектором правой части dV.
    procedure GaussTransform(isize : Integer;
                            var dA : array of TmyDynArray;
                            var dV : array of Float);
    // находился на стадии тестирования
    // есть множество вопросов и сложностей по реализации.
    // Операции по определению поля давления самые ресурсоёмкие.
    // Перед решением уравнения для поправки давления поле поправки давления
    // надо инициализировать нулевым значением.
    // решает линейное уравнение для поправки давления
    //  методом сопряжённых градиентов Хестенса и Штифмена.
    // Здесь формируется матрица СЛАУ которая затем передаётся
    // уточняющему солверу SoprGrad или прямому GaussAlgorithm.
    // Это универсальный метод решения уравнения для поправки давления
    // содержащий прямой метод исключения Гаусса, а также метод
    // сопряжённых градиентов Хестенсена и Штифеля.
    // Также в него встроена возможность применения трансформации Гаусса.
    // Если булева переменная bGaussTransform равна true то применяется трансформация
    // Гаусса. Если булева переменнная bHestensenShtifiel равна true то применяется
    // метод сопряжённых градиентов иначе прямой метод исключения Гаусса.
    procedure SolveUniversalPamendment(bGaussTransform : Boolean;
                                       bHestensenShtifiel : Boolean;
                                       var rescontinity : Float);
    // решает уравнение для поправки давления
    // с учётом выбранного солвера
    procedure SolvePamendment(var rescontinity : Float); // вызывает соответствующие солверы

    // Следующие несколько методов оптимизируют метод Сопряжённых градиентов
    // как по объёму используемой им памяти так и по скорости его работы.
    // Это алгоритмы 1. Быстрой сортировки, 2. Эффективного умножения разреженной
    // матрицы на вектор с учётом формата хранения CRS, 3. Реализации генерации
    // разреженной матрицы в формате хранения CRS.

    // Запрограммировано с использованием
    // Брайан Керниган и Дени Ритчи "The C Programming Language".
    // Swap : Обмен местами list[i] и list[j] (для QuickSort).
    procedure Swap(var list : array of TmyNonZeroElemMatrix;
                          i : Integer;
                          j : Integer);
    // Вот алгоритм PivotList (для QuickSort).
    // он возвращает точку деления элементов массива на две части.
    // Запрограммировано с использованием книжки ДЖ. Макконел
    // Анализ алгоритмов стр. 106.
    function PivotList(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer) : Integer;
    // Быстрая сортировка Хоара.
    // Это рекурсивный алгоритм который эффективен по быстродействию
    // но возможно не эффективен по памяти.
    // Запрограммировано с использованием Дж. Макконел
    // Анализ алгоритмов стр. 106.
    procedure QuickSort(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer);
    // умножение матрицы на вектор
    // используя формат хранения CRS
    // Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
    // Запрограммировано с использованием
    // 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
    // 2. Р. Тьюарсон "Разреженные матрицы".
    // Матрицы передаются по ссылке чтобы избежать возможного переполнения стека.
    procedure MatrixCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of Float; // заданный вектор на который производится умножение
                                var dx : array of Float);  // результат умножения заносится в dx.
    // умножение транспонированной матрицы на вектор
    // используя формат хранения CRS
    // Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
    // Запрограммировано с использованием
    // 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
    // 2. Р. Тьюарсон "Разреженные матрицы".
    // Матрицы передаются по ссылке чтобы избежать возможного переполнения стека.
    procedure MatrixTransposeCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of Float; // заданный вектор на который производится умножение
                                var dx : array of Float);  // результат умножения заносится в dx.
    // Решает задачу методом сопряжённых градиентов
    // Хестенса и Штифеля
    // для универсальной искомой функции U.
    // данный метод имеет итерационный характер с хорошей скоростью сходимости,
    // т.к. он строит базис и поэтому сходится за количество итераций
    // равных размерности вектора правой части СЛАУ.
    // Ещё одним достоинством данного метода является то, что он
    // стартуя с некоторого начального приближения уточняет решение.
    // Данная версия реализована с использованием технологии CRS хранения
    // и обработки разреженных матриц. Учёт разреженности матрицы позволяет
    // более эффективно использовать оперативную память компьютера и повысить
    // скорость операций по решению большой СЛАУ. После того как данный метод
    // пройдёт тестирование он может быть рекомендован к использованию.
    procedure SoprGradCRSUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         bmessage : Boolean; // выводить ли значение невязки на консоль: true - ДА, false - НЕТ
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         itypealg : Integer; // тип алгоритма: 0 - Сопряжённые градиенты, 1 - Ю.Г. Соловейчика.
                         const db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // Метод Сопряжённых градиентов
    // Хестенса и Штифеля
    // см. например, диссертацию Н.Г. Бураго
    // или Г.И. Марчук методы вычислительной математики
    // здесь применена технология CRS хранения и обработки разреженной матрицы.
    // Этот алгоритм подходит не только для SPD - Symmetric and Positively Defined матриц.
    // SPD - Самосопряжённые и положительно определённые матрицы.
    // В зависимости от значения передаваемого параметра bGaussTransform
    // в нём примененяется или не применяется трансформация Гаусса.
    // Трансформация Гаусса состоит в домножении СЛАУ на транспонированную матрицу слева,
    // что позволяет из любой СЛАУ получить СЛАУ с положительно определённой самосопряжённой матрицей.
    // Однако трансформация Гаусса сильно портит число обусловленности матрицы (спектр матрицы) возводя его в квадрат.
    procedure SoprGradCRS(isize : Integer; // размер квадратной матрицы
                          const val : array of Float; // матрица СЛАУ
                          const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                          const row_ptr : array of Integer; // информация о началах строк
                          const dV : array of Float;  // вектор правой части
                          const dX0 : array of Float; // вектор начального приближения
                          var dres : array of Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение на максимальное количество итераций
                          bGaussTransform : Boolean; // выполнять ли трансформацию Гаусса
                          epsilon : Float); // точность вычисления
    // Переформировать пирамиду
    procedure FixHeap(var list : array of TmyNonZeroElemMatrix;
                          root : Integer;
                          m : TmyNonZeroElemMatrix;
                          bound : Integer);
    // Пирамидальная сортировка оптимальна как
    // по памяти, так и по быстродействию, к тому же её алгоритм
    // очень интересен.
    // Ограничение состоит в том, что нумерация массива должна начинаться с 1.
    procedure HeapSort(var list : array of TmyNonZeroElemMatrix;  // упорядочиваемый список элементов
                              n : Integer); // число элементов в списке
    // находится на стадии тестирования
    // Операции по определению поля давления самые ресурсоёмкие.
    // Перед решением уравнения для поправки давления поле поправки давления
    // надо инициализировать нулевым значением.
    // решает линейное уравнение для поправки давления
    //  методом сопряжённых градиентов Хестенса и Штифмена.
    // Здесь формируется матрица СЛАУ в формате CRS которая затем передаётся
    // уточняющему солверу SoprGrad.
    // этот метод эффективен по памяти т.к. здесь используется алгоритм хранеия доступа CRS.
    procedure SolveSoprGradCRSPamendment(bGaussTransform : Boolean; bipifix : Boolean;
                                         bSoloveichikAlg : Boolean; // применять ли алгоритм Ю.Г. Соловейчика 93 года
                                         var rescontinity : Float);
    // норма вектора
    // как максимальное значение среди компонент вектора
    function NormaSupV(isize : Integer; // размерность вектора
                               const dV : array of Float) : Float;
    // норма вектора
    // сумма модулей компонент вектора
    // октаэдрическая норма.
    function NormaSup2V(isize : Integer; // размерность вектора
                       const dV : array of Float) : Float;
    // восстановление вихря с интерполяцией на основную сетку
    procedure CurlConstruct;
    // вычисление функции тока
    // bmessage - выводить ли сообщения на системную консоль
    // kend - максимальное количество итераций по достижению которого вычисление заканчивается.
    procedure SolveStreamFunction(bmessage : Boolean; kend : Integer);
    // инициализация функции тока
    procedure initStreamFunction;
    // евклидова норма внутренности универсальной полевой величины U
    // возвращает корень квадратный из суммы квадратов компонентов вектора невязки.
    // для внутренней части расчётной области.
    // евклидова норма.
    function myEvklidNorma(const U : array of Float; icolx : Integer; icoly : Integer): Float;
    // октаэдрическая норма внутренности универсальной полевой величины U
    // возвращает сумму модулей компонент вектора невязки.
    // октаэдрическая норма.
    function mySup2Norma(const U : array of Float; icolx : Integer; icoly : Integer): Float;
    // создаёт файл для программы tecplot
    // переменная  ifuncexport отвечает за то какое значение передавать
    // в программу tecplot.
    // 1 - со значением вихря,
    // 2 - со значением функции тока.
    procedure exporttecplotUniversal(ifuncexport : Integer);
    // Это исправление граничных условий для давления
    // до граничных условий Неймана для корректного
    // отображения при визуализации.
    procedure PressurePathit;
    // Для исследования вибрационного воздействия
    // Возвращает текущее значение силы тяжести
    // в зависимости от текущего момента времени.
    function GetRealGravity(chDirect : Char) : Float;
    // алгоритм Ю.Г.Соловейчика [1993]
    // для возможно несимметричных матриц.
    procedure SoloveichikAlg(isize : Integer; // размер квадратной матрицы
                         const val : array of Float; // матрица СЛАУ
                         const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                         const row_ptr : array of Integer; // информация о началах строк
                         const dV : array of Float;  // вектор правой части
                         const dX0 : array of Float; // вектор начального приближения
                         var dres : array of Float; // вектор результата
                         bconsole_message : Boolean; // выводить ли значения невязки на консоль
                         kend : Integer; // ограничение на максимальное количество итераций
                         epsilon : Float); // точность вычисления
    // универсальная функция визуализации
    // основная сетка
    procedure DisplayUniversalInternal(ival : Integer);
    // инициализация параметров в алгоритме SIMPLE
    procedure initparamSIMPLE(bposttemperature : Boolean);
    // Щас реализуется возможность приостановки и последующего
    // продолжения вычисления с остановленного места. Это приводит
    // к необходимости в случае малейших изменений, например в граничных условиях, производить
    // инициализацию решения заново. Иначе новые граничные условия не будут учтены.
    procedure myInitializationRestart;
    // Вычисляет текущие невязки для компонент скорости
    procedure getrealresFlow(var resVx : Float; var resVy : Float);
    // определение угловых точек и их типов
    procedure ugoldetect(var map : TdynArraymyNode; icolx, icoly : Integer);
                               // нескомпенсированные источники массы
    procedure PamendmentCoef(var rescontinity :  Float;
            var mp : array of MatrixCoef; // коэффициенты дискретного аналога
            var db : array of  Float); // коэффициенты источникового члена
     // передвигает координаты сетки
     procedure mymovingmesh;
     //при динамической сетке надо обновлять карты
     procedure UpdateMap;
     // инициализация функции тока
     procedure initmeanSF(str : String);
     // вычисление осреднённой на периоде функции тока
     procedure RememberStreamFunction;
     // вычисление осреднённой на периоде функции тока
     procedure CalculateMeanStreamFunction;
     // вычисление осреднённой на периоде функции тока
     procedure CalculateMeanSF(inum : Integer);
     // контролирует одну итерацию алгоритма SIMPLE
     procedure controlSimpletune;
     // создаёт файл для программы tecplot
     // со всеми расчитанными функциями.
     // в программу tecplot:
     // 1 - со значением вихря,
     // 2 - со значением функции тока,
     // 3 - со значением распределения давления.
     // 4 - со значением горизонтальной скорости,
     // 5 - со значением вертикальной скорости.
     // 7 - математическое ожидание функции тока
     procedure exporttecplotmeanUniversalComplete;
     // генеральные настройки
     procedure myGeneraltune;
     // параметры материалов
     procedure materialtune;
     // задание граничных условий
     procedure BoundaryConditionTune;
     // вызывает меню, где можно выбрать
     // уравнения подлежащие решению
     procedure EquationTune;
     // Выбор алгоритма солвера
     procedure SelectSolvertune;
     // вызывает форму где можно задать параметры релаксации
     procedure RelaxationFactorstune;
     // инициализация перед началом счёта
     procedure Initializationtune;
     // запуск на вычисление
     procedure RunTune;
     // аппроксимация конвективного члена и алгоритм решения
     procedure Methodstune;
     // управление простейшей динамической сеткой
     procedure DynamMeshtune;
     // инициализация осредненнной горизонтальной
     // компоненты скорости
     procedure initmeanXvel(str : String);
     // инициализация осреднённой вертикальной
     // компоненты скорости
     procedure initmeanYvel(str : String);
     // инициализация осреднённого поля температур
     procedure initmeanTemp(str : String);
      // инициализация осреднённого вихря
     procedure initmeanOmega(str : String);
     // вычисление осреднённой на периоде горизонтальной скорости
     procedure RememberXVelDM;
     // вычисление осреднённой на периоде вертикальной скорости
     procedure RememberYVelDM;
     // вычисление осреднённой на периоде температуры
     procedure RememberTempDM;
     // вычисление осреднённого вихря
     procedure RememberOmega1T;
     // вычисление осреднённого на периоде вихря
     procedure CalculateMeanOmega1T;
     // вычисление осреднённой на периоде
     // горизонтальной компоненты скорости
     procedure CalculateMeanXVel;
     // вычисление осреднённой на периоде
     // вертикальной компоненты скорости
     procedure CalculateMeanYVel;
     // вычисление осреднённой на периоде температуры
     procedure CalculateMeanTempreture;
     // вычисление математического ожидания от температуры
     procedure CalculateMeanT(inum : Integer);
     // вычисление мат ожидания горизонтальной скорости
     procedure CalculateMeanVx(inum : Integer);
     // вычисление математического ожидания от вертикальной скорости
     procedure CalculateMeanVy(inum : Integer);
     // вычисление мат ожидания от вихря
     procedure CalculateMeanOmega(inum : Integer);
     // задание граничных условий
     // первого рода  для Давления
     procedure initBoundaryConditionPressure;
     // устраняет дефекты графической визуализации
     procedure VelXPachit;
     // вычисляет невязку для температуры
     procedure getrealResTemp(var restemp : Float);
     // графики невязок
     procedure updatemainpaintbox; // графики невязок
     // создаёт файл для программы tecplot
    // со всеми расчитанными функциями.
    // в программу tecplot:
    //
    // 1 -  вихрь,
    // 2 -  температура,
    // 3 -  горизонтальная скорость,
    // 4 -  вертикальная скорость,
    // векторное поле скоростей может быть автоматически
    // сгенерировано используя пункты 3 и 4.
    // 5 -  модуль скорости,
    // 6 -  функция тока,
    // 7 - функция цвета.
    //
    procedure exporttecplotUniversalComplete;
    // инициализация функции цвета
    procedure initVOF;
    // плотность
    function density(ipi : Integer) : Float;
    // динамическая вязкость
    function viscosity(ipi : Integer) : Float;
    // инициализирует решение в VOF методе и не только
    procedure patchtune;
    // запоминает текущую плотность в массив
    // DensityOldTimeStep
    procedure rememberDensity;
    // LU разложение
    procedure LUdecomposition(isize : Integer; // размер квадратной матрицы
                              var dA : array of TmyDynArray; // матрица СЛАУ
                              icolx : Integer; // количество узлов по горизонтали
                              icoly : Integer; // количество узлов по вертикали
                              const move : array of Integer; // для ленточной матрицы
                              var dV : array of  Float; // вектор правой части
                              var dx : array of  Float; // результат вычисления
                              bmessage : Boolean);
    // решение уравнения для давления
    procedure SolveGZPressure(bipifix : Boolean); // фиксировать ли уровень давления  ?
    // задание граничных условий
    // первого рода
    // для функции тока
    procedure initBoundaryConditionStreamFunction;
    // вычисляет коэффициенты дискретного аналога для
    // уравнения переноса завихрённости с учётом конвективного члена
    //  Операция составления дискретного аналога выполнена универсальным
    // образом. Т.е. она подходит и для процессов не зависящих от времени, а также
    // для нестационарных процессов.
    // Внимание: перед использованием этой процедуры массиву
    // OmegaoldTimeStep должна быть выделена оперативная память и
    //  он должен быть проинициализирован соответствующим образом.
    procedure OmegaConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                               var db : array of Float); // правая часть
    // по значениям функции тока находит
    // горизонтальную скорость.
    procedure VxConstruct;
    // по значениям функции тока находит
    // вертикальную скорость.
    procedure VyConstruct;
    // найти вихрь.
    procedure SolveOmegaSteady;
    // решает Навье-Стокса в переменных Вихрь - Функция тока
    procedure VorcityStreamfunctionSolveEquation;
    // Поячеечная сборка матрицы:
    procedure TempCoefCell(var m : array of MatrixCoef;
                          var db : array of Float); // правая часть

  end;

var
  Form1: TForm1;

implementation

uses  // список используемых самописных модулей
   DisplayUnit, MeshGen, myGeneralSolver, InitializeUnit, myRunmodule,
   MaterialUnit, ExportTecplotUnit, BoundaryConditionUnit,
   SourceInEquationUnit, Unit2DPlot, InterpolateCaseUnit, myProgressBarUnit,
   myProgressBarUnsteadyUnit, AlgoSolverUnit, controlSIMPLEUnit,
   RelaxFactorsUnit, ApproxConvectionUnit, ModelEquationUnit, MyResControlUnit,
   SoprGradUnit, GravityUnit, TerminateProcessUnit, GridGenUnit, DynMeshUnit,
   PamendmentcontrolUnit, PatchUnit;

{$R *.dfm}


// используется для уравнения теплопроводности
// передаёт параметры из формы в программу,
// задаёт постоянные параметры материалов,
// задаёт постоянные источникового члена,
// выделяет память под массивы использующиеся
// при решениии уравнения теплопроводности.
procedure TForm1.initparam;
begin
   // выделение памяти под динамические массивы
   SetLength(lambda, inx*iny+1); // теплопроводность dlambda(x,y);
   initlambda; // инициализирует теплопроводность
   SetLength(T, inx*iny+1); // поле температур.
   if (actiVibr.bOn) then
   begin
      SetLength(meanT1T,inx*iny+1);
      SetLength(meanTGl,inx*iny+1);
      SetLength(meanT,inx*iny+1);
   end;
   initTemp; // инициализирует поле темпеатур
   initBoundaryConditionTempreture; // задаёт граничные условия
   if (actiVibr.bOn) then
   begin
      initmeanTemp('T'); // на одном периоде
      initmeanTemp('G'); // глобальное среднее
      initmeanTemp('M'); // мат ожидание
   end;
   // выделяем память для хранения поля температур с предыдущей итерации
   SetLength(TOldIteration, inx*iny+1); // поле температур с предыдущей итерации
   // запоминаем поле температур с предыдущей итерации
   RememberTOldTimeStep(false);
   // выделяем память для хранения поля температур с прошлого временного слоя
   // только в случае нестационарного солвера
   if (btimedepend) then SetLength(ToldTimeStep, inx*iny+1);
   // источниковый член
   SetLength(dSc, inx*iny+1); // постоянная составляющая источникового члена
   initdSc; // инициализация постоянной составляющей источникового члена
   dSp:=defmysource.Temperature.dSp; // линейная составляющая источникового члена
   // параметры материалов
   // хранятся в структуре MaterialProperties
   drho:=matprop[0].drho; // постоянная плотность
   dcp:=matprop[0].dcp; // постоянная теплоёмкость
   dbeta:=matprop[0].beta; // коэффициент линейного температурного расширения
   SetLength(VOF,inx*iny+1);
   initVOF;
end; // initparam

// Используется для решения уравнений Навье-Стокса
// задаёт парамеры материалов,
// выделяет память под массивы для компонент скорости:
// с учётом текущей сетки для расчитываемой скорости,
// для скорости с прошлой итерации, для скорости с прошлого шага по времени,
// давления, поправки давления. Заполняет эти массивы значениями по умолчанию.
// Инициализирует значения источниковых членов для уравнений импульса.
procedure TForm1.initparam2;
begin
   // выделение памяти под динамические массивы
   // Для давления надо ставить условия II рода (Условия Неймана).
   SetLength(P,inx*iny+1); // давление
   // для поправки давления
   SetLength(Pamendment,inx*iny+1); // поправка давления на основной сетке
   SetLength(Vx,(inx-1)*iny+1); // Vx на смещённой по оси x сетке
   SetLength(Vy,inx*(iny-1)+1); // Vy на смещённой по оси y сетке
   SetLength(VxOld,(inx-1)*iny+1); // Vx с прошлой итерации
   SetLength(VyOld,inx*(iny-1)+1); // Vy с прошлой итерации
   SetLength(VxOldTimeStep,(inx-1)*iny+1); // Vx с прошлого временного слоя
   SetLength(VyOldTimeStep,inx*(iny-1)+1); // Vy с прошлого временного слоя
   SetLength(SF,inx*iny+1); // функция тока
   SetLength(Omega,inx*iny+1); // вихрь
   if (actiVibr.bOn) then
   begin
      //средние характеристики для сбора статистики
      SetLength(meanSF1T,inx*iny+1); // средняя функция тока на одном периоде
      // средняя функция тока в глобальном смысле на нескольких периодах
      SetLength(meanSFGl,inx*iny+1);
      // истинное математическое ожидание функции тока
      SetLength(meanSF,inx*iny+1); // выделение оперативной памяти
      // вихрь
      SetLength(meanOmega1T,inx*iny+1);
      SetLength(meanOmegaGl,inx*iny+1);
      SetLength(meanOmega,inx*iny+1);
      // горизонтальная скорость
      SetLength(meanVx1T,(inx-1)*iny+1);
      SetLength(meanVxGl,(inx-1)*iny+1);
      SetLength(meanVx,(inx-1)*iny+1);
      // вертикальная скорость
      SetLength(meanVy1T,inx*(iny-1)+1);
      SetLength(meanVyGl,inx*(iny-1)+1);
      SetLength(meanVy,inx*(iny-1)+1);
   end;
   // параметры материалов
   SetLength(dmu,inx*iny+1); // динамическая вязкость dmu(x,y)
   // здесь надо не забыть задать плотность
   drho:=matprop[0].drho; // постоянная плотность
   // задаём динамическую вязкость
   initmu; // инициализация динамической вязкости mu(x,y);
   // инициализация поля скорости
   initXvel; // инициализация горизонтальной скорости
   initYvel; // инициализация вертикальной скорости
   initPressure; // задание начального поля давления
   // задание граничных условий для скорости
   // это нужно делать именно после инициализациии скоростей внутри расчётной области.
   initBoundaryConditionVx; // граничные условия для горизонтальной скорости
   initBoundaryConditionVy; // граничные условия для вертикальной скорости
   initBoundaryConditionPressure; // граничные условия для давления
   // запоминаем начальное поле скорости
   // инициализируя тем самым вспомогательные массивы VxOld, VyOld
   // Они инициализируются уже с учётом граничных условий.
   RememberXvel(VxOld); // запоминаем горизонтальную компоненту скорости
   RememberYvel(VyOld); // запоминаем вертикальную компоненту скорости
   // инициализация источниковых членов для Vx
   dScVx:=defmysource.Vxvelocity.dSc; // постоянная составляющая источникового члена для горизонтальной компоненты скорости
   dSpVx:=defmysource.Vxvelocity.dSp; // линеаризованная составляющая источникового члена для Vx
   // инициализация источниковых членов для Vy
   dScVy:=defmysource.Vyvelocity.dSc; // постоянная составляющая источникового члена для Vy
   dSpVy:=defmysource.Vyvelocity.dSp; // линеаризованная составляющая источникового члена для Vy
   // Здесь краевые условия для функции тока нулевые.
   // Это верно для ряда задач: течения в изотермической каверне,
   // т.к. стенки непроницаемы для жидкости и ряда других задач
   // например задач  с естественной конвекцией в прямоугольной области стенки которой
   // непроницаемы для жидкости.
   initStreamFunction; // инициализация функции тока нулём включая граничные точки
   initBoundaryConditionStreamFunction; // задание граничных условий
   if (actiVibr.bOn) then
   begin
      // функция тока
      initmeanSF('T'); // на одном периоде
      initmeanSF('G'); // глобальное среднее
      initmeanSF('M'); // мат ожидание
      // вихрь
      initmeanOmega('T'); // на одном периоде
      initmeanOmega('G'); // глобальное среднее
      initmeanOmega('M'); // мат ожидание
      // горизонтальная скорость
      initmeanXvel('T'); // на одном периоде
      initmeanXvel('G'); // глобальное среднее
      initmeanXvel('M'); // мат ожидание
      // вертикальная скорость
      initmeanYvel('T'); // на одном периоде
      initmeanYvel('G'); // глобальное среднее
      initmeanYvel('M'); // мат ожидание
   end;
   SetLength(VOF,inx*iny+1);
   initVOF; // функция цвета
   SetLength(DensityOldTimeStep,inx*iny+1); // плотность на предыдущем временном шаге
   // здесь плотность не инициализируется, т.к. сначала надо
   // соответствующим образом инициализировать VOF функцию цвета: Solve->Initialize->Patch.
   // инициализация происходит внутри алгоритма SIMPLE.
end; // initparam2

// запоминает текущую плотность в массив
// DensityOldTimeStep
procedure TForm1.rememberDensity;
var
    i,j : Integer; // счётчики
    ipi : Integer; // текущая точка
begin
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*inx;
         DensityOldTimeStep[ipi]:=density(ipi);
      end;
   end;
end; // rememberDensity

// инициализация материалов
// инициализация теплопроводности
procedure TForm1.initlambda;
var
   i1 : Integer; // Счётчик
begin
   for i1:=1 to imaxnumbernode do
   begin
     with mapPT[i1] do
     begin
        if (itype<>0) then
        begin
           // точка расчётной области
           // либо внутренняя либо граничная

           // постоянная теплопроводность
           lambda[i+(j-1)*inx]:=matprop[0].dlambda;
        end;
     end;
   end;
end; // initlambda

// инициализация коэффициента динамической вязкости
procedure TForm1.initmu;
var
   i1 : Integer; // Счётчик
begin

   for i1:=1 to imaxnumbernode do
   begin
      with (mapPT[i1]) do
      begin
         if (itype<>0) then
         begin
            // точка расчётной области
            // либо внутренняя либо граничная

            // инициализация динамической вязкости
            dmu[i+(j-1)*inx]:=matprop[0].dmu;
         end;
      end;
    end;
end; // initmu

// инициализация поля температур
procedure TForm1.initTemp;
var
   i : Integer; // счётчики
begin

   for i:=1 to imaxnumbernode do
   begin
      with mapPT[i] do
      begin
         if (itype<>0) then
         begin
            // только внутренние узлы и граничные узлы
            // постоянная темпеатура
            // В структуре InitVal содержится необходимое начальное значение
            T[i+(j-1)*inx]:=InitVal.TempInit;
         end;
     end; // with
   end;
end; // initTemp

// инициализация осреднённого поля температур
procedure TForm1.initmeanTemp(str : String);
var
   i : Integer; // счётчик

begin
   for i:=1 to imaxnumbernode do
   begin
      with mapPT[i] do
      begin
         if (itype<>0) then
         begin
            // только внутренние узлы и граничные узлы
            // постоянная темпеатура
            //  значение равное нулю.
            case str[1] of
             'T' : meanT1T[i+(j-1)*inx]:=0.0;  // среднее за период
             'G' : meanTGl[i+(j-1)*inx]:=0.0;  // глобальное среднее
             'M' : meanT[i+(j-1)*inx]:=0.0;   // математическое ожидание
            end;
         end;
     end; // with
   end;
end; // initmeanTemp

// инициализация распределения давления
procedure TForm1.initPressure;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // постоянное давление равное 0
            P[i+(j-1)*inx]:=0.0;
         end;
      end;
   end;
end; // initPressure

// инициализация функции цвета
procedure TForm1.initVOF;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            VOF[i+(j-1)*inx]:=0.0;
         end;
     end;
   end;
end; // initVOF

// инициализация функции тока
procedure TForm1.initStreamFunction;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            SF[i+(j-1)*inx]:=0.0;
         end;
     end;
   end;
end; // initStreamFunction

// инициализация функции тока
procedure TForm1.initmeanSF(str : String);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            case str[1] of
              'T' : meanSF1T[i+(j-1)*inx]:=0.0;
              'G' : meanSFGl[i+(j-1)*inx]:=0.0;
              'M' : meanSF[i+(j-1)*inx]:=0.0; // мат ожидание
            end; // case
         end;
     end; // with
   end;
end; // initmeanSF

// инициализация осреднённого вихря
procedure TForm1.initmeanOmega(str : String);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            case str[1] of
              'T' : meanOmega1T[i+(j-1)*inx]:=0.0;
              'G' : meanOmegaGl[i+(j-1)*inx]:=0.0;
              'M' : meanOmega[i+(j-1)*inx]:=0.0; // мат ожидание
            end; // case
         end;
     end; // with
   end;
end; // initmeanOmega

// вычисление осреднённой на периоде функции тока
procedure TForm1.RememberStreamFunction;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanSF1T[i+(j-1)*inx]:=meanSF1T[i+(j-1)*inx] + SF[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberStreamFunction

// вычисление осреднённого вихря
procedure TForm1.RememberOmega1T;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanOmega1T[i+(j-1)*inx]:=meanOmega1T[i+(j-1)*inx] + Omega[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberOmega1T

// вычисление осреднённой на периоде горизонтальной скорости
procedure TForm1.RememberXVelDM;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVx1T[i+(j-1)*(inx-1)]:=meanVx1T[i+(j-1)*(inx-1)] + Vx[i+(j-1)*(inx-1)];
         end;
     end;
   end;
end; // RememberXVelDM

// вычисление осреднённой на периоде вертикальной скорости
procedure TForm1.RememberYVelDM;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVy do
   begin
      with mapVy[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVy1T[i+(j-1)*inx]:=meanVy1T[i+(j-1)*inx] + Vy[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberYVelDM


// вычисление осреднённой на периоде температуры
procedure TForm1.RememberTempDM;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanT1T[i+(j-1)*inx]:=meanT1T[i+(j-1)*inx] + T[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberTempDM

// вычисление осреднённой на периоде функции тока
procedure TForm1.CalculateMeanStreamFunction;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanSFGl[i+(j-1)*inx]:=meanSFGl[i+(j-1)*inx] + meanSF1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanStreamFunction

// вычисление осреднённого на периоде вихря
procedure TForm1.CalculateMeanOmega1T;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanOmegaGl[i+(j-1)*inx]:=meanOmegaGl[i+(j-1)*inx] + meanOmega1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanOmega1T;


// вычисление осреднённой на периоде
// горизонтальной компоненты скорости
procedure TForm1.CalculateMeanXVel;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVxGl[i+(j-1)*(inx-1)]:=meanVxGl[i+(j-1)*(inx-1)] + meanVx1T[i+(j-1)*(inx-1)]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanXVel;

// вычисление осреднённой на периоде
// вертикальной компоненты скорости
procedure TForm1.CalculateMeanYVel;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVy do
   begin
      with mapVy[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVyGl[i+(j-1)*inx]:= meanVyGl[i+(j-1)*inx] + meanVy1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanYVel;

// вычисление осреднённой на периоде температуры
procedure TForm1.CalculateMeanTempreture;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanTGl[i+(j-1)*inx]:=meanTGl[i+(j-1)*inx] + meanT1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanTempreture

// вычисление мат ожидания функции тока
procedure TForm1.CalculateMeanSF(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanSF[i+(j-1)*inx]:=meanSFGl[i+(j-1)*inx]/inum;
         end;
     end;
   end;
end; // CalculateMeanSF

// вычисление мат ожидания от вихря
procedure TForm1.CalculateMeanOmega(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanOmega[i+(j-1)*inx]:=meanOmegaGl[i+(j-1)*inx]/inum;
         end;
     end;
   end;
end; // CalculateMeanOmega

// вычисление математического ожидания от температуры
procedure TForm1.CalculateMeanT(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanT[i+(j-1)*inx]:=meanTGl[i+(j-1)*inx]/inum;
         end;
     end;
   end;
end; // CalculateMeanT

// вычисление мат ожидания горизонтальной скорости
procedure TForm1.CalculateMeanVx(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVx[i+(j-1)*(inx-1)]:=meanVxGl[i+(j-1)*(inx-1)]/inum;
         end;
     end;
   end;
end; // CalculateMeanVx


// вычисление математического ожидания от вертикальной скорости
procedure TForm1.CalculateMeanVy(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVy do
   begin
      with mapVy[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVy[i+(j-1)*inx]:=meanVyGl[i+(j-1)*inx]/inum;
         end;
     end;
   end;
end; // CalculateMeanVy

// инициализация распределения поправки давления
// О важности начального распеределения поправки давления
// в данном случае:
// Любой итерационный метод решения алгебраических
// уравнений даёт сходимость решения, абсолютное значение
// которого определяется начальным приближением.
procedure TForm1.initPamendmentZero;
var
   i : Integer; // счётчики
begin
   for i:=1 to imaxnumbernode do
   begin
      if (mapPT[i].itype<>0) then
      begin
        // только для узлов принадлежащих расчётной области

        // инициализация распределения поправки давления нулём !
        Pamendment[mapPT[i].i+(mapPT[i].j-1)*inx]:=0.0;
     end; // j
   end; // i
end; // initPamendmentZero

// инициализация постоянной составляющей источникового члена
// для уравнения теплопроводности
// хорошо бы переименовать метод в что-то типа
// initTempdSc
procedure TForm1.initdSc;
var
   i : Integer; // счётчики циклов
begin
   // инициализация постоянной составляющей
   // источникового члена
   // для уравнения теплопрооводности
   for i:=1 to imaxnumbernode do
   begin
      if (mapPT[i].itype<>0) then
      begin
        // только внутренние узлы и граничные узлы

        // постоянная составляющая источникового члена
        dSc[mapPT[i].i+(mapPT[i].j-1)*inx]:=defmysource.Temperature.dSc;
     end; // j
   end; // i
end; // initdSc

// инициализация горизонтальной
// компоненты скорости
procedure TForm1.initXvel;
var
   i : Integer; // счётчик при обходе по карте

begin
   // инициализация горизонтальной
   // компоненты скорости

   for i:=1 to imaxnumbernodeVx do
   begin
      with mapVx[i] do
      begin
         if (itype<>0) then
         begin
            // если узел внутренний
            // горизонтальная компонента скорости
            // В структуре InitVal содержится необходимое начальное значение
            Vx[i+(j-1)*(inx-1)]:=InitVal.XvelInit;
         end;
      end; // with
   end;
end; // initXvel

// инициализация осредненнной горизонтальной
// компоненты скорости
procedure TForm1.initmeanXvel(str : String);
var
   i : Integer; // счётчик при обходе по карте

begin
   // инициализация горизонтальной
   // компоненты скорости

   for i:=1 to imaxnumbernodeVx do
   begin
      with mapVx[i] do
      begin
         if (itype<>0) then
         begin
            // если узел внутренний
            // горизонтальная компонента скорости
            // присваивается значение 0.0
            case str[1] of
              'T' :  meanVx1T[i+(j-1)*(inx-1)]:=0.0; // на одном периоде
              'G' :  meanVxGl[i+(j-1)*(inx-1)]:=0.0; // глобальная
              'M' :  meanVx[i+(j-1)*(inx-1)]:=0.0; // просто мат ожидание
            end;

         end;
      end; // with
   end;
end; // initmeanXvel1T


// запоминание поля температуры
// для того чтобы использовать эти значения
// на следующем временном слое
// В случае если передаваемый параметр bcopyoldtimetempreture принимает значение true.
// Если этот параметр принимает значение false то копируется поле температур с предыдущей итерации.
// Это нужно для сильно нелинейных задач для применения нижней релаксации.
procedure TForm1.RememberTOldTimeStep(bcopyoldtimetempreture : Boolean);
var
   i : Integer; // счётчики циклов
begin
   // запоминание поля температур
   // для использования на следующем временном слое
   for i:=1 to imaxnumbernode do
   begin
      if (mapPT[i].itype<>0) then
      begin
         // если точка принадлежит расчётной области
         if (bcopyoldtimetempreture) then
         begin
            // копирование температуры с предыдущего временного слоя
            ToldTimeStep[mapPT[i].i+(mapPT[i].j-1)*inx]:=T[mapPT[i].i+(mapPT[i].j-1)*inx];
         end
          else
         begin
            // копирование поля температур с предыдущей итерации
            TOldIteration[mapPT[i].i+(mapPT[i].j-1)*inx]:=T[mapPT[i].i+(mapPT[i].j-1)*inx];
         end;
      end;
   end;
end; // RememberTOldTimeStep


// запоминание горизонтальной компоненты скорости
// удовлетворяющей уравнению неразрывности
procedure TForm1.RememberXvel(var U : array of Float);
var
   i,j : Integer; // счётчики циклов
begin
   // запоминание горизонтальной
   // компоненты скорости
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         U[i+(j-1)*(inx-1)]:=Vx[i+(j-1)*(inx-1)];
      end; // j
   end; // i
end; // RememberXvel

// инициализация вертикальной
// компоненты скорости
procedure TForm1.initYvel;
var
    i : Integer; // счётчик при обходе по карте
begin

   // инициализация вертикальной
   // компоненты скорости
   // При этом граничные значения тоже учитываются.

   for i:=1 to imaxnumbernodeVy do
   begin
      with mapVy[i] do
      begin
         if (itype<>0) then
         begin
            // если внутренний узел

            // инициализация:
            // вертикальная компонента скорости
            // В структуре InitVal содержится необходимое начальное значение
            Vy[i+(j-1)*inx]:=InitVal.YvelInit;
         end;
      end; // with
   end;
end; // initYvel

// инициализация осреднённой вертикальной
// компоненты скорости
procedure TForm1.initmeanYvel(str : String);
var
    i : Integer; // счётчик при обходе по карте
begin

   // инициализация вертикальной
   // компоненты скорости
   // При этом граничные значения тоже учитываются.

   for i:=1 to imaxnumbernodeVy do
   begin
      with mapVy[i] do
      begin
         if (itype<>0) then
         begin
            // если внутренний узел

            // инициализация:
            // вертикальная компонента скорости
            // нулевыми значениями
            case str[1] of
              'T' : meanVy1T[i+(j-1)*inx]:=0.0;
              'G' : meanVyGl[i+(j-1)*inx]:=0.0;
              'M' : meanVy[i+(j-1)*inx]:=0.0;
            end; // case
         end;
      end; // with
   end;
end; // initmeanYvel

// запоминание вертикальной
// компоненты скорости
// удовлетворяющей уравнению неразрывности
procedure TForm1.RememberYvel(var U : array of Float);
var
    i,j : Integer; // счётчик циклов
begin
   // запоминание вертикальной
   // компоненты скорости
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         U[i+(j-1)*inx]:=Vy[i+(j-1)*inx];
      end; // j
   end; // i
end; // RememberYvel


// задание граничных условий
// первого рода
// для поля температур
procedure TForm1.initBoundaryConditionTempreture;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный номер границы

begin
    // проход по всем узлам
    for i:=1 to imaxnumbernode do
    begin
       // если узел является граничным
       if (mapPT[i].itype = 2) then
       begin
          // уникальный номер границы
          iunicalnumber:=mapPT[i].iboundary;
          // поиск границы с уникальным номером.
          for j:=1 to GridGenForm.inumboundary do
          begin
             if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
             begin
                T[mapPT[i].i + (mapPT[i].j-1)*inx]:=GridGenForm.edgelist[j].temperaturecondition;
             end;
          end;
       end;
    end;

end; // initBoundaryConditionTempreture

// задание граничных условий
// первого рода
// для функции тока
procedure TForm1.initBoundaryConditionStreamFunction;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный номер границы

begin
    // проход по всем узлам
    for i:=1 to imaxnumbernode do
    begin
       // если узел является граничным
       if (mapPT[i].itype = 2) then
       begin
          // уникальный номер границы
          iunicalnumber:=mapPT[i].iboundary;
          // поиск границы с уникальным номером.
          for j:=1 to GridGenForm.inumboundary do
          begin
             if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
             begin
                case GridGenForm.edgelist[j].chSFval of
                  'c' : // const
                      begin
                         SF[mapPT[i].i + (mapPT[i].j-1)*inx]:=GridGenForm.edgelist[j].rSFval;
                      end;
                  'x' : // значения абсциссы
                      begin
                         SF[mapPT[i].i + (mapPT[i].j-1)*inx]:=xpos[mapPT[i].i];
                      end;
                  'y' : // значение ординаты
                      begin
                         SF[mapPT[i].i + (mapPT[i].j-1)*inx]:=ypos[mapPT[i].j];
                      end;
                end;
             end;
          end;
       end;
    end;

end; // initBoundaryConditionStreamFunction


// задание граничных условий
// первого рода
// для горизонтальной компоненты скорости Vx
procedure TForm1.initBoundaryConditionVx;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный идентификатор границы к которой принадлежит граничная точка

begin
   
   for i:=1 to imaxnumbernodeVx do
   begin
      if (mapVx[i].itype = 2) then
      begin
         // граничный узел
         // условия первого рода
         // уникальный номер границы
         iunicalnumber:=mapVx[i].iboundary;
         // поиск границы с уникальным номером.
         for j:=1 to GridGenForm.inumboundary do
         begin
            if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
            begin
               Vx[mapVx[i].i + (mapVx[i].j-1)*(inx-1)]:=GridGenForm.edgelist[j].Vx;
            end;
         end;
      end;
   end;
end; // initBoundaryConditionVx


// задание граничных условий
// первого рода
// для вертикальной компоненты скорости Vy
procedure TForm1.initBoundaryConditionVy;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный идентификатор границы к которой принадлежит граничная точка

begin

   for i:=1 to imaxnumbernodeVy do
   begin
      if (mapVy[i].itype = 2) then
      begin
         // граничный узел
         // условия первого рода
         // уникальный номер границы
         iunicalnumber:=mapVy[i].iboundary;
         // поиск границы с уникальным номером.
         for j:=1 to GridGenForm.inumboundary do
         begin
            if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
            begin
               Vy[mapVy[i].i + (mapVy[i].j-1)*inx]:=GridGenForm.edgelist[j].Vy;
            end;
         end;
      end;
   end;

end; // initBoundaryConditionVy

// задание граничных условий
// первого рода
// для Давления
procedure TForm1.initBoundaryConditionPressure;
var
  k,j1 : Integer; // счётчики
  iunicalnumber : Integer; // уникальный идентификатор границы к которой принадлежит граничная точка

begin

   for k:=1 to imaxnumbernode do
   begin
   with mapPT[k] do
   begin
      if (itype = 2) then
      begin
         // граничный узел
         // условия первого рода
         // уникальный номер границы
         iunicalnumber:=iboundary;
         // поиск границы с уникальным номером.
         for j1:=1 to GridGenForm.inumboundary do
         begin
            if ( GridGenForm.edgelist[j1].idescriptor = iunicalnumber) then
            begin
               if (GridGenForm.edgelist[j1].bpressure) then
               begin
                  // Давление в граничных точках не оказывает влияния.
                  P[i + (j-1)*inx]:=GridGenForm.edgelist[j1].rpressure;
                  case mapPT[i + (j-1)*inx].chnormal of
                  'N' : begin
                           // внутренняя нормаль
                           P[i + (j)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  'S' : begin
                           // внутренняя нормаль
                           P[i + (j-2)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  'W' : begin
                           // внутренняя нормаль
                           P[(i-1) + (j-1)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  'E' : begin
                           // внутренняя нормаль
                           P[(i+1) + (j-1)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  end; // case
               end;
            end;
         end;
      end;
      end;
   end;

end; // initBoundaryConditionPressure


// Делает одну иерацию методом Гаусса - Зейделя
// для универсальной искомой функции U.
procedure TForm1.GZUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         var db : array of Float); // коэффициенты правой части, содержащие источниковый член
const
      epsilon = 1e-30;
      relaxfactorboncon = 0.01; // параметр релаксации для граничного условия на выходной границе
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблон
    iwwi, ieei, inni, issi : Integer; // для мягких граничных условий
    bnei, bsim, boutflow : Boolean; // для условия Неймана
    k : Integer; // Счётчики
    ilengthmap : Integer;
    relaxfac : Float; // параметр релаксации
    ptilda : Float;

begin

    ilengthmap:=imaxnumbernode; // инициализация
    relaxfac:=1; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
             relaxfac:=myrelaxfactors.pSORTempreture;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
             relaxfac:=myrelaxfactors.pSORVelocityVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
              relaxfac:=myrelaxfactors.pSORVelocityVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
             relaxfac:=1;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
             relaxfac:=myrelaxfactors.pSORPressure;
          end;
    'S' : begin
             // функция тока
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0; // нет релаксации
          end;
    end;

    try

   // цикл по всем узлам расчётной области
   for k:=1 to ilengthmap do
   begin
      with map[k] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел
            ini:=i + j*icolx; // север
            isi:=i + (j-2)*icolx; // юг
            iwi:=(i-1) + (j-1)*icolx; // запад
            iei:=(i+1) + (j-1)*icolx; // восток
            ipi:=i + (j-1)*icolx; // текущая точка
            if (abs(m[ipi].dap) < epsilon ) then
            begin
               m[ipi].dap:=1.0;
            end;
            ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
            U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
         end // внутренняя точка
          else
         begin
            // граничный узел с условием Неймана
            // задан тепловой поток
            if (itype = 2) then
            begin

               // такая граница найдена
               // и на ней поставлено условие Неймана.

               // на границе поставлено условие Неймана
               if (iugol=0) then
               begin
                  // граничная точка не является угловой


                  case chvariable of
                   'T' : begin
                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           bnei:= GridGenForm.isneiman(iboundary,chvariable,chnormal);
                           if (bnei) then
                           begin
                              case chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   ini:=i+j*icolx; // север
                                   iwi:=(i-1)+(j-1)*icolx; // запад
                                   iei:=(i+1)+(j-1)*icolx; // восток
                                   ipi:=i+(j-1)*icolx; // текущая точка
                                   if (abs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   isi:=i+(j-2)*icolx; // юг
                                   iwi:=(i-1)+(j-1)*icolx; // запад
                                   iei:=(i+1)+(j-1)*icolx; // восток
                                   ipi:=i+(j-1)*icolx; // текущая точка
                                   if (abs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   ini:=i+j*icolx; // север
                                   isi:=i+(j-2)*icolx; // юг
                                   iwi:=(i-1)+(j-1)*icolx; // запад
                                   ipi:=i+(j-1)*icolx; // текущая точка
                                   if (abs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   ptilda:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   ini:=i+j*icolx; // север
                                   isi:=i+(j-2)*icolx; // юг
                                   iei:=(i+1)+(j-1)*icolx; // восток
                                   ipi:=i+(j-1)*icolx; // текущая точка
                                   if (abs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                              end; // case  нормаль
                           end; // условие Неймана
                           boutflow:= GridGenForm.isoutflow(iboundary,chvariable,chnormal);
                           if (boutflow) then
                           begin
                              case chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        ipi:=i+(j-1)*icolx; // текущая точка
                                        ini:=i+j*icolx; // север
                                        inni:=i+(j+1)*icolx; // удвоеннный север
                                        ptilda:=(2*U[ini]-U[inni]);
                                        U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        ipi:=i+(j-1)*icolx; // текущая точка
                                        isi:=i+(j-2)*icolx; // юг
                                        issi:= i+(j-3)*icolx; // удвоенный юг
                                        ptilda:=(2*U[isi]-U[issi]);
                                        U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=i+(j-1)*icolx; // текущая точка
                                        iwi:=(i-1)+(j-1)*icolx; // запад
                                        iwwi:=(i-2)+(j-1)*icolx; // удвоенный запад
                                        ptilda:=(2*U[iwi]-U[iwwi]);
                                        U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=i+(j-1)*icolx; // текущая точка
                                        iei:=(i+1)+(j-1)*icolx; // восток
                                        ieei:= (i+2)+(j-1)*icolx; // удвоенный восток
                                        ptilda:=(2*U[iei]-U[ieei]);
                                        U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     end;
                              end; // case
                           end;
                           bsim:=GridGenForm.issimm(iboundary,chvariable,chnormal);
                           if (bsim) then
                           begin
                              case chnormal of
                              'N' : // нижняя стенка
                                  // внутренняя нормаль
                                  begin
                                     ipi:=i+(j-1)*icolx; // текущая точка
                                     ini:=i+j*icolx; // север
                                     ptilda:=U[ini];
                                     U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                  end;
                               'S' : // верхняя стенка
                                  // внутренняя нормаль
                                  begin
                                     ipi:=i+(j-1)*icolx; // текущая точка
                                     isi:=i+(j-2)*icolx; // юг
                                     ptilda:=U[isi];
                                     U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                  end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=i+(j-1)*icolx; // текущая точка
                                        iwi:=(i-1)+(j-1)*icolx; // запад
                                        ptilda:=U[iwi];
                                        U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     end;
                               'E' : // восток (левая стенка)
                                   // внутренняя нормаль
                                   begin
                                      ipi:=i+(j-1)*icolx; // текущая точка
                                      iei:=(i+1)+(j-1)*icolx; // восток
                                      ptilda:=U[iei];
                                      U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   end;
                               end; //case
                           end; // граница симметрии
                  end; // T
                  'U' : begin
                           // горизонтальная скорость.
                           boutflow:= GridGenForm.isoutflow(iboundary,chvariable,chnormal);
                           if (boutflow) then
                           begin
                              case chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 ini:=i + j*icolx; // север
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 iei:=(i+1) + (j-1)*icolx; // восток
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 ini:=i+j*icolx; // север
                                                 inni:=i+(j+1)*icolx; // удвоеннный север
                                                 ptilda:=(2*U[ini]-U[inni]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ini:=i + j*icolx; // север
                                                 U[ipi]:=U[ini]; // равенство нормальной производной нулю.
                                              end;
                                        end; // case
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=i + (j-2)*icolx; // юг
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 iei:=(i+1) + (j-1)*icolx; // восток
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 isi:=i+(j-2)*icolx; // юг
                                                 issi:= i+(j-3)*icolx; // удвоенный юг
                                                 ptilda:=(2*U[isi]-U[issi]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                  ipi:=i + (j-1)*icolx; // текущая точка
                                                  isi:=i + (j-2)*icolx; // юг
                                                  U[ipi]:=U[isi]; // равенство нормальной производной нулю.
                                              end;
                                          end; // case
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                         case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=i + (j-2)*icolx; // юг
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 ini:=(i) + (j)*icolx; // север
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 if (j = (iny div 2)) then
                                                 begin
                                                    U[ipi]:=1; // скорости на входе в расчётную область
                                                 end
                                                  else
                                                 begin
                                                    U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 end;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 iwi:=(i-1)+(j-1)*icolx; // запад
                                                 iwwi:=(i-2)+(j-1)*icolx; // удвоенный запад
                                                 ptilda:=(2*U[iwi]-U[iwwi]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 U[ipi]:=U[iwi]; // равенство нормальной производной нулю.
                                              end;
                                          end;
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=i + (j-2)*icolx; // юг
                                                 iei:=(i+1) + (j-1)*icolx; // восток
                                                 ini:=(i) + (j)*icolx; // север
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                               end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 iei:=(i+1)+(j-1)*icolx; // восток
                                                 ieei:= (i+2)+(j-1)*icolx; // удвоенный восток
                                                 ptilda:=(2*U[iei]-U[ieei]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                           2 : // из статьи в интернете
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 iei:=(i+1) + (j-1)*icolx; // запад
                                                 U[ipi]:=U[iei]; // равенство нормальной производной нулю.
                                              end;
                                          end;
                                     end;
                              end; // case
                           end;
                           bsim:= GridGenForm.issimm(iboundary,chvariable,chnormal);
                           if (bsim) then
                           begin
                              case chnormal of
                               'N' : // нижняя стенка
                                begin
                                   ipi:=i+(j-1)*icolx; // текущая точка
                                   ini:=i+j*icolx; // север
                                   U[ipi]:= U[ini];// + relaxfac*(U[ini]-U[ipi]);
                                end;
                               'S' : // верхняя стенка
                               begin
                                   ipi:=i+(j-1)*icolx; // текущая точка
                                   isi:=i+(j-2)*icolx; // юг j
                                   U[ipi]:= U[isi];// + relaxfac*(U[isi]-U[ipi]);
                                end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=i+(j-1)*icolx; // текущая точка
                                    U[ipi]:= 0.0;
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=i+(j-1)*icolx; // текущая точка
                                    U[ipi]:= 0.0;
                                 end;
                              end; // case нормаль
                           end;// bsimm
                        end; // U - горизонтальная скорость
                  'V' : // вертикальная скорость
                        begin
                           boutflow:= GridGenForm.isoutflow(iboundary,chvariable,chnormal);
                           if (boutflow) then
                           begin
                              case chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 ini:=i + j*icolx; // север
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 iei:=(i+1) + (j-1)*icolx; // восток
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 ini:=i+j*icolx; // север
                                                 inni:=i+(j+1)*icolx; // удвоеннный север
                                                 ptilda:=(2*U[ini]-U[inni]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ini:=i + j*icolx; // север
                                                 U[ipi]:=U[ini];
                                              end;
                                          end; // case
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=i + (j-2)*icolx; // юг
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 iei:=(i+1) + (j-1)*icolx; // восток
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 isi:=i+(j-2)*icolx; // юг
                                                 issi:= i+(j-3)*icolx; // удвоенный юг
                                                 ptilda:=(2*U[isi]-U[issi]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 isi:=i+(j-2)*icolx; // юг
                                                 U[ipi]:=U[isi];
                                              end;
                                        end; // case
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=i + (j-2)*icolx; // юг
                                                 iwi:=(i-1) + (j-1)*icolx; // запад
                                                 ini:=(i) + (j)*icolx; // север
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 iwi:=(i-1)+(j-1)*icolx; // запад
                                                 iwwi:=(i-2)+(j-1)*icolx; // удвоенный запад
                                                 ptilda:=(2*U[iwi]-U[iwwi]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 iwi:=(i-1)+(j-1)*icolx; // запад
                                                 U[ipi]:=U[iwi];
                                              end;
                                        end; // case
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=i + (j-2)*icolx; // юг
                                                 iei:=(i+1) + (j-1)*icolx; // восток
                                                 ini:=(i) + (j)*icolx; // север
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=i+(j-1)*icolx; // текущая точка
                                                 iei:=(i+1)+(j-1)*icolx; // восток
                                                 ieei:= (i+2)+(j-1)*icolx; // удвоенный восток
                                                 ptilda:=(2*U[iei]-U[ieei]);
                                                 U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=i + (j-1)*icolx; // текущая точка
                                                 iei:=(i+1)+(j-1)*icolx; // восток
                                                 U[ipi]:=U[iei];
                                              end;
                                        end; // case
                                     end;
                              end; // case
                           end; // outflow
                           bsim:= GridGenForm.issimm(iboundary,chvariable,chnormal);
                           if (bsim) then
                           begin
                              case chnormal of
                               'N' : // нижняя стенка
                                   begin
                                      ipi:=i+(j-1)*icolx; // текущая точка
                                      U[ipi]:=0.0; // нет протекания через границу симметрии
                                   end;
                                'S' : // верхняя стенка
                                    begin
                                       ipi:=i+(j-1)*icolx; // текущая точка
                                       U[ipi]:=0.0; // нет протекания через границу симметрии
                                    end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=i+(j-1)*icolx; // текущая точка
                                    iwi:=(i-1)+(j-1)*icolx; // запад
                                    U[ipi]:= U[iwi];// + relaxfac*(U[iwi]-U[ipi]);
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=i+(j-1)*icolx; // текущая точка
                                    iei:=(i+1)+(j-1)*icolx; // восток
                                    U[ipi]:= U[iei];// + relaxfac*(U[iei]-U[ipi]);
                                 end;
                              end; // case нормаль
                           end;// bsimm
                        end;
                        // Давления здесь нет, т.к. для него краевые точки не играют роли
                        // (не учитываются при расчёте).
                  end; // case chvariable
               end // граничная точка
                else
               begin  // угловая точка
                  ipi:=i+(j-1)*icolx; // текущая точка
                  // среднее арефметическое на значащих узлах
                  case iugol of
                     1 :  // левый нижний угол
                        begin
                           ini:=i+j*icolx; // север
                           iei:=(i+1)+(j-1)*icolx; // восток
                           if (abs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=(0.5*U[iei]+0.5*U[ini]);
                        end;
                     2 : // правый нижний угол
                        begin
                           ini:=i+j*icolx; // север
                           iwi:=(i-1)+(j-1)*icolx; // запад
                           if (abs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=(0.5*U[iwi]+0.5*U[ini]);
                        end;
                     3 : // верхний левый угол
                        begin
                           isi:=i+(j-2)*icolx; // юг
                           iei:=(i+1)+(j-1)*icolx; // восток
                           if (abs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=(0.5*U[iei]+0.5*U[isi]);
                        end;
                     4 : // верхний правый угол
                        begin
                            isi:=i+(j-2)*icolx; // юг
                            iwi:=(i-1)+(j-1)*icolx; // запад
                            if (abs(m[ipi].dap) < epsilon ) then
                            begin
                                m[ipi].dap:=1.0;
                            end;
                             //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                             U[ipi]:=(0.5*U[iwi]+0.5*U[isi]);
                        end;
                     5 : // пятиточечная звезда
                        begin
                           ini:=i+j*icolx; // север
                           isi:=i+(j-2)*icolx; // юг
                           iei:=(i+1)+(j-1)*icolx; // восток
                           iwi:=(i-1)+(j-1)*icolx; // запад
                           if (abs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=(0.25*U[iei]+0.25*U[ini]+0.25*U[isi]+0.25*U[iwi]);
                        end;
                  end; // case
               end; // угловая точка

            end;
         end;
      end;
   end;

   except
      MainMemo.Lines.Add('exception GZ : division by zero');
   end;

end; // GZUniversal

// решение СЛАУ с трёхдиагональной матрицей
// при вертикальной прошивке расчётной области
procedure TForm1.TDMAGibridGZUniversalVertical(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           boncond : Integer; // тип граничных условий снизу
                           bonconup : Integer; // тип граничных условий сверху
                           jstart, jend : Integer; // маркеры на чала и конца прогонки
                           i : Integer; // номер вертикальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
var
    j : Integer; // горизонтальный счётчик
    iei,iwi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    tom : array of TOMASelem; // коэффициенты СЛАУ с Трёхдиагональной матрицей
    rdivision : Float; // для ускорения времени счёта
    i1, ilength : Integer; // счётчик в алгоритме Томаса

begin
    ilength:=jend-jstart+1;
   // для фиксированного i меняем j от 1 до icoly
   // имеем уравнение
   // m[ipi].dap*U[ipi]=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+d[ipi];
   // где d[ipi]:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
   SetLength(tom,ilength+1); // нумерация начинается с единицы
   case boncond of
   0 :
      begin
         // Граничные условия I рода.
         // значение первой точки при j=1 на границе задано
         tom[1].a:=1;
         tom[1].b:=0;
         tom[1].c:=0; // c1
         tom[1].d:=U[i+(jstart-1)*icolx]; // U1 = U[i+(j-1)*icolx], но j=1.
      end;
   1 :
      begin
         // Граничные условия II рода.
         j:=jstart;
         //ini:=i+j*icolx;  // север              j+1
         //isi:=i+(j-2)*icolx; // юг              j-1
         ipi:=i+(j-1)*icolx; // текущая точка   j
         // это для коэффициента tom[1].d
         iwi:=(i-1)+(j-1)*icolx; // запад
         iei:=(i+1)+(j-1)*icolx; // восток

         tom[1].a:=m[ipi].dap;
         tom[1].b:=m[ipi].dan;
         tom[1].c:=0; // c1
         tom[1].d:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
      end;
   2 : // условия симметрии
      begin
         tom[1].a:=1;
         tom[1].b:=-1;
         tom[1].c:=0; // c1
         tom[1].d:=0;
      end;
   end; // case
   case bonconup of
   0 :
       begin
          // Граничные условия I рода
          // значение последней точки при j=icoly на границе задано
          tom[ilength].a:=1;
          tom[ilength].b:=0; // bN
          tom[ilength].c:=0;
          tom[ilength].d:=U[i+(jend-1)*icolx]; // UN
       end;
   1 :
       begin
          // Граничные условия II рода
          j:=jend;

          //ini:=i+j*icolx;  // север              j+1
          //isi:=i+(j-2)*icolx; // юг              j-1
          ipi:=i+(j-1)*icolx; // текущая точка   j
          // это для коэффициента tom[icoly].d
          iwi:=(i-1)+(j-1)*icolx; // запад
          iei:=(i+1)+(j-1)*icolx; // восток

          tom[ilength].a:=m[ipi].dap;
          tom[ilength].b:=0;
          tom[ilength].c:=m[ipi].das; // c1
          tom[ilength].d:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
       end;
   2 :  // граница симметрии
       begin
          tom[ilength].a:=1;
          tom[ilength].b:=0;
          tom[ilength].c:=-1;
          tom[ilength].d:=0;
       end;
   end; // case
   for j:=(jstart+1) to (jend-1) do
   begin  // здесь для какого-либо фиксированного i.

      //ini:=i+j*icolx;  // север              j+1
      //isi:=i+(j-2)*icolx; // юг              j-1
      ipi:=i+(j-1)*icolx; // текущая точка   j
      // это для коэффициента tom[j].d
      iwi:=(i-1)+(j-1)*icolx; // запад
      iei:=(i+1)+(j-1)*icolx; // восток

      tom[j-jstart+1].a:=m[ipi].dap;
      tom[j-jstart+1].b:=m[ipi].dan; // северный коэффициент при j+1
      tom[j-jstart+1].c:=m[ipi].das;  // южный коэффициент при j-1
      tom[j-jstart+1].d:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
   end;
   // теперь все коэффициенты  от 1 до N=icoly
   // трёхдиагональной СЛАУ определены
   rdivision:=1/tom[1].a;
   tom[1].P:=tom[1].b*rdivision; // P1=b1/a1
   tom[1].Q:=tom[1].d*rdivision; // Q1=d1/a1
   for i1:=(jstart+1) to jend do
   begin  // вычисление прогоночных коэффициентов Pi1, Qi1
     // Деление более ресурсоёмкая операция чем умножение.
     rdivision:=1/(tom[i1-jstart+1].a-tom[i1-jstart+1].c*tom[i1-jstart+1-1].P);
     // P[i1]=b[i1]/(a[i1]-c[i1]*P[i1-1]);
     tom[i1-jstart+1].P:=tom[i1-jstart+1].b*rdivision;
     // Q[i1]=(d[i1]+c[i1]*Q[i1-1])/(a[i1]-c[i1]*P[i1-1]);
     tom[i1-jstart+1].Q:=(tom[i1-jstart+1].d+tom[i1-jstart+1].c*tom[i1-jstart+1-1].Q)*rdivision;
   end; // i1
   // теперь можно узнать значения искомой величины U
   // UN=QN в случае граничных условий I рода эта информация не нужна,
   // так как граничная точка при условиях I рода и так известна.
   if ((bonconup=1) or (bonconup=2)) then
   begin
      // Определение граничной точки в случае условий Неймана.
      j:=jend;
      U[i+(j-1)*icolx]:=tom[ilength].Q;
   end;
   for j:=(jend-1) downto (jstart+1) do
   begin
     // при j=1 снова имеем граничную точку U1 = U[i].
     // Её значение и так известно в случае граничных условий I рода.
     // обратный ход метода прогонки
     // U[j]:=tom[j].P*U[j+1]+tom[j].Q;
     U[i+(j-1)*icolx]:=tom[j-jstart+1].P*U[i+j*icolx]+tom[j-jstart+1].Q;
   end; // теперь все температуры найдены.
   if ((boncond=1) or (boncond=2)) then
   begin
      // Определение граничной точки в случае условий Неймана.
      j:=jstart;
      U[i+(j-1)*icolx]:=tom[1].P*U[i+j*icolx]+tom[1].Q;
   end;
end; // TDMAGibridGZUniversalVertical

// решение СЛАУ с трёхдиагональной матрицей
// при горизонтальной прошивке расчётной области
procedure TForm1.TDMAGibridGZUniversalGorizontal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           bonconl : Integer; // тип граничных условий слева
                           bonconr : Integer; // тип граничных условий справа
                           istart, iend : Integer; // маркеры на чала и конца прогонки
                           j : Integer; // номер горизонтальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
var
    i : Integer; // Счётчики
    ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    tom : array of TOMASelem; // коэффициенты СЛАУ с Трёхдиагональной матрицей
    rdivision : Float; // для ускорения времени счёта
    i1 : Integer; // счётчик в алгоритме Томаса
    ilength : Integer;

begin
   ilength:=iend-istart+1;
   SetLength(tom,ilength+1); // нумерация начинается с единицы
   case bonconl of
   0 : begin
          // Граничные условия I рода.
          // значение первой точки при i=1 на границе задано
          tom[1].a:=1;
          tom[1].b:=0;
          tom[1].c:=0; // c1
          tom[1].d:=U[istart+(j-1)*icolx]; // U1 = U[1+(j-1)*icolx], при i=1.
       end;
   1 : begin
          // Граничные условия II рода.
          i:=istart;
          //iei:=(i+1)+(j-1)*icolx; // восток    i+1
          //iwi:=(i-1)+(j-1)*icolx; // запад     i-1
          ipi:=i+(j-1)*icolx; // текущая точка       i
          // это для коэффициента tom[j].d
          ini:=i+j*icolx;  // север
          isi:=i+(j-2)*icolx; // юг

          tom[1].a:=m[ipi].dap;
          tom[1].b:=m[ipi].dae; // северный коэффициент при i+1
          tom[1].c:=0.0;  // южный коэффициент при i-1
          tom[1].d:=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi];
       end;
   2 : begin
          // условие симметрии:
          // U[ipi]=U[iei] <=>     U[i]=U[i+1];
          tom[1].a:=1;
          tom[1].b:=-1;
          tom[1].c:=0; // c1
          tom[1].d:=0;
       end;
   end; // case
   case bonconr of
   0 : begin
          // Граничные условия I рода.
          // значение последней точки при i=icolx на границе задано
          tom[ilength].a:=1;
          tom[ilength].b:=0; // bN
          tom[ilength].c:=0;
          tom[ilength].d:=U[iend+(j-1)*icolx]; // UN
       end;
   1 : begin
         // Граничные условия II рода.
         i:=iend;

         //iei:=(i+1)+(j-1)*icolx; // восток     i+1
         //iwi:=(i-1)+(j-1)*icolx; // запад      i-1
         ipi:=i+(j-1)*icolx; // текущая точка       i
         // это для коэффициента tom[j].d
         ini:=i+j*icolx;  // север
         isi:=i+(j-2)*icolx; // юг

         tom[ilength].a:=m[ipi].dap;
         tom[ilength].b:=0.0; // северный коэффициент при i+1
         tom[ilength].c:=m[ipi].daw;  // южный коэффициент при i-1
         tom[ilength].d:=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi];
       end;
      2 : // условие симметрии U[i]=U[i-1];
        begin
          tom[ilength].a:=1;
          tom[ilength].b:=0;
          tom[ilength].c:=-1;
          tom[ilength].d:=0;
        end;
   end;

   for i:=(istart+1) to (iend-1) do
   begin  // здесь для какого-либо фиксированного j.

      //iei:=(i+1)+(j-1)*icolx; // восток            i+1
      //iwi:=(i-1)+(j-1)*icolx; // запад             i-1
      ipi:=i+(j-1)*icolx; // текущая точка       i
      // это для коэффициента tom[j].d
      ini:=i+j*icolx;  // север
      isi:=i+(j-2)*icolx; // юг

      tom[i-istart+1].a:=m[ipi].dap;
      tom[i-istart+1].b:=m[ipi].dae; // северный коэффициент при i+1
      tom[i-istart+1].c:=m[ipi].daw;  // южный коэффициент при i-1
      tom[i-istart+1].d:=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi];
   end;
   // теперь все коэффициенты  от 1 до N=icolx
   // трёхдиагональной СЛАУ определены
   rdivision:=1/tom[1].a;
   tom[1].P:=tom[1].b*rdivision; // P1=b1/a1
   tom[1].Q:=tom[1].d*rdivision; // Q1=d1/a1
   for i1:=(istart+1) to iend do
   begin  // вычисление прогоночных коэффициентов Pi1, Qi1
      // Для ускорения счёта: операция деления более ресурсоёмкое чем
      // умножение. Множитель rdivision вычисляется один раз а потом используется.
      rdivision:=1/(tom[i1-istart+1].a-tom[i1-istart+1].c*tom[i1-istart+1-1].P);
      // P[i1]=b[i1]/(a[i1]-c[i1]*P[i1-1]);
      tom[i1-istart+1].P:=tom[i1-istart+1].b*rdivision;
      // Q[i1]=(d[i1]+c[i1]*Q[i1-1])/(a[i1]-c[i1]*P[i1-1]);
      tom[i1-istart+1].Q:=(tom[i1-istart+1].d+tom[i1-istart+1].c*tom[i1-istart+1-1].Q)*rdivision;
   end; // i1

   // теперь можно узнать значения температур
   // UN=QN в случае граничных условий первого рода эта информация ненужна,
   // т.к. значение на границе и так известно. Но в случае условий Неймана вычислять надо.
   if ((bonconr=1) or (bonconr=2))  then
   begin
     // Определение граничной точки в случае условий Неймана.
     i:=iend;
     U[i+(j-1)*icolx]:=tom[ilength].Q;
   end;
   for i:=(iend-1) downto (istart+1) do
   begin
     // при i=1 снова имеем граничную точку U1 = U[1+(j-1)*icolx]
     // Её значение и так известно в случае граничных условий I рода.
     // обратный ход метода прогонки
     // U[i]:=tom[i].P*U[i+1]+tom[i].Q;
     U[i+(j-1)*icolx]:=tom[i-istart+1].P*U[i+1+(j-1)*icolx]+tom[i-istart+1].Q;
   end; // теперь все значения искомой величины найдены.
   if ((bonconl=1) or (bonconl=2)) then
   begin
      // Определение значения на границе в случае условий Неймана.
      i:=istart;
      U[i+(j-1)*icolx]:=tom[1].P*U[(i+1)+(j-1)*icolx]+tom[1].Q;
   end;

end; // TDMAGibridGZUniversalGorizontal


// делает одну итерацию методом переменных направлений
// Этот метод также можно назвать методом продольно - поперечной прогонки.
// для любой искомой величины, для граничных условий I & II рода.
// этому методу передаются на вход коэффициенты дискретного аналога
// и карта расположения узлов.
procedure TForm1.TDMAGibridGZUniversal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           const map : array of TmyNode; // карта
                           chvariable : Char; // какая переменная рассматривается
                           var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           var db : array of Float); // коэффициенты правой части, содержащие источниковый член
type
     Tprogonka = record
        istart, iend : Integer;
        boncond, bonconup : Integer; // 0 - I рода, 1 - II рода.
        // 2 - условия симметрии.
     end;

const
     epsilon = 1e-30;
var
    i, j,k : Integer; // Счётчики
    Aseq : array of Tprogonka; // прогоночные интервалы
    bflag1, bflag2, bflag3  : Boolean; // для создания прогоночных интервалов
    ipi,imarker : Integer; // текущая точка и кол-ва прогоночных интервалов
    ini, iei,isi, iwi : Integer;
    ilengthmap : Integer;

begin
   // идея алгоритма следующая
   // 1. выбрать направление прошивки, например вертикальное.
   // 2. для каждой вертикальной направляющей требуется найти
   // интервалы для вертикальной прошивки - это расстояние
   // от границы до границы через внутренние точки расчётной области.

   // фиксируем i
   for i:=2 to icolx-1 do
   begin
      // проход слева направо
      // скорость передачи информации о граничных условиях
      // вглубь расчётной области: в горизонтальном направлении оси x
      // медленная (как у Гаусса-Зейеля), зато в вертикальном направлении
      // мгновенная.

      imarker:=1; // инициализация
      SetLength(Aseq, 1); // пока ни одного интервала
      bflag1:=false; // граница не найдена
      bflag2:=false;
      for j:=1 to icoly do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         ini:=i+(j+1-1)*icolx; // верхняя точка
         if (map[ipi].itype=2) then
         begin // граничная точка
            bflag3:=false;
            if (j<icoly) then
            begin
               if (map[ini].itype=1) then bflag3:=true;
            end;
            if ((not(bflag1)) and (bflag3)) then
            begin
                // граница начала а за ней сразу внутренняя точка
                // редактирует длину массива границ
                inc(imarker);
                SetLength(Aseq,imarker); // выделение памяти под новый интервал
                // точка на нижней стенке
                Aseq[imarker-1].istart:=j; // индекс начальной точки.
                case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'N')) then
                              Aseq[imarker-1].boncond:=1  // II - рода
                            else
                              Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'N')) then
                               Aseq[imarker-1].boncond:=2  // условия симметрии
                            else
                               Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 end;

                bflag1:=true; // начальная граница найдена
                bflag2:=true; // не сразу граница конца
            end;
            if ((bflag1) and (not(bflag2))) then
            begin
               // граница конца
               // точка на верхней стенке
               Aseq[imarker-1].iend:=j; // индекс конечной точки
               case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'S')) then
                              Aseq[imarker-1].bonconup:=1  // II - рода
                            else
                             Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'S')) then
                               Aseq[imarker-1].bonconup:=2  // условия симметрии
                            else
                               Aseq[imarker-1].bonconup:=0; // I - рода
                          end;
                 end;
                bflag1:=false;
            end;
            bflag2:=false;
         end;
      end;

      for j:=1 to (imarker-1) do
      begin
         // прошивка в вертикальном направлении при фиксированном i
         TDMAGibridGZUniversalVertical(U, icolx, icoly, Aseq[j].boncond, Aseq[j].bonconup, Aseq[j].istart, Aseq[j].iend, i, m, db);
      end;
   end; // i
   // конец первого прохода слева направо


   // проход снизу вверх
   // фиксируем j
   for j:=2 to icoly-1 do
   begin
      imarker:=1; // инициализация
      SetLength(Aseq, 1); // пока ни одного интервала
      bflag1:=false; // граница не найдена
      bflag2:=false;
      for i:=1 to icolx do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         iei:=(i+1)+(j-1)*icolx; // следующая точка
         if (map[ipi].itype=2)  then
         begin  // граничная точка
            bflag3:=false;
            if (i<icolx) then
            begin
               if (map[iei].itype=1) then bflag3:=true;
            end;
            if ((not(bflag1)) and (bflag3)) then
            begin
                // граница сначала,  а за ней сразу внутренняя точка расчётной области
                // редактирует длину массива границ
                inc(imarker);
                SetLength(Aseq,imarker); // выделение памяти под новый интервал
                // точка на левой стенке
                Aseq[imarker-1].istart:=i; // индекс начала интервала
                case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'E')) then
                              Aseq[imarker-1].boncond:=1  // II - рода
                            else
                             Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'E')) then
                               Aseq[imarker-1].boncond:=2  // условия симметрии
                            else
                               Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 end;
                bflag1:=true; // начальная граница найдена
                bflag2:=true; // не сразу граница конца
            end;
            if ((bflag1) and (not(bflag2))) then
            begin
               // граница конца
               // точка на правой стенке
               Aseq[imarker-1].iend:=i; // индекс конца интервала
               case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'W')) then
                              Aseq[imarker-1].bonconup:=1  // II - рода
                            else
                             Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                  'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'W')) then
                               Aseq[imarker-1].bonconup:=2  // условия симметрии
                            else
                               Aseq[imarker-1].bonconup:=0; // I - рода
                       end;

                 end;
               bflag1:=false;
            end;
            bflag2:=false;
         end;
      end;


      for i:=1 to (imarker-1) do
      begin
         // Прошивка в горизонтальном направлении при фиксированном j.
         TDMAGibridGZUniversalGorizontal(U, icolx, icoly, Aseq[i].boncond, Aseq[i].bonconup, Aseq[i].istart, Aseq[i].iend, j, m, db);
      end;
   end;
   // конец прохода снизу вверх


   // проход справа налево
   // фиксируем i
   for i:=icolx-1 downto 2 do
   begin
      // проход справа налево
      // скорость передачи информации о граничных условиях
      // вглубь расчётной области: в горизонтальном направлении оси x
      // медленная (как у Гаусса-Зейеля), зато в вертикальном направлении
      // мгновенная.
      imarker:=1; // инициализация
      SetLength(Aseq, 1); // пока ни одного интервала
      bflag1:=false; // граница не найдена
      bflag2:=false;
      for j:=1 to icoly do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         ini:=i+(j+1-1)*icolx; // верхняя точка
         if (map[ipi].itype=2) then
         begin // граничная точка
             bflag3:=false;
            if (j<icoly) then
            begin
               if (map[ini].itype=1) then bflag3:=true;
            end;
            if ((not(bflag1)) and (bflag3)) then
            begin
                // граница начала а за ней сразу внутренняя точка
                // редактирует длину массива границ
                inc(imarker);
                SetLength(Aseq,imarker); // выделение памяти под новый интервал
                // точка на нижней стенке
                Aseq[imarker-1].istart:=j; // индекс начальной точки.
                case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'N')) then
                              Aseq[imarker-1].boncond:=1  // II - рода
                            else
                             Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'N')) then
                               Aseq[imarker-1].boncond:=2  // условия симметрии
                            else
                               Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 end;
                bflag1:=true; // начальная граница найдена
                bflag2:=true; // не сразу граница конца
            end;
            if ((bflag1) and (not(bflag2))) then
            begin
               // граница конца
               // точка на верхней стенке
               Aseq[imarker-1].iend:=j; // индекс конечной точки
               case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'S')) then
                              Aseq[imarker-1].bonconup:=1  // II - рода
                            else
                             Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'S')) then
                               Aseq[imarker-1].bonconup:=2  // условия симметрии
                            else
                               Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 end;
               bflag1:=false;
            end;
            bflag2:=false;
         end;
      end;


      for j:=1 to (imarker-1) do
      begin
         // прошивка в вертикальном направлении при фиксированном i
         TDMAGibridGZUniversalVertical(U, icolx, icoly,  Aseq[j].boncond, Aseq[j].bonconup, Aseq[j].istart, Aseq[j].iend, i, m, db);
      end;
   end; // i
   // конец третьего прохода справа налево


   // проход сверху вниз
   // фиксируем j
   for j:=icoly-1 downto 2 do
   begin

      imarker:=1; // инициализация
      SetLength(Aseq, 1); // пока ни одного интервала
      bflag1:=false; // граница не найдена
      bflag2:=false;
      for i:=1 to icolx do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         iei:=(i+1)+(j-1)*icolx; // следующая точка
         if (map[ipi].itype=2)  then
         begin  // граничная точка
            bflag3:=false;
            if (i<icolx) then
            begin
               if (map[iei].itype=1) then bflag3:=true;
            end;
            if ((not(bflag1)) and (bflag3)) then
            begin
                // граница сначала,  а за ней сразу внутренняя точка расчётной области
                // редактирует длину массива границ
                inc(imarker);
                SetLength(Aseq,imarker); // выделение памяти под новый интервал
                // точка на левой стенке
                Aseq[imarker-1].istart:=i; // индекс начала интервала
                case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'E')) then
                              Aseq[imarker-1].boncond:=1  // II - рода
                            else
                             Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'E')) then
                               Aseq[imarker-1].boncond:=2  // условия симметрии
                            else
                               Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 end;
                bflag1:=true; // начальная граница найдена
                bflag2:=true; // не сразу граница конца
            end;
            if ((bflag1) and (not(bflag2))) then
            begin
               // граница конца
               // точка на правой стенке
               Aseq[imarker-1].iend:=i; // индекс конца интервала
               case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'W')) then
                              Aseq[imarker-1].bonconup:=1  // II - рода
                            else
                             Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'W')) then
                               Aseq[imarker-1].bonconup:=2  // условия симметрии
                            else
                               Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 end;
               bflag1:=false;
            end;
            bflag2:=false;
         end;
      end;

      for i:=1 to (imarker-1) do
      begin
         // Прошивка в горизонтальном направлении при фиксированном j.
         TDMAGibridGZUniversalGorizontal(U, icolx, icoly, Aseq[i].boncond, Aseq[i].bonconup, Aseq[i].istart, Aseq[i].iend, j, m, db);
      end;
   end; // j
   // конец проходу сверху вниз


   ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
          end;
    end;

   // обработка всех угловых точек
   for k:=1 to ilengthmap do
   begin
      with (map[k]) do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         ini:=i+j*icolx; // север
         isi:=i+(j-2)*icolx; // юг
         iei:=(i+1)+(j-1)*icolx; // восток
         iwi:=(i-1)+(j-1)*icolx; // запад
         if (itype = 2) then
         begin
            // только если граничный узел

            // среднее арефметическое на значащих узлах
            case iugol of
              1 :  // левый нижний угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iei]+U[ini]);
                end;
              2 : // правый нижний угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iwi]+U[ini]);
                end;
              3 : // верхний левый угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iei]+U[isi]);
                end;
              4 : // верхний правый угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iwi]+U[isi]);
                end;
              5 : // пятиточечная звезда
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                   U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                end;
            end; // case
         end;
      end;// with
   end;

end; // TDMAGibridGZUniversal


// Решает задачу прямым методом исключения Гаусса
// для универсальной искомой функции U.
procedure TForm1.GaussUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсированные индексы
    i,j,k,i1,j1 : Integer; // Счётчики
    dA  : array of TmyDynArray; // матрица СЛАУ (хранится только лента).
    move : array of Integer; // для хранения ленточной матрицы
    dV  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    ilengthmap, ilengthA : Integer; // длина карты
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    bnei,bsymm : Boolean; // поставлено ли граничное условие Неймана, условие симметрии
    // проверяющий участок кода для отладки.
   //f : TStrings; // для отладки заполнения формируемых матриц
   //str : String; // для формирования отладочной информации

begin


   SetLength(pointerlistrevers,icolx*icoly);

    ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    end;

    // определим
    ilengthA:=0; // число уравнений которые потребуется решить
    for i:=1 to ilengthmap do
    begin
       if (map[i].itype<>0) then
       begin
          inc(ilengthA);
          // в число решаемых уравнений обязательно входят
          // все не пустые узлы (не hollow point) карты map
       end;
    end;

    // прямое преобразование
    SetLength(pointerlist,ilengthA);
    j:=0;
     for i:=1 to ilengthmap do
    begin
       if (map[i].itype<>0) then
       begin
          // список номеров уравнений
          // обязательно должна быть -1
          pointerlist[j]:=(map[i].i-1) + (map[i].j-1)*icolx; // номер для U
          inc(j); // переход к следующей не пустой точке.
       end;
    end;

    // инициализация
     for i:=0 to (icolx*icoly-1) do pointerlistrevers[i]:=-1; // будет вылетать по обращению на несуществующий адрес
    // обратное преобразование
    for i:=0 to (icolx*icoly-1) do
    begin
       // нужно найти в pointerlist[j] уникальный номер i
       for j:=0 to (ilengthA-1) do
       begin  // нахождение соответствия
          if (pointerlist[j]=i) then
          begin
             // по номеру для дает номер для x
             // для некоторых соответствующих несуществует
             // и тогда номер заменяется условным значением -1
             pointerlistrevers[i]:=j;
          end;
       end;
    end;

   if (bmessage) then MainMemo.Lines.Add('начало выделения оперативной памяти ');

   // выделение памяти под матрицу СЛАУ
   SetLength(move,ilengthA);
   for i:=0 to (ilengthA-1) do move[i]:=icolx-i; // массив сдвигов
   SetLength(dA,ilengthA);
   for i:=0 to (ilengthA-1) do SetLength(dA[i],2*icolx+1); // храним только ленту
   // выделение памяти под вектор правой части
   SetLength(dV,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);

   if (bmessage) then MainMemo.Lines.Add('окончание выделения оперативной памяти ');

   // обнуление матрицы dА
   for i:=0 to (ilengthA-1) do  for j:=0 to (2*icolx+1-1) do  dA[i][j]:=0.0; // обнуляем только ленту
   // инициализация вектора правой части
   for i:=0 to (ilengthA-1) do dV[i]:=0.0;
   // инициализация вектора
   k:=0;
   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin
          // нужно ли уравнение для данной точки ?
          j1:=i+(j-1)*inx;
          // принадлежит ли эта точка к списку зачисленных ?
          for i1:=0 to (ilengthA-1) do
          begin
             if (j1 = (pointerlist[i1]+1)) then
             begin
                // в U нумерация начинается с 1.
                dx[k]:= U[j1];
                inc(k);
             end;
          end;
      end;
   end;
   if (bmessage) then MainMemo.Lines.Add('прошла инициализация ');


   for i:=1 to ilengthmap do
   begin
      // внутренний узел
      ini:=map[i].i+map[i].j*icolx; // север
      isi:=map[i].i+(map[i].j-2)*icolx; // юг
      iwi:=(map[i].i-1)+(map[i].j-1)*icolx; // запад
      iei:=(map[i].i+1)+(map[i].j-1)*icolx; // восток
      ipi:=map[i].i+(map[i].j-1)*icolx; // текущая точка
      // реверсированные точки:
      rini:=pointerlistrevers[ini-1];
      risi:=pointerlistrevers[isi-1];
      riwi:=pointerlistrevers[iwi-1];
      riei:=pointerlistrevers[iei-1];
      ripi:=pointerlistrevers[ipi-1];
      if (map[i].itype = 1) then
      begin
         //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
         dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
         dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
         dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
         dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
         dA[ripi][risi+move[ripi]]:= - m[ipi].das;
         dV[ripi]:= db[ipi];
      end
       else
      begin
         // граничный узел
         if (map[i].itype = 2) then
         begin
            case chvariable of
             'T','P' : begin
                          // ищем границу по уникальному номеру
                          // на которой поставлено условие Неймана
                          bnei:=GridGenForm.isneiman(map[i].iboundary,chvariable,map[i].chnormal);
                          if (bnei) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие Неймана

                             // на границе поставлено условие Неймана
                             if (map[i].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i].iugol of
                              0 : // граничное условие первого рода
                                begin
                                  dA[ripi][ripi+move[ripi]]:=1.0;
                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][rini+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   dA[ripi][rini+move[ripi]]:= - 0.5;
                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riei+move[ripi]]:= - 0.25;
                                   dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   dA[ripi][rini+move[ripi]]:= - 0.25;
                                   dA[ripi][risi+move[ripi]]:= - 0.25;
                                   dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                    end;
             'U','V' : begin
                          bsymm:=GridGenForm.issimm(map[i].iboundary,chvariable,map[i].chnormal);
                          if (bsymm) then
                          begin
                             if (map[i].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=U[ini];
                                    dA[ripi][ripi+move[ripi]]:= 1;
                                    dA[ripi][rini+move[ripi]]:= - 1;
                                    dV[ripi]:= 0;
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=U[isi];
                                     dA[ripi][ripi+move[ripi]]:= 1;
                                     dA[ripi][risi+move[ripi]]:= - 1;
                                     dV[ripi]:= 0;
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=U[iwi];
                                      dA[ripi][ripi+move[ripi]]:= 1;
                                      dA[ripi][riwi+move[ripi]]:= - 1;
                                      dV[ripi]:= 0;
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=U[iei];
                                      dA[ripi][ripi+move[ripi]]:= 1;
                                      dA[ripi][riei+move[ripi]]:= - 1;
                                      dV[ripi]:= 0;
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i].iugol of
                              0 : // граничное условие первого рода
                                begin
                                  dA[ripi][ripi+move[ripi]]:=1.0;
                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][rini+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   dA[ripi][rini+move[ripi]]:= - 0.5;
                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riei+move[ripi]]:= - 0.25;
                                   dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   dA[ripi][rini+move[ripi]]:= - 0.25;
                                   dA[ripi][risi+move[ripi]]:= - 0.25;
                                   dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                       end;
             end; // case
         end;
      end;
   end;


   (* // проверяющий участок кода.
   f:=TStringList.Create();
   for k:=0 to (2*icolx) do
   begin
      str:='';
      for i:=0 to (ilengthA-1) do
      begin
         str:=str+FloatToStr(dA[i][k]) + ' ';
      end;
      f.Add(str);
   end;
   f.SaveToFile('debug.txt');
   f.Free;
   *)


   if (bmessage) then
   begin
      MainMemo.Lines.Add('матрица СЛАУ сформирована ');
   end;

   // Решение СЛАУ
   // прямым методом исключения Гаусса
   GaussAlgorithm(ilengthA, dA, icolx, icoly, move, dV, dx, bmessage);
   //LUdecomposition(ilengthA, dA, icolx, icoly, move, dV, dx, bmessage);
   // копирование полученного решения обратно в U
   for i:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i] + 1] := dx[i]; // вектор с решением задачи;
   end;
   // освобождение памяти
   Finalize(dA); // эта матрица на больших сетках будет действительно очень много памяти съедать.
   Finalize(move); // для вычисления сдвига при обращении к ленте
   Finalize(dV); // вектор правой части
   Finalize(dx); // вектор решения


end; // GaussUniversal

// трансформация Гаусса.
// выполняется и над матрицей СЛАУ dA и над вектором правой части dV.
procedure TForm1.GaussTransform(isize : Integer;
                                 var dA : array of TmyDynArray;
                                 var dV : array of Float);
var
    dB : array of TmyDynArray; // транспонированнпая матрица dA
    dC : array of TmyDynArray; // самосопряжённое положительно определённое произведение dB*dA
    i,j,k : Integer; // счётчик цикла for
    dsum : Float; // некая формируемая сумма
    dx : array of Float;

begin
   // преобразует матрицу СЛАУ путём
   // домножения её на саму себя транспонированную.
   // Результирующая матрица, являющая собой произведение двух,
   // будет уже самосопряжённой положительно определённой.
   // такому же преобразованию (домножению на транспонированную) должен
   // подвергаться и вектор правой части СЛАУ.

   // выделение памяти
   SetLength(dB, isize);
   for i:=0 to (isize-1) do SetLength(dB[i], isize);
   SetLength(dC, isize);
   for i:=0 to (isize-1) do SetLength(dC[i], isize);
   SetLength(dx, isize);

   // инициализация
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         dB[i][j]:=dA[j][i];
         dC[i][j]:=0.0;
      end;
      dx[i]:=0.0;
   end;

   // умножение транспонированной матрицы dA раной dB
   // на вектор dV. Результат сохраняется в dx.
   MatrixByVector(isize, dB, dV, dx);
   // запись результата обратно в dV
   for i:=0 to (isize-1) do dV[i]:=dx[i];

   // вычисление произведения
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         // нахождение элемента dC[i][j]
         dsum:=0.0; // обнуление сумматора
         for k:=0 to (isize-1) do
         begin
            dsum:= dsum + dB[i][k]*dA[k][j];
         end;
         dC[i][j]:=dsum;
      end;
   end;

   // формирование результата
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         dA[i][j]:=dC[i][j];
      end;
   end;

   // освобождение
   // оперативной памяти
   Finalize(dB);
   Finalize(dC);
   Finalize(dx);

end; // GaussTransform

// Решает задачу методом сопряжённых градиентов
// Хестенса и Штифеля
// для универсальной искомой функции U.
// данный метод имеет итерационный характер с хорошей скоростью сходимости,
// т.к. он строит базис и поэтому сходится за количество итераций
// равных размерности вектора правой части СЛАУ.
// Ещё одним достоинством данного метода является то, что он
// стартуя с некоторого начального приближения уточняет решение.
procedure TForm1.SoprGradUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсированные  индексы узлов на пятиточечном шаблоне
    i,j,k,i1,j1 : Integer; // Счётчики
    dA  : array of TmyDynArray; // матрица СЛАУ
    dV  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    ilengthmap, ilengthA : Integer; // длина пути по карте
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    bnei : Boolean; // поставлено ли граничное условие Неймана
    rbuf : Float;

begin
    ilengthmap:=imaxnumbernode; // инициализация
   case chvariable of
   'T' : begin
            // температура
            ilengthmap:=imaxnumbernode;
         end;
   'U' : begin
            // горизонтальная скорость
            ilengthmap:=imaxnumbernodeVx;
         end;
   'V' : begin
            // вертикальная скорость
            ilengthmap:=imaxnumbernodeVy;
         end;
   'O' : begin
            // others все другие переменные
            ilengthmap:=imaxnumbernode;
         end;
   end; // case

   // определим
    ilengthA:=0; // число уравнений которые потребуется решить
    for i:=1 to ilengthmap do
    begin
       if (map[i].itype<>0) then
       begin
          inc(ilengthA);
          // в число решаемых уравнений обязательно входят
          // все не пустые узлы (не hollow point) карты map
       end;
    end;

    // прямое преобразование
    SetLength(pointerlist,ilengthA);
    j:=0;
     for i:=1 to ilengthmap do
    begin
       if (map[i].itype<>0) then
       begin
          // список номеров уравнений
          // обязательно должна быть -1
          pointerlist[j]:=(map[i].i-1) + (map[i].j-1)*icolx; // номер для U
          inc(j); // переход к следующей не пустой точке.
       end;
    end;

    SetLength(pointerlistrevers,icolx*icoly); // выделение памяти
    // инициализация
     for i:=0 to (icolx*icoly-1) do pointerlistrevers[i]:=-1; // будет вылетать по обращению на несуществующий адрес
    // обратное преобразование
    for i:=0 to (icolx*icoly-1) do
    begin
       // нужно найти в pointerlist[j] уникальный номер i
       for j:=0 to (ilengthA-1) do
       begin  // нахождение соответствия
          if (pointerlist[j]=i) then
          begin
             // по номеру для дает номер для x
             // для некоторых соответствующих несуществует
             // и тогда номер заменяется условным значением -1
             pointerlistrevers[i]:=j;
          end;
       end;
    end;

   if (bmessage) then MainMemo.Lines.Add('начало выделения оперативной памяти ');

   // выделение памяти под матрицу СЛАУ
   SetLength(dA,ilengthA);
   for i:=0 to (ilengthA-1) do SetLength(dA[i],ilengthA);
   // выделение памяти под вектор правой части
   SetLength(dV,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);

   if (bmessage) then MainMemo.Lines.Add('окончание выделения оперативной памяти ');

   // обнуление матрицы dА
   for i:=0 to (ilengthA-1) do for j:=0 to (ilengthA-1) do  dA[i][j]:=0.0;
   // инициализация вектора правой части
   for i:=0 to (ilengthA-1) do dV[i]:=0.0;
   // инициализация вектора
   k:=0;
   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin
          // нужно ли уравнение для данной точки ?
          j1:=i+(j-1)*inx;
          // принадлежит ли эта точка к списку зачисленных ?
          for i1:=0 to (ilengthA-1) do
          begin
             if (j1 = (pointerlist[i1]+1)) then
             begin
                // в U нумерация начинается с 1.
                dx[k]:= U[j1];
                inc(k);
             end;
          end;
      end;
   end;
   if (bmessage) then MainMemo.Lines.Add('прошла инициализация ');

   for i:=1 to ilengthmap do
   begin
      ini:=map[i].i+map[i].j*icolx; // север
      isi:=map[i].i+(map[i].j-2)*icolx; // юг
      iwi:=(map[i].i-1)+(map[i].j-1)*icolx; // запад
      iei:=(map[i].i+1)+(map[i].j-1)*icolx; // восток
      ipi:=map[i].i+(map[i].j-1)*icolx; // текущая точка

      ripi:=pointerlistrevers[ipi-1];
      riei:=pointerlistrevers[iei-1];
      riwi:=pointerlistrevers[iwi-1];
      rini:=pointerlistrevers[ini-1];
      risi:=pointerlistrevers[isi-1];

      if (map[i].itype = 1) then
      begin
          // внутренний узел

         //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
         rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
         dA[ripi][ripi]:= 1.0;
         dA[ripi][riei]:= - rbuf*m[ipi].dae;
         dA[ripi][riwi]:= - rbuf*m[ipi].daw;
         dA[ripi][rini]:= - rbuf*m[ipi].dan;
         dA[ripi][risi]:= - rbuf*m[ipi].das;
         dV[ripi]:= rbuf*db[ipi];
      end
       else
      begin
         // граничный узел
         if (map[i].itype = 2) then
         begin
            // ищем границу по уникальному номеру
            // на которой поставлено условие Неймана
            bnei:=GridGenForm.isneiman(map[i].iboundary,chvariable,map[i].chnormal);
            if (bnei) then
            begin
               // такая граница найдена
               // и на ней поставлено условие Неймана

               // на границе поставлено условие Неймана
               if (map[i].iugol=0) then
               begin
                  //  граничная точка не являющаяся угловой

                  case map[i].chnormal of
                     'N' : //север (верх)
                      begin
                        //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                        rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                        dA[ripi][ripi]:= 1.0;
                        dA[ripi][riei]:= - rbuf*m[ipi].dae;
                        dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                        dA[ripi][rini]:= - rbuf*m[ipi].dan;
                        dV[ripi]:= rbuf*db[ipi];
                      end;
                   'S' : // юг (низ)
                    begin
                       //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                       rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                       dA[ripi][ripi]:= 1.0;
                       dA[ripi][riei]:= - rbuf*m[ipi].dae;
                       dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                       dA[ripi][risi]:= - rbuf*m[ipi].das;
                       dV[ripi]:= rbuf*db[ipi];
                    end;
                   'W' : // запад (лево)
                    begin
                       //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                       rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                       dA[ripi][ripi]:= 1.0;
                       dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                       dA[ripi][rini]:= - rbuf*m[ipi].dan;
                       dA[ripi][risi]:= - rbuf*m[ipi].das;
                       dV[ripi]:= rbuf*db[ipi];
                    end;
                   'E' : // восток (право)
                    begin
                       //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                        rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                        dA[ripi][ripi]:= 1.0;
                        dA[ripi][riei]:= - rbuf*m[ipi].dae;
                        dA[ripi][rini]:= - rbuf*m[ipi].dan;
                        dA[ripi][risi]:= - rbuf*m[ipi].das;
                        dV[ripi]:= rbuf*db[ipi];
                    end;
                  end; // case

                end
                 else
                begin
                  // среднее арефметическое на значащих узлах
                  case map[i].iugol of
                     1 :  // левый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riei]:= - rbuf*m[ipi].dae;
                           dA[ripi][rini]:= - rbuf*m[ipi].dan;
                           dV[ripi]:= 0.0;
                        end;
                     2 : // правый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                           dA[ripi][rini]:= - rbuf*m[ipi].dan;
                           dV[ripi]:= 0.0;
                        end;
                     3 : // верхний левый угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                            rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riei]:= - rbuf*m[ipi].dae;
                            dA[ripi][risi]:= - rbuf*m[ipi].das;
                            dV[ripi]:=0.0;
                        end;
                     4 : // верхний правый угол
                        begin
                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                            dA[ripi][risi]:= - rbuf*m[ipi].das;
                            dV[ripi]:= 0.0;
                        end;
                     5 : // пятиточечная звезда
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                            rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                            dA[ripi][ripi]:=1.0;
                            dA[ripi][riei]:= - rbuf*m[ipi].dae;
                            dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                            dA[ripi][rini]:= - rbuf*m[ipi].dan;
                            dA[ripi][risi]:= - rbuf*m[ipi].das;
                            dV[ripi]:= 0.0;
                        end;
                  end; // case

                end;
             end
               else
             begin
                // Обычные краевые условия первого рода которые
                // в данном случае также необходимо учесть

                  // среднее арефметическое на значащих узлах
                  case map[i].iugol of
                     0 : // граничное условие первого рода
                        begin
                           dA[ripi][ripi]:=1.0;
                           dV[ripi]:=U[ipi];
                        end;
                     1 :  // левый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riei]:= - 0.5;
                           dA[ripi][rini]:= - 0.5;
                           dV[ripi]:= 0.0;
                        end;
                     2 : // правый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riwi]:= - 0.5;
                           dA[ripi][rini]:= - 0.5;
                           dV[ripi]:= 0.0;
                        end;
                     3 : // верхний левый угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riei]:= - 0.5;
                            dA[ripi][risi]:= - 0.5;
                            dV[ripi]:=0.0;
                        end;
                     4 : // верхний правый угол
                        begin
                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riwi]:= - 0.5;
                            dA[ripi][risi]:= - 0.5;
                            dV[ripi]:= 0.0;
                        end;
                     5 : // пятиточечная звезда
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riei]:= - 0.25;
                            dA[ripi][riwi]:= - 0.25;
                            dA[ripi][rini]:= - 0.25;
                            dA[ripi][risi]:= - 0.25;
                            dV[ripi]:= 0.0;
                        end;
                  end;

            end;
         end;
      end;
   end;


   // Всё нижеперечисленное справедливо только для
   // граничных условий первого рода на всём периметре


   // Диагональное предъобуславливание:
   // домножение СЛАУ слева на обратную матрицу
   // к главной диагонали матрицы А.
   (*  сейчас диагональное преъдобуславливание
       встроено в формирование матрицы СЛАУ
   for i:=0 to ilengthA-1 do
   begin
      rbuf:=1/dA[i][i];
      dV[i]:=rbuf*dV[i];
      for j:=1 to ilengthA-1 do
      begin
         if (dA[i][j]<>0.0) then dA[i][j]:=rbuf*dA[i][j];
      end;
   end;
   *)


   MainMemo.Lines.Add('матрица СЛАУ сформирована ');

   if (bgt) then
   begin
      // трансформация Гаусса
      GaussTransform(ilengthA, dA, dV);
   end;

   // Решение СЛАУ
   // методом Сопряжённых Градиентов
   // Хестенса и Штифеля
   SoprGrad(ilengthA, dA, dV, U, dx, true, kend, epsilon); // точность вычисления epsilon
   // копирование полученного решения обратно в U
   for i:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i] + 1] := dx[i]; // вектор с решением задачи;
   end;

   // освобождение памяти
   Finalize(dA); Finalize(dV); Finalize(dx);

end; // SoprGradUniversal

// Решает задачу методом сопряжённых градиентов
// Хестенса и Штифеля
// для универсальной искомой функции U.
// данный метод имеет итерационный характер с хорошей скоростью сходимости,
// т.к. он строит базис и поэтому сходится за количество итераций
// равных размерности вектора правой части СЛАУ.
// Ещё одним достоинством данного метода является то, что он
// стартуя с некоторого начального приближения уточняет решение.
// Данная версия реализована с использованием технологии CRS хранения
// и обработки разреженных матриц. Учёт разреженности матрицы позволяет
// более эффективно использовать оперативную память компьютера и повысить
// скорость операций по решению большой СЛАУ. После того как данный метод
// пройдёт тестирование он может быть рекомендован к использованию.
procedure TForm1.SoprGradCRSUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         bmessage : Boolean; // выводить ли значение невязки на консоль: true - ДА, false - НЕТ.
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         itypealg : Integer; // тип алгоритма: 0 - Сопряжённые градиенты, 1 - Ю.Г. Соловейчика.
                         const db : array of Float); // коэффициенты правой части, содержащие источниковый член
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсивные индексы узлов на пятиточечном шаблоне
    i1,j1,i2,j2 : Integer; // Счётчики
    iNelem : Integer; // число ненулевых элементов матрицы СЛАУ
    k,k1 : Integer; // счётчик количества ненулевых элементов + проход по карте
    ilengthmap : Integer; // длина пути по карте
    nze : array of TmyNonZeroElemMatrix; // ненулевые элементы матрицы СЛАУ
    val  : array of Float; // ненулевые элементы матрицы СЛАУ
    col_ind : array of Integer; // соответствующие номера столбцов
    row_ptr : array of Integer; // для определения начала следующей строки.
    dV1  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    bnei : Boolean; // Условие Неймана для температуры
    ilengthA : Integer; // число уравнений которое требуется решить
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    dmul : Real; // для диагонального предъобуславливателя

begin
   ilengthmap:=imaxnumbernode; // инициализация
   case chvariable of
   'T' : begin
            // температура
            ilengthmap:=imaxnumbernode;
         end;
   'U' : begin
            // горизонтальная скорость
            ilengthmap:=imaxnumbernodeVx;
         end;
   'V' : begin
            // вертикальная скорость
            ilengthmap:=imaxnumbernodeVy;
         end;
   'O' : begin
            // others все другие переменные
            ilengthmap:=imaxnumbernode;
         end;
   end; // case

   // Это верно только для температуры
   k:=0;
   for k1:=1 to ilengthmap do
   begin
      if (map[k1].itype=1) then
      begin
         // внутренний узел
         k:=k+5;
      end
       else
      begin
         if (map[k1].itype=2) then
         begin
            // граничный узел
            bnei:=GridGenForm.isneiman(map[k1].iboundary,chvariable,map[k1].chnormal);
            if (bnei) then
            begin
               case map[k1].iugol of
                 0: begin
                       // условие Неймана
                       k:=k+4; // условие 2 рода
                    end;
                 1 : begin
                       k:=k+3;
                     end;
                 2:  begin
                       k:=k+3;
                     end;
                 3: begin
                       k:=k+3;
                     end;
                 4: begin
                       k:=k+3;
                     end;
                 5 : begin
                        k:=k+5;
                     end;
                 end; // case
            end  // Нейман
             else
            begin
               case map[k1].iugol of
                 0: begin
                       // условие Дирихле
                       k:=k+1; // условие 1 рода
                    end;
                 1 : begin
                       k:=k+3;
                     end;
                 2:  begin
                       k:=k+3;
                     end;
                 3: begin
                       k:=k+3;
                     end;
                 4: begin
                       k:=k+3;
                     end;
                 5 : begin
                        k:=k+5;
                     end;
                 end; // case
            end;
         end;
      end;
   end;

   // определим число уравнений которое требуется решить
   ilengthA:=0;
   for k1:=1 to ilengthmap do
   begin
      if (map[k1].itype<>0) then
      begin
         inc(ilengthA);
         // число решаемых уравнений равно числу
         // непустых узлов (не Hollow point) карты map.
      end;
   end;

   iNelem:=k; // число ненулевых элементов матрицы СЛАУ
   // выделение памяти под ненулевые эементы матрицы СЛАУ.
   // Этот массив будет использоваться для сортировки
   // сортировка выполняется с целью упорядочить строки матицы и ключом
   // служит номер строки. При этом среди множества ключей есть ключи равные друг другу,
   // однако это не мешает выполнить сортировку.
   SetLength(nze,iNelem+1); // ненулевые элементы которые потом придётся сортировать по строкам
   SetLength(val,iNelem); // ненулевые элементы матрицы СЛАУ
   SetLength(col_ind,iNelem); // соответствующие ненулевым элементам номера столбцов
   SetLength(row_ptr,ilengthA+1); // информация о том где начинается следующая строка
   // выделение памяти под вектор правой части
   SetLength(dV1,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);


   // обнуление матрицы dА
   // здесь было от 1 до iNelem
   for k1:=0 to (iNelem) do
   begin
      // инициализация
      // массива для хранения
      // ненулевых элементов
      nze[k1].i:=0;
      nze[k1].j:=0;
      nze[k1].aij:=0.0;
      nze[k1].key:=0;
   end;

   // обнуление матрицы dА
   for k1:=0 to (iNelem-1) do
   begin
      // инициализация
      val[k1]:=0.0;
      col_ind[k1]:=0;
   end;

   // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
   // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
   for k1:=0 to (ilengthA) do row_ptr[k1]:=iNelem; // инициализация указателей на следующую строку

   for k1:=0 to (ilengthA-1) do
   begin
      dV1[k1]:=0.0;  // инициализация вектора правой части
   end;

   // прямое преобразование
   SetLength(pointerlist,ilengthA);
   j1:=0;
   for i1:=1 to ilengthmap do
   begin
      if (map[i1].itype<>0) then
      begin
         // список номеров уравнений
         with map[i1] do
         begin
            pointerlist[j1]:=(i-1)+(j-1)*icolx; // номер для U
         end; // with
         inc(j1); // переход к следующей непустой точке
      end;
   end;

   // обратное преобразование
   SetLength(pointerlistrevers,icolx*icoly); // выделение памяти
   // инициализация
   // номер -1 соответствует hollow point
   for i1:=0 to (icolx*icoly-1) do pointerlistrevers[i1]:=-1;
   for i1:=0 to (icolx*icoly-1) do
   begin
      // нужно найти в pointerlist[j1] уникальный номер i1
      for j1:=0 to (ilengthA-1) do
      begin
         // нахождение соответствия
         if (pointerlist[j1]=i1) then
         begin
            // по номеру для U даёт номер для x
            // для некоторых соответствующих несуществует
            // и тогда номер заменяется условным значением -1
            pointerlistrevers[i1]:=j1;
         end;
      end;
   end;

   // инициализация вектора
   k1:=0;
   for i1:=1 to icolx do
   begin
      for j1:=1 to icoly do
      begin
         // нужно ли уравнение для этой точки ?
         j2:=i1+(j1-1)*inx; // нумерация начинается с 1
         // принадлежит ли эта точка к списку зачисленных ?
         for i2:=0 to (ilengthA-1) do
         begin
            if (j2 = (pointerlist[i2]+1)) then
            begin
               // в U нумерация начинается с 1
               dx[k1]:=U[j2]; // инициализация вектора решения
               inc(k1);
            end;
         end;
      end;
   end;

   k:=1; // счётчик ненулевых элементов
   // k - это просто индекс, нумерация начиная с 1 нужна для пирамидальной сортировки

   // здесь происходит обращение к элементам nze от 0 до iNelem-1

   // Заполнение матрицы dА с учётом её разреженности и
   // вектора правой части dV
   for k1:=1 to ilengthmap do
   begin
      with map[k1] do
      begin
         ini:=i+j*icolx; // север
         isi:=i+(j-2)*icolx; // юг
         iwi:=(i-1)+(j-1)*icolx; // запад
         iei:=(i+1)+(j-1)*icolx; // восток
         ipi:=i+(j-1)*icolx; // текущая точка

         rini:=pointerlistrevers[ini-1];
         risi:=pointerlistrevers[isi-1];
         riwi:=pointerlistrevers[iwi-1];
         riei:=pointerlistrevers[iei-1];
         ripi:=pointerlistrevers[ipi-1];


         if (itype = 1) then
         begin
            // внутренний узел

            // первый шаблон заполнения
            // U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
            // второй шаблон заполнения
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
            dmul:=1/m[ipi].dap; // диагональное предъобуславливание
            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
            nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i; k:=k+1;
            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i; k:=k+1;
            nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i; k:=k+1;
            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i; k:=k+1;
            dV1[ripi]:= dmul*db[ipi];
         end
          else
         begin
            // граничный узел
            if (itype = 2) then
            begin

               bnei:=GridGenForm.isneiman(iboundary,chvariable,chnormal);
               if (bnei) then
               begin
                  // такая граница найдена
                  // и на ней поставлено условие Неймана

                  if (iugol=0) then
                  begin
                     // граничная точка не являющаяся угловой

                     case chnormal of
                       'N' : // север (верх)
                       begin
                          //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                       'S' : // юг (низ)
                       begin
                          //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                      'W' : // запад (лево)
                       begin
                          //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                      'E' : // восток (право)
                       begin
                          //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                     end; // case
                  end
                   else
                  begin
                     // угловые точки при условии Неймана
                     // угловые точки

                     // среднее арефметическое на значащих узлах
                     case iugol of
                       1 :  // левый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                           dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                       2 : // правый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                           dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                       3 : // верхний левый угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                            dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:=0.0;
                        end;
                       4 : // верхний правый угол
                        begin
                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                            dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:= 0.0;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                           dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                    end; // case iugol

                  end; // if iugol1 else ...

               end // Условие Неймана
                else
               begin
                  // Обычные краевые условия первого
                  // рода которые тоже необходимо учесть

                  // среднее арефметическое на значащих узлах
                  case iugol of
                     0 : // граничное условие первого рода
                        begin
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:=1.0;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:=U[ipi];
                        end;
                     1 :  // левый нижний угол
                        begin

                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - 0.5;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - 0.5;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                     2 : // правый нижний угол
                        begin

                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - 0.5;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - 0.5;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                     3 : // верхний левый угол
                        begin

                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - 0.5;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - 0.5;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:=0.0;
                        end;
                     4 : // верхний правый угол
                        begin

                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - 0.5;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - 0.5;
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:= 0.0;
                        end;
                     5 : // пятиточечная звезда
                        begin

                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - 0.25;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - 0.25;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - 0.25;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - 0.25;
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:= 0.0;
                        end;
                  end; // case


               end;
            end;
         end;
      end; // with
   end;

   // debug
   //MainMemo.Lines.Add('k='+IntToStr(k)+' iNelem='+IntToStr(iNelem)); // верно

   for k:=iNelem downto 1  do nze[k]:=nze[k-1]; // сдвиг вправо на 1.
   // нумерация начинается с 1, а при заполнении nze нумерация начиналась с нуля
   if (itypesorter = 1) then
   begin
      QuickSort(nze,1,iNelem); // быстрая сортировка Хоара
   end
    else
   begin
      // itypesorter = 2
      HeapSort(nze,iNelem); // пирамидальная сортировка
   end;


   // формирование матрицы разреженной матрицы СЛАУ
   //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
   for k:=0 to iNelem-1 do
   begin
      // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
      // это требование алгоритма пирамидальной сортировки.
      val[k]:=nze[k+1].aij;
      col_ind[k]:=nze[k+1].j;
      row_ptr[nze[k+1].i]:=min(k, row_ptr[nze[k+1].i]);
   end;

   Finalize(nze); // освобождение памяти под массив nze
   if (bmessage) then MainMemo.Lines.Add('матрица СЛАУ сформирована ');


   case itypealg of
   0 : // Сопряжённые градиенты Хестенса и Штифеля
       begin
          // Решение СЛАУ
          // методом Сопряжённых Градиентов
          // Хестенса и Штифеля
          // на основе технологии хранения и обработки разреженных матриц CRS
          // В зависимости от значения параметра bgt применяется или не применяется трансформация Гаусса.
          SoprGradCRS(ilengthA, val, col_ind, row_ptr, dV1, U, dx, bmessage, kend, bgt, epsilon);
       end;
   1 : // алгоритм Ю.Г. Соловейчика [1993]
       begin
          SoloveichikAlg(ilengthA, val, col_ind, row_ptr, dV1, U, dx, bmessage, kend, epsilon);
       end;
   end;

   // копирование полученного решения обратно в U
   for i1:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i1]+1] := dx[i1]; // вектор с решением задачи;
   end;

   // Освобождение памяти из под
   // матрицы А
   Finalize(val);
   Finalize(col_ind);
   Finalize(row_ptr);
   // и вектора правой части.
   Finalize(dV1);

end; // SoprGradCRSUniversal

// Граничное условие II рода на левой стенке
                                      // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefLeft(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                         qbleft : Float; // заданный тепловой поток на границе
                                      place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dke, dkn, dks : Float; // теплопроводность на грани контрольного объёма
    iei, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне

begin
   with place do
   begin
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iei:=(i+1)+(j-1)*inx; // восток
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      m[ipi].dae:=dke*dy/dxe; // коэффициенты
      m[ipi].daw:=0.0; // дискретного
      m[ipi].dan:=dkn*dx/dyn; // аналога
      m[ipi].das:=dks*dx/dys;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].dae + m[ipi].dan + m[ipi].das;
      m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV;
      db[ipi]:=dSc[ipi]*dV + qbleft;
      if (btimedepend) then
      begin
         // учёт поля температуры с последней итерации
         db[ipi]:=db[ipi] + dap0*ToldTimeStep[ipi];
      end;
   end; // with
end; // TempBoundaryCoefLeft

// Граничное условие II рода на правой стенке
                                      // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                         qbright : Float; // заданный тепловой поток на границе
                                       place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dkw, dkn, dks : Float; // теплопроводность на грани контрольного объёма
    iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iwi:=(i-1)+(j-1)*inx; // запад
      ini:=i+j*inx; // север
      isi:=i+(j-2)*inx; // юг
      // теплопроводность на грани контрольного объёма
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      m[ipi].daw:=dkw*dy/dxw; // коэффициенты
      m[ipi].dae:=0.0; // дискретного
      m[ipi].dan:=dkn*dx/dyn; // аналога
      m[ipi].das:=dks*dx/dys;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].daw + m[ipi].dan + m[ipi].das;
      m[ipi].dap:= m[ipi].dap + dap0 - dSp*dV;
      db[ipi]:=dSc[ipi]*dV + qbright;
      if (btimedepend) then
      begin
         // учёт поля температуры с предедущей итерации
         db[ipi]:=db[ipi] + dap0*ToldTimeStep[ipi];
      end;
   end; // with
end; // TempBoundaryCoefRight

// Граничное условие II рода на нижней стенке
                                      // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefBottom(var m : array of MatrixCoef;
                                        var db : array of Float; // правая часть
                        qbbottom : Float; // заданный тепловой поток на границе
                                        place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dkw, dkn, dke : Float; // теплопроводность на грани контрольного объёма
    iwi, ini, iei, ipi : Integer; // номера узлов на пятиточечном шаблоне

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      m[ipi].dae:=dke*dy/dxe; // коэффициенты
      m[ipi].daw:=dkw*dy/dxw; // дискретного
      m[ipi].dan:=dkn*dx/dyn; // аналога
      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].dan + m[ipi].dae + m[ipi].daw;
      m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV;
      db[ipi]:=dSc[ipi]*dV + qbbottom;
      if (btimedepend) then
      begin
         db[ipi]:=db[ipi]+dap0*ToldTimeStep[ipi]; // учёт поля температуры с предедущей итерации
      end;
   end; // with
end; // TempBoundaryCoefBottom

// Граничное условие II рода на верхней стенке
                                   // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefTop(var m : array of MatrixCoef;
                                     var db : array of Float; // правая часть
                         qbtop : Float; // заданный тепловой поток на границе
                                     place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dkw, dks, dke : Float; // теплопроводность на грани контрольного объёма
    iwi, isi, iei, ipi : Integer; // номера узлов на пятиточечном шаблоне


begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      isi:=i+(j-2)*inx; // юг
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      m[ipi].daw:=dkw*dy/dxw;  // коэффициенты
      m[ipi].dae:=dke*dy/dxe;  // дискретного
      m[ipi].dan:=0.0; // аналога
      m[ipi].das:=dks*dx/dys;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].das + m[ipi].daw + m[ipi].dae;
      m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV;
      db[ipi]:=dSc[ipi]*dV + qbtop;
      if (btimedepend) then
      begin
         // учёт поля температуры с предедущей итерации
         db[ipi]:=db[ipi]+dap0*ToldTimeStep[ipi];
      end;
   end; // with
end; // TempBoundaryCoefTop


// вычисление коэффициентов дискретного аналога для уравнения
// теплопроводности.
// коэффициенты дискретного аналога.
// Поузловая сборка матрицы:
procedure TForm1.TempCoef(var m : array of MatrixCoef;
                          var db : array of Float); // правая часть
var
    dap0 : Float;  // нестационарный коэффициент
    dke, dkw, dkn, dks : Float; // теплопроводность на грани контрольного объёма
    iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    k : Integer; // счётчики для вычисления коэффициентов дискретного аналога
    qb : Float; // тепловой поток через границу
    bneiman : Boolean; // поставлено ли условие неймана

begin

   // проход по всем внутренним точкам
   // для определения матриц коэффициентов m и db

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // теплопроводность на грани контрольного объёма
            dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
            dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
            dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
            dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
            m[ipi].dae:=dke*dy/dxe;  // коэффициенты
            m[ipi].daw:=dkw*dy/dxw; // дискретного
            m[ipi].dan:=dkn*dx/dyn;  // аналога
            m[ipi].das:=dks*dx/dys;
            if (btimedepend) then
            begin
               // нестационарная теплопроводность
               dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
            end
             else
            begin
               // стационарная теплопроводность
               dap0:=0.0; // стационарный вклад
            end;

            db[ipi]:=dSc[ipi]*dV;// неизменная составляющая источникового члена
            if (btimedepend) then
            begin
               // учёт поля температуры с предедущей итерации
               db[ipi]:=db[ipi]+dap0*ToldTimeStep[ipi];
            end;
            m[ipi].dap:=m[ipi].dae + m[ipi].daw + m[ipi].dan + m[ipi].das;
            m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV;
         end;

         if (itype = 2 ) then
         begin

            // граничный узел
            // возможны условия Неймана
            // словесно порядок действий следующий:
            // каждая граничная точка принадлежит
            // какойлибо определенной границе с уникальным номером
            // по этому уникальному номеру (идентификатору) граница
            // должна быть найдена  и для неё должно быть проверено
            // поставлено ли на ней условие Неймана.
            // iboundary - уникальный номер границы

            // на границе поставлено условие Неймана
            if (iugol=0) then
            begin
               bneiman:=GridGenForm.isneimanqb(iboundary, 'T', qb);
               if (bneiman) then
               begin
                  // точка не является угловой
                  case chnormal of
                   'N' : begin
                            // На нижней границе.
                            TempBoundaryCoefBottom(m, db, qb, mapPT[k]);
                         end;
                   'S' : begin
                            // На верхней границе.
                            TempBoundaryCoefTop(m, db, qb, mapPT[k]);
                         end;
                   'W' : begin
                            // Правая стенка
                            TempBoundaryCoefRight(m, db, qb, mapPT[k]);
                         end;
                   'E' : begin
                            // Левая стенка
                            TempBoundaryCoefLeft(m, db, qb, mapPT[k]);
                         end;
                  end; // case
               end; // Нейман
            end
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
               // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;
                     end;
                    2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.5;
                     end;
                    3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.0;
                     end;
                    4 : // верхний правй угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.5;
                     end;
                    5 : // пятиточечная звезда
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.25;
                        m[ipi].dan:=0.25;
                        m[ipi].das:=0.25;
                        m[ipi].daw:=0.25;
                     end;
                  end; // case
               end; // угловая точка
         end; // принадлежит границе расчётной области
      end; // with
   end;

end; // TempCoef

// Поячеечная сборка матрицы:
// TODO 15 июля
procedure TForm1.TempCoefCell(var m : array of MatrixCoef;
                          var db : array of Float); // правая часть
var
    i,j : Integer; // счётчик
    k1,k2,k3,k4 : Integer; // вешины ячейки
    hx, hy : Float; // размеры ячейки дискретизации
    A : array [1..4] of array [1..4] of Float;
    lam12, lam13, lam24, lam34 : Float; // средняя теплопроводность внутри ячейки
    G : array [1..4] of Float;// вектор правой части
    C : array [1..4] of Float; // нестационарный вклад
    i1 : Integer;
    qb : Float; // значение теплового потока через границу
begin
   //  вся информация и о самом уравнении и о граничных условиях
   //  должна содержаться в матрице (m & db). В методе Гаусса - Зейделя
   // или методе Ричардсона -Либмана должно быть обращение только к
   // (m & db) и ни к чему другому.

   //нужно осуществить прозход по всем ячейкам дискретизации
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         k1:=i+(j-1)*inx;
         k2:=(i+1)+(j-1)*inx;
         k3:=i+(j)*inx;
         k4:=(i+1)+(j)*inx;
         if ((mapPT[k1].itype<>0) and
             (mapPT[k2].itype<>0) and
             (mapPT[k3].itype<>0) and
             (mapPT[k4].itype<>0)) then
             begin
                // размеры ячейки
                hx:=xpos[i+1]-xpos[i];
                hy:=ypos[j+1]-ypos[j];
                // теплопроводность на гранях контрольного объёма
                lam12:=2*lambda[k1]*lambda[k2]/((lambda[k1]+lambda[k2]));
                lam13:=2*lambda[k1]*lambda[k3]/((lambda[k1]+lambda[k3]));
                lam24:=2*lambda[k2]*lambda[k4]/((lambda[k2]+lambda[k4]));
                lam34:=2*lambda[k3]*lambda[k4]/((lambda[k3]+lambda[k4]));
                for i1:=1 to 4 do C[i1]:=0.0; // обнуление
                if (btimedepend) then
                begin
                   // к контрольному объему
                   C[1]:=drho*dcp*hx*hy/4; // k1  можно drho[k1], dcp[k1]
                   C[2]:=drho*dcp*hx*hy/4; // k2  drho[k2], dcp[k2]
                   C[3]:=drho*dcp*hx*hy/4; // k3  drho[k3], dcp[k3]
                   C[4]:=drho*dcp*hx*hy/4; // k4  drho[k4], dcp[k4]
                end;
                // использование средней теплопроводности плохая идея,
                // лучше аппроксимировать теплопроводность для каждой грани отдельно.
                // аналогично и с источниковым членом.
                // формирование матрицы жёсткости А:
                // левая нижняя четвертинка контрольного объёма:
                A[1][1]:=lam12*hy/(2*hx)+lam13*hx/(2*hy); A[1][2]:=-lam12*hy/(2*hx);
                A[1][3]:=-lam13*hx/(2*hy); A[1][4]:=0.0;
                m[k1].dap:=m[k1].dap+A[1][1]+C[1]/dTimeStep;;
                m[k1].dae:=m[k1].dae-A[1][2]; // здесь вычитание, но
                m[k1].dan:=m[k1].dan-A[1][3]; // в матрице было бы сложение
                // правая нижняя четвертинка контрольного объёма:
                A[2][1]:=-lam12*hy/(2*hx); A[2][2]:=lam12*hy/(2*hx)+lam24*hx/(2*hy);
                A[2][3]:=0.0; A[2][4]:=-lam24*hx/(2*hy);
                m[k2].daw:=m[k2].daw-A[2][1]; // здесь вычитание, но
                m[k2].dap:=m[k2].dap+A[2][2]+C[2]/dTimeStep;;
                m[k2].dan:=m[k2].dan-A[2][4]; // в матрице было бы сложение
                // левая верхняя четвертинка контрольного объёма
                A[3][1]:=-lam13*hx/(2*hy); A[3][2]:=0.0;
                A[3][3]:=lam34*hy/(2*hx)+lam13*hx/(2*hy); A[3][4]:=-lam34*hy/(2*hx);
                m[k3].das:=m[k3].das-A[3][1]; // здесь вычитание, но
                m[k3].dap:=m[k3].dap+A[3][3]+C[3]/dTimeStep;;
                m[k3].dae:=m[k3].dae-A[3][4]; // в матрице было бы сложение
                // правая верхняя четвертинка контрольного объёма
                A[4][1]:=0.0; A[4][2]:=-lam24*hx/(2*hy);
                A[4][3]:=-lam34*hy/(2*hx); A[4][4]:=lam34*hy/(2*hx)+lam24*hx/(2*hy);
                m[k4].das:=m[k4].das-A[4][2]; // здесь вычитание, но
                m[k4].daw:=m[k4].daw-A[4][3]; // в матрице было бы сложение
                m[k4].dap:=m[k4].dap+A[4][4]+C[4]/dTimeStep;
                // вектор правой части:
                G[1]:=dSc[k1]*hx*hy/4;  // левый нижний
                db[k1]:=db[k1]+G[1]+C[1]*ToldTimeStep[k1]/dTimeStep;
                G[2]:=dSc[k2]*hx*hy/4;  // правый нижний
                db[k2]:=db[k2]+G[2]+C[2]*ToldTimeStep[k2]/dTimeStep;
                G[3]:=dSc[k3]*hx*hy/4;  // левый верхний
                db[k3]:=db[k3]+G[3]+C[3]*ToldTimeStep[k3]/dTimeStep;
                G[4]:=dSc[k4]*hx*hy/4;  // правый верхний
                db[k4]:=db[k4]+G[4]+C[4]*ToldTimeStep[k4]/dTimeStep;
             end;
      end;
   end;

   // алгоритм учёта краевых условий 2 и 3 рода
   // сначала проход по всем вертикальным рёбрам на границах,
   // потом проход по всем горизонтальным рёбрам на границах.
   // проход по всем вертикальным рёбрам на которых
   // поставлено краевое условие 2 или 3 рода
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         // введём локальную нумерацию точек
         k1:=i+(j-1)*inx;
         k2:=i+(j)*inx;
         if ((mapPT[k1].itype=2) and
             (mapPT[k2].itype=2)) then // вертикальная граница
             begin
                // нужно проверить поставлены ли
                // на данном ребре краевые условия
                // второго или третьего рода:
                if (GridGenForm.isneimanqb(mapPT[k1].iboundary, 'T', qb) and
                    GridGenForm.isneimanqb(mapPT[k2].iboundary, 'T', qb)) then
                    begin
                       // на ребре соединяющем точки k1 и k2
                       // поставлено краевое условие 2 или 3 рода
                       // TODO
                    end;
             end;
      end;
   end;

end; // TempCoefCell



// закрывает главное приложение
procedure TForm1.Close1Click(Sender: TObject);
begin
   // нужно освободить выделенную память перед
   // закрытием
   // освобождаем память выделенную под карты
   if (High(mapPT)>1) then SetLength(mapPT,1);
   if (High(mapVx)>1) then SetLength(mapVx,1);
   if (High(mapVy)>1) then SetLength(mapVy,1);
   // освобождаем память выделенную под функции
   if (High(T)>1) then SetLength(T,1);
   if (High(TOldIteration)>1) then SetLength(TOldIteration,1);
   if (High(TOldTimeStep)>1) then SetLength(TOldTimeStep,1);
   if (High(SF)>1) then SetLength(SF,1);
   if (High(Omega)>1) then SetLength(Omega,1);
   if (High(Vx)>1) then SetLength(Vx,1);
   if (High(Vy)>1) then SetLength(Vy,1);
   if (High(VxOld)>1) then SetLength(VxOld,1);
   if (High(VyOld)>1) then SetLength(VyOld,1);
   if (High(VxOldTimeStep)>1) then SetLength(VxOldTimeStep,1);
   if (High(VyOldTimeStep)>1) then SetLength(VyOldTimeStep,1);
   if (High(P)>1) then SetLength(P,1);
   if (High(Pamendment)>1) then SetLength(Pamendment,1);
   // для осреднённого вибрационного течения
   // функция тока
   if (High(meanSF)>1) then SetLength(meanSF,1);
   if (High(meanSF1T)>1) then SetLength(meanSF1T,1);
   if (High(meanSFGl)>1) then SetLength(meanSFGl,1);
   // вихрь
   if (High(meanOmega)>1) then SetLength(meanOmega,1);
   if (High(meanOmega1T)>1) then SetLength(meanOmega1T,1);
   if (High(meanOmegaGl)>1) then SetLength(meanOmegaGl,1);
   // температура
   if (High(meanT1T)>1) then SetLength(meanT1T,1);
   if (High(meanTGl)>1) then SetLength(meanTGl,1);
   if (High(meanT)>1) then SetLength(meanT,1);
   // горизонтальная скорость
   if (High(meanVx1T)>1) then SetLength(meanVx1T,1);
   if (High(meanVxGl)>1) then SetLength(meanVxGl,1);
   if (High(meanVx)>1) then SetLength(meanVx,1);
   // вертикальная скорость
   if (High(meanVy1T)>1) then SetLength(meanVy1T,1);
   if (High(meanVyGl)>1) then SetLength(meanVyGl,1);
   if (High(meanVy)>1) then SetLength(meanVy,1);
   // VOF метод
   if (High(VOF)>1) then SetLength(VOF,1);
   if (High(DensityOldTimeStep)>1) then SetLength(DensityOldTimeStep,1);
   // освобождение сеточных мвассивов
   if (High(xpos)>1) then SetLength(xpos,1);
   if (High(ypos)>1) then SetLength(ypos,1);
   if (High(yposfix)>1) then SetLength(yposfix,1);
   Application.MessageBox('память освобождена','память освобождена',MB_OK);
   Close; // закрывает главное приложение
end;

// прорисовывает расчётную сетку
procedure TForm1.Mesh2Click(Sender: TObject);
begin
    with DisplayForm do
    begin
         Show;  // отображает форму
         iwhotvisible:=1; // прорисовка сетки
         displaymesh; // вызывает метод прорисовки расчётной сетки
    end;
end;

// вызывает визуализатор для функции D
procedure TForm1.myDisp;
var
  iselect : Integer; // способ интерполяции
begin
    with DisplayForm do
    begin
         Show;  // отображает форму
         // эта штука определяет нужна ли интерполяция
         // и если нужна то какая именно
         iselect:=InterpolateCaseForm.RadioGroup1.ItemIndex;
         case iselect of
           0 : begin
                 // без интерполяции
                 iwhotvisible:=2;
                 displayTempreture; // вызывает прорисовку поля температур
               end;
           // интерполяция пока не работает на неравномерных сетках
           1 : begin
                 b13:=false; // бикубический сплайн
                 iwhotvisible:=3;
                 displayTempreturebicubicsplane;
               end;
           2 : begin
                 b13:=true; // билинейный сплайн
                 iwhotvisible:=4;
                 displayTempreturebicubicsplane;
               end;
         end; // case
    end;

end;  // myDisp

// Анимационная картина сходимости для темпеатуры
// она основана на устаревшем солвере и будет удалена
// дата удаления 19 августа 09
procedure TForm1.empreture2Click(Sender: TObject);
(*
var
   k : Integer;  // счётчик
   icoliter : Integer; // количество итераций при анимации
*)
begin
   (*
   // можно придумать много параметров анимации:
   // величина задержки, периодичность выполнения,
   // используемая интерполяция, какую из величин отображать и т.п.
   icoliter:=100;
   Form1.initparam; // инициализирует данные
   Form1.initlambda; // инициализирует теплопроводность
   Form1.initTemp; // инициализирует поле темпеатур
   Form1.initdSc; // инициализация источникового члена
   Form1.initBoundaryConditionTempreture; // задаёт граничные условия
   Form1.DisplayTemperature; // показывает поле температур
   Sleep(100); // пауза
   for k:=1 to icoliter do
   begin
      oneitertemp;
      Form1.DisplayTemperature; // показывает поле температур
      Sleep(100); // пауза
   end;
   // сообщает о том что анимация закончена
   Application.MessageBox('анимировано 100 итераций Гаусса Зейделя','',MB_OK);
   *)
   // сообщает о том что метод устарел 19 августа
   Application.MessageBox('метод устарел и доступ к нему через GUI закрыт 19 августа 09','',MB_OK);
end; // анимация


// загружает основной тест
// программного комплекса МАРЕНА
// загрузка должна производится только после генерации сетки
procedure TForm1.MARENAtest1Click(Sender: TObject);
begin
   MARENAload;
   // сообщает о том что загрузка тестового примера МАРЕНА
   // успешно завершена
   Application.MessageBox('тест МАРЕНА успешно загружен','',MB_OK);
end;  // загружает МАРЕНА тест


// загружает основной тест
// программного комплекса МАРЕНА
// загрузка должна производится только после генерации сетки
// эти функции можно использовать для инициализации
// всех обрабатываемых матриц.
procedure TForm1.MARENAload;
const
    MPI=3.141; // число ПИ
var
   i,j : Integer;

function F1(x, y : Float) : Float; // правая часть
var
   r : Float;
begin
  r:=8*(cos(2*MPI*y)*(cos(2*MPI*x)-power(sin(MPI*x),2))-cos(2*MPI*x)*power(sin(MPI*y),2));
  r:=r-power(sin(MPI*x)*sin(2*MPI*x),2)*sin(4*MPI*y);
  r:=r+power(sin(MPI*y)*sin(2*MPI*y),2)*sin(4*MPI*x);
  r:=r*power(MPI,4);
  Result:=r;
end; // F1

function F2(x, y : Float) : Float; // функция тока
var
   r : Float;
begin
  r:=power(sin(MPI*x)*sin(MPI*y),2);
  Result:=r;
end;  // F2

function F3(x, y : Float) : Float; // вихрь
var
   r : Float;
begin
  r:=-2*power(MPI,2)*(cos(2*MPI*x)*power(sin(MPI*y),2)+cos(2*MPI*y)*power(sin(MPI*x),2));
  Result:=r;
end;  // F3

function F4(x, y : Float) : Float; // горизонтальная компонента скорости
var
   r : Float;
begin
  r:=2*MPI*power(sin(MPI*x),2)*sin(MPI*y)*cos(MPI*y);
  Result:=r;
end; // F4

function F5(x, y : Float) : Float; // вертикальная компонента скорости
var
   r : Float;
begin
  r:=-2*MPI*power(sin(MPI*y),2)*cos(MPI*x)*sin(MPI*x);
  Result:=r;
end; // F5

begin
   // выделение памяти под расчитываемые матрицы
   SetLength(dSc,inx*iny+1);
   SetLength(SF,inx*iny+1);
   SetLength(Omega,inx*iny+1);
   SetLength(Vx,(inx-1)*iny+1); // на смещённой по горизонтали сетке
   SetLength(Vy,inx*(iny-1)+1); // на смещённой по горизонтали сетке
   SetLength(P,inx*iny+1); // давление
   SetLength(Pamendment,inx*iny+1); // поправка давления
   // Здесь нехватает давления и температуры.
   for i:=1 to inx do
   begin
     for j:=1 to iny do
     begin
        // Правая часть
        dSc[i+(j-1)*inx]:=F1(xpos[i],ypos[j]);
        // функция тока
        SF[i+(j-1)*inx]:=F2(xpos[i],ypos[j]);
        // вихрь
        Omega[i+(j-1)*inx]:=F3(xpos[i],ypos[j]);
        // давление
        P[i+(j-1)*inx]:=0.0;
        // поправка давления
        Pamendment[i+(j-1)*inx]:=0.0;
     end;
   end;
   // Загрузка горизонтальной компоненты скорости
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         // горизонтальная компонента скорости
         // грани контрольных объёмов находятся по середине между узлами
         // расчётной сетки
         // по оси x точек на одну меньше !
         Vx[i+(j-1)*(inx-1)]:=F4(0.5*(xpos[i]+xpos[i+1]),ypos[j]);
      end;
   end;
   // Загрузка вертикальной компоненты скорости
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         // горизонтальная компонента скорости
         // грани контрольных объёмов находятся по середине между узлами
         // расчётной сетки
         Vy[i+(j-1)*inx]:=F5(xpos[i],0.5*(ypos[j]+ypos[j+1]));
      end;
   end;
end; // MARENAload

// универсальная функция визуализации
// основная сетка
procedure TForm1.DisplayUniversalInternal(ival : Integer);
var
   i, j : Integer;
   dfe : Float; // для учёта неравномерности сетки
begin
    // Визуализируемая величина определяется
    // параметром ival:
    // 1 - поле температур,
    // 2 - горизонтальная компонента скорости,
    // 3 - вертикальная компонента скорости, 4 - вихрь,
    // 5 - функцию тока, 6 - поправка давления,
    // 7 - давление, 8 - источниковый член уравнения теплопроводности.
    SetLength(DisplayForm.D,inx*iny+1);
    for i:=1 to inx do
    begin
       for j:=1 to iny do
       begin
          case ival of
            1 : DisplayForm.D[i+(j-1)*inx]:=T[i+(j-1)*inx];
            2 : // горизонтальная компонента скорости
                begin
                   if (i=1) then DisplayForm.D[i+(j-1)*inx]:=Vx[1+(j-1)*(inx-1)];
                   if (i=inx) then DisplayForm.D[i+(j-1)*inx]:=Vx[(inx-1)+(j-1)*(inx-1)];
                   // используется линейная интерполяция
                   // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                   // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                   dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                   if ((i<>1) and (i<>inx)) then
                   begin
                      DisplayForm.D[i+(j-1)*inx]:=dfe*Vx[(i-1)+(j-1)*(inx-1)] + (1-dfe)*Vx[i+(j-1)*(inx-1)];
                   end;
                end;
            3 : // вертикальная компонента скорости
                begin
                   if (j=1) then
                   begin
                      DisplayForm.D[i+(j-1)*inx]:=Vy[i];
                   end;
                   if (j=iny) then
                   begin
                      DisplayForm.D[i+(j-1)*inx]:=Vy[i+(iny-2)*inx];
                   end;
                   // линейная интерполяция
                   // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                   // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                   dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                   if ((j<>1) and (j<>iny)) then
                   begin
                      DisplayForm.D[i+(j-1)*inx]:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
                   end;
                end;
            4 : DisplayForm.D[i+(j-1)*inx]:=Omega[i+(j-1)*inx];
            5 : DisplayForm.D[i+(j-1)*inx]:=SF[i+(j-1)*inx];
            6 : DisplayForm.D[i+(j-1)*inx]:=Pamendment[i+(j-1)*inx];
            7 : DisplayForm.D[i+(j-1)*inx]:=P[i+(j-1)*inx];
            8 : DisplayForm.D[i+(j-1)*inx]:=dSc[i+(j-1)*inx];
          end;
       end;
    end;
    myDisp;
end; // DisplayUniversalInternal

// восстановление вихря с интерполяцией на основную сетку
// здесь требуется выполнить операции дифференцирования
// для компонент скорости с учётом шахматной (разнесённой) сетки.
procedure TForm1.CurlConstruct;
var
    i,j : Integer; // счётчики
    rbuf : Float; // временное хранилище
    CurlBuf : array of Float; // временное хранилище для вихря на другой сетке
begin
   // выделение оперативной памяти
   SetLength(CurlBuf, (inx-1)*(iny-1) + 1);
   // обнуление вихря
   CurlBuf[0]:=0.0;
   for i:=1 to (inx - 1) do
   begin
      for j:=1 to (iny - 1) do
      begin
         CurlBuf[i+(j-1)*(inx-1)]:=0.0;
      end;
   end;
   // CurlBuf = diff(Vy,x) - diff(Vx,y);
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         // rbuf := diff(Vy,x);
         rbuf:= (Vy[(i+1)+(j-1)*inx] - Vy[i+(j-1)*inx])/(xpos[i+1] - xpos[i]);
         // rbuf := rbuf - diff(Vx,y);
         rbuf:=rbuf - (Vx[i+(j-1+1)*(inx-1)]-Vx[i+(j-1)*(inx-1)])/(ypos[j+1]-ypos[j]);
         // CurlBuf = diff(Vy,x) - diff(Vx,y);
         CurlBuf[i+(j-1)*(inx-1)]:=rbuf;
      end;
   end;
   // восстановление на основную сетку
   // путём интерполяции

   // для внутренних точек расчётной области
   for i:=2 to (inx-1) do
   begin
      for j:=2 to (iny-1) do
      begin
         Omega[i+(j-1)*inx]:=0.25*(CurlBuf[(i-1)+(j-1-1)*(inx-1)]+CurlBuf[(i-1)+(j-1)*(inx-1)]+CurlBuf[i+(j-1-1)*(inx-1)]+CurlBuf[i+(j-1)*(inx-1)]);
      end;
   end;
   // левая и правая граница
   for j:=2 to (iny-1) do
   begin
      // левая граница
      i:=1;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[i+(j-1-1)*(inx-1)]+CurlBuf[i+(j-1)*(inx-1)]);
      // правая граница
      i:=inx;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[(i-1)+(j-1-1)*(inx-1)]+CurlBuf[(i-1)+(j-1)*(inx-1)]);
   end;
   // нижняя и верхние границы
   for i:=2 to (inx-1) do
   begin
      // нижняя граница
      j:=1;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[(i-1)+(j-1)*(inx-1)]+CurlBuf[i+(j-1)*(inx-1)]);
      // верхняя граница
      j:=iny;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[(i-1)+(j-1-1)*(inx-1)]+CurlBuf[i+(j-1-1)*(inx-1)]);
   end;
   // угловые точки
   // левый нижний угол
   i:=1; j:=1;
   Omega[i+(j-1)*inx]:=CurlBuf[i+(j-1)*(inx-1)];
   // правый нижний угол
   i:=inx; j:=1;
   Omega[i+(j-1)*inx]:=CurlBuf[(i-1)+(j-1)*(inx-1)];
   // правый верхний угол
   i:=inx; j:=iny;
   Omega[i+(j-1)*inx]:=CurlBuf[(i-1)+(j-1-1)*(inx-1)];
   // левый верхний угол
   i:=1; j:=iny;
   Omega[i+(j-1)*inx]:=CurlBuf[i+(j-1-1)*(inx-1)];
   // освобождение оперативной памяти
   Finalize(CurlBuf);
   // домножение на минус 1: *(-1)
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         Omega[i+(j-1)*inx]:= (-1)*Omega[i+(j-1)*inx];
      end;
   end;

end; // CurlConstruct

// генеральные настройки
procedure TForm1.myGeneraltune;
begin
   // инициализирует форму
   if (btimedepend) then // нестационарный
   begin
      General.RadioGroup1.ItemIndex:=1;
   end
    else // стационарный
   begin
      General.RadioGroup1.ItemIndex:=0;
   end;
   // показывает форму
   General.ShowModal; // вызывает форму где задаются параметры солвера
   myInitializationRestart; // всё придётся инициализировать заново: выделение памяти и присвоение значений.
end;

// форма параметров солвера
procedure TForm1.General1Click(Sender: TObject);
begin
   // главные параметры солвера:
   // стационарный и нестационарный
   myGeneraltune;
end;

// Щас реализуется возможность приостановки и последующего
// продолжения вычисления с остановленного места. Это приводит
// к необходимости в случае малейших изменений, например в граничных условиях, производить
// инициализацию решения заново. Иначе новые граничные условия не будут учтены.
procedure TForm1.myInitializationRestart;
var
    i : Integer; // внутренний счётчик.
begin
   // 1 - чистая теплопроводность,
   // 2 - теплопроводность с учётом конвективного члена,
   // 3 - чистый Навье-Стокс, 4 - Навье-Стокс с учётом теплопроводности.
   // 5 - VOF метод.
   // говорит о том что перед началом счёта требуется
   // инициализировать искомые величины и выделить под их хранение память.
   for i:=1 to 5 do bweShouldInitialize[i]:=true;
end;

// некоторые параметры требуется инициализировать непосредственно
// сразу после создания формы приложения
procedure TForm1.FormCreate(Sender: TObject);
var
   dx, dy : Float; // равномерные шаги сетки
   i : Integer; // Счётчики

begin
   // для исследования сходимости
   // гидродинамических алгоритмов
   freport:=TStringList.Create();
   // сгенерируем сетку по умолчанию
   // равномерная 10 на 10
   // это нужно для того чтобы не было сбоев
   // при попытке сразу запустить расчёт на выполнение.
   dLx:=1; // ширина области
   dLy:=1; // высота области
   inx:=10; // 10 узлов по горизонтали
   iny:=10; // 10 узлов по вертикали
   dx:=dLx/(inx-1);
   dy:=dLy/(iny-1);
   SetLength(xpos,inx+1); // выделение памяти
   for i:=1 to inx do
   begin
     xpos[i]:=0+(i-1)*dx;
   end;
   SetLength(ypos,iny+1); // выделение памяти
   for i:=1 to iny do
   begin
      ypos[i]:=0+(i-1)*dy;
   end;
   // инициализация всех обрабатываемых матриц
   // включая выделение памяти
   MARENAload; // начальные значения полевых величин
   // выделение памяти и инициализация поля температур
   SetLength(T,inx*iny+1);
   for i:=0 to inx*iny do T[i]:=0.0;
   SetLength(VOF,inx*iny+1);
   for i:=0 to inx*iny do VOF[i]:=0.0; // всё занято первой жидкостью
   myInitializationRestart; // всё придётся инициализировать заново: выделение памяти и присвоение значений.
   // параметры относящиеся к управлению
   // солвером
   bsimplec:=false; // по умолчанию применяется алгоритм SIMPLE.
   bsimpler:=false; // по умолчанию применяется алгоритм SIMPLE.
   ishconv:=4; // схема со степенным законом рекомендуемая С. Патанкаром
   imodelEquation:=3; // чистая гидродинамика по умолчанию.
   // выбор типа солвера для каждого из уравнений в отдельности
   itypesolver.itemperature:=1; // GZ// метод Сопряжённых Градиентов
   itypesolver.ivelocity:=1; // GZ//по умолчанию метод переменных направлений
   itypesolver.ipamendment:=1; // Солвер Гаусса - Зейделя
   itypesolver.istreamfunction:=1; // по умолчанию переменных направлений
   // разреженность матрицы всегда учитывается на основе CRS формата хранения.
   // алгоритм сортировки в методе сопряжённых градиентов на основе CRS.
   itypesorter:=2; // по умолчанию пирамидальная сортировка как экономичная по памяти.
   // какую норму использовать
   // 1 - евклидова, 2 - кубическая норма, 3 - октаэдрическая норма.
   ibasenorma:=1; // по умолчанию евклидова норма.
   // контроль сходимости
   // вычислительного процесса
   rcs.temp:=1e-9; // пороговое значение невязки по температуре
   rcs.Vx:=1e-5; // отклонение при преодолении нелинейности для горизонтальной скорости
   rcs.Vy:=1e-5; // отклонение при преодолении нелинейности для вертикальной скорости
   rcs.Pamendment:=1e-9; // пороговое значение невязки для поправки давления
   rcs.continity:=1e-6; // пороговое значение невязки для несбалансированных источников массы
   rcs.streamfunction:=1e-7; // пороговое значение невязки для функции тока
   rcs.Pressure:=1e-9; // пороговое значение невязки для давления
   // параметры релаксации
   // для алгоритма SIMPLE
   myrelaxfactors.xVelRelax:=0.5; // для горизонтальной скорости
   myrelaxfactors.yVelRelax:=0.5; // для вертикальной скорости
   myrelaxfactors.PressureRelax:=0.8; // для давления
   // для SOR в уравнении для поправки давления.
   myrelaxfactors.pSORPressure:=1; // по умолчанию SOR (значение 1.855 подобрано для задачи течения внутри изотермической каверны).
   myrelaxfactors.pSORpresr:=1; // для давления в алгоритме SIMPLER
   myrelaxfactors.pSORTempreture:=1; // для поля температур
   myrelaxfactors.pSORVelocityVx:=1; // для горизонтальной скорости
   myrelaxfactors.pSORVelocityVy:=1; // для вертикальной скорости
   myrelaxfactors.prelaxBodyForce:=1.0; // по умолчанию нижняя релаксация ( < 1) отсутствует.
   // структура одной итерации алгоритма SIMPLE
   // при перестроении сетки эти параметры подстраиваются автоматом
   iterSimple.iterVxNonLin:=max(inx,iny);
   iterSimple.iterVyNonLin:=max(inx,iny);
   iterSimple.iterVxLin:=1; // здесь будет
   iterSimple.iterVyLin:=1; // нижняя релаксация
   iterSimple.bCoupledVelocitySolver:=true; // по умолчанию совместное решение компонент скорости
   iterSimple.iterPamendment:=9*inx*iny; // для поправки давления
   iterSimple.iterPressure:=9*inx*iny; // для давления в алгоритме SIMPLER
   // в случае задач с учётом естественной конвекции
   // требуется решать также уравнение теплопроводности
   // здесь даётся оценка сверху для количества итераций
   // в предположении что используется полилинейный солвер.
   iterSimple.iterTemperature:=9*inx*iny;
   // нахождение функции тока происходит после окончания
   // работы алгоритма SIMPLE
   // максимальное число итераций оценивается равным 9*inx*iny, где 9 = ln(1e4).
   iterSimple.iterStreamFunction:=9*inx*iny; // для нахождения функции тока
   // нужно ли продолжить вычисления
   bweShouldContinue:=true; // для прерывания вычисления в случае false
   // временная зависимость
   btimedepend:=false; // по умолчанию стационарный решатель
   // количество итераций зависит от качества итерационной процедуры
   // решения задачи и размерности вектора переменных.
   // в данный момент реализован однослойный метод Гаусса-Зейделя
   // оценка числа итераций составляет для него порядка 2*N^2, где
   // N = inx*iny - размерность вектора нейзвестных.
   itercount:=inx*inx*iny*iny; // количество итераций для сетки 10 на 10.
   iglobalnumberiteration:=1; // глобальный номер итераций присваивается при инициализации
   // параметры овечающие за начальную
   // инициализацию полевых величин
   InitVal.TempInit:=0.0; // начальное значение поля температур
   InitVal.XvelInit:=0.0; // начальное значение Vx
   InitVal.YvelInit:=0.0; // начальное значение Vy
   // задание начального времени
   realFlowTime:=0.0;
   // параметры материалов
   // air
   matprop[0].drho:=1; // плотность
   matprop[0].dlambda:=1; // теплопроводность
   matprop[0].dcp:=1; // теплоёмкость
   matprop[0].dmu:=1; // динамическая вязкость
   matprop[0].beta:=1; // коэффициент линейного температурного расширения
   // water
   matprop[1].drho:=1; // плотность
   matprop[1].dlambda:=1; // теплопроводность
   matprop[1].dcp:=1; // теплоёмкость
   matprop[1].dmu:=1; // динамическая вязкость
   matprop[1].beta:=1; // коэффициент линейного температурного расширения

   // приближение Буссинеска
   bBussinesk:=false; // по умолчанию выключено
   // ускорение свободного падения
   dgx:=0.0;
   dgy:=0.0;
   // для силы тяжести изменяющейся по гармоническому закону от времени
   rgravVib.bOn:=false; // по умолчанию вибрации выключены.
   rgravVib.Amplitude:=0.01; // Амрлитуда
   rgravVib.Frequency:=20; // Частота 20 Гц
   // граничные условия
   // информация отсутствует так как модуль переделывается

   // линеаризованные источниковые члены
   // всех уравнений
   // уравнение теплопроводности
   defmysource.Temperature.dSc:=0.0; // постоянная составляющая
   defmysource.Temperature.dSp:=0.0; // линеаризованная составляющая
   // уравнение для горизонтальной скорости
   defmysource.Vxvelocity.dSc:=0.0; // постоянная составляющая
   defmysource.Vxvelocity.dSp:=0.0; // линеаризованная составляющая
   // уравнение для вертикальной скорости
   defmysource.Vyvelocity.dSc:=0.0; // постоянная составляющая
   defmysource.Vyvelocity.dSp:=0.0; // линеаризованная составляющая
   // для вихря
   defmysource.Omega.dSc:=0.0; // постоянная составляющая
   defmysource.Omega.dSp:=0.0; // линеаризованная составляющая
   imarker:=0; // для графической визуализации невязок.
   // Граничные условия в уравнении для поправки давления:
   // если = true значит нет влияния от точки на границе как у Патанкара в книжке,
   // а если = false значит условие Неймана равенство нулю нормальной производной.
   bPatankarPressure:=true; // по умолчанию условия Патанкара.
   bipifixpamendment:=false; // по умолчанию уровень поправки давления фиксировать не надо
   // выбор граничного условия на выходной границе потока
   // 0 - условия Патанкара, 1 - F[i]=2*F[i-1]-F[i-2];
   // 3 - игнорируется.
   ioutflow:=3;
   // сообщение о том что запуск программы
   // произошёл успешно.
   MainMemo.Lines.Add('Данная программа поставляется в исходных кодах');
   MainMemo.Lines.Add('на условиях FreeBSD подобной лицензии.');
   MainMemo.Lines.Add('Системные требования:');
   MainMemo.Lines.Add('1. Windows XP Professional x64');
   MainMemo.Lines.Add('2. Tecplot 360');
   MainMemo.Lines.Add('3. Delphi 6.0 Build 6.163 2001 года');
   MainMemo.Lines.Add('Авторы среды программирования Delphi:');
   MainMemo.Lines.Add('проф. Никлаус Вирт, Филипп Канн (Kahn), Андерс Хейлсберг (Hejlsberg) и др.');
   MainMemo.Lines.Add('Авторы CFD алгоритмов: С. Патанкар и проф. Сполдинг и др. ');
   MainMemo.Lines.Add('Для работы на других платформах в другом окружении');
   MainMemo.Lines.Add('можно использовать, например, WINE ');
   MainMemo.Lines.Add('или переписать программу для компилятора gcc.');
   MainMemo.Lines.Add('Возможной альтернативой является обращение, например, к проекту lazarus.');
   MainMemo.Lines.Add('Done.');
end; // FormCreate

// возвращает наибольшую из величин da, db.
function TForm1.maxoper(da,db : Float) : Float;
var
   r : Float;
begin
   r:=da;
   if (db>r) then r:=db;
   Result:=r;
end;

// функция A(|P|) для различных схем
// ishconvection - номер схемы
function TForm1.ApproxConvective(fp : Float; ishconvection : Integer) : Float;
var
   r : Float;
begin
   r:=1; // по умолчанию с разностями против потока
   // fp - имеет смысл сеточного числа Пекле
   // внутрь данной функции передаётся модуль числа fp и
   // здесь мы имеем дело только с fp>=0.
   case ishconvection of
      1 : // Центрально-разностная
      begin
         // Центрально-разностная схема
         // пригодна только для небольших
         // чисел fp (Пекле) (по модулю меньших 1)
         // поэтому здесь при fp>1 осуществляется автоматический переход
         //  на рекомендуемую схему со степенным законом
         if (fp<1) then
         begin
            r:=1-0.5*fp;
         end;
         // если p>=1 то автоматический переход на схему со степенным законом
         if ((fp>=1) and (fp<10)) then
         begin
            // во избежании переполнения данная аппроксимация
            // используется только для сеточных чисел Пекле меньших 10
            r:=(1-0.1*fp)*(1-0.1*fp)*(1-0.1*fp)*(1-0.1*fp)*(1-0.1*fp);
         end
         else
         begin
            // при сеточном числе Пекле большем 10 искомая величина
            // прекрасно аппроксимируется нулём
            r:=0;
         end;
      end;
      2 : // с разностями против потока
      begin
         // здесь разумно ступеньку сделать
         if (fp<10) then
         begin
            r:=1;
         end
         else
         begin
            // здесь fp>=10
            r:=0;
         end;
      end;
      3 : // Комбинированная
      begin
         r:=maxoper(0,1-0.5*fp);
      end;
      4 : // со степенным законом
      begin
          // по условию сюда подаётся fp>=0.

         // здесь может быть переполнение,
         // если написать так:
         // r:=maxoper(0,power(1-0.1*fp,5)); // уже пи вычислении степени возникнет переполнение при p чуть большем 10
         // r:=maxoper(0,r); - здесь и кроется переполнение, на данном этапе r уже очень велико и предыдущая операция даст сбой
         // здесь сделано так чтобы его корректно исключить:

         if (fp<10) then
         begin
            // по своему смыслу r лежит в интервале от нуля до единицы
            r:=(1-0.1*fp)*(1-0.1*fp)*(1-0.1*fp)*(1-0.1*fp)*(1-0.1*fp);
         end
         else // fp>=10
         begin
            // если p>10 то мы уходим в область отрицательных
            // значений и к тому-же там может быть очень большое
            // по абсолютной величине значение так что может быть и переполнение.
            // В связи с этим разумно ограничится предложенной реализацией.
            r:=0;
         end;

      end;
      5 : // экспоненциальная (точная )
      begin
         if (fp<10) then
         begin
            // этим можно пользоваться только
            // при fp<10, при больших p значение
            // данной функции будет хорошо аппроксимироваться 0
            // иными словами 0 её асимптотика при больших fp, но
            // прямая подстановка слишком больших fp приводит
            // к переполнению т.к. exp(fp) становится слишком большим.
            if (fp<1e-2) then
            begin
              r:=1-0.5*fp; // центрально-разностная
            end
            else
            begin
               r:=fp/(exp(fp)-1);
            end;
         end
         else
         begin
            // при fp>=10 данная функция
            // достаточно хорошо аппроксимируется нулём.
            r:=0;
         end;
      end;
      6 : // В.К. Булгаков, Н.В. Булгаков
          // Хабаровский государственный технический университет
          // зависимость 23 из статьи
      begin
         if (fp<10) then
         begin
            r:=1/(1+0.6712*fp*fp);
         end
         else
         begin
            r:=0;
         end;
      end;
      7 : // показательная зависимость
      begin
         if (fp<10) then
         begin
            r:=power(0.553,fp);
         end
         else
         begin
            r:=0;
         end;
      end;
   end;
   Result:=r;
end; // ApproxConvective


// Решает задачу теплопроводности с учётом конвекции или
// без конвекции если требуется. За это отвечает передаваемый
// параметр bconv если он равен true то значит с конвекцией,
// а если false - то без конвективного члена.
// Операции по вычислению коэффициентов
// дискретного аналога вынесены за пределы цикла.
// Это можно сделать потому, что значения этих
// коэффициентов зависят только от координат x и y
// а сетка неизменна, зависимости коэффициентов
// дискретного аналога от искомой функции тоже нет,
// так что задача линейна.
// недостатком является использование несколько большего
// количества оперативной памяти для хранения коэффициентов.
// Содержит в себе четыре решателя:
// 1). Гаусса-Зейделя (ГЗ), 2).  гибридный ГЗ-Томас он же метод
//  продольно поперечной прогонки или метод переменных направлений.
// 3). прямой метод исключения Гаусса, 4). метод сопряжённых градиентов Хестенса и Штифеля.
// 5) алгоритм Ю.Г. Соловейчика [1993]
// ГЗ - это поточечный последовательный
// метод Гауса-Зейделя.
// Главный недостаток метода Гаусса-Зейделя это медленная сходимость.
// гибридный ГЗ-Томас:  используется гибридный алгоритм:
// итерационный в сочетании с прямым.
// При расчёте используется алгоритм Томаса (
// трёхдиагональной матрицы или алгоритм прогонки).
//
// Прямой метод исключения Гаусса реализован с учётом ленточной структуры матрицы СЛАУ.
// Сходимость методов гарантируется критерием Скарбороу.
procedure TForm1.SolveTempSteady(bmessage : Boolean; kfinish : Integer; bconv : Boolean);
var
   k : Integer; // номер итерации
   m : array of MatrixCoef; // матрица коэффициетов
   db : array of Float;  // коэффициенты
   residualtemp : Float; // текущее значение невязки
   //iboncon : Integer; // устаревшая переменная отвечающая за условия Неймана

begin
   // показываем ход выполнения
   if ((bmessage) and (itypesolver.itemperature < 3)) then myProgressBarForm.Show;

   // коэффициенты дискретного аналога не зависят от
   // температуры и этим можно воспользоваться, т.е.
   // их можно вычислить только один раз и дальше только использовать при вычислении.
   SetLength(m,inx*iny+1); // выделение памяти под коэффициенты
   SetLength(db,inx*iny+1); // выделение памяти под коэффициент

   // коэффициенты дискретного аналога вычисляются
   // только один раз путём прохода по всем внутренним точкам
   // а затем только используются.
   if (bconv) then TempConvCoef(m, db) // с конвективным членом
   else TempCoef(m,db); // чистая теплопроводность

   // коэффициенты дискретного аналога уже вычислены
   // и теперь будут только использоваться.
   if (itypesolver.itemperature < 3) then
   begin
      k:=0;
      residualtemp:=1e0; // очень большое число
      // матрицы коэффициентов m и db сформированы
      // и теперь просто будут только использоваться.
      while ((bweShouldContinue) and (residualtemp > rcs.temp) and (k < kfinish)) do
      begin
         // Реализовано только для граничных условий первого рода.

         case itypesolver.itemperature of
           1 : // итерационный последовательный поточечный метод
               // Гаусса-Зейделя
             begin
                // одна итерация методом Гаусса-Зейделя
                GZUniversal(T,inx,iny,mapPT, 'T', m,db);
             end;
           2 : // метод переменных направлений
             begin
                // одна итерация методом переменных направлений
                // для поля температур и граничных условий первого рода
                TDMAGibridGZUniversal(T,inx,iny, mapPT, 'T',m, db);
             end;
         end; // case

         // текущее значение невязки
         residualtemp:=myResidual(T,inx,iny,mapPT,'T',m,db);
         if (imodelEquation < 3) then
         begin
            inc(imarker);
            SetLength(myresplot,imarker);
            myresplot[imarker-1].temperature:=residualtemp; // нумерация начинается от нуля
            if (imarker>1) then updatemainpaintbox; // графики невязок
         end;

         if (bmessage) then
         begin
            if (k mod 10 = 0) then  MainMemo.Lines.Add('iter   temperature');
            MainMemo.Lines.Add(IntToStr(k+1) + '    ' + FormatFloat('#.####e-0',residualtemp));
         end;

         // индикатор хода выполнения
         if (bmessage) then myProgressBarForm.ProgressBar1.Position:=round((k+1)/itercount*100);
         k:=k+1; // переходим к следующей итерации
         Application.ProcessMessages;
      end; // k while
      // Если решалось только уравнение теплопроводности,
      // то восстанавливаем готовность к решению.
      if (imodelEquation < 3) then bweShouldContinue:=true;
      if (bmessage) then
      begin
         myProgressBarForm.ProgressBar1.Position:=0;
         myProgressBarForm.Close; // закрываем индикатор хода выполнения
      end;
   end
   else
   begin

      case itypesolver.itemperature of
        3 :  // решение задачи прямым методом Гаусса
           begin
              // эсли этот код используется в нестационарном решателе
              // и граничное условие является функцией времени, то
              // это приводит к необходимости обращать матрицу СЛАУ
              // на каждом временном слое.
              GaussUniversal(T,inx,iny, mapPT, 'T', m,db,bmessage);
              // текущее значение невязки
              residualtemp:=myResidual(T,inx,iny,mapPT,'T',m,db);
              if (bmessage) then
              begin
                 MainMemo.Lines.Add('residual tempreture ='+ FloatToStr(residualtemp));
              end;
           end;
        4 : // метод Сопряжённых Градиентов
           begin
              // передаваемое значение bconv=true означает
              // что будет выполнена трансформация Гаусса
              // необходимая для того чтобы матрица СЛАУ была
              // самосопряжённой положительно определённой
              // метод сопряжённых градиентов Хестенса и Штифеля.
              // debug без учёта разреженности.
              //SoprGradUniversal(T,inx,iny, mapPT,  'T', m, true, kfinish, rcs.temp, db,bmessage);

              SoprGradCRSUniversal( T, inx, iny, mapPT, 'T', m, bconv, bmessage, kfinish, rcs.temp, 0,db); // хранение разреженной матрицы в формате CRS
           end;
        5 : // алгоритм Ю.Г. Соловейчика
           begin
              // Локально оптимальная схема.
              // алгоритм Ю.Г. Соловейчика [1993]
              // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
              SoprGradCRSUniversal( T, inx, iny, mapPT, 'T', m, bconv, bmessage, kfinish, rcs.temp*rcs.temp, 1,db); // используется формат хранения разреженной матрицы CRS
           end;
        end; // case

   end;

   if ((bmessage) and (itypesolver.itemperature < 3)) then
   begin
      myProgressBarForm.ProgressBar1.Position:=0; // в исходное положение
      myProgressBarForm.Close;
   end;
end; // SolveTempSteadyConv

// Граничное условие II рода на левой стенке
// для уравнения теплопроводности с учётом конвективного члена.
procedure TForm1.TempBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                          var db : array of Float; // правая часть
                                          qbleft : Float; // заданный тепловой поток на границе
                                          place : TmyNode); // место на карте
var
    iei,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpn, dps : Float; // числа Пекле
    dfe, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iecvi:=i+(j-1)*(inx-1);
      dfn:=drho*dcp*Vy[incvi]*dx; // интенсивность
      dfs:=drho*dcp*Vy[iscvi]*dx; // конвекции
      dfe:=drho*dcp*Vx[iecvi]*dy; // или течения
      // теплопроводность на грани контрольного объёма
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      ddn:=dkn*dx/dyn;
      dds:=dks*dx/dys;
      dde:=dke*dy/dxe;
      dpn:=dfn/ddn; // Значение
      dps:=dfs/dds; // чисел
      dpe:=dfe/dde; // Пекле
      // коэффициенты дискретного аналога
      m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(-dfe,0);
      m[ipi].daw:=0.0;
      m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(-dfn,0);
      m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+maxoper(dfs,0);
      if (btimedepend) then
      begin
         // нестационарный солвер
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dSc[ipi]*dV + qbleft; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
      end;
      m[ipi].dap:=m[ipi].dae + m[ipi].dan + m[ipi].das + dap0 - dSp*dV;
   end; // with

end; // TempBoundaryCoefConvLeft

// Граничное условие II рода на правой стенке
// для уравнения теплопроводности с учётом конвективного члена.
                                         // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefConvRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                        qbright : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте
var
    iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dkw, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpw, dpn,dps : Float; // числа Пекле
    dfw, dfn, dfs : Float; // интенсивность течения или конвекции
    ddw, ddn, dds : Float; // диффузионная составляющая
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iwi:=(i-1)+(j-1)*inx; // запад
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iwcvi:=(i-1)+(j-1)*(inx-1);
      dfn:=drho*dcp*Vy[incvi]*dx; // интенсивность
      dfs:=drho*dcp*Vy[iscvi]*dx; // конвекции
      dfw:=drho*dcp*Vx[iwcvi]*dy; // или течения
      // теплопроводность на грани контрольного объёма
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      ddn:=dkn*dx/dyn; // диффузионная
      dds:=dks*dx/dys; // составляющая
      ddw:=dkw*dy/dxw;
      dpn:=dfn/ddn; // Значение
      dps:=dfs/dds; // числа
      dpw:=dfw/ddw; // Пекле
      m[ipi].dae:=0.0;  // коэффициенты  дискретного аналога
      m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv)+ maxoper(dfw,0);
      m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+ maxoper(-dfn,0);
      m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+ maxoper(dfs,0);
      if (btimedepend) then
      begin
         // нестационарный солвер
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dSc[ipi]*dV + qbright; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
      end;
      m[ipi].dap:=m[ipi].daw + m[ipi].dan + m[ipi].das + dap0 - dSp*dV;
   end; // with

end; // TempBoundaryCoefConvRight

// Граничное условие II рода на нижней стенке
// для уравнения теплопроводности с учётом конвективного члена.
                                          // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefConvBottom(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                       qbbottom : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте
var
    iei,iwi,ini,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi : Integer;// номера узлов для граней контрольного объёма
    dke, dkw,dkn : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn : Float; // числа Пекле
    dfe, dfw, dfn : Float;
    dde, ddw, ddn : Float;
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx;
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      dfe:=drho*dcp*Vx[iecvi]*dy; // интенсивность
      dfw:=drho*dcp*Vx[iwcvi]*dy; // конвекции
      dfn:=drho*dcp*Vy[incvi]*dx; // или течения
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dde:=dke*dy/dxe;  // диффузионная
      ddw:=dkw*dy/dxw;  // составляющая.
      ddn:=dkn*dx/dyn;
      dpn:=dfn/ddn;  // Значения
      dpe:=dfe/dde;  //  чисел Пекле.
      dpw:=dfw/ddw;
      // коэффициенты дискретного аналога
      m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0);
      m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);
      m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0);
      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарный солвер
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dSc[ipi]*dV + qbbottom; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
      end;
      m[ipi].dap:= m[ipi].dan + m[ipi].dae + m[ipi].daw + dap0 - dSp*dV;
   end; // with

end; // TempBoundaryCoefConvBottom

// Граничное условие II рода на верхней стенке
// для уравнения теплопроводности с учётом конвективного члена.
                                     // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefConvTop(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                          qbtop : Float; // заданный тепловой поток на границе
                                         place : TmyNode); // место на карте
var
    iei,iwi,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpw, dps : Float; // числа Пекле
    dfe, dfw, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, dds : Float; // диффузионный вклад
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      isi:=i+(j-2)*inx; // юг
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      iscvi:=i+(j-2)*inx;
      dfe:=drho*dcp*Vx[iecvi]*dy; // интенсивность
      dfw:=drho*dcp*Vx[iwcvi]*dy; // конвекции
      dfs:=drho*dcp*Vy[iscvi]*dx; // или течения
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      dde:=dke*dy/dxe;  // диффузионный
      ddw:=dkw*dy/dxw;  // вклад
      dds:=dks*dx/dys;
      dpe:=dfe/dde; // Значения
      dpw:=dfw/ddw; // чисел
      dps:=dfs/dds; // Пекле
      // коэффициенты дискретного аналога
      m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0);
      m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);
      m[ipi].dan:=0.0;
      m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
      if (btimedepend) then
      begin
         // нестационарный солвер
         dap0:=drho*dcp*dV/dTimeStep; // нестаионарный вклад
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dSc[ipi]*dV + qbtop; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
      end;
      m[ipi].dap:=m[ipi].das+m[ipi].dae+m[ipi].daw+dap0-dSp*dV;
   end; // with
end; // TempBoundaryCoefConvTop

// вычисляет коэффициенты дискретного аналога для
// уравнения теплопроводности с учётом конвективного члена
//  Операция составления дискретного аналога выполнена универсальным
// образом. Т.е. она подходит и для процессов не зависящих от времени, а также
// для нестационарных процессов.
// Внимание: перед использованием этой процедуры массиву
// ToldTimeStep должна быть выделена оперативная память и
//  он должен быть проинициализирован соответствующим образом.
procedure TForm1.TempConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                              var db : array of Float); // правая часть
var
    iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw,dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dfe, dfw, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    k : Integer; // счётчик для вычисления коэфффициентов дискретного аналога
    bneiman : Boolean; // если граничное условие Неймана
    qb, den : Float; // значение теплового потока на границе расчётной области,
    // den - значение плотности на грани контрольного объёма

begin

   // проход по всем внутренним точкам
   // для определения коэффициентов
   // дискретного аналога  m и db

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // для шахматной сетки (для компонент скорости)
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
            dfe:=den*dcp*Vx[iecvi]*dy; // интенсивность
            den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
            dfw:=den*dcp*Vx[iwcvi]*dy; // конвекции
            den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
            dfn:=den*dcp*Vy[incvi]*dx; // или
            den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
            dfs:=den*dcp*Vy[iscvi]*dx; // течения
            // теплопроводность на грани контрольного объёма
            dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
            dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
            dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
            dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
            dde:=dke*dy/dxe;  // коэффициенты
            ddw:=dkw*dy/dxw;  // дискретного
            ddn:=dkn*dx/dyn;  // аналога
            dds:=dks*dx/dys;
            dpe:=dfe/dde; // значения
            dpw:=dfw/ddw; // чисел
            dpn:=dfn/ddn; // Пекле
            dps:=dfs/dds;
            // коэффициенты дискретного аналога
            m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(-dfe,0);
            m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv)+maxoper(dfw,0);
            m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(-dfn,0);
            m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+maxoper(dfs,0);
            if (btimedepend) then
            begin
               // нестационарный солвер
               dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            end
             else
            begin
               // стационарный солвер
               dap0:=0.0; // стационарный вклад
            end;
            db[ipi]:=dSc[ipi]*dV;// неизменная составляющая источникового члена
            if (btimedepend) then
            begin
               // нестационарный добавок к источниковому члену
              db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
            end;
            m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;
            m[ipi].dap:=m[ipi].dap + dap0-dSp*dV;
         end;

         if (itype = 2 ) then
         begin
            // граничный узел
            // возможны условия Неймана
            // словесно порядок действий следующий:
            // каждая граничная точка принадлежит
            // какойлибо определенной границе с уникальным номером
            // по этому уникальному номеру (идентификатору) граница
            //  должна быть найдена и для неё должно быть проверено
            //  поставлено ли на ней условие Неймана.

            // на границе поставлено условие Неймана
            if (iugol=0) then
            begin
               // iboundary - уникальный номер границы
               bneiman:=GridGenForm.isneimanqb(iboundary, 'T', qb);
               if (bneiman) then
               begin
                  // точка не является угловой
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             TempBoundaryCoefConvBottom(m, db, qb, mapPT[k]);
                          end;
                    'S' : begin
                             // На верхней границе.
                             TempBoundaryCoefConvTop(m, db, qb, mapPT[k]);
                          end;
                    'W' : begin
                             // Правая стенка
                             TempBoundaryCoefConvRight(m, db, qb, mapPT[k]);
                          end;
                    'E' : begin
                             // Левая стенка
                             TempBoundaryCoefConvLeft(m, db, qb, mapPT[k]);
                          end;
                  end; // case
               end; // Нейман
            end // точка лежащая внутри границы расчётной области
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
                 // угловая точка
                  case iugol of
                  1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;
                     end;
                  2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.5;
                     end;
                  3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.0;
                     end;
                  4 : // верхний правй угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.5;
                     end;
                  5 : // пятиточечная звезда
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.25;
                        m[ipi].dan:=0.25;
                        m[ipi].das:=0.25;
                        m[ipi].daw:=0.25;
                     end;
                  end; // case
               end; // угловая точка
         end; // граничная точка
      end; // with
   end;

end; // TempConvCoef

// вычисляет коэффициенты дискретного аналога для
// уравнения переноса завихрённости с учётом конвективного члена
//  Операция составления дискретного аналога выполнена универсальным
// образом. Т.е. она подходит и для процессов не зависящих от времени, а также
// для нестационарных процессов.
// Внимание: перед использованием этой процедуры массиву
// OmegaoldTimeStep должна быть выделена оперативная память и
//  он должен быть проинициализирован соответствующим образом.
procedure TForm1.OmegaConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                               var db : array of Float); // правая часть
var
    iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw,dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dfe, dfw, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    k : Integer; // счётчик для вычисления коэфффициентов дискретного аналога
    bneiman : Boolean; // если граничное условие Неймана
    den : Float; // значение плотности на грани контрольного объёма
    dgxeffective, dgyeffective :  Float; // эффективное ускорение свободного падения (нужно для вибрационного воздействия).

begin

   // проход по всем внутренним точкам
   // для определения коэффициентов
   // дискретного аналога  m и db

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // для шахматной сетки (для компонент скорости)
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
            dfe:=den*Vx[iecvi]*dy; // интенсивность
            den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
            dfw:=den*Vx[iwcvi]*dy; // конвекции
            den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
            dfn:=den*Vy[incvi]*dx; // или
            den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
            dfs:=den*Vy[iscvi]*dx; // течения
            // теплопроводность на грани контрольного объёма
            dke:=2*viscosity(ipi)*viscosity(iei)/((viscosity(ipi)+viscosity(iei)));
            dkw:=2*viscosity(ipi)*viscosity(iwi)/((viscosity(ipi)+viscosity(iwi)));
            dkn:=2*viscosity(ipi)*viscosity(ini)/((viscosity(ipi)+viscosity(ini)));
            dks:=2*viscosity(ipi)*viscosity(isi)/((viscosity(ipi)+viscosity(isi)));
            dde:=dke*dy/dxe;  // коэффициенты
            ddw:=dkw*dy/dxw;  // дискретного
            ddn:=dkn*dx/dyn;  // аналога
            dds:=dks*dx/dys;
            dpe:=dfe/dde; // значения
            dpw:=dfw/ddw; // чисел
            dpn:=dfn/ddn; // Пекле
            dps:=dfs/dds;
            // коэффициенты дискретного аналога
            m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(-dfe,0);
            m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv)+maxoper(dfw,0);
            m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(-dfn,0);
            m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+maxoper(dfs,0);
            if (btimedepend) then
            begin
               // нестационарный солвер
               dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
            end
             else
            begin
               // стационарный солвер
               dap0:=0.0; // стационарный вклад
            end;
            // неизменная составляющая источникового члена
            db[ipi]:=defmysource.Omega.dSc*dV;
            // сила тяжести
            dgxeffective:=dgx; dgyeffective:=dgy;
            // В случае силы тяжести меняющейся по гармоническому закону:
            if ((btimedepend) and (rgravVib.bOn)) then
            begin
               // Только в том случае если процесс нестационарный и
               // сила тяжести меняется по гармоническому закону.

               dgxeffective:= dgxeffective + GetRealGravity('x');
               dgyeffective:= dgyeffective + GetRealGravity('y');
            end;
            // Приближение Буссинеска.
            if (bBussinesk) then
            begin
               // Здесь записывается источниковый вклад в модели Буссинеска,
               // где плотность линейно зависит от температуры. Подробнее можно
               // посмотреть у Г.З. Гершини и Е.М. Жуховицкого.
               db[ipi]:=db[ipi]+density(ipi)*dbeta*dgxeffective*(T[ini]-T[isi])/(ypos[j+1]-ypos[j-1]);
               db[ipi]:=db[ipi]+density(ipi)*dbeta*dgyeffective*(T[iei]-T[iwi])/(xpos[i+1]-xpos[i-1]);
            end;
            
            if (btimedepend) then
            begin
               // нестационарный добавок к источниковому члену
              db[ipi]:=db[ipi]+ dap0*OmegaoldTimeStep[ipi];
            end;
            m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;
            m[ipi].dap:=m[ipi].dap + dap0 - defmysource.Omega.dSp*dV;
         end;

         if (itype = 2 ) then
         begin
            // граничный узел
            
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // Условие Тома.
            m[ipi].dae:=0;
            m[ipi].daw:=0;
            m[ipi].dan:=0;
            m[ipi].das:=0;
            m[ipi].dap:=1.0;

            // на границе поставлено условие Тома
            if (iugol=0) then
            begin
               // точка не является угловой
               case chnormal of
                 'N' : begin
                         // Условие Тома.
                         // На нижней границе.
                         db[ipi]:=2*(SF[ini]-SF[ipi])/((ypos[j+1]-ypos[j])*(ypos[j+1]-ypos[j]));
                       end;
                 'S' : begin
                          // Условие Тома.
                          // На верхней границе.
                          db[ipi]:=2*(SF[isi]-SF[ipi])/((ypos[j]-ypos[j-1])*(ypos[j]-ypos[j-1]));
                       end;
                 'W' : begin
                          // Условие Тома.
                          // Правая стенка
                          db[ipi]:=2*(SF[iwi]-SF[ipi])/((xpos[i]-xpos[i-1])*(xpos[i]-xpos[i-1]));
                       end;
                 'E' : begin
                          // Условие Тома.
                          // Левая стенка
                          db[ipi]:=2*(SF[iei]-SF[ipi])/((xpos[i+1]-xpos[i])*(xpos[i+1]-xpos[i]));
                       end;
               end; // case

            end // точка лежащая внутри границы расчётной области
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
                 // угловая точка
                  case iugol of
                  1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;
                     end;
                  2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.5;
                     end;
                  3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.0;
                     end;
                  4 : // верхний правй угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.5;
                     end;
                  5 : // пятиточечная звезда
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.25;
                        m[ipi].dan:=0.25;
                        m[ipi].das:=0.25;
                        m[ipi].daw:=0.25;
                     end;
                  end; // case
               end; // угловая точка
         end; // граничная точка
      end; // with
   end;

end; // OmegaConvCoef


// нестационарный температурный солвер с конвекцией
procedure TForm1.SolveTempUnsteady(bconv : Boolean);
var
    j : Integer; //  j - номер временного шага

begin
   // показать ход выполнения
   myProgressBarUnsteadyForm.Show;


   // теперь сам температурный солвер
   // с учётом  или без учёта конвекции
   j:=1;
   while ((bweShouldContinue) and (j <= inumbertimestep)) do
   begin // шаги по времени
      // глобальная переменная realFlowTime
      // используется как параметр при различных вибрационных воздействиях.
      realFlowTime:=realFlowTime + dTimeStep; // Текущее время при нестационарном расчёте

      // третий параметр true означает
      // что решается уравнение теплопроводности
      //  с учётом конвективного члена.
      SolveTempSteady(true, itercount, bconv);

      // запоминаем поле температур в переменной ToldTimeStep
      RememberTOldTimeStep(true);
      // переход к следующему временному слою
      MainMemo.Lines.Add('time ' + FloatToStr(realFlowTime));

      // временное прерывание расчётов
      // для того чтобы программа смогла
      // среагировать на другие события от
      // пользователя или операционной системы.
      Application.ProcessMessages;

      // скорость выполнения шагов по времени
      myProgressBarUnsteadyForm.ProgressBar2.Position:=round(j/inumbertimestep*100);
      j:=j+1; // переход к следующему временному слою.
   end; // j - временные шаги

   bweShouldContinue:=true; // восстанавливаем готовность к решению.

   myProgressBarUnsteadyForm.ProgressBar1.Position:=0; // обнуление
   myProgressBarUnsteadyForm.ProgressBar2.Position:=0; // индикаторов
   myProgressBarUnsteadyForm.Close; // закрыть индикатор хода выплнения
end; // SolveTempUnsteadyConv


// создаёт файл для программы tecplot
// переменная  ifuncexport отвечает за то какое значение передавать
// в программу tecplot:
// 1 - со значением вихря,
// 2 - со значением функции тока,
// 3 - со значением поля температур,
// 4 - со значением распределения давления.
// 5 - со значением горизонтальной скорости,
// 6 - со значением вертикальной скорости.
// 7 - со значением функции цвета (VOF)
procedure TForm1.exporttecplotUniversal(ifuncexport : Integer);
var
   f : TStrings; // переменная типа объект TStringList
   fname, sbuf : String; // имя создаваемого файла
   iNum, iE : Integer;
   i,j,ius : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости

begin
   // инициализация
   ihigh:=1; // по умолчанию несоответствие сетки и вычисляемой функции.
   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   case ifuncexport of
     1 : ihigh:= High(Omega) - (inx*iny); // вихрь
     2 : ihigh:= High(SF) - (inx*iny); // функция тока
     3 : ihigh:= High(T) - (inx*iny); // поле температур
     4 : ihigh:= High(P) - (inx*iny); // давление
     5 : ihigh:= High(Vx) - ((inx-1)*iny); // горизонтальная компонента скорости
     6 : ihigh:= High(Vy) - (inx*(iny-1)); // вертикальная компонента скорости
     7 : ihigh:= High(VOF) - (inx*iny); // функция цвета VOF method
   end;


   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for i:=1 to imaxnumbernode do
       begin
          if ((mapPT[i].i < inx) and (mapPT[i].j < iny)) then
          begin
             if ((GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[(mapPT[i].i+1)+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[(mapPT[i].i+1)+(mapPT[i].j)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j)*inx].itypenode > 0)) then
             begin
                // все четыре узла внутренние
                inc(iE);
             end;
          end;
       end;
       // экспортирует данные в программу tecplot
       f:=TStringList.Create();
       case ifuncexport of
         1 : // Вихрь
            begin
               f.Add('TITLE = " Omega "');
               f.Add('VARIABLES = X,Y, "omega"');
            end;
         2 : // функция тока
            begin
               f.Add('TITLE = " Stream Function "');
               f.Add('VARIABLES = X,Y, "stream function"');
            end;
         3 : // поле температур
            begin
               f.Add('TITLE = " Tempreture "');
               f.Add('VARIABLES = X,Y, "tempreture"');
            end;
         4 : // распределение давления
            begin
              f.Add('TITLE = " Pressure "');
              f.Add('VARIABLES = X,Y, "pressure"');
            end;
         5 : // горизонтальная компонента скорости
            begin
               f.Add('TITLE = " X-Velocity "');
               f.Add('VARIABLES = X,Y, "x-velocity"');
            end;
         6 : // вертикальная компонента скорости
            begin
               f.Add('TITLE = " Y-Velocity "');
               f.Add('VARIABLES = X,Y, "y-velocity"');
            end;
         7 : // функция цвета (VOF method)
            begin
              f.Add('TITLE = " Phases "');
              f.Add('VARIABLES = X,Y, "phases"');
            end;
       end;


       f.Add('ZONE T="Rampant", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       f.Add('');

       SetLength(number,inx*iny+1);
       for i:=1 to imaxnumbernode do
       begin
          number[mapPT[i].i+(mapPT[i].j-1)*inx]:=i; // уникальные номера для каждого узла
       end;

       // x - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
          sbuf:=sbuf + FloatToStr(xpos[mapPT[i].i])+' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // y - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
          sbuf:=sbuf + FloatToStr(ypos[mapPT[i].j])+' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
           case ifuncexport of
               1 : // Вихрь
                 begin
                    sbuf:=sbuf+FloatToStr(Omega[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                 end;
               2 : // функция тока
                 begin
                    sbuf:=sbuf+FloatToStr(SF[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                 end;
               3 : // поле температур
                 begin
                    sbuf:=sbuf+FloatToStr(T[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                 end;
               4 : // распределение давления
                  begin
                     sbuf:=sbuf+FloatToStr(P[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                  end;
               5 : // горизонтальная компонента скорости
                  begin
                     dresult:=0.0; // инициализация
                     if (mapPT[i].i=1) then dresult:=Vx[1+(mapPT[i].j-1)*(inx-1)];
                     if (mapPT[i].i=inx) then dresult:=Vx[(inx-1)+(mapPT[i].j-1)*(inx-1)];
                     if ((mapPT[i].i<>1) and (mapPT[i].i<>inx)) then
                     begin
                        // используется линейная интерполяция
                        // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                        // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                        dfe:=(xpos[mapPT[i].i+1]-xpos[mapPT[i].i])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i-1]); // учёт неравномерности сетки
                        dresult:=dfe*Vx[(mapPT[i].i-1)+(mapPT[i].j-1)*(inx-1)]+(1-dfe)*Vx[mapPT[i].i+(mapPT[i].j-1)*(inx-1)];
                     end;
                     sbuf:=sbuf+FloatToStr(dresult)+' ';
                  end;
               6 : // вертикальная компонента скорости
                  begin
                     dresult:=0.0; // инициализация
                     if (mapPT[i].j=1) then
                     begin
                        dresult:=Vy[mapPT[i].i];
                     end;
                     if (mapPT[i].j=iny) then
                     begin
                        dresult:=Vy[mapPT[i].i+(iny-2)*inx];
                     end;
                     if ((mapPT[i].j<>1) and (mapPT[i].j<>iny)) then
                     begin
                        // линейная интерполяция
                        // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                        // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                        dfe:=(ypos[mapPT[i].j+1]-ypos[mapPT[i].j])/(ypos[mapPT[i].j+1]-ypos[mapPT[i].j-1]);
                        dresult:=dfe*Vy[mapPT[i].i+(mapPT[i].j-2)*inx]+(1-dfe)*Vy[mapPT[i].i+(mapPT[i].j-1)*inx];
                     end;
                     sbuf:=sbuf+FloatToStr(dresult)+' ';
                  end;
                7 : // распределение функции цвета
                  begin
                     sbuf:=sbuf+FloatToStr(VOF[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                  end;
             end;
             if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
          if ((mapPT[i].i < inx) and (mapPT[i].j < iny)) then
          begin
             if ((GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+1+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+1+(mapPT[i].j)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j)*inx].itypenode > 0)) then
                 begin
                    // все четыре узла внутренние
                    sbuf:=IntToStr(number[mapPT[i].i+(mapPT[i].j-1)*inx])+' '+
                    IntToStr(number[mapPT[i].i+1+(mapPT[i].j-1)*inx])+' '
                    +IntToStr(number[mapPT[i].i+1+(mapPT[i].j)*inx])+' '
                    +IntToStr(number[mapPT[i].i+(mapPT[i].j)*inx])+' ';
                    f.Add(sbuf);
                 end;
          end;
       end;


       case ifuncexport of
         1 : // Вихрь
            begin
               fname:='c:\omega.PLT';
            end;
         2 : // функция тока
            begin
               fname:='c:\streamfunctec.PLT';
            end;
         3 : // поле температур
            begin
               fname:='temptec.PLT';
            end;
         4 : // распределение давления
            begin
               fname:='c:\pressuretec.PLT';
            end;
         5 : // распределение горизонтальной скорости
            begin
               fname:='c:\x_velocity.PLT';
            end;
         6 : // распределение вертикальной скорости
            begin
               fname:='c:\y_velocity.PLT';
            end;
         7 : // распределение функции цвета (VOF метод)
            begin
               fname:='c:\phases.PLT';
            end;
       end;

       f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',pChar(fname),nil,SW_SHOW);
       f.Free;
   end
   else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Вихрь
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь на данной сетке.');
               MainMemo.Lines.Add('Вихрь не может быть отображён.');
               Application.MessageBox('Вы не рассчитывали вихрь на данной сетке.','',MB_OK);
            end;
        2 : // Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли функцию тока на данной сетке.');
               MainMemo.Lines.Add('Функция тока не может быть отображена.');
               Application.MessageBox('Вы не рассчитывали функцию тока на данной сетке.','',MB_OK);
            end;
        3 : // поле температур
            begin
               MainMemo.Lines.Add('Вы не вычисляли поле температур на данной сетке.');
               MainMemo.Lines.Add('Поле температур не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали поле температур на данной сетке.','',MB_OK);
            end;
        4 : // распределение давления
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение давления на данной сетке.');
               MainMemo.Lines.Add('распределение давления не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение давления на данной сетке.','',MB_OK);
            end;
        5 : // распределение горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение горизонтальной компоненты скорости на данной сетке.');
               MainMemo.Lines.Add('распределение горизонтальной компоненты скорости не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение горизонтальной компоненты скорости на данной сетке.','',MB_OK);
            end;
        6 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение вертикальной компоненты скорости на данной сетке.');
               MainMemo.Lines.Add('распределение вертикальной компоненты скорости не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение вертикальной компоненты скорости на данной сетке.','',MB_OK);
            end;
        7 : // распределение функции цвета
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение функции цвета на данной сетке.');
               MainMemo.Lines.Add('распределение функции цвета не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение функции цвета на данной сетке.','',MB_OK);
            end;
      end;

   end;
end; //exporttecplotUniversal

// создаёт файл для программы tecplot
// со всеми расчитанными функциями.
// в программу tecplot:
//
// 1 - мат ожидание вихря,
// 2 - мат. ожидание температуры
// 3 - мат. ожидание горизонтальной скорости,
// 4 - мат. ожидание  вертикальной скорости.
// 5 - мат. ожидание модуля скорости.
// 6 - математическое ожидание функции тока
procedure TForm1.exporttecplotmeanUniversalComplete;
var
   f : TStrings; // переменная типа объект TStringList
   fname, sbuf : String; // имя создаваемого файла
   iNum, iE : Integer;
   i1,j1,k,ius : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости
   ifuncexport : Integer; // где случилась ошибка
   meanvelmag : array of Float; // мат ожидание модуля скорости

begin
   // инициализация

   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   // выделение памяти
     SetLength(meanvelmag,inx*iny+1);
     // инициализация
     for i1:=1 to inx do
     begin
         for j1:=1 to iny do
         begin
             meanvelmag[i1+(j1-1)*inx]:=0.0;
         end;
     end;

     // по умолчанию проверка на несоответствие сетки и вычисляемой функции
     // для функции вихрь.
     ihigh:= High(meanOmega) - (inx*iny); // вихрь
     if (ihigh=0) then
     begin
        ihigh:= High(SF) - (inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=1;
     end;
     if (Form1.imodelEquation<>3 ) then
     begin
        if (ihigh=0) then
        begin
           ihigh:= High(meanT) - (inx*iny); // осреднённая температура
        end
         else
        begin
           ifuncexport:=2;
        end;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(meanVx) - ((inx-1)*iny); // осреднённая горизонтальная компонента скорости
     end
      else
     begin
        ifuncexport:=3;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(meanVy) - (inx*(iny-1)); // осреднённая вертикальная компонента скорости
     end
      else
     begin
        ifuncexport:=4;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(meanSF) - (inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=5;
     end;
     if (ihigh <> 0) then ifuncexport:=6;


   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j)*inx].itypenode > 0) and
                    (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                begin
                   // все четыре узла внутренние
                   inc(iE);
                end;
             end;
          end;
       end;
       // экспортирует данные в программу tecplot
       f:=TStringList.Create();
       f.Add('TITLE = " CFD Vahl-DavisTestDelphi "');
       if (Form1.imodelEquation<>3 ) then
       begin
          f.Add('VARIABLES = X,Y, "mean-omega", "mean-T", "mean-x-velocity", "mean-y-velocity", "mean-vel-mag", "mean-SF"');
       end
        else
       begin
          f.Add('VARIABLES = X,Y, "mean-omega", "mean-x-velocity", "mean-y-velocity", "mean-vel-mag", "mean-SF"');
       end;

       f.Add('ZONE T="Rampant", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       f.Add('');

       SetLength(number,inx*iny+1);
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             number[i+(j-1)*inx]:=k; // уникальные номера для каждого узла
          end;
       end;

       // значения X
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf + FloatToStr(xpos[i])+' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Значения Y
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf + FloatToStr(ypos[j])+' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-Omega
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(meanOmega[i+(j-1)*inx])+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

        if (Form1.imodelEquation<>3 ) then
        begin
           // mean-T
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
              with mapPT[k] do
              begin
                 sbuf:=sbuf+FloatToStr(meanT[i+(j-1)*inx])+' ';
                 if ((k+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
              end;
           end;
           if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
        end;

       // mean-x-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (i=1) then dresult:=meanVx[1+(j-1)*(inx-1)];
             if (i=inx) then dresult:=meanVx[(inx-1)+(j-1)*(inx-1)];
             // используется линейная интерполяция
             // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
             // из книжки С.Патанкара. (это лучше для неравномерных сеток).
             dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
             if ((i<>1) and (i<>inx)) then
             begin
                dresult:=dfe*meanVx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*meanVx[i+(j-1)*(inx-1)];
             end;
             sbuf:=sbuf+FloatToStr(dresult)+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-y-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (j=1) then
             begin
                dresult:=meanVy[i];
             end;
             if (j=iny) then
             begin
                dresult:=meanVy[i+(iny-2)*inx];
             end;
             // линейная интерполяция
             // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
             // из книжки С. Патанкара. (это лучше для неравномерных сеток).
             dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
             if ((j<>1) and (j<>iny)) then
             begin
                dresult:=dfe*meanVy[i+(j-2)*inx]+(1-dfe)*meanVy[i+(j-1)*inx];
             end;
             sbuf:=sbuf+FloatToStr(dresult)+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-vel-mag
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
           with mapPT[k] do
           begin
              dresult:=0.0; // инициализация
              if (i=1) then dresult:=meanVx[1+(j-1)*(inx-1)];
              if (i=inx) then dresult:=meanVx[(inx-1)+(j-1)*(inx-1)];
              // используется линейная интерполяция
              // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
              // из книжки С.Патанкара. (это лучше для неравномерных сеток).
              dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
              if ((i<>1) and (i<>inx)) then
              begin
                 dresult:=dfe*meanVx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*meanVx[i+(j-1)*(inx-1)];
              end;
              meanvelmag[i+(j-1)*inx]:=dresult*dresult;
              dresult:=0.0; // инициализация
              if (j=1) then
              begin
                  dresult:=meanVy[i];
              end;
              if (j=iny) then
              begin
                 dresult:=meanVy[i+(iny-2)*inx];
              end;
              // линейная интерполяция
              // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
              // из книжки С. Патанкара. (это лучше для неравномерных сеток).
              dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
              if ((j<>1) and (j<>iny)) then
              begin
                 dresult:=dfe*meanVy[i+(j-2)*inx]+(1-dfe)*meanVy[i+(j-1)*inx];
              end;
              meanvelmag[i+(j-1)*inx]:=meanvelmag[i+(j-1)*inx] + dresult*dresult;
              sbuf:=sbuf+FloatToStr(sqrt(meanvelmag[i+(j-1)*inx]))+' ';
              if ((k+1) mod 10 =0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
           end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-SF
         sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(meanSF[i+(j-1)*inx])+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                   begin
                      // все четыре узла внутренние
                      sbuf:=IntToStr(number[i+(j-1)*inx])+' '+
                      IntToStr(number[i+1+(j-1)*inx])+' '
                      +IntToStr(number[i+1+(j)*inx])+' '
                      +IntToStr(number[i+(j)*inx])+' ';
                      f.Add(sbuf);
                   end;
             end;
          end; // with
       end;

       fname:='c:\CFDmeanFlow.PLT';
       f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',pChar(fname),nil,SW_SHOW);
       f.Free;
   end
    else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Вихрь
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь на данной сетке.');
               MainMemo.Lines.Add('Вихрь не может быть отображён.');
               Application.MessageBox('Вы не рассчитывали вихрь на данной сетке.','',MB_OK);
            end;
        2 : // Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли мат. ожидания поля температур на данной сетке.');
               MainMemo.Lines.Add('мат. ожидание поля температур не может быть отображена.');
               Application.MessageBox('Вы не рассчитывали мат ожидание поля температур на данной сетке.','',MB_OK);
            end;
        3 : // распределение осреднённой температуры
            begin
               MainMemo.Lines.Add('Вы не вычисляли mean-T на данной сетке.');
               MainMemo.Lines.Add('mean-T не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали mean-T на данной сетке.','',MB_OK);
            end;
        4 : // распределение осреднённой горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение mean-x-velocity на данной сетке.');
               MainMemo.Lines.Add('mean-x-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение mean-x-velocity на данной сетке.','',MB_OK);
            end;
        5 : // распределение осреднённой вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение mean-y-velocity на данной сетке.');
               MainMemo.Lines.Add('mean-y-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение mean-y-velocity на данной сетке.','',MB_OK);
            end;
        6 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение математического ожидания от функции тока на данной сетке.');
               MainMemo.Lines.Add('математическое ожидание от функции тока не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали мат ожидание от функции тока на данной сетке.','',MB_OK);
            end;
      end;

   end;
end; //exporttecplotmeanUniversalComplete

// создаёт файл для программы tecplot
// со всеми расчитанными функциями.
// в программу tecplot:
//
// 1 -  вихрь,
// 2 -  температура,
// 3 -  горизонтальная скорость,
// 4 -  вертикальная скорость,
// векторное поле скоростей может быть автоматически
// сгенерировано используя пункты 3 и 4.
// 5 -  модуль скорости,
// 6 -  функция тока,
// 7 - давление.
procedure TForm1.exporttecplotUniversalComplete;
var
   f : TStrings; // переменная типа объект TStringList
   sbuf : String; // имя создаваемого файла
   fname : String;
   iNum, iE : Integer;
   i1,j1,k,ius : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости
   ifuncexport : Integer; // где случилась ошибка
   velmag : array of Float; //  модуль скорости

begin
   // инициализация

   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   // выделение памяти
     SetLength(velmag,inx*iny+1);
     // инициализация
     for i1:=1 to inx do
     begin
         for j1:=1 to iny do
         begin
             velmag[i1+(j1-1)*inx]:=0.0;
         end;
     end;

     // по умолчанию проверка на несоответствие сетки и вычисляемой функции
     // для вихря.
     ihigh:= High(Omega) - (inx*iny); // вихрь
     if (ihigh=0) then
     begin
        ihigh:= High(SF) - (inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=1;
     end;
     if (Form1.imodelEquation<>3 ) then
     begin
        if (ihigh=0) then
        begin
           ihigh:= High(T) - (inx*iny); //  температура
        end
         else
        begin
           ifuncexport:=2;
        end;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Vx) - ((inx-1)*iny); //  горизонтальная компонента скорости
     end
      else
     begin
        ifuncexport:=3;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Vy) - (inx*(iny-1)); //  вертикальная компонента скорости
     end
      else
     begin
        ifuncexport:=4;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(P) - (inx*iny); // давление
     end
      else
     begin
        ifuncexport:=5;
     end;
     if (ihigh <> 0) then ifuncexport:=6;


   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j)*inx].itypenode > 0) and
                    (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                begin
                   // все четыре узла внутренние
                   inc(iE);
                end;
             end;
          end;
       end;
       // экспортирует данные в программу tecplot
       f:=TStringList.Create();
       f.Add('TITLE = " CFD Vahl-DavisTestDelphi "');
       if (Form1.imodelEquation<>3 ) then
       begin
          f.Add('VARIABLES = X,Y, "omega", "T", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure"');
       end
        else
       begin
          f.Add('VARIABLES = X,Y, "omega", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure"');
       end;

       f.Add('ZONE T="Rampant", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       f.Add('');

       SetLength(number,inx*iny+1);
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             number[i+(j-1)*inx]:=k; // уникальные номера для каждого узла
          end;
       end;

       // значения X
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf + FloatToStr(xpos[i])+' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Значения Y
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf + FloatToStr(ypos[j])+' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Omega
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(Omega[i+(j-1)*inx])+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

        if (Form1.imodelEquation<>3 ) then
        begin
           // T
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
              with mapPT[k] do
              begin
                 sbuf:=sbuf+FloatToStr(T[i+(j-1)*inx])+' ';
                 if ((k+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
              end;
           end;
           if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
        end;

       // x-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (i=1) then dresult:=Vx[1+(j-1)*(inx-1)];
             if (i=inx) then dresult:=Vx[(inx-1)+(j-1)*(inx-1)];
             if ((i<>1) and (i<>inx)) then
             begin
                // используется линейная интерполяция
                // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                dresult:=dfe*Vx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*Vx[i+(j-1)*(inx-1)];
             end;
             sbuf:=sbuf+FloatToStr(dresult)+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // y-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (j=1) then
             begin
                dresult:=Vy[i];
             end;
             if (j=iny) then
             begin
                dresult:=Vy[i+(iny-2)*inx];
             end;

             if ((j<>1) and (j<>iny)) then
             begin
                // линейная интерполяция
                // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                dresult:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
             end;
             sbuf:=sbuf+FloatToStr(dresult)+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // vel-mag
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
           with mapPT[k] do
           begin
              dresult:=0.0; // инициализация
              if (i=1) then dresult:=Vx[1+(j-1)*(inx-1)];
              if (i=inx) then dresult:=Vx[(inx-1)+(j-1)*(inx-1)];
              if ((i<>1) and (i<>inx)) then
              begin
                 // используется линейная интерполяция
                 // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                 // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                 dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                 dresult:=dfe*Vx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*Vx[i+(j-1)*(inx-1)];
              end;
              velmag[i+(j-1)*inx]:=dresult*dresult;
              dresult:=0.0; // инициализация
              if (j=1) then
              begin
                  dresult:=Vy[i];
              end;
              if (j=iny) then
              begin
                 dresult:=Vy[i+(iny-2)*inx];
              end;
              if ((j<>1) and (j<>iny)) then
              begin
                 // линейная интерполяция
                 // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                 // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                 dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                 dresult:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
              end;
              velmag[i+(j-1)*inx]:=velmag[i+(j-1)*inx] + dresult*dresult;
              sbuf:=sbuf+FloatToStr(sqrt(velmag[i+(j-1)*inx]))+' ';
              if ((k+1) mod 10 =0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
           end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // SF
         sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(SF[i+(j-1)*inx])+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Давление
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(P[i+(j-1)*inx])+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                   begin
                      // все четыре узла внутренние
                      sbuf:=IntToStr(number[i+(j-1)*inx])+' '+
                      IntToStr(number[i+1+(j-1)*inx])+' '
                      +IntToStr(number[i+1+(j)*inx])+' '
                      +IntToStr(number[i+(j)*inx])+' ';
                      f.Add(sbuf);
                   end;
             end;
          end; // with
       end;

       fname:='c:\CFDFlow.PLT';
       f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',PChar(fname),nil,SW_SHOW);
       f.Free;
   end
    else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Вихрь
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь на данной сетке.');
               MainMemo.Lines.Add('Вихрь не может быть отображён.');
               Application.MessageBox('Вы не рассчитывали вихрь на данной сетке.','',MB_OK);
            end;
        2 : // Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли функцию тока на данной сетке.');
               MainMemo.Lines.Add(' функция тока не может быть отображена.');
               Application.MessageBox('Вы не рассчитывали функцию тока на данной сетке.','',MB_OK);
            end;
        3 : // распределение температуры
            begin
               MainMemo.Lines.Add('Вы не вычисляли поле температур на данной сетке.');
               MainMemo.Lines.Add('поле температур не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали поле температур на данной сетке.','',MB_OK);
            end;
        4 : // распределение горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение x-velocity на данной сетке.');
               MainMemo.Lines.Add('x-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение x-velocity на данной сетке.','',MB_OK);
            end;
        5 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение y-velocity на данной сетке.');
               MainMemo.Lines.Add('y-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение y-velocity на данной сетке.','',MB_OK);
            end;
        6 : // распределение давления 
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение давления на данной сетке.');
               MainMemo.Lines.Add('поле давления не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали давление на данной сетке.','',MB_OK);
            end;
      end;

   end;
end; //exporttecplotUniversalComplete

// по значениям функции тока находит
// горизонтальную скорость.
procedure TForm1.VxConstruct;
var
   i,j : Integer; // счётчики
   ipi,ini,isi : Integer;
   VxL,VxR : Float; // значения горизонтальной скорости слева и справа
begin
   for i:=1 to (inx-1) do
   begin
      for j:=1 to iny do
      begin
         if ((j>1) and (j<iny)) then
         begin
            ini:=i+j*inx;
            isi:=i+(j-2)*inx;
            VxL:=(SF[ini]-SF[isi])/(ypos[j+1]-ypos[j-1]);
            ini:=(i+1)+j*inx;
            isi:=(i+1)+(j-2)*inx;
            VxR:=(SF[ini]-SF[isi])/(ypos[j+1]-ypos[j-1]);
            ipi:=i+(j-1)*(inx-1);
            Vx[ipi]:=0.5*(VxL+VxR);
         end;
         if (j=1) then
         begin
            ini:=i+j*inx;
            ipi:=i+(j-1)*inx;
            VxL:=(SF[ini]-SF[ipi])/(ypos[j+1]-ypos[j]);
            ini:=(i+1)+j*inx;
            ipi:=(i+1)+(j-1)*inx;
            VxR:=(SF[ini]-SF[ipi])/(ypos[j+1]-ypos[j]);
            ipi:=i+(j-1)*(inx-1);
            Vx[ipi]:=0.5*(VxL+VxR);
         end;
         if (j=iny) then
         begin
            ipi:=i+(j-1)*inx;
            isi:=i+(j-2)*inx;
            VxL:=(SF[ipi]-SF[isi])/(ypos[j]-ypos[j-1]);
            ipi:=(i+1)+(j-1)*inx;
            isi:=(i+1)+(j-2)*inx;
            VxR:=(SF[ipi]-SF[isi])/(ypos[j]-ypos[j-1]);
            ipi:=i+(j-1)*(inx-1);
            Vx[ipi]:=0.5*(VxL+VxR);
         end;
      end;
   end;
end; // VxConstruct

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
procedure TForm1.Vxcoef(i, j : Integer; var m : MatrixCoef);
var
    iei,iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu, jywd, jyed : Integer; // номера для компонента скорости Vy
    dfe, dfw, dfn, dfs : Float; // конвективные члены
    dmuA,dmuB : Float; // для двойной интерполяции по dmu
    dge, dgw, dgn, dgs : Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // значения плотности
    dre, drw, drn, drs : Float; // значения плотности
    dikoef    : Real; // интерполяционный коэффициент для Vx скорости
    dde, ddw, ddn, dds : Float;
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dap0 : Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*Vx[ipi]*Vx[iei]/(Vx[ipi]+Vx[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*Vx[ipi]*Vx[iwi]/(Vx[ipi]+Vx[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   dfe:=dre*(dikoef*Vx[ipi]+(1-dikoef)*Vx[iei])*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   dfw:=drw*(dikoef*Vx[iwi]+(1-dikoef)*Vx[ipi])*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   drhoA:=2*density(jwu)*density(jw)/(density(jw)+density(jwu)); //двойная
   drhoB:=2*density(jeu)*density(je)/(density(jeu)+density(je)); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   dfn:=drn*(0.5*(Vy[jywu]+Vy[jyeu]))*(xpos[i+1]-xpos[i]); // или
   drhoA:=2*density(jw)*density(jwd)/(density(jw)+density(jwd)); // двойная
   drhoB:=2*density(je)*density(jed)/(density(je)+density(jed)); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   dfs:=drs*(0.5*(Vy[jywd]+Vy[jyed]))*(xpos[i+1]-xpos[i]); // течения

   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия
   dde:=dge*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+2]-xpos[i]));  // коэффициенты
   ddw:=dgw*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+1]-xpos[i-1]));  // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j]);  // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1]);

   dpe:=dfe/dde; // значения
   dpw:=dfw/ddw; // чисел
   dpn:=dfn/ddn; // Пекле
   dps:=dfs/dds;
   m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
   m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
   m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
   m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
      drhoA:=2*density(jw)*density(je)/(density(jw)+density(je));
      dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
   end;

   m.dap:= m.dae + m.daw + m.dan + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));

end; // Vxcoef

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// для нижней границы
procedure TForm1.VxcoefBottom(i, j : Integer; var m : MatrixCoef);
var
    iei,iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu : Integer; // номера для компонента скорости Vy
    dfe, dfw, dfn : Float; // конвективные члены
    dmuA,dmuB : Float; // для двойной интерполяции по dmu
    dge, dgw, dgn : Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // значения плотности
    dre, drw, drn : Float; // значения плотности
    dikoef    : Float; // интерполяционный коэффициент для Vx скорости
    dde, ddw, ddn : Float;
    dpe,dpw,dpn : Float; // числа Пекле
    dap0 : Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;


   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*Vx[ipi]*Vx[iei]/(Vx[ipi]+Vx[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*Vx[ipi]*Vx[iwi]/(Vx[ipi]+Vx[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   dfe:=dre*(dikoef*Vx[ipi]+(1-dikoef)*Vx[iei])*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   dfw:=drw*(dikoef*Vx[iwi]+(1-dikoef)*Vx[ipi])*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   drhoA:=2*density(jwu)*density(jw)/(density(jw)+density(jwu)); //двойная
   drhoB:=2*density(jeu)*density(je)/(density(jeu)+density(je)); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   dfn:=drn*(0.5*(Vy[jywu]+Vy[jyeu]))*(xpos[i+1]-xpos[i]); // или


   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   // Диффузия
   dde:=dge*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+2]-xpos[i]));  // коэффициенты
   ddw:=dgw*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+1]-xpos[i-1]));  // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j]);  // аналога


   dpe:=dfe/dde; // значения
   dpw:=dfw/ddw; // чисел
   dpn:=dfn/ddn; // Пекле
   m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
   m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
   m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
   m.das:=0.0; //dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
      drhoA:=2*density(jw)*density(je)/(density(jw)+density(je));
      dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
   end;

   
   m.dap:= m.dae + m.daw + m.dan  + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));

end; // VxcoefBottom

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// для выходной границы
procedure TForm1.VxcoefTop(i, j : Integer; var m : MatrixCoef);
var
    iei,iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywd, jyed : Integer; // номера для компонента скорости Vy
    dfe, dfw, dfs : Float; // конвективные члены
    dmuA,dmuB : Float; // для двойной интерполяции по dmu
    dge, dgw,  dgs : Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drs : Float; // значения плотности
    dikoef    : Float; // интерполяционный коэффициент для Vx скорости
    dde, ddw, dds : Float;
    dpe,dpw,dps : Float; // числа Пекле
    dap0 : Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*Vx[ipi]*Vx[iei]/(Vx[ipi]+Vx[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*Vx[ipi]*Vx[iwi]/(Vx[ipi]+Vx[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   dfe:=dre*(dikoef*Vx[ipi]+(1-dikoef)*Vx[iei])*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   dfw:=drw*(dikoef*Vx[iwi]+(1-dikoef)*Vx[ipi])*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // или
   drhoA:=2*density(jw)*density(jwd)/(density(jw)+density(jwd)); // двойная
   drhoB:=2*density(je)*density(jed)/(density(je)+density(jed)); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   dfs:=drs*(0.5*(Vy[jywd]+Vy[jyed]))*(xpos[i+1]-xpos[i]); // течения

   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия
   dde:=dge*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+2]-xpos[i]));  // коэффициенты
   ddw:=dgw*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+1]-xpos[i-1]));  // дискретного
     // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1]);

   dpe:=dfe/dde; // значения
   dpw:=dfw/ddw; // чисел
   // Пекле
   dps:=dfs/dds;
   m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
   m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
   m.dan:=0.0;// аналога
   m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
      drhoA:=2*density(jw)*density(je)/(density(jw)+density(je));
      dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
   end;

   m.dap:= m.dae + m.daw  + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));

end; // VxcoefTop

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j в случае когда этот узел находится на правой выходной границе
procedure TForm1.VxcoefRight(i, j : Integer; var m : MatrixCoef);
var
    iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu, jywd, jyed : Integer; // номера для компонента скорости Vy
    dfw, dfn, dfs : Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    drw, drn, drs : Float; // значения плотности
    dikoef    :  Float; // интерполяционный коэффициент для Vx скорости
    ddw, ddn, dds :  Float;
    dpw,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*Vx[ipi]*Vx[iei]/(Vx[ipi]+Vx[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*Vx[ipi]*Vx[iwi]/(Vx[ipi]+Vx[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   // интенсивность
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   dfw:=drw*(dikoef*Vx[iwi]+(1-dikoef)*Vx[ipi])*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   drhoA:=2*density(jwu)*density(jw)/(density(jw)+density(jwu)); //двойная
   drhoB:=2*density(jeu)*density(je)/(density(jeu)+density(je)); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   dfn:=drn*(0.5*(Vy[jywu]+Vy[jyeu]))*(xpos[i+1]-xpos[i]); // или
   drhoA:=2*density(jw)*density(jwd)/(density(jw)+density(jwd)); // двойная
   drhoB:=2*density(je)*density(jed)/(density(je)+density(jed)); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   dfs:=drs*(0.5*(Vy[jywd]+Vy[jyed]))*(xpos[i+1]-xpos[i]); // течения

   // переменная динамическая вязкость
   // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия

   ddw:=dgw*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+1]-xpos[i-1]));  // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j]);  // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1]);

   // значения
   dpw:=dfw/ddw; // чисел
   dpn:=dfn/ddn; // Пекле
   dps:=dfs/dds;
   m.dae:=0.0; // нет влияния справа, так как поток справа неизвестен
   m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
   m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
   m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
      drhoA:=2*density(jw)*density(je)/(density(jw)+density(je));
      dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
   end;

   m.dap:= 0.0 + m.daw + m.dan + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));

end; // VxcoefRight

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// в случае когда выходная граница находится слева
procedure TForm1.VxcoefLeft(i, j : Integer; var m : MatrixCoef);
var
    iei,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu, jywd, jyed : Integer; // номера для компонента скорости Vy
    dfe, dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // значения плотности
    dre, drn, drs : Float; // значения плотности
    dikoef    :  Float; // интерполяционный коэффициент для Vx скорости
    dde, ddn, dds :  Float;
    dpe,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*Vx[ipi]*Vx[iei]/(Vx[ipi]+Vx[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*Vx[ipi]*Vx[iwi]/(Vx[ipi]+Vx[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   dfe:=dre*(dikoef*Vx[ipi]+(1-dikoef)*Vx[iei])*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
    // конвекции
   drhoA:=2*density(jwu)*density(jw)/(density(jw)+density(jwu)); //двойная
   drhoB:=2*density(jeu)*density(je)/(density(jeu)+density(je)); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   dfn:=drn*(0.5*(Vy[jywu]+Vy[jyeu]))*(xpos[i+1]-xpos[i]); // или
   drhoA:=2*density(jw)*density(jwd)/(density(jw)+density(jwd)); // двойная
   drhoB:=2*density(je)*density(jed)/(density(je)+density(jed)); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   dfs:=drs*(0.5*(Vy[jywd]+Vy[jyed]))*(xpos[i+1]-xpos[i]); // течения

   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
    // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия
   dde:=dge*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+2]-xpos[i]));  // коэффициенты
     // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j]);  // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1]);

   dpe:=dfe/dde; // значения
    // чисел
   dpn:=dfn/ddn; // Пекле
   dps:=dfs/dds;
   m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
   m.daw:=0.0;  // дискретного
   m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
   m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
      drhoA:=2*density(jw)*density(je)/(density(jw)+density(je));
      dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
   end;

   m.dap:= m.dae  + m.dan + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));

end; // VxcoefLeft



// коэффициенты дискретного аналога для
// горизонтальной компоненты скорости
procedure TForm1.VxGlobalCoef(var mglobal : array of MatrixCoef;  // все коэффициенты дискретного аналога
                              var dbglobal : array of  Float);  // часть источникового члена

var
   m  : MatrixCoef; // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   ipi : Integer; // текущая узловая точка для Vx на пятиточечном шаблоне
   je, jw : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
   drhointerpol : Float; // для интерполяции плотности
   db :  Float; // коэффициент
   dpressure :  Float; // действующий градиент давления
   i : Integer; // счётчик
   dap0 :  Float; // нестационарный коэффициент
   dgxeffective :  Float; // эффективное ускорение свободного падения (нужно для вибрационного воздействия).
   rBodyForceBussinesknew, rBodyForceBussineskold :  Float; // учёт приближения Буссинеска
   bout : Boolean; // условие на выходной границе


begin
   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
    for i:=1 to imaxnumbernodeVx do
    begin
       //  номера узлов для массива Vx
         ipi:=mapVx[i].i+(mapVx[i].j-1)*(inx-1); // текущая точка

        if (mapVx[i].itype=1) then
        begin
           // внутренний узел


           // значение полей m не инициализировано, но
           // по возвращении из процедуры Vxcoef
           // соответствующие поля m будут соответствовать соответствующим коэффициентам
           // дискретного аналога
           Vxcoef(mapVx[i].i, mapVx[i].j, m); // вычисление коэффициентов дискретного аналога
           // если коэффициенты дискретного аналога вычислялись
            // то осталось только вычислить исто чниковый член



            // номера обычных узлов для переменных T и P
            je:=(mapVx[i].i+1)+(mapVx[i].j-1)*inx; // для обычных переменных
            jw:=mapVx[i].i+(mapVx[i].j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
            drhointerpol:=2*density(jw)*density(je)/(density(jw)+density(je));

            db:=dScVx*(xpos[mapVx[i].i+1]-xpos[mapVx[i].i])*(0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1])); // постоянная составляющая источникового члена
            if (btimedepend) then
            begin
               // нестационарный вклад
               // с постоянным шагом по времени
               dap0:=drhointerpol*(xpos[mapVx[i].i+1]-xpos[mapVx[i].i])*(0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]))/dTimeStep;
               db:=db + dap0*VxOldTimeStep[ipi]; // учёт нестационарности если требуется.
            end;

            dgxeffective:=dgx; // ускорение свободного падения

            // В случае силы тяжести меняющейся по гармоническому закону:
            if ((btimedepend) and (rgravVib.bOn)) then
            begin
               // Только в том случае если процесс нестационарный и
               // сила тяжести меняется по гармоническому закону.

               dgxeffective:= dgxeffective + GetRealGravity('x');
            end;

            // учёт приближения Буссинеска
            // температура аппроксимирована как среднее арефметическое
            if (bBussinesk) then
            begin
               // Здесь записывается источниковый вклад в модели Буссинеска,
               // где плотность линейно зависит от температуры. Подробнее можно
               // посмотреть у Г.З. Гершини и Е.М. Жуховицкого.

               // в некоторых случаях, например при больших значениях,
               // чисел Рэлея, имеет смысл замедлить изменение источникового члена от итерации к итерации.
               rBodyForceBussinesknew:= - drhointerpol*dbeta*dgxeffective*0.5*(T[jw]+T[je]);
               rBodyForceBussineskold:= - drhointerpol*dbeta*dgxeffective*0.5*(TOldIteration[jw]+TOldIteration[je]);
               db:= db + (myrelaxfactors.prelaxBodyForce*rBodyForceBussinesknew + (1-myrelaxfactors.prelaxBodyForce)*rBodyForceBussineskold)*(xpos[mapVx[i].i+1]-xpos[mapVx[i].i])*(0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]));
            end
             else
            begin
               // Здесь просто учитывается сила тяжести.
               // К приближению Буссинеска это не имеет отношения.
               // См. ГИДРОДИНАМИКА Л.Д. Ландау и Е.М. Лифшица стр. 16.

               db:= db +  drhointerpol*dgxeffective;

            end;

            dpressure:=(P[jw]-P[je])*0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]); // сила давления действующая на контрольный объём

            mglobal[ipi].dae:=m.dae; // коэффициенты
            mglobal[ipi].daw:=m.daw; // дискретного
            mglobal[ipi].dan:=m.dan; // аналога
            mglobal[ipi].das:=m.das;
            mglobal[ipi].dap:=m.dap/myrelaxfactors.xVelRelax;

            // VxOld - глобальный параметр, значение скорости с предыдущей итерации алгоритма
            // SIMPLE удовлетворяющее уравнению непрерывности (сохранению массы)
            dbglobal[ipi]:= db + dpressure + ((1-myrelaxfactors.xVelRelax)*m.dap*VxOld[ipi])/myrelaxfactors.xVelRelax;  // вклад источникового члена

         end;  // end внутренний узел

         if (mapVx[i].itype=2) then
         begin
            // граничный узел
            // нужно проверить принадлежит ли этот узел выходной границе


            if (mapVx[i].iugol = 0) then
            begin
               // точка не является угловой.

               // ищем границу к которой принадлежит эта точка
               bout:=GridGenForm.isoutflow(mapVx[i].iboundary, 'U',mapVx[i].chnormal);
               if (bout) then
               begin

                  // Это неверно, т.к. на выходной границе должны ставится мягкие условия
                  // F[i]=2F[i-1]-F[i-2]


                  // это выходная граница расчётной области
                  // внутренняя нормаль
                  case (mapVx[i].chnormal) of
                   'W' : // правая (здесь внутренняя нормаль
                       begin
                          // выходная граница находится справа
                          VxcoefRight(mapVx[i].i, mapVx[i].j,mglobal[ipi]);

                       end;
                   'E' : // левая сторона (внутренняя нормаль)
                       begin
                          // выходная граница находится слева
                          VxcoefLeft(mapVx[i].i, mapVx[i].j, mglobal[ipi]);
                       end;
                   'S' : // верхняя граница
                       begin
                          VxcoefTop(mapVx[i].i, mapVx[i].j, mglobal[ipi]);
                       end;
                   'N' : //  нижняя граница
                       begin
                          VxcoefBottom(mapVx[i].i, mapVx[i].j, mglobal[ipi]);
                       end;
                  end; // case

                  mglobal[ipi].dap:=mglobal[ipi].dap/myrelaxfactors.xVelRelax;

                  je:=(mapVx[i].i+1)+(mapVx[i].j-1)*inx; // для обычных переменных
                  jw:=mapVx[i].i+(mapVx[i].j-1)*inx;
                  dpressure:=(P[jw]-P[je])*0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]);
                  dbglobal[ipi]:=dpressure + ((1-myrelaxfactors.xVelRelax)*m.dap*VxOld[ipi])/myrelaxfactors.xVelRelax; ; // нет источникового члена

               end; // boutflow
            end
             else
            begin
               dbglobal[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               case mapVx[i].iugol of
                1 : // левый нижний угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.5;
                     mglobal[ipi].dan:=0.5;
                     mglobal[ipi].das:=0.0;
                     mglobal[ipi].daw:=0.0;
                  end;
                2 : // правый нижний угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.0;
                     mglobal[ipi].dan:=0.5;
                     mglobal[ipi].das:=0.0;
                     mglobal[ipi].daw:=0.5;
                  end;
                3 : // верхний левый угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.5;
                     mglobal[ipi].dan:=0.0;
                     mglobal[ipi].das:=0.5;
                     mglobal[ipi].daw:=0.0;
                  end;
                4 : // верхний правй угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.0;
                     mglobal[ipi].dan:=0.0;
                     mglobal[ipi].das:=0.5;
                     mglobal[ipi].daw:=0.5;
                  end;
                5 : // пятиточечная звезда
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.25;
                     mglobal[ipi].dan:=0.25;
                     mglobal[ipi].das:=0.25;
                     mglobal[ipi].daw:=0.25;
                  end;
               end; // case


            end;
         end;


      end;
end;  // VxGlobalCoef

// решение нелинейного уравнения для горизонтальной скорости
// реализовано вычисление коэффициентв дискретного аналога, а также
// есть два солвера: Гаусс-Зейдель и
// метод переменных направлений.
procedure TForm1.SolveVx;
var
   mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
   dbglobal : array of  Float; // часть источникового члена
   i, j : Integer; // счётчики внутренний и преодоления нелинейности
   // данные переменные позволяют судить о нахождении решения
   // нелинейного уравнения для верикальной компоненты скорости
   VxOldNonLin : array of  Float; // поле скорости с предыдущей итерации по устранению нелинейности
   deviation :  Float; // отклонение от скорости на предыдущей итерации по устранению нелинейности

begin
   // выделение оперативной памяти
   SetLength(mglobal,(inx-1)*iny+1); // основные коэффициенты дискретного аналога
   SetLength(dbglobal,(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(VxOldNonLin,(inx-1)*iny+1); // выделение памяти под скорость с предыдущей итерации
   // iterSimple.iterVxLin - количество итераций для решения внутренней номинально линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.

   RememberXvel(VxOldNonLin); // запоминание горизонтальной скорости
   deviation:=1e3; // некоторое большое число
   j:=1;


   while (( deviation > rcs.Vx ) and (j <= iterSimple.iterVxNonLin)) do
   begin
      // цикл преодоления нелинейности
      // шаг 1:
      // вычисление коэффициентов дискретного аналога
      // проход по всем внутренним точкам
      VxGlobalCoef(mglobal,dbglobal);

      // шаг 2:
      // решение по сути линейного уравнения
      // с полученными ранее коэффициентами
      if (itypesolver.ivelocity < 3) then
      begin
         for i:=1 to iterSimple.iterVxLin do
         begin
            case itypesolver.ivelocity of
            1 : // Гаусс-Зейдель
              begin
                 // одна итерация методом Гаусса-Зейделя
                 GZUniversal(Vx,inx-1,iny, mapVx, 'U',  mglobal,dbglobal);
              end;
            2 : // метод переменных направлений
              begin
                 // одна итерация методом переменных направлений
                 TDMAGibridGZUniversal(Vx,inx-1,iny, mapVx, 'U', mglobal, dbglobal);
              end;
            end; // case

         end; // i - решение линейной системы
      end
      else
      begin
         case itypesolver.ivelocity of
         3 : // алгоритм Ю.Г. Соловейчика [1993]
            begin
               // itypesolver.ivelocity = 3
               // с учётом конвективного члена, без печати диагностических сообщений,
               // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
               // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
               SoprGradCRSUniversal( Vx, inx-1, iny, mapVx, 'U', mglobal, true, false, iterSimple.iterVxLin, rcs.Vx*rcs.Vx, 1,dbglobal);
            end;
         4 : // прямой метод исключения Гаусса
            begin
               GaussUniversal(Vx, inx-1, iny, mapVx, 'U',  mglobal, dbglobal,false);
            end;
         end; // case
      end;

     j:=j+1; // переход к следующему циклу устранения нелинейности
     deviation:=mySupNorma2(Vx,VxOldNonLin,inx-1,iny);  // отклонение от предыдущей итерации
     RememberXvel(VxOldNonLin); // запоминание скорости
     //freport.Add(FloatToStr(deviation)); // для диагностики

   end; // нелинейность преодолена ?
   // смотри значение deviation

end; // SolveVx

// по значениям функции тока находит
// вертикальную скорость.
procedure TForm1.VyConstruct;
var
    i,j : Integer; // счётчики
    ipi, iei, iwi : Integer;
    VyT, VyB : Float; // значения вертикальной скорости сверху и снизу
begin
   for i:=1 to inx do
   begin
      for j:=1 to (iny-1) do
      begin
         if ((i>1) and (i<inx)) then
         begin
            iei:=(i+1)+(j-1)*inx;
            iwi:=(i-1)+(j-1)*inx;
            VyB:=(SF[iei]-SF[iwi])/(xpos[i+1]-xpos[i-1]);
            iei:=(i+1)+(j)*inx;
            iwi:=(i-1)+(j)*inx;
            VyT:=(SF[iei]-SF[iwi])/(xpos[i+1]-xpos[i-1]);
            ipi:=i+(j-1)*inx;
            Vy[ipi]:=-0.5*(VyB+VyT);
         end;
         if (i=1) then
         begin
            ipi:=i+(j-1)*inx;
            iei:=(i+1)+(j-1)*inx;
            VyB:=(SF[iei]-SF[ipi])/(xpos[i+1]-xpos[i]);
            ipi:=i+(j)*inx;
            iei:=(i+1)+(j)*inx;
            VyT:=(SF[iei]-SF[ipi])/(xpos[i+1]-xpos[i]);
            ipi:=i+(j-1)*inx;
            Vy[ipi]:=-0.5*(VyB+VyT);
         end;
         if (i=inx) then
         begin
            ipi:=i+(j-1)*inx;
            iwi:=(i-1)+(j-1)*inx;
            VyB:=(SF[ipi]-SF[iwi])/(xpos[i]-xpos[i-1]);
            ipi:=i+(j)*inx;
            iwi:=(i-1)+(j)*inx;
            VyT:=(SF[ipi]-SF[iwi])/(xpos[i]-xpos[i-1]);
            ipi:=i+(j-1)*inx;
            Vy[ipi]:=-0.5*(VyB+VyT);
         end;
      end;
   end;
end; // VyConstruct


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
procedure TForm1.Vycoef(i, j : Integer; var m : MatrixCoef);
var
    ini,isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed, jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfe, dfw, dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drn, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddw, ddn, dds :  Float;  // диффузионные члены
    dpe,dpw,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:= 2*density(jn)*density(jnr)/(density(jn)+density(jnr));
        drhoB:= 2*density(js)*density(jsr)/(density(js)+density(jsr));
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        dfe:=dre*(0.5*(Vx[jxed]+Vx[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        // здесь dikoef=0.5
        drhoA:= 2*density(jnl)*density(jn)/(density(jnl)+density(jn));
        drhoB:= 2*density(jsl)*density(js)/(density(jsl)+density(js));
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        dfw:=drw*(0.5*(Vx[jxwu]+Vx[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        dfn:=drn*(dikoef*Vy[ipi]+(1-dikoef)*Vy[ini])*(0.5*(xpos[i+1]-xpos[i-1])); // или
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        dfs:=drs*(dikoef*Vy[isi]+(1-dikoef)*Vy[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgn:=viscosity(jn);
        dgs:=viscosity(js);

        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i]);  // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1]);  // дискретного
        ddn:=dgn*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+2]-ypos[j]));  // аналога
        dds:=dgs*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+1]-ypos[j-1]));

        dpe:=dfe/dde; // значения
        dpw:=dfw/ddw; // чисел
        dpn:=dfn/ddn; // Пекле
        dps:=dfs/dds;
        m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
        m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          drhoA:= 2*density(jn)*density(js)/(density(jn)+density(js));
          dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
        end;

        m.dap:= m.dae + m.daw + m.dan + m.das + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // Vycoef


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// правая стенка.
procedure TForm1.VycoefRight(i, j : Integer; var m : MatrixCoef);
var
    ini,isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfw, dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    drw, drn, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    ddw, ddn, dds :  Float;  // диффузионные члены
    dpw,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
          // r - right правые узлы


        // номера узлов для горизонтальной компоненты скорости Vx
         // e - правый u - верхний
         // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        // интенсивность
        // здесь dikoef=0.5
        drhoA:= 2*density(jnl)*density(jn)/(density(jnl)+density(jn));
        drhoB:= 2*density(jsl)*density(js)/(density(jsl)+density(js));
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        dfw:=drw*(0.5*(Vx[jxwu]+Vx[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        dfn:=drn*(dikoef*Vy[ipi]+(1-dikoef)*Vy[ini])*(0.5*(xpos[i+1]-xpos[i-1])); // или
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        dfs:=drs*(dikoef*Vy[isi]+(1-dikoef)*Vy[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgn:=viscosity(jn);
        dgs:=viscosity(js);

        // Диффузия
          // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1]);  // дискретного
        ddn:=dgn*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+2]-ypos[j]));  // аналога
        dds:=dgs*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+1]-ypos[j-1]));

         // значения
        dpw:=dfw/ddw; // чисел
        dpn:=dfn/ddn; // Пекле
        dps:=dfs/dds;
        m.dae:=0.0; // коэффициенты
        m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          drhoA:= 2*density(jn)*density(js)/(density(jn)+density(js));
          dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
        end;

        m.dap:=  m.daw + m.dan + m.das + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // VycoefRight



// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// левая стенка
procedure TForm1.VycoefLeft(i, j : Integer; var m : MatrixCoef);
var
    ini,isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed  : Integer; // номера узлов для горизонтальной скорости Vx
    dfe,  dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge,  dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drn, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddn, dds :  Float;  // диффузионные члены
    dpe,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ

        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
         // w - левый, u - верхний
         // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:= 2*density(jn)*density(jnr)/(density(jn)+density(jnr));
        drhoB:= 2*density(js)*density(jsr)/(density(js)+density(jsr));
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        dfe:=dre*(0.5*(Vx[jxed]+Vx[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        // здесь dikoef=0.5
         // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        dfn:=drn*(dikoef*Vy[ipi]+(1-dikoef)*Vy[ini])*(0.5*(xpos[i+1]-xpos[i-1])); // или
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        dfs:=drs*(dikoef*Vy[isi]+(1-dikoef)*Vy[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);

        dgn:=viscosity(jn);
        dgs:=viscosity(js);


        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i]);  // коэффициенты
         // дискретного
        ddn:=dgn*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+2]-ypos[j]));  // аналога
        dds:=dgs*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+1]-ypos[j-1]));

        dpe:=dfe/dde; // значения
         // чисел
        dpn:=dfn/ddn; // Пекле
        dps:=dfs/dds;
        m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
        m.daw:=0.0;  // дискретного
        m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          drhoA:= 2*density(jn)*density(js)/(density(jn)+density(js));
          dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
        end;

        m.dap:= m.dae  + m.dan + m.das + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // VycoefLeft


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// нижняя граница
procedure TForm1.VycoefBottom(i, j : Integer; var m : MatrixCoef);
var
    ini,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed, jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfe, dfw, dfn :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw, dgn :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drn :  Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddw, ddn :  Float;  // диффузионные члены
    dpe,dpw,dpn :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:= 2*density(jn)*density(jnr)/(density(jn)+density(jnr));
        drhoB:= 2*density(js)*density(jsr)/(density(js)+density(jsr));
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        dfe:=dre*(0.5*(Vx[jxed]+Vx[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        // здесь dikoef=0.5
        drhoA:= 2*density(jnl)*density(jn)/(density(jnl)+density(jn));
        drhoB:= 2*density(jsl)*density(js)/(density(jsl)+density(js));
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        dfw:=drw*(0.5*(Vx[jxwu]+Vx[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        dfn:=drn*(dikoef*Vy[ipi]+(1-dikoef)*Vy[ini])*(0.5*(xpos[i+1]-xpos[i-1])); // или

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgn:=viscosity(jn);

        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i]);  // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1]);  // дискретного
        ddn:=dgn*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+2]-ypos[j]));  // аналога

        dpe:=dfe/dde; // значения
        dpw:=dfw/ddw; // чисел
        dpn:=dfn/ddn; // Пекле
        m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
        m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        m.das:=0.0;

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          drhoA:= 2*density(jn)*density(js)/(density(jn)+density(js));
          dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
        end
         else
        begin
           // стационарный
           dap0:=0.0;
        end;

        m.dap:= m.dae + m.daw + m.dan  + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // VycoefBottom


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// для выходной границы
procedure TForm1.VycoefTop(i, j : Integer; var m : MatrixCoef);
var
    isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed, jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfe, dfw,  dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw,  dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddw, dds :  Float;  // диффузионные члены
    dpe,dpw,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
          // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:= 2*density(jn)*density(jnr)/(density(jn)+density(jnr));
        drhoB:= 2*density(js)*density(jsr)/(density(js)+density(jsr));
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        dfe:=dre*(0.5*(Vx[jxed]+Vx[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        // здесь dikoef=0.5
        drhoA:= 2*density(jnl)*density(jn)/(density(jnl)+density(jn));
        drhoB:= 2*density(jsl)*density(js)/(density(jsl)+density(js));
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        dfw:=drw*(0.5*(Vx[jxwu]+Vx[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        // или
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        dfs:=drs*(dikoef*Vy[isi]+(1-dikoef)*Vy[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgs:=viscosity(js);


        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i]);  // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1]);  // дискретного
        // аналога
        dds:=dgs*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+1]-ypos[j-1]));

        dpe:=dfe/dde; // значения
        dpw:=dfw/ddw; // чисел
         // Пекле
        dps:=dfs/dds;
        m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
        m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        m.dan:=0.0; // аналога
        m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          drhoA:= 2*density(jn)*density(js)/(density(jn)+density(js));
          dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
        end;


        m.dap:= m.dae + m.daw  + m.das + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // VycoefTop


// коэффициенты дискретного аналога для
// вертикальной компоненты скорости
procedure TForm1.VyGlobalCoef(var mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
                              var dbglobal : array of  Float); // часть источникового члена
var
    m : MatrixCoef; // значение коэффициентов дискретного аналога на пятиточечном шаблоне
    ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    drhointerpol : Float; // для интерполяции плотности
    db :  Float;  // коэффициент
    dpressure :  Float; // действующий градиент давления
    i : Integer; // счётчики
    dap0 :  Float; // нестационарный коэффициент
    dgyeffective :  Float; // эффективное ускорение свободного падения (нужно для вибрационного воздействия).
    rBodyForceBussinesknew, rBodyForceBussineskold :  Float; // учёт приближения Буссинеска
    bout : Boolean; // условие на выходной границе


begin
   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
    for i:=1 to imaxnumbernodeVy do
    begin



        if (mapVy[i].itype=1) then
        begin
           // внутренний узел

          // значение полей m не инициализировано, но
          // по возвращении из процедуры Vycoef
          // соответствующие поля m будут соответствовать соответствующим коэффициентам
          // дискретного аналога для переменной Vy
          Vycoef(mapVy[i].i, mapVy[i].j, m);

           //  номера узлов для массива Vy
          ipi:=mapVy[i].i+(mapVy[i].j-1)*inx; // текущая точка


          // номера обычных узлов для переменных T и P
          // n - верх, s - низ
          jn:=mapVy[i].i+mapVy[i].j*inx; // для обычных переменных
          js:=mapVy[i].i+(mapVy[i].j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
          drhointerpol:= 2*density(jn)*density(js)/(density(jn)+density(js));

          db:=dScVy*(0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]))*(ypos[mapVy[i].j+1]-ypos[mapVy[i].j]); // постоянная составляющая источникового члена
          if (btimedepend) then
          begin
             // нестационарный  вклад
             // с постоянным шагом по времени
             dap0:=drhointerpol*(0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]))*(ypos[mapVy[i].j+1]-ypos[mapVy[i].j])/dTimeStep;
             db:=db + dap0*VyOldTimeStep[ipi]; // вклад нестационарного члена если требуется.
          end;

          dgyeffective:=dgy; // ускорение свободного падения

          // В случае силы тяжести меняющейся по гармоническому закону:
          if ((btimedepend) and (rgravVib.bOn)) then
          begin
             // Только в том случае если процесс нестационарный и
             // сила тяжести меняется по гармоническому закону.

             dgyeffective:= dgyeffective + GetRealGravity('y');
          end;

          // учёт приближения Буссинеска
          // температура аппроксимирована как среднее арефметическое
          if (bBussinesk) then
          begin
             // Здесь записывается источниковый вклад в модели Буссинеска,
             // где плотность линейно зависит от температуры. Подробнее можно
             // посмотреть у Г.З. Гершини и Е.М. Жуховицкого.

             // в некоторых случаях, например при больших значениях,
             // чисел Рэлея, имеет смысл замедлить изменение источникового члена от итерации к итерации.
             rBodyForceBussinesknew:= - drhointerpol*dbeta*dgyeffective*0.5*(T[js]+T[jn]);
             rBodyForceBussineskold:= - drhointerpol*dbeta*dgyeffective*0.5*(TOldIteration[js]+TOldIteration[jn]);
             db:= db + (myrelaxfactors.prelaxBodyForce*rBodyForceBussinesknew + (1-myrelaxfactors.prelaxBodyForce)*rBodyForceBussineskold)*(0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]))*(ypos[mapVy[i].j+1]-ypos[mapVy[i].j]);
          end
           else
          begin
             // Здесь просто учитывается сила тяжести.
             // К приближению Буссинеска это не имеет отношения.
             // См. ГИДРОДИНАМИКА Л.Д. Ландау и Е.М. Лифшица стр. 16.

             db:= db +  drhointerpol*dgyeffective;
          end;

          dpressure:=(P[js]-P[jn])*0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]); // сила давления действующая на контрольный объём

          mglobal[ipi].dae:=m.dae;  // коэффициенты
          mglobal[ipi].daw:=m.daw;  // дискретного
          mglobal[ipi].dan:=m.dan;  // аналога
          mglobal[ipi].das:=m.das;
          mglobal[ipi].dap:=m.dap/myrelaxfactors.yVelRelax;

          dbglobal[ipi]:= db + dpressure + ((1-myrelaxfactors.yVelRelax)*m.dap*VyOld[ipi])/myrelaxfactors.yVelRelax;  // вклад источникового члена
       end;


       if (mapVy[i].itype=2) then
        begin
           // граничный узел
           //  номера узлов для массива Vy
           ipi:=mapVy[i].i+(mapVy[i].j-1)*inx; // текущая точка
           // нужно проверить принадлежит ли
           // этот узел выходной зоне потока из расчётной области

           if (mapVy[i].iugol = 0) then
           begin
              bout:=GridGenForm.isoutflow(mapVy[i].iboundary, 'V',mapVy[i].chnormal);
              if (bout) then
               begin

                 // точка не является угловой.
                 // это выходная граница расчётной области
                 case (mapVy[i].chnormal) of
                 'N' :  // выходная граница находится снизу
                     begin
                        VycoefBottom(mapVy[i].i, mapVy[i].j, mglobal[ipi]);
                     end;
                 'S' : // выходная граница находится сверху
                     begin
                        VycoefTop(mapVy[i].i, mapVy[i].j, mglobal[ipi]);
                     end;
                 'E' : // выходная граница находится слева
                      begin
                         VycoefLeft(mapVy[i].i, mapVy[i].j, mglobal[ipi]);
                      end;
                 'W' : // выходная граница находится справа
                       begin
                          VycoefRight(mapVy[i].i, mapVy[i].j, mglobal[ipi]);
                       end;
                 end; // case

                   mglobal[ipi].dap:= mglobal[ipi].dap/myrelaxfactors.yVelRelax;
                 // номера обычных узлов для переменных T и P
                 // n - верх, s - низ
                 jn:=mapVy[i].i+mapVy[i].j*inx; // для обычных переменных
                 js:=mapVy[i].i+(mapVy[i].j-1)*inx;
                 dpressure:=(P[js]-P[jn])*0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]);
                 dbglobal[ipi]:= dpressure + ((1-myrelaxfactors.yVelRelax)*m.dap*VyOld[ipi])/myrelaxfactors.yVelRelax;
                end;
            end
             else
              begin
                 dbglobal[ipi]:=0.0; // нет источникового члена
                 // здесь всё будет построено на среднем арефметическом
                 case mapVy[i].iugol of
                 1 : // левый нижний угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.5;
                        mglobal[ipi].dan:=0.5;
                        mglobal[ipi].das:=0.0;
                        mglobal[ipi].daw:=0.0;
                     end;
                 2 : // правый нижний угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.0;
                        mglobal[ipi].dan:=0.5;
                        mglobal[ipi].das:=0.0;
                        mglobal[ipi].daw:=0.5;
                     end;
                 3 : // верхний левый угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.5;
                        mglobal[ipi].dan:=0.0;
                        mglobal[ipi].das:=0.5;
                        mglobal[ipi].daw:=0.0;
                     end;
                  4 : // верхний правй угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.0;
                        mglobal[ipi].dan:=0.0;
                        mglobal[ipi].das:=0.5;
                        mglobal[ipi].daw:=0.5;
                     end;
                  5 : // пятиточечная звезда
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.25;
                        mglobal[ipi].dan:=0.25;
                        mglobal[ipi].das:=0.25;
                        mglobal[ipi].daw:=0.25;
                     end;
                  end; //case

              end;
          end;
       end;
end;  // VyGlobalCoef

// решение нелинейного уравнения для вертикальной скорости
// методом переменных направлений.
// в стационарном случае
procedure TForm1.SolveVy;
var
    mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
    dbglobal : array of  Float; // часть источникового члена
    i, j : Integer; // счётчики: внутренний и для преодоления нелинейности
    // данные переменные позволяют судить о нахождении решения
    // нелинейного уравнения для верикальной компоненты скорости
    VyOldNonLin : array of  Float; // поле скорости с предыдущей итерации по устранению нелинейности
    deviation :  Float; // отклонение от скорости на предыдущей итерации по устранению нелинейности

begin
   // выделение оперативной памяти
   SetLength(mglobal,inx*(iny-1)+1); // основные коэффициенты дискретного аналога
   SetLength(dbglobal,inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(VyOldNonLin,inx*(iny-1)+1); // выделение памяти под скорость с предыдущей итерации
   // iterSimple.iterVyLin - число итераций необходимое для решения линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.
   // iterSimple.iterVyNonLin - количество циклов преодоления нелинейности

   RememberYvel(VyOldNonLin); // запоминание скорости
   deviation:=1e300; // некоторое большое число
   j:=1;

   while (( deviation > rcs.Vy ) and (j <= iterSimple.iterVyNonLin)) do
   begin
     // цикл преодоления нелинейности
     // шаг 1:
     // вычисление коэффициентов дискретного аналога
     // проход по всем внутренним точкам
     VyGlobalCoef(mglobal,dbglobal);
     // шаг 2:
     // решение по сути линейного уравнения
     // с полученными ранее коэффициентами
     if (itypesolver.ivelocity < 3) then
     begin
        for i:=1 to iterSimple.iterVyLin do
        begin
           case itypesolver.ivelocity of
             1 : // ГЗ
                begin
                   // одна итерация методом Гаусса-Зейделя
                   GZUniversal(Vy,inx,iny-1, mapVy, 'V',  mglobal,dbglobal);
                end;
             2 : // метод переменных направлений
                begin
                   // одна итерация методом переменных направлений
                   TDMAGibridGZUniversal(Vy,inx,iny-1, mapVy, 'V', mglobal, dbglobal);
                end;
           end; // case

        end; // i - конец решения линейной системы
     end
      else
     begin
        case itypesolver.ivelocity of
           3 : // алгоритм Ю.Г. Соловейчика [1993]
           begin
              // itypesolver.ivelocity = 3
              // с учётом конвективного члена, без печати диагностических сообщений,
              // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
              // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
              SoprGradCRSUniversal( Vy, inx, iny-1, mapVy, 'V', mglobal, true, false, iterSimple.iterVyLin, rcs.Vy*rcs.Vy, 1, dbglobal);
           end;
           4 : // прямой метод исключения Гаусса
           begin
              GaussUniversal(Vy,inx,iny-1, mapVy, 'V',  mglobal,dbglobal,false);
           end;
         end; // case
     end;

     j:=j+1; // переход к следующему циклу устранения нелинейности
     deviation:=mySupNorma2(Vy,VyOldNonLin,inx,iny-1);  // отклонение от предыдущей итерации
     RememberYvel(VyOldNonLin); // запоминание скорости
     //freport.Add(FloatToStr(deviation)); // для диагностики

   end; // нелинейность преодолена ?
   // смотри значение deviation

end; // solveVy

// совместное решение уравнений для горизонтальной
// и вертикальной компонент скорости
// по-моему это несколько улучшит скорость сходимости
// нелинейных уравнений для компонент скорости
procedure TForm1.SolveVxVyCoupled;
var
    mVxGlobal : array of MatrixCoef; // все коэффициенты дискретного аналога для Vx
    dbVxGlobal : array of  Float; // часть источникового члена  для Vx
    mVyGlobal : array of MatrixCoef; // все коэффициенты дискретного аналога  для Vy
    dbVyGlobal : array of  Float; // часть источникового члена  для Vy
    i, j : Integer; // счётчики внутренний и преодоления нелинейности
    // данные переменные позволяют судить о нахождении решения
    // нелинейного уравнения для верикальной компоненты скорости
    VxOldNonLin : array of  Float; // поле скорости Vx с предыдущей итерации по устранению нелинейности
    VyOldNonLin : array of  Float; // поле скорости Vy с предыдущей итерации по устранению нелинейности
    deviationVx, deviationVy :  Float;  // отклонение по каждой из компонент скорости
    deviation :  Float; // отклонение от скорости на предыдущей итерации по устранению нелинейности

begin
   // выделение оперативной памяти
   SetLength(mVxGlobal,(inx-1)*iny+1); // основные коэффициенты дискретного аналога
   SetLength(dbVxGlobal,(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(VxOldNonLin,(inx-1)*iny+1); // выделение памяти под скорость с предыдущей итерации
   // iterSimple.iterVxLin - количество итераций для решения внутренней номинально линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.
   SetLength(mVyGlobal,inx*(iny-1)+1); // основные коэффициенты дискретного аналога
   SetLength(dbVyGlobal,inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(VyOldNonLin,inx*(iny-1)+1); // выделение памяти под скорость с предыдущей итерации
   // iterSimple.iterVyLin - число итераций необходимое для решения линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.
   // iterSimple.iterVyNonLin - количество циклов преодоления нелинейности

   RememberXvel(VxOldNonLin); // запоминание горизонтальной скорости
   RememberYvel(VyOldNonLin); // запоминание вертикальной скорости
   deviation:=1e3; // некоторое большое число
   j:=1;


   while (( deviation > min(rcs.Vx, rcs.Vy)) and (j <= max(iterSimple.iterVxNonLin,iterSimple.iterVyNonLin))) do
   begin
      // цикл преодоления нелинейности
      // шаг 1:
      // вычисление коэффициентов дискретного аналога
      // для горизонтальной компоненты скорости.
      // проход по всем внутренним точкам
      VxGlobalCoef(mVxGlobal,dbVxGlobal);

      // шаг 2:
      // решение по сути линейного уравнения
      // с полученными ранее коэффициентами
      if (itypesolver.ivelocity < 3) then
      begin
         for i:=1 to iterSimple.iterVxLin do
         begin
            case itypesolver.ivelocity of
             1 : // Гаусс-Зейдель
                begin
                   // одна итерация методом Гаусса-Зейделя
                   GZUniversal(Vx,inx-1,iny, mapVx, 'U', mVxGlobal,dbVxGlobal);
                end;
             2 : // метод переменных направлений
                begin
                   // одна итерация методом переменных направлений
                   TDMAGibridGZUniversal(Vx,inx-1,iny, mapVx, 'U', mVxGlobal,dbVxGlobal);
                end;
            end; // case

         end; // i - решение линейной системы
      end
       else
      begin
        case itypesolver.ivelocity of
           3 : // алгоритм Ю.Г. Соловейчика [1993]
           begin
              // itypesolver.ivelocity = 3
              // с учётом конвективного члена, без печати диагностических сообщений,
              // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
              SoprGradCRSUniversal( Vx, inx-1, iny, mapVx, 'U', mVxGlobal, true, false, iterSimple.iterVxLin, rcs.Vx, 1,dbVxGlobal);
            end;
           4 : // прямой метод исключения Гаусса
           begin
              GaussUniversal(Vx, inx-1, iny, mapVx, 'U',  mVxGlobal, dbVxGlobal,false);
           end;
        end; // case
      end;

      // шаг 3:
      // вычисление коэффициентов дискретного аналога
      // для вертикальной компоненты скорости Vy.
      // проход по всем внутренним точкам
      VyGlobalCoef(mVyGlobal,dbVyGlobal);

      // шаг 4:
      // решение по сути линейного уравнения
      // с полученными ранее коэффициентами
      if (itypesolver.ivelocity < 3) then
      begin
         for i:=1 to iterSimple.iterVyLin do
         begin
            case itypesolver.ivelocity of
              1 : // ГЗ
                 begin
                    // одна итерация методом Гаусса-Зейделя
                    GZUniversal(Vy,inx,iny-1, mapVy, 'V', mVyGlobal,dbVyGlobal);
                 end;
              2 : // метод переменных направлений
                 begin
                    // одна итерация методом переменных направлений
                    TDMAGibridGZUniversal(Vy,inx,iny-1, mapVy, 'V', mVyGlobal,dbVyGlobal);
                 end;
            end; // case

         end; // i - конец решения линейной системы
      end
       else
      begin
         case itypesolver.ivelocity of
           3 : // алгоритм Ю.Г. Соловейчика [1993]
           begin
              // itypesolver.ivelocity = 3
              // с учётом конвективного члена, без печати диагностических сообщений,
              // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
              SoprGradCRSUniversal( Vy, inx, iny-1, mapVy, 'V', mVyGlobal, true, false, iterSimple.iterVyLin, rcs.Vy, 1, dbVyGlobal);
           end;
           4 : // прямой метод исключения Гаусса
           begin
              GaussUniversal(Vy,inx,iny-1, mapVy, 'V',  mVyGlobal ,dbVyGlobal,false);
           end;
         end;//case
      end;


     j:=j+1; // переход к следующему циклу устранения нелинейности
     deviationVx:=mySupNorma2(Vx,VxOldNonLin,inx-1,iny);  // отклонение от предыдущей итерации
     RememberXvel(VxOldNonLin); // запоминание скорости
     deviationVy:=mySupNorma2(Vy,VyOldNonLin,inx,iny-1);  // отклонение от предыдущей итерации
     RememberYvel(VyOldNonLin); // запоминание скорости
     deviation:=max(deviationVx,deviationVy);
     //freport.Add(FloatToStr(deviation)); // для диагностики

   end; // нелинейность преодолена ?
   // смотри значение deviation


end; // SolveVxVyCoupled

// преобразованные коэффициенты дискретного аналога
// компонент скорости (см. idirect : 1 - x, 2 - y)
// которые используются в уравнении для поправки давления.
function TForm1.Vcoefpam(i : Integer; j : Integer; idirect : Integer) :  Float;
var
   m : MatrixCoef; // для компонент скорости
   dapvel :  Float; // возвращаемое значение

begin
   case idirect of
     1 : Vxcoef(i,j,m); // m.dap=ae
     2 : Vycoef(i,j,m); // m.dap=an
   end;
   if (bsimplec) then
   begin
      // алгоритм SIMPLEC
      // здесь может быть деление на ноль в будущем,
      // его нужно избежать:
      dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
      // Ниже константа 1e-7 выбрана импирически чтобы избежать деления на ноль.
      // В принципе её значение спорно и может быть несколько другим.
      // Для задачи с изотермической каверной это работает.
      if (abs(dapvel) < 1e-7) then dapvel:=m.dap; // то-же значение что и в алгоритме SIMPLE.
   end
    else
   begin
      // алгоритм SIMPLE
      dapvel:=m.dap;
   end;

   Result:=dapvel;
end; // Vcoefpam


// находится на стадии тестирования
// По всей видимости использование сверхрелаксации с параметром 1.9
// или какой-либо другой сверх релаксации здесь себя не оправдывает т.к.
// наблюдается остановка процесса сходимости в то время как она ещё не достигнута.
// Например, если не использовать сверхрелаксацию то процесс сходимости
// застрянет на значении 1e-5 в то время как если не использовать сверхрелаксацию
// вовсе, а использовать чистого Гаусса-Зейделя то невязки уменьшаются до значений 1e-10.
// Перед решением уравнения для поправки давления поле поправки давления
// надо инициализировать нулевым значением.
// решает линейное уравнение для поправки давления
// ускоренным методом Гаусса-Зейделя
// ускорение достигается за счёт того, что коэффициенты
// дискретного аналога не зависят от искомой функции
// т.е. уравнение линейно и эти коэффициенты можно
// вычислить только один раз и запомнить.
procedure TForm1.SolveGZPamendment(bipifix : Boolean; // фиксировать ли уровень поправки давления  ?
                                   var rescontinity :  Float); // нескомпенсированные источники массы
const bmax0 = false; // ограничение для давления снизу
var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для поправки давления
   db : array of  Float; // коэффициенты источникового члена
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i1,j1,k,k1 : Integer;
   myrP : array of  Float; // невязка для поправки давления
   // следующая переменная используется для сверхрелаксации
   Ptilda :  Float; // новое приближение i-ой компоненты поправки давления
   deviation :  Float; // критерий выхода из цикла
   dapvel, rhointerpol :  Float;
   bnei, bvisit : Boolean;

begin
   // если передаваемый параметр bipifix = true, то нужно фиксировать уровень поправки давления
   // на нулевом уровне, иначе bipifix = false поправка давления будет сама искать свой уровень.
   // Когда поправка давления сама ищет свой уровень, то это может означать более быструю сходимость,
   // т.к. отсутствует точка ipifix в центре расчётной области которая всё портит.
   // Однако для прямого методаисключения Гаусса фиксировать точку ipifix обязательно.

   // выделение памяти
   SetLength(mp,inx*iny+1); // массив коэффициентов
   SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
   SetLength(myrP,inx*iny+1); // выделение памяти под невязку
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
   while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя

   for i1:=2 to inx-1 do
   begin
      for j1:=2 to iny-1 do
      begin
         // инициализация значений переменных
         ipi:=i1+(j1-1)*inx;  // текущая точка
         // нулевыми значениями
         db[ipi]:=0.0;
         mp[ipi].dae:=0.0;
         mp[ipi].daw:=0.0;
         mp[ipi].dan:=0.0;
         mp[ipi].das:=0.0;
         mp[ipi].dap:=1.0; // т.к. на эту точку возможно деление
         myrP[ipi]:=0.0; // обнуление невязки
      end;
   end;


   // вычисление коэффициентов
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел

            bvisit:=false; // если true то поправка равна нулю

            // координаты узлов для поправки давления
            // используется обыкновенная сетка
            ipi:=i+(j-1)*inx;  // текущая точка
            iei:=(i+1)+(j-1)*inx; // восток
            iwi:=(i-1)+(j-1)*inx; // запад
            ini:=i+(j)*inx; // север
            isi:=i+(j-2)*inx; // юг
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для поправки давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
            // требуется покрайней мере в четыре раза больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.
            // Здесь граничные коэффициенты дискретного аналога обнуляюся
            // и физически это означает, что граничные значения не влияют
            // на поле давления внутри расчётной области.
            // По этому поводу см. Патанкар ст. 108, 109.


            // в линейной струкруре карты mapPT
            // ориентация по сторонам света
            // юг, север, восток и запад происходит
            // всё по тем же правилам
            rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
            if (mapPT[iei].itype <> 2) then
            begin
               // если северная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               mp[ipi].dae:=rhointerpol*dy*dy/dapvel;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[iei].iboundary, 'P',mapPT[iei].chnormal);
               if (not(bnei)) then
               begin
                  // поправка равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dae:=0; // нет влияния от давления на границе
               end;
           end;

           rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
           if (mapPT[iwi].itype <> 2) then
           begin
              // если южная точка не является граничной
              dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
              mp[ipi].daw:=rhointerpol*dy*dy/dapvel;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[iwi].iboundary, 'P',mapPT[iwi].chnormal);
              if (not(bnei)) then
              begin
                 // поправка равна нулю
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].daw:=0; // нет влияния от давления на границе
              end;
           end;

           rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
           if (mapPT[ini].itype <> 2) then
           begin
              // если северная точка не является граничной
              dapvel:=Vcoefpam(i,j,2); // Vycoef
              mp[ipi].dan:=rhointerpol*dx*dx/dapvel;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[ini].iboundary, 'P', mapPT[ini].chnormal);
              if (not(bnei)) then
              begin
                 // поправка равна нулю
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].dan:=0; // нет влияния граничных условий
              end;
            end;

            rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
            if (mapPT[isi].itype <> 2) then
            begin
               // если южная точка не является граничной
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               mp[ipi].das:=rhointerpol*dx*dx/dapvel;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[isi].iboundary, 'P',mapPT[isi].chnormal);
               if (not(bnei)) then
               begin
                  // поправка равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].das:=0; // нет влияния граничных значений
               end;
            end;

            if (bvisit) then
            begin
               // поправка равна нулю
               mp[ipi].dap:=1.0;
               db[ipi]:=0.0;
               mp[ipi].dae:=0.0;
               mp[ipi].daw:=0.0;
               mp[ipi].dan:=0.0;
               mp[ipi].das:=0.0;
            end
             else
            begin
               mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
               db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
               rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
               db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
               rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
               db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
               rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
               db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
               rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
               db[ipi]:=db[ipi] - rhointerpol*Vy[incvi]*dx;

            end;
         end;
      end; // with
   end;

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity:
   case ibasenorma of
      1 : // евклидова норма
        begin
           rescontinity:=myEvklidNorma(db,inx,iny); // невязка continity
        end;
      2 : // кубическая
        begin
           rescontinity:=mySupNorma(db,inx,iny); // невязка continity
        end;
      3 : // октаэдрическая
        begin
           rescontinity:=mySup2Norma(db,inx,iny); // невязка continity
        end;
   end;


   // теперь когда все коэффициенты вычислены
   // можно приступить к решению.
   deviation:=1e300; // очень большое число
   k:=1;


   while ((deviation > rcs.Pamendment) and (k<=iterSimple.iterPamendment)) do
   begin
      // как быть с граничными условиями для поправки давления ?
      for k1:=1 to imaxnumbernode do
      begin
         with mapPT[k1] do
         begin
            if (itype = 1) then
            begin
               // внутренний узел

               // координаты узлов для поправки давления
               // используется обыкновенная сетка
               ini:=i+j*inx; // север
               isi:=i+(j-2)*inx; // юг
               iwi:=(i-1)+(j-1)*inx; // запад
               iei:=(i+1)+(j-1)*inx; // восток
               ipi:=i+(j-1)*inx;  // текущая точка
               // здесь может быть деление на ноль, его надо исключить
               if (abs(mp[ipi].dap) > 1e-300) then
               begin
                  // здесь гарантировно нет деления на ноль
                  if ((bipifix) and (ipi=ipifix)) then
                  begin
                     Pamendment[ipifix]:=0.0; // фиксируем уровень
                  end
                   else
                  begin
                     // Сверхрелаксация с коэффициентом 1.9 убрана, т.к.
                     // по-моему, препятствует сходимости вычислительного
                     // процесса: невязки уменьшаются до определённого значения,
                     // скажем 1e-5 и дальше не падают.
                     // Если убрать какую-бы то ни было релаксацию и оставить
                     // чистого Гаусса-Зейделя то сходимость гарантирована.
                     // Здесь оставлен чистый Гаусс-Зейдель (соответствует значению 1.0).
                     Ptilda:=(mp[ipi].dae*Pamendment[iei]+mp[ipi].daw*Pamendment[iwi]+mp[ipi].dan*Pamendment[ini]+mp[ipi].das*Pamendment[isi]+db[ipi])/mp[ipi].dap;
                     // исходя из физического смысла задачи давление ограничено снизу значением 0.
                     if (bmax0) then
                     begin
                        Pamendment[ipi]:=max(0,Pamendment[ipi]+myrelaxfactors.pSORPressure*(Ptilda-Pamendment[ipi]));
                     end
                      else
                     begin
                        Pamendment[ipi]:=Pamendment[ipi]+myrelaxfactors.pSORPressure*(Ptilda-Pamendment[ipi]);
                     end;
                  end;
               end;
            end; // проход по
         end; // with
      end; // внутренним точкам

      // для существенного ускорения
      // времени счёта невязка будет вычисляться
      // каждую 0.5*(inx+iny) итерацию солвера Гаусса и Зейделя.
      // Время вычисления невязки равно времени одной итерации Г-З
      if (((2*k) mod (inx+iny)) = 0) then
      begin
         // отслеживаем невязку Pamendment
         for k1:=1 to imaxnumbernode do
         begin
            with (mapPT[k1]) do
            begin
               if (itype = 1) then
               begin
                  // внутренний узел

                  // используется обыкновенная сетка
                  ipi:=i+(j-1)*inx;  // текущая точка
                  if ((bipifix) and (ipi = ipifix)) then
                  begin
                     myrP[ipifix]:=0.0; // одно уравнение выполняется точно
                  end
                   else
                  begin
                     ini:=i+j*inx; // север
                     isi:=i+(j-2)*inx; // юг
                     iwi:=(i-1)+(j-1)*inx; // запад
                     iei:=(i+1)+(j-1)*inx; // восток
                     myrP[ipi]:=mp[ipi].dae*Pamendment[iei];
                     myrP[ipi]:=myrP[ipi]+mp[ipi].daw*Pamendment[iwi];
                     myrP[ipi]:=myrP[ipi]+mp[ipi].dan*Pamendment[ini];
                     myrP[ipi]:=myrP[ipi]+mp[ipi].das*Pamendment[isi];
                     myrP[ipi]:=myrP[ipi]+db[ipi]-mp[ipi].dap*Pamendment[ipi];
                  end;
               end;
            end; // with
         end;


         // проверка того насколько точно выполняется
         // дискретный аналог
         case ibasenorma of
           1 : // евклидова норма
             begin
                // насколько точно выполняется дискретный аналог
                deviation:=myEvklidNorma(myrP,inx,iny);
             end;
           2 : // кубическая
             begin
                // насколько точно выполняется дискретный аналог
                deviation:=mySupNorma(myrP,inx,iny);
             end;
           3 : // октаэдрическая
             begin
                // насколько точно выполняется дискретный аналог
                deviation:=mySup2Norma(myrP,inx,iny);
             end;
         end;

         //freport.Add(FloatToStr(deviation));
      end;

      k:=k+1; // переход к следующей итерации
   end; // k

end; // SolveGZPamendment

// нескомпенсированные источники массы
procedure TForm1.PamendmentCoef(var rescontinity :  Float;
            var mp : array of MatrixCoef; // коэффициенты дискретного аналога
            var db : array of  Float); // коэффициенты источникового члена
const
    epsilon = 1e-20;
var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   m : MatrixCoef; // используется для вычисления в компонентах скорости
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i1,j1,k,k1 : Integer;
   // следующая переменная используется для сверхрелаксации
   Ptilda :  Float; // новое приближение i-ой компоненты поправки давления
   deviation :  Float; // критерий выхода из цикла
   dapvel, rhointerpol :  Float;
   bnei: Boolean;

begin
   // если передаваемый параметр bipifix = true, то нужно фиксировать уровень поправки давления
   // на нулевом уровне, иначе bipifix = false поправка давления будет сама искать свой уровень.
   // Когда поправка давления сама ищет свой уровень, то это может означать более быструю сходимость,
   // т.к. отсутствует точка ipifix в центре расчётной области которая всё портит.
   // Однако для прямого методаисключения Гаусса фиксировать точку ipifix обязательно.


   // Инициализация обязательно важна
   for i1:=1 to inx do
   begin
      for j1:=1 to iny do
      begin
         // инициализация значений переменных
         ipi:=i1+(j1-1)*inx;  // текущая точка
         // нулевыми значениями
         db[ipi]:=0.0;
         mp[ipi].dae:=0.0;
         mp[ipi].daw:=0.0;
         mp[ipi].dan:=0.0;
         mp[ipi].das:=0.0;
         mp[ipi].dap:=1.0; // т.к. на эту точку возможно деление
      end;
   end;


   // вычисление коэффициентов
   for i1:=1 to imaxnumbernode do
   begin
      with mapPT[i1] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел

            // координаты узлов для поправки давления
            // используется обыкновенная сетка
            ipi:=i+(j-1)*inx;  // текущая точка
            iei:=(i+1)+(j-1)*inx; // восток
            iwi:=(i-1)+(j-1)*inx; // запад
            ini:=i+(j)*inx; // север
            isi:=i+(j-2)*inx; // юг
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для поправки давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты
            //  дискретного аналога) требуется покрайней мере в четыре раза
            // больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.
            // Здесь граничные коэффициенты дискретного аналога обнуляюся
            // и физически это означает, что граничные значения не влияют
            // на поле давления внутри расчётной области.
            // По этому поводу см. Патанкар ст. 108, 109.

            rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
            if (mapPT[iei].itype <> 2) then
            begin
               // если восточная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dae:=rhointerpol*dy*dy/dapvel;
            end
             else
            begin
               // есть влияние с востока
               // восточная точка  является граничной
               VxcoefRight(i,j,m);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
               // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dae:=rhointerpol*dy*dy/dapvel;

                //mp[ipi].dae:=0.0; // нет влияния с востока
            end;

            rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
            if (mapPT[iwi].itype <> 2) then
            begin
               // если западная точка не является граничной
               dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].daw:=rhointerpol*dy*dy/dapvel;
            end
             else
            begin

               // западная точка является граничной
               VxcoefLeft(i,j,m);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
                // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].daw:=rhointerpol*dy*dy/dapvel;

               //mp[ipi].daw:=0.0;  // нет влияния с запада
            end;

            rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
            if (mapPT[ini].itype <> 2) then
            begin
               // если северная точка не является граничной
               dapvel:=Vcoefpam(i,j,2); // Vycoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dan:=rhointerpol*dx*dx/dapvel;
            end
             else
            begin

               // северная точка является граничной
               VycoefTop(i,j,m);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
               // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dan:=rhointerpol*dx*dx/dapvel;

                //mp[ipi].dan:=0.0; // нет влияния с севера
            end;

            rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
            if (mapPT[isi].itype <> 2) then
            begin
               // если южная точка не является граничной
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].das:=rhointerpol*dx*dx/dapvel;
            end
             else
            begin

               // южная точка является граничной
               // есть влияние от южной точки
               VycoefBottom(i,j,m);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
               // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].das:=rhointerpol*dx*dx/dapvel;

                //mp[ipi].das:=0.0; // нет влияния с юга
            end;

            // см Патанкар стр. 104.
            mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;

            db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
            rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
            db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
            rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
            db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
            rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
            db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
            rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
            db[ipi]:=db[ipi] - rhointerpol*Vy[incvi]*dx;

         end; // внутренний узел


         if (itype = 2) then
         begin
            // граничная точка

            ipi:=i+(j-1)*inx;  // текущая точка
            iei:=(i+1)+(j-1)*inx; // восток
            iwi:=(i-1)+(j-1)*inx; // запад
            ini:=i+(j)*inx; // север
            isi:=i+(j-2)*inx; // юг

            // граничный узел
            if (iugol=0) then
            begin
               // если граница выходная из расчётной области,
               // то возвращает false.
               // если на границе задано давление то возвращает false.
               // в любых других случаях возвращает true.

               bnei:=GridGenForm.isneiman(iboundary ,'P',chnormal);
               // граничная точка не являющаяся угловой
               case chnormal of
                'N' : // север
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].dan:=1;
                         iecvi:=i+(j-1)*(inx-1); // в массиве Vx
                         iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
                         db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
                         db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
                         rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
                         db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
                         mp[ipi].dap:=mp[ipi].dan;

                      end
                       else
                      begin
                         // нулевое значение поправки заданное давление на границе
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
                'S' : // юг
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].das:=1;
                         iecvi:=i+(j-1)*(inx-1); // в массиве Vx
                         iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
                         db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
                         db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
                         rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
                         db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
                         mp[ipi].dap:=mp[ipi].das;
                      end
                       else
                      begin
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
                'W' : // запад  (правая стенка)
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].daw:=1;
                         incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
                         iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
                         db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
                         db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
                         rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
                         db[ipi]:= db[ipi] - rhointerpol*Vy[incvi]*dx;
                         mp[ipi].dap:=mp[ipi].daw;
                      end
                       else
                      begin
                         // заданное давление на границе
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
                'E' : // восток
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].dae:=1;
                         incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
                         iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
                         db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
                         db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
                         rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
                         db[ipi]:= db[ipi] - rhointerpol*Vy[incvi]*dx;
                         mp[ipi].dap:=mp[ipi].dae;
                      end
                       else
                      begin
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
               end; // case
            end
             else
            begin
               // угловая точка основано на среднем арефметическом
               case iugol of
                1 :  // левый нижний угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].dae:=0.5;
                     mp[ipi].dan:=0.5;
                     db[ipi]:= 0.0;
                  end;
                2 : // правый нижний угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].daw:=0.5;
                     mp[ipi].dan:=0.5;
                     db[ipi]:= 0.0;
                  end;
                3 : // верхний левый угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].dae:=0.5;
                     mp[ipi].das:=0.5;
                     db[ipi]:= 0.0;
                  end;
                4 : // верхний правый угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].daw:=0.5;
                     mp[ipi].das:=0.5;
                     db[ipi]:= 0.0;
                  end;
                5 : // пятиточечная звезда
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].dan:=0.25;
                     mp[ipi].das:=0.25;
                     mp[ipi].daw:=0.25;
                     mp[ipi].dae:=0.25;
                     db[ipi]:= 0.0;
                  end;
               end; // case
           end; // угловая точка
        end; // граничная точка
      end; // with
   end;  // конец цикла по всем точкам

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity:
   case ibasenorma of
      1 : // евклидова норма
        begin
           rescontinity:=myEvklidNorma(db,inx,iny); // невязка continity
        end;
      2 : // кубическая
        begin
           rescontinity:=mySupNorma(db,inx,iny); // невязка continity
        end;
      3 : // октаэдрическая
        begin
           rescontinity:=mySup2Norma(db,inx,iny); // невязка continity
        end;
   end;


end; // PamendmentCoef

// находится на стадии тестирования
// Операции по определению поля давления самые ресурсоёмкие.
// Перед решением уравнения для поправки давления поле поправки давления
// надо инициализировать нулевым значением.
// решает линейное уравнение для поправки давления
//  методом сопряжённых градиентов Хестенса и Штифмена.
// Здесь формируется матрица СЛАУ которая затем передаётся
// уточняющему солверу SoprGrad.
// этот метод неэффективен по памяти т.к. здесь очень много памяти
// уходит на большую матрицу СЛАУ.
procedure TForm1.SolveUniversalPamendment(bGaussTransform : Boolean;
                                          bHestensenShtifiel : Boolean;
                                          var rescontinity :  Float);
// bGaussTransform - нужно ли использовать Трансформацию Гаусса: true - ДА, false - НЕТ.
// bHestensenShtifiel - нужно ли использовать метод сопряжённых Градиентов,
// альтернативой которому служит прямой метод исключения Гаусса.
// rescontinity - показатель сходимости всей системы уравнений Навье-Стокса,
// нескомпенсированные источники массы которые должны быть скомпенсированы.

var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для поправки давления
   db : array of Float; // коэффициенты источникового члена
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i1,j1,k1 : Integer; // Счётчики цикла for
   dapvel :  Float; // коэффициент дискретного аналога в уравнениях для импульса
   dA  : array of TmyDynArray; // матрица СЛАУ
   move : array of Integer;
   dV  : array of  Float; // вектор правой части
   dx  : array of  Float; // вектор с решением
   bnei, bvisit : Boolean;

begin
   // TODO 4 июня

   // предположительно довольно много времени уходит
   // на выделение памяти
   // выделение памяти
   SetLength(mp,inx*iny+1); // массив коэффициентов
   SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
   SetLength(dA,inx*iny); // Матрица СЛАУ
   SetLength(move, inx*iny); // для ленточной матрицы
   for i1:=0 to (inx*iny-1) do SetLength(dA[i1], inx*iny);
   SetLength(dV,inx*iny); // вектор правой части
   SetLength(dx,inx*iny); // вектор с результатом

   // обнуление матрицы dA
   for i1:=0 to (inx*iny-1) do for j1:=0 to (inx*iny-1) do dA[i1][j1]:=0.0;
   // инициализация векторов dx и dV
   for i1:=0 to (inx*iny-1) do
   begin
      dV[i1]:=0.0;
      dx[i1]:=0.0;
   end;

   // ipifix - фиксированная точка где-то в центре расчётной области
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;
   while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя

   // вычисление коэффициентов
   // дискретного аналога во внутренних точках
   // расчётной области
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         if (itype=1) then
         begin
            // внутренний узел

            bvisit:=false; // если true то поправка давления равна нулю

            // координаты узлов для поправки давления
            // используется обыкновенная сетка
            ini:=i+j*inx; // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx;  // текущая точка
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для поправки давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
            // требуется покрайней мере в четыре раза больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.


            if (mapPT[iei].itype <> 2) then
            begin
               // если восточная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               mp[ipi].dae:=drho*dy*dy/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[iei].iboundary, 'P', mapPT[iei].chnormal);
               if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dae:=0; // нет влияния от давления на границе
               end;
            end;

            if (mapPT[iwi].itype <> 2) then
            begin
               dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
               mp[ipi].daw:=drho*dy*dy/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[iwi].iboundary, 'P', mapPT[iwi].chnormal);
               if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].daw:=0; // нет влияния от давления на границе
               end;
            end;

            if (mapPT[ini].itype <> 2) then
            begin
                // если северная точка не является граничной
                dapvel:=Vcoefpam(i,j,2); // Vycoef
                mp[ipi].dan:=drho*dx*dx/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[ini].iboundary, 'P', mapPT[ini].chnormal);
               if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dan:=0; // нет влияния граничных условий
               end;
            end;

            if (mapPT[isi].itype <> 2) then
            begin
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               mp[ipi].das:=drho*dx*dx/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[isi].iboundary, 'P', mapPT[isi].chnormal);
                if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].das:=0; // нет влияния граничных значений
               end;
            end;

            if (bvisit) then
            begin
               // поправка давления равна нулю
               mp[ipi].dap:=1.0;
               db[ipi]:=0.0;
               mp[ipi].dae:=0.0;
               mp[ipi].daw:=0.0;
               mp[ipi].dan:=0.0;
               mp[ipi].das:=0.0;
            end
             else
            begin
               mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
               db[ipi]:=drho*(Vx[iwcvi]-Vx[iecvi])*dy+drho*(Vy[iscvi]-Vy[incvi])*dx;
            end;

            if ((i+(j-1)*inx) <> ipifix) then
            begin
               // формирование матрицы СЛАУ dA и вектора правой части dV
               dA[ipi-1][ipi-1]:= mp[ipi].dap; // центральная узловая точка
               dA[ipi-1][iei-1]:= - mp[ipi].dae;  // восток
               dA[ipi-1][iwi-1]:= - mp[ipi].daw;  // запад
               dA[ipi-1][ini-1]:= - mp[ipi].dan;  // север
               dA[ipi-1][isi-1]:= - mp[ipi].das;  // юг
              // ? dV[ipi-1]:= db[ipi]; // вектор правой части
            end
             else
            begin
               // фиксируем значение в центральной точке
               // расчётной области
               // это нужно сделать именно в этой секции,
               // т.к. если это сделать после то пришлось бы обнулять
               // дополнительные прежде заполненнные элементы матрицы A в одной из строк.
               dA[ipifix-1][ipifix-1]:= 1.0;
               // ? dV[ipifix-1]:= 0.0;
            end;

        end; // itype=1 внутренний узел
      end; // with
   end; // k1

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity...

   case ibasenorma of
       1 : // евклидова норма
          begin
             rescontinity:=myEvklidNorma(db,inx,iny);
          end;
       2 : // кубическая
          begin
             rescontinity:=mySupNorma(db,inx,iny);
          end;
       3 : // октаэдрическая
          begin
             rescontinity:=mySup2Norma(db,inx,iny);
          end;
   end;

   // Здесь на границе ставится условие Неймана
   // нормальная производная от поправки давления равна нулю.
   // По этому поводу см. 1. Патанкар ст. 108, 109.
   // 2. статья В.М. Ковеня Об одном алгоритме решения
   // уравнений Навье-Стокса вязкой несжимаемой жидкости.
   // 3. Лев Герасимович Лойцянский Механика жидкости и газа.

   (*
   // Условие Неймана на нижней
   // и верхней границах
   for i1:=2 to inx-1 do
   begin
      j1:=1; // низ
      ipi:=i1+(j1-1)*inx;  // текущая точка
      ini:=i1+j1*inx; // север
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][ini-1]:=-1.0;
      dV[ipi-1]:= 0.0;
      j1:=iny; // верх
      ipi:=i1+(j1-1)*inx;  // текущая точка
      isi:=i1+(j1-2)*inx; // юг
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][isi-1]:=-1.0;
      dV[ipi-1]:= 0.0;
   end;

   // Условие Неймана на левой
   // и правой границах
   for j1:=2 to iny-1 do
   begin
      i1:=1; // лево
      ipi:=i1+(j1-1)*inx;  // текущая точка
      iei:=(i1+1)+(j1-1)*inx; // восток
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][iei-1]:=-1.0;
      dV[ipi-1]:= 0.0;
      i1:=inx; // право
      ipi:=i1+(j1-1)*inx;  // текущая точка
      iwi:=(i1-1)+(j1-1)*inx; // запад
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][iwi-1]:=-1.0;
      dV[ipi-1]:= 0.0;
   end;

   // Значение давления в 4
   // угловых точках.
   // Четыре угловые точки расчётной области
   // левый нижний угол
   i:=1;
   j:=1;
   ini:=i+j*inx; // север
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][ini-1]:= - 0.5;
   dA[ipi-1][iei-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   // правый нижний угол
   i:=inx;
   j:=1;
   ini:=i+j*inx; // север
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][ini-1]:= - 0.5;
   dA[ipi-1][iwi-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   // правый верхний угол
   i:=inx;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][isi-1]:= - 0.5;
   dA[ipi-1][iwi-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   // левый верхний угол
   i:=1;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][isi-1]:= - 0.5;
   dA[ipi-1][iei-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   *)

   // трансформация Гаусса
   // обязательно т.к. задача с конвекцией
   // вопрос о необходимости применения в данном случае
   // трансформации Гаусса требует подробного рассмотрения.
   if (bGaussTransform) then GaussTransform(inx*iny, dA, dV);

   // Решение СЛАУ
   // методом Сопряжённых Градиентов
   // Хестенса и Штифеля
   if (bHestensenShtifiel) then
   begin
      // для этого метода по-моему обязательно требуется
      // трансформация Гаусса.
      // насчёт обязательности фиксации поправки давления в одной точке
      // для метода сопряжённых градиентов сказать пока сложно - это требует
      // подробного рассмотрения.
      // Здесь уровень поправки давления фиксируется.
      // Максимальное количество итераций увеличено в 10 раз, пороговое значение невязки
      // дополнительно уменьшено возведением в квадрат.
      SoprGrad(inx*iny, dA, dV, Pamendment, dx, false, 10*iterSimple.iterPamendment, rcs.Pamendment*rcs.Pamendment); // точность вычисления rcs.Pamendment
   end
   else // или прямой метод исключения Гаусса
   begin
      // для метода исключения Гаусса
      // необязательно проводить трансформацию Гаусса,
      // зато для него важно произвести фиксацию
      // поправки давления в одной точке с номером ipifix.
      GaussAlgorithm(inx*iny, dA, inx, iny, move, dV, dx, false);
   end;
   // копирование полученного решения обратно в Pamendment
   for i1:=0 to (inx*iny-1) do Pamendment[i1+1] := dx[i1]; // вектор с решением задачи;

end; // SolveUniversalPamendment

// находится на стадии тестирования
// Операции по определению поля давления самые ресурсоёмкие.
// Перед решением уравнения для поправки давления поле поправки давления
// надо инициализировать нулевым значением.
// решает линейное уравнение для поправки давления
// методом сопряжённых градиентов Хестенса и Штифеля.
// Здесь формируется матрица СЛАУ в формате CRS которая затем передаётся
// уточняющему солверу SoprGrad.
// этот метод эффективен по памяти т.к. здесь используется алгоритм хранеия доступа CRS.
procedure TForm1.SolveSoprGradCRSPamendment(bGaussTransform : Boolean;
                                            bipifix : Boolean;
                                            bSoloveichikAlg : Boolean; // применять ли алгоритм Ю.Г. Соловейчика 93 года
                                            var rescontinity :  Float);
// bGaussTransform - нужно ли использовать Трансформацию Гаусса: true - ДА, false - НЕТ.
// bipifix - нужно ли фиксировать поправку давления в центральной точке расчётной облсти: true - Да, false - Нет.
// rescontinity - нескомпенсированные источники массы

var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   m : MatrixCoef; // для компонент скорости
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для поправки давления
   db : array of  Float; // коэффициенты источникового члена
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i,j : Integer; // Счётчики цикла for
   iNelem : Integer; // число ненулевых элементов матрицы СЛАУ
   k : Integer; // счётчик количества ненулевых элементов
   nze : array of TmyNonZeroElemMatrix; // ненулевые элементы матрицы СЛАУ
   val  : array of  Float; // ненулевые элементы матрицы СЛАУ
   col_ind : array of Integer; // соответствующие номера столбцов
   row_ptr : array of Integer; // для определения начала следующей строки.
   dV  : array of  Float; // вектор правой части
   dx  : array of  Float; // вектор с решением

begin
   // число ненулевых элементов матрицы СЛАУ
   // учтено, что одна точка расчётной области фиксирована
   if (bipifix) then
   begin
      // одна точка в центре расчётной области фиксирована
      iNelem:=5*(inx-2)*(iny-2)+(inx-2)*4+(iny-2)*4+4*3-5+1;
   end
   else
   begin
      // поправка давления сама ищет свой уровень
      iNelem:=5*(inx-2)*(iny-2)+(inx-2)*4+(iny-2)*4+4*3;
   end;
   // предположительно довольно много времени уходит
   // на выделение памяти
   // выделение памяти
   SetLength(mp,inx*iny+1); // массив коэффициентов
   SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
   // выделение памяти под ненулевые эементы матрицы СЛАУ.
   // Этот массив будет использоваться для сортировки
   // сортировка выполняется с целью упорядочить строки матицы и ключом
   // служит номер строки. При этом среди множества ключей есть ключи равные друг другу,
   // однако это не мешает выполнить сортировку.
   SetLength(nze,iNelem+1); // ненулевые элементы которые потом придётся сортировать по строкам
   SetLength(val,iNelem); // ненулевые элементы матрицы СЛАУ
   SetLength(col_ind,iNelem); // соответствующие ненулевым элементам номера столбцов
   SetLength(row_ptr,inx*iny+1); // информация о том где начинается следующая строка

   SetLength(dV,inx*iny); // вектор правой части
   SetLength(dx,inx*iny); // вектор с результатом

   // обнуление матрицы dА
   for i:=1 to (iNelem) do
   begin
      // инициализация
      // массива для хранения
      // ненулевых элементов
      nze[i].i:=0;
      nze[i].j:=0;
      nze[i].aij:=0.0;
      nze[i].key:=0;
   end;

   // обнуление матрицы dА
   for i:=0 to (iNelem-1) do
   begin
      // инициализация
      val[i]:=0.0;
      col_ind[i]:=0;
   end;

   // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
   // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
   for i:=0 to (inx*iny) do row_ptr[i]:=iNelem; // инициализация указателей на следующую строку

   // инициализация векторов dx и dV
   for i:=0 to (inx*iny-1) do
   begin
      dV[i]:=0.0;
      dx[i]:=0.0;
   end;

   // ipifix - фиксированная точка где-то в центре расчётной области
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;

   k:=1; // счётчик ненулевых элементов массива nze

   // вычисление коэффициентов
   // дискретного аналога во внутренних точках
   // расчётной области
   for i:=2 to inx-1 do
   begin
      for j:=2 to iny-1 do
      begin
         // координаты узлов для поправки давления
         // используется обыкновенная сетка
         ini:=i+j*inx; // север
         isi:=i+(j-2)*inx; // юг
         iwi:=(i-1)+(j-1)*inx; // запад
         iei:=(i+1)+(j-1)*inx; // восток
         ipi:=i+(j-1)*inx;  // текущая точка
         // для скоростей на гранях контрольного объёма
         iecvi:=i+(j-1)*(inx-1); // в массиве Vx
         iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
         incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
         iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
         // в уравнении для поправки давления
         // потребовались коэффициенты для компонент скорости
         // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
         // требуется покрайней мере в четыре раза больший объём вычислений
         // чем для уравнений для компонент скорости или температуры.

         if (i<>(inx-1)) then
         begin
            Vxcoef(i,j,m); // m.dap=ae
            mp[ipi].dae:=drho*(0.5*(ypos[j+1]-ypos[j-1]))*(0.5*(ypos[j+1]-ypos[j-1]))/m.dap;
         end
         else
         begin
            mp[ipi].dae:=0; // нет влияния от давления на границе
         end;

         if (i<>2) then
         begin
            Vxcoef(i-1,j,m); // m.dap=aw
            mp[ipi].daw:=drho*(0.5*(ypos[j+1]-ypos[j-1]))*(0.5*(ypos[j+1]-ypos[j-1]))/m.dap;
         end
         else
         begin
            mp[ipi].daw:=0; // нет влияния от давления на границе
         end;

         if (j<>(iny-1)) then
         begin
            Vycoef(i,j,m); // m.dap=an
            mp[ipi].dan:=drho*(0.5*(xpos[i+1]-xpos[i-1]))*(0.5*(xpos[i+1]-xpos[i-1]))/m.dap;
         end
         else
         begin
            mp[ipi].dan:=0; // нет влияния граничных условий
         end;

         if (j<>2) then
         begin
            Vycoef(i,j-1,m); // m.dap=as
            mp[ipi].das:=drho*(0.5*(xpos[i+1]-xpos[i-1]))*(0.5*(xpos[i+1]-xpos[i-1]))/m.dap;
         end
         else
         begin
            mp[ipi].das:=0; // нет влияния граничных значений
         end;
         mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
         db[ipi]:=drho*(Vx[iwcvi]-Vx[iecvi])*(0.5*(ypos[j+1]-ypos[j-1]))+drho*(Vy[iscvi]-Vy[incvi])*(0.5*(xpos[i+1]-xpos[i-1]));

         if ((bipifix) and (ipi = ipifix)) then
         begin
            // фиксируем значение в центральной точке
            // расчётной области
            // это нужно сделать именно в этой секции,
            // т.к. если это сделать после то пришлось бы обнулять
            // дополнительные прежде заполненнные элементы матрицы A в одной из строк.
            // шаблон заполнения
            // dA[ipifix-1][ipifix-1]:= 1.0;
            nze[k].i:=ipifix-1; nze[k].j:=ipifix-1; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
            dV[ipifix-1]:= 0.0;
         end
         else
         begin
            // формирование матрицы СЛАУ dA и вектора правой части dV
           // шаблон заполнеиия
           // dA[ipi-1][ipi-1]:= mp[ipi].dap; // центральная узловая точка
           // dA[ipi-1][iei-1]:= - mp[ipi].dae;  // восток
           // dA[ipi-1][iwi-1]:= - mp[ipi].daw;  // запад
           // dA[ipi-1][ini-1]:= - mp[ipi].dan;  // север
           // dA[ipi-1][isi-1]:= - mp[ipi].das;  // юг
           nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=mp[ipi].dap; nze[k].key:=nze[k].i;  k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:= - mp[ipi].dae; nze[k].key:=nze[k].i; k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:= - mp[ipi].daw; nze[k].key:=nze[k].i; k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:= - mp[ipi].dan; nze[k].key:=nze[k].i; k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:= - mp[ipi].das; nze[k].key:=nze[k].i; k:=k+1;

           dV[ipi-1]:= db[ipi]; // вектор правой части
         end;
      end; // j
   end; // i

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity...
   case ibasenorma of
       1 : // евклидова норма
          begin
             rescontinity:=myEvklidNorma(db,inx,iny);
          end;
       2 : // кубическая
          begin
             rescontinity:=mySupNorma(db,inx,iny);
          end;
       3 : // октаэдрическая
          begin
             rescontinity:=mySup2Norma(db,inx,iny);
          end;
   end;


   // Здесь на границе ставится условие Неймана
   // нормальная производная от поправки давления равна нулю.
   // По этому поводу см. 1. Патанкар ст. 108, 109.
   // 2. статья В.М. Ковеня Об одном алгоритме решения
   // уравнений Навье-Стокса вязкой несжимаемой жидкости.
   // 3. Лев Герасимович Лойцянский Механика жидкости и газа.

   // Условие Неймана на нижней
   // и верхней границах
   for i:=2 to inx-1 do
   begin
      j:=1; // низ
      ipi:=i+(j-1)*inx;  // текущая точка
      ini:=i+j*inx; // север
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][ini-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:= -1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
      j:=iny; // верх
      ipi:=i+(j-1)*inx;  // текущая точка
      isi:=i+(j-2)*inx; // юг
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][isi-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:=-1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
   end;

   // Условие Неймана на левой
   // и правой границах
   for j:=2 to iny-1 do
   begin
      i:=1; // лево
      ipi:=i+(j-1)*inx;  // текущая точка
      iei:=(i+1)+(j-1)*inx; // восток
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][iei-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:= -1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
      i:=inx; // право
      ipi:=i+(j-1)*inx;  // текущая точка
      iwi:=(i-1)+(j-1)*inx; // запад
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][iwi-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:=-1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
   end;

   // Значение давления в 4
   // угловых точках.
   // Четыре угловые точки расчётной области
   // левый нижний угол
   i:=1;
   j:=1;
   ini:=i+j*inx; // север
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][ini-1]:= - 0.5;
   // dA[ipi-1][iei-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   dV[ipi-1]:= 0.0;
   // правый нижний угол
   i:=inx;
   j:=1;
   ini:=i+j*inx; // север
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][ini-1]:= - 0.5;
   // dA[ipi-1][iwi-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   dV[ipi-1]:= 0.0;
   // правый верхний угол
   i:=inx;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][isi-1]:= - 0.5;
   // dA[ipi-1][iwi-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   dV[ipi-1]:= 0.0;
   // левый верхний угол
   i:=1;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][isi-1]:= - 0.5;
   // dA[ipi-1][iei-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;
   dV[ipi-1]:= 0.0;


   if (itypesorter = 1) then
   begin
      QuickSort(nze,1,iNelem); // быстрая сортировка Хоара
   end
    else
   begin
      // itypesorter = 2
      HeapSort(nze,iNelem); // пирамидальная сортировка
   end;

   // формирование матрицы разреженной матрицы СЛАУ
   //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
   for k:=0 to iNelem-1 do
   begin
      // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
      // это требование алгоритма пирамидальной сортировки.
      val[k]:=nze[k+1].aij;
      col_ind[k]:=nze[k+1].j;
      row_ptr[nze[k+1].i]:=min(k, row_ptr[nze[k+1].i]);
   end;

   Finalize(nze); // освобождение памяти под массив nze
   //MainMemo.Lines.Add('матрица СЛАУ сформирована ');

   // трансформация Гаусса
   // обязательно т.к. задача с конвекцией, но вообще
   // вопрос о необходимости применения в данном случае
   // трансформации Гаусса требует подробного рассмотрения.
   // Матрица СЛАУ может быть также несимметрична из-за граничных условий первого рода.
   // А метод сопряжённых градиентов применим только для симметричных матриц.

   // Решение СЛАУ
   // методом Сопряжённых Градиентов
   // Хестенса и Штифеля
   // для этого метода по-моему обязательно требуется
   // трансформация Гаусса.
   // насчёт обязательности фиксации поправки давления в одной точке
   // для метода сопряжённых градиентов сказать пока сложно - это требует
   // подробного рассмотрения.
   // В зависимости от значения параметра bGaussTransform
   // применяется или не применяется трансформация Гаусса.
   // здесь передаётся квадрат значения невязки что уменьшаёт передаваемое значение и
   // заставляет сделать больше итераций.
   // максимальное количество итераций также увеличено в 10 раз.
   if (not(bSoloveichikAlg)) then
   begin
      // Алгоритм сопряжённых Градиентов Хестенса и Штифеля
      SoprGradCRS(inx*iny, val, col_ind, row_ptr, dV, Pamendment, dx, false, 10*iterSimple.iterPamendment,  bGaussTransform, rcs.Pamendment*rcs.Pamendment); // точность вычисления rcs.Pamendment
   end
    else
   begin
      // алгоритм Ю.Г. Соловейчика [1993]
      // Алгоритм Соловейчика не работает на уравнении для поправки давления.
      // нет сходимости.
      SoloveichikAlg(inx*iny, val, col_ind, row_ptr, dV, Pamendment, dx, false, 10*iterSimple.iterPamendment, rcs.Pamendment*rcs.Pamendment);
   end;


   // копирование полученного решения обратно в Pamendment
   for i:=0 to (inx*iny-1) do Pamendment[i+1]:= dx[i]; // вектор с решением задачи;

end; // SolveSoprGradCRSPamendment


// коррекция Давления
procedure TForm1.CorrectNewPressure;
var
   k : Integer; // Счётчик
   ipi : Integer; // координата текущего узла
   
begin
      for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
         begin
            if (itype=1) then
            begin
               // внутренний и граничный узел.
               // 7 апреля испытывается новыый солвер для поправки давления
               // До этого стоял только внутреннний узел.

               // используется обыкновенная сетка
               ipi:=i+(j-1)*inx;  // текущая точка
               // Здесь реализуется четвёртый шаг алгоритма SIMPLE
               // Смысл которого состоит в коррекции давления,
               // так чтобы значения переменных Vx, Vy и P лучше удовлетворяли
               // уравнению неразрывности.
               // alphap=0.8;
               if (not bsimplec) then
               begin
                  // Алгоритм Патанкара и Сполдинга [1972] SIMPLE
                  P[ipi]:=P[ipi]+myrelaxfactors.PressureRelax*Pamendment[ipi];
               end
                else
               begin
                  // Алгоритм SIMPLEC [1984]
                  // нижней релаксации не нужно.
                  P[ipi]:=P[ipi] + Pamendment[ipi];
               end;
            end;
         end; // with
      end;
end; //  CorrectNewPressure

// поправочная формула для горизонтальной скорости
procedure TForm1.CorrectVx;
var
   k : Integer; // Счётчик
   ipi : Integer; // координата текущего узла для Vx
   je, jp : Integer; // координаты боковых узлов для давления
   m : MatrixCoef; // для компонент скорости
   //bnei : Boolean; // если граничное условие Неймана

begin

   for k:=1 to imaxnumbernodeVx do
      begin
         with (mapVx[k]) do
         begin
            if (itype =1) then
            begin
               // только для внутреннего узла

               // координата текущего узла на шахматной сетке
               // для горизонтальной компоненты скорости
               // для Vx на шахматной сетке по горизонтали на одну точку меньше.
               ipi:=i+(j-1)*(inx-1); // текущая точка для Vx
               jp:=i+(j-1)*inx;  // давление слева
               je:=(i+1)+(j-1)*inx; // давление справа
               VxCoef(i,j,m); // вычисление коэффициента при скорости
               Vx[ipi]:=Vx[ipi]+ dy*(Pamendment[jp]-Pamendment[je])/m.dap;
            end;
         end; // with
   end;
end; // CorrectVx

// устраняет дефекты графической визуализации
procedure TForm1.VelXPachit;
var
   k : Integer;
   bnei : Boolean;
   ipi, ini, isi, iei, iwi : Integer;
   
begin
   for k:=1 to imaxnumbernodeVx do
   begin
     with (mapVx[k]) do
       begin
         if (itype = 2) then
         begin  // граничный узел
            bnei:=GridGenForm.isneiman(iboundary, 'P',chnormal);
            if (not(bnei)) then
            begin
               ipi:=i+(j-1)*(inx-1);
               case chnormal of
                'N' : begin
                         ini:=i+j*(inx-1);
                         Vx[ipi]:=Vx[ini];
                      end;
                'S' : begin
                         isi:=i+(j-2)*(inx-1);
                         Vx[ipi]:=Vx[isi];
                      end;
                'E' : begin
                         iei:=(i+1)+(j-1)*(inx-1);
                         Vx[ipi]:=Vx[iei];
                      end;
                'W' : begin
                         iwi:=(i-1)+(j-1)*(inx-1);
                         Vx[ipi]:=Vx[iwi];
                      end;
                end; // case
            end;
         end;
       end;
   end;

end;// VelXPachit;

// поправочная формула для вертикальной скорости
procedure TForm1.CorrectVy;
var
   k : Integer; // Счётчик
   ipi : Integer; // координата текущего узла для Vy
   jn, jp : Integer; // координаты боковых узлов для давления
   m : MatrixCoef; // для компонент скорости
begin
   // после этой коррекции
   // компоненты скорости удовлетворяют
   //уравнению неразрывности
   for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype =1 ) then
            begin
               // только для внутреннего узла

               // координата текущего узла на шахматной сетке
               // для вертикальной компоненты скорости
               // для Vy на шахматной сетке по вертикали на одну точку меньше.
               ipi:=i+(j-1)*inx; // текущая точка для Vy
               jn:=i+j*inx; // давление сверху
               // здесь нестандартное обозначение для давления снизу
               // хорошо бы его обозвать jp вместо js
               jp:=i+(j-1)*inx; // давление снизу
               VyCoef(i,j,m); // вычисление коэффициента при скорости
               Vy[ipi]:=Vy[ipi]+dx*(Pamendment[jp]-Pamendment[jn])/m.dap;
            end;
         end; // with
   end;
end; // CorrectVy

// запуск на вычисление
procedure TForm1.RunTune;
begin
   with myRun do
   begin
       // по умолчанию вычисления не были запущены на выполнение
       // Это нужно если форма была просто закрыта и пользователь не захотел начать вычисление.
       btheBeginingCalculation:=false;

       // если задача стационарная
       // то панель с нестационарными параметрами надо
       // сделать неактивной
       if (btimedepend) then
       begin
          ErealFlowTimeVal.Text:=FloatToStr(realFlowTime);
          Panel1.Visible:=true; // нестационарный
       end
        else
       begin
          Panel1.Visible:=false; // стационарный
       end;

       if (imodelEquation <= 2) then
       begin
          // Чистая теплопроводность
          // или теплопроводность с учётом
          // конвективного члена

          case itypesolver.itemperature of
             1 : // ГЗ
               begin // Солвер Гаусса-Зейделя
                  Panel3.Visible:=true;
                  // в соответствии с теорией из учебника
                  // Александра Андреевича Самарского,
                  // а также Ульян Гайковича Пирумова
                  // для метода простой итерации
                  // в случае линеной системы
                  // требуется выполнить до сходимости
                  // 2*N^2 итераций, где N - число неизвестных
                  // в уравнении.
                  // Для метода Зейделя, который здесь используется
                  // эта оценка составляет N^2.
                  Eitercount.Text:=IntToStr(inx*inx*iny*iny);
               end;
             2 : // переменных направлений
               begin  // Метод переменных направлений
                  Panel3.Visible:=true;
                   // В теории метод переменных направлений полилинейный.
                   Eitercount.Text:=IntToStr(inx*iny*round(ln(max(inx,iny))));
               end;
             3 : // прямой метод исключения Гаусса
               begin
                  // итераций нет это прямой метод
                  Panel3.Visible:=false;
               end;
             4 : // метод сопряжённых градиентов Хестенса и Штифеля
               begin
                  // метод является итерационным несмотря на то что
                  // для него в теории для полной сходимости требуется очень мало итераций.
                  Panel3.Visible:=true;
                  // задаём количество итераций по умолчанию.
                  Eitercount.Text:=IntToStr(inx*iny*round(ln(max(inx,iny))));
               end;
          end;
       end
        else
       begin
          // Навье - Стокс
          Panel3.Visible:=true;
          if (actiVibr.bOn) then
          begin
             Ltimestepnow.Caption:='число шагов за период';
             Etimestep.Text:='200'; // 200 шагов по времени за период
             Lnumbertimestep.Caption:='число периодов вибрации';
             Enumbertimestep.Text:='400'; // 400 периодов
          end
           else
          begin
             Ltimestepnow.Caption:='шаг по времени';
             Etimestep.Text:='1e-1';
             Lnumbertimestep.Caption:='количество шагов по времени';
             Enumbertimestep.Text:='10';
          end;
          // количество итераций для стационарного солвера
          Eitercount.Text:=IntToStr(120);
       end;
     end; // with

   // показывает форму запуска
   myRun.ShowModal; // временно передаёт управление модулю запуска.

   if (myRun.btheBeginingCalculation) then
   begin
      // Пользователь захотел запустить вычисление на выполнение.

      // Как только работа модуля запуска закончится управление
      // передастся обратно в этот участок кода и выполнятся следующие процедуры.

      if (btimedepend = false) then // стационарный
      begin
         // В форме myRunModule уже задано
         // количество итераций itercount и
         // количество шагов по времени равное 1 -
         // это нужно из-за универсальности процедур расчёта.

         case imodelEquation of
            1 : // чистая теплопроводность без конвекции
              begin
                 RunCleanThermalConductionSteady;
              end;
            2 : // теплопроводность с учётом конвекции
                // на основе МАРЕНА тест
              begin
                 RunConvectiveThermalConductionSteady;
              end;
            3 : // чистая гидродинамика
              begin
                 // Здесь определяется только поле течения.
                 myVersionSIMPLEAlgorithm(false);
              end;
            4 : // гидродинамика плюс теплопроводность
              begin
                 // Здесь в добавок к уравнениям течения
                 // также будет решаться и уравнение теплопроводности.
                 myVersionSIMPLEAlgorithm(true);
              end;
         end; // case
      end
       else // нестационарный
      begin

         // В форме myRunModule уже задано
         // количество итераций itercount и
         // количество шагов по времени inumbertimestep.
         // Шаг по времени является постоянным с значением dTimeStep.
         // Начальное время расчёта задаётся равным dStartTime и
         // дальше больше нигде не используется.

         case imodelEquation of
           1 : // чистая теплопроводность без конвекции
              begin
                 RunCleanThermalConductionUnsteady;
              end;
           2 : // теплопроводность с учётом конвекции
               // на основе МАРЕНА тест
              begin
                 RunConvectiveThermalConductionUnsteady;
              end;
           3 : //  чистая гидродинамика
              begin
                 // данный код находится в стадии тестирования
                 myVersionSIMPLEAlgorithm(false);
              end;
           4 : // гидродинамика плюс теплопроводность
              begin
                 // данный код находится в стадии тестирования
                 myVersionSIMPLEAlgorithm(true);
              end;
         end; // case

      end;
   end;

end;

// вызывает солвер
procedure TForm1.Run1Click(Sender: TObject);
begin
   RunTune;
end; // вызывает солвер

// инициализация перед началом счёта
procedure TForm1.Initializationtune;
begin
   with myInitialize do
   begin
      case imodelEquation of
        1 : // чистая теплопроводность
          begin
             PTempreture.Visible:=true;
             PFlow.Visible:=false;
          end;
        2 : // теплопроводность с учётом конвективного члена на основе MARENA тест.
          begin
              PTempreture.Visible:=true;
              PFlow.Visible:=false;
          end;
         3 : // чистая гидродинамика
          begin
              PTempreture.Visible:=false;
              PFlow.Visible:=true;
          end;
         4 : // гидродинамика плюс теплопроводность
          begin
             PTempreture.Visible:=true;
             PFlow.Visible:=true;
          end;
      end;

      // загружает запомненные параметры инициализации
      EinitXvel.Text:=FloatToStr(InitVal.XvelInit); // горизонтальная скорость
      EinitYvel.Text:=FloatToStr(InitVal.YvelInit); // вертикальная скорость
      EinitTemp.Text:=FloatToStr(InitVal.TempInit); // температура
   end; // with
   // вызывает модуль инициализации
   myInitialize.ShowModal;
end;


// параметры материалов
procedure TForm1.materialtune;
begin
   with MaterialForm do
   begin
      // инициализация формы материалов
      // параметрами выставленными при запуске
      Erho.Text:=FloatToStr(matprop[0].drho); // плотность
      Emu.Text:=FloatToStr(matprop[0].dmu); // динамическая вязкость
      Ecp.Text:=FloatToStr(matprop[0].dcp); // теплоёмкость
      Elambda.Text:=FloatToStr(matprop[0].dlambda); // теплопроводность
      EbetaT.Text:=FloatToStr(matprop[0].beta); // коэффициент температурного расширения
      // динамическая вязкость
      if (Form1.imodelEquation>2) then
      begin
         PanelNusha.Visible:=true;
         if (Form1.imodelEquation=3) then
         begin
            Panellambda.Visible:=false;
         end
          else
         begin
            Panellambda.Visible:=true;
         end;
      end
       else
      begin
         PanelNusha.Visible:=false;
         Panellambda.Visible:=true;
      end;
      // стационарный или нестационарный
      if (Form1.btimedepend) then
      begin
         // нестационарный
         PanelCp.Visible:=true;
         GroupBoxDensity.Visible:=true;
      end
       else
      begin
         // стационарный
         // плотность и теплоёмкость при постоянном давлении ненужны,
         // для случая где решается чистая теплопроводность.
         PanelCp.Visible:=false;
         if (Form1.imodelEquation < 3) then
         begin
            GroupBoxDensity.Visible:=false;
         end
          else
         begin
            GroupBoxDensity.Visible:=true;
         end
      end;
   end; // with
   // вызывает экранную форму задания параметров
   // материала
   MaterialForm.ShowModal;
   // всё придётся инициализировать заново: выделение памяти и присвоение значений.
   myInitializationRestart;
end;

// задаёт постоянные параметры материалов
procedure TForm1.Materials1Click(Sender: TObject);
begin
   // параметры материалов
   materialtune;
end; // задаёт параметры материалов

// передаёт картинку в программу tecplot
procedure TForm1.ecplot1Click(Sender: TObject);
begin
    if (Form1.actiVibr.bOn) then
    begin
       ExportTecplotForm.Panelmean.Visible:=true;
       if (imodelEquation=3) then
       begin
          ExportTecplotForm.LmeanT.Visible:=false;
          ExportTecplotForm.LT.Visible:=false;
       end
        else
       begin
          ExportTecplotForm.LmeanT.Visible:=true;
          ExportTecplotForm.LT.Visible:=true;
       end;
    end
     else
    begin
       ExportTecplotForm.Panelmean.Visible:=false;
       if (imodelEquation=3) then
       begin
          ExportTecplotForm.LT.Visible:=false;
       end
        else
       begin
          ExportTecplotForm.LT.Visible:=true;
       end;
    end;
   // вызывает форму для выбора величины
   // которую надо визуализировать
   ExportTecplotForm.ShowModal;
end; // визуализация результатов вычислений в программе tecplot

// задание граничных условий
procedure TForm1.BoundaryConditionTune;
var
    i : Integer; // счётчик.

begin
   with BoundaryConditionForm do
   begin
     if (imodelEquation = 3) then
     begin
        // условия по температуре делаем невидимыми
        TabControl1.TabIndex:=1;
        Panel3.Visible:=false;
        GroupBox2.Visible:=true;
     end;
      // вызывает форму задания граничных условий:
      // имена границ на которых задаются граничные условия, а также
      // значения граничных условий по умолчанию
      // сгенерированы в модуле GridGenUnit.
      // инициализация формы:
     EdgeComboBox.Clear; // очистка списка границ
     for i:=1 to GridGenForm.inumboundary do
     begin
        EdgeComboBox.Items.Add(GridGenForm.edgelist[i].boundaryname);
     end;
   end;

    // показывает форму где задаются граничные условия
    BoundaryConditionForm.ShowModal;

    // всё придётся инициализировать заново: выделение памяти и присвоение значений.
    //myInitializationRestart;
end;

// задание граничных условий
procedure TForm1.BoundaryCondition1Click(Sender: TObject);
begin
   BoundaryConditionTune;
end; // задание граничных условий

// задаёт источниковый член в уравнениях
procedure TForm1.Source1Click(Sender: TObject);
begin
   // вызывает форму задания источникового члена
   SourceInEquationForm.Show;
end; // задаёт источниковый член в уравнениях

// меню для реализованной визуализации
procedure TForm1.N2Dplot1Click(Sender: TObject);
begin
   Form2DPlot.Show; // вызывает меню визуализации
end;

// выбор способа интерполяции
procedure TForm1.UseInterpolate1Click(Sender: TObject);
begin
   // вызывает форму на которой можно выбрать
   InterpolateCaseForm.Show; // способ интерполяции
   // в этом же меню от интерполляции можно вообще отказаться
end;  // способ интерполяции

// решает уравнение для поправки давления
// с учётом выбранного солвера
procedure TForm1.SolvePamendment(var rescontinity : Float);
var
    i : Integer; // Счётчик
    mp : array of MatrixCoef;
    db : array of  Float;
    deviation : Float; // невязка
    ipifix : Integer; // фиксируемая точка
    bpresflag : Boolean; // задано ли давление на одном из рёбер

begin
   // параметр rescontinity - это значение невязки по нескомпенсированным
   // источникам массы которые должны быть скомпенсированы. По этому значению
   // можно судить о сходимости всей системы уравнений Навье-Стокса в целом.

   if (not(bPatankarPressure)) then
   begin
      // выделение памяти
      SetLength(mp,inx*iny+1); // массив коэффициентов
      SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена

      // вычисление коэффициентов дискретного аналога
      PamendmentCoef(rescontinity, mp, db);
   end;

   // решатель для поправки давления:
      case itypesolver.ipamendment of
      1 : // последовательный поточечный метод Гаусса-Зейделя.
          begin
             if (not(bPatankarPressure)) then
             begin

                if (bipifixpamendment) then
                begin
                   bpresflag:=false;
                   for i:=1 to GridGenForm.inumboundary do
                   begin
                      if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                   end;
                   if (not(bpresflag)) then
                   begin
                      ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                      while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                      mp[ipifix].dae:=0.0;
                      mp[ipifix].daw:=0.0;
                      mp[ipifix].dan:=0.0;
                      mp[ipifix].das:=0.0;
                      mp[ipifix].dap:=1.0;
                      db[ipifix]:=0.0; // давление в этой точке равно нулю.
                   end;
                end;

                i:=1;
                deviation:=1e300;
                while ((deviation > rcs.Pamendment) and (i <= iterSimple.iterPamendment)) do
                begin
                   GZUniversal(Pamendment,inx,iny, mapPT, 'P',  mp,db);
                   if (((2*i) mod (inx+iny)) = 0 ) then
                   begin
                      deviation:=myResidual(Pamendment, inx, iny, mapPT, 'P', mp, db);
                   end;
                   inc(i); // переход к следующей итерации
                end;

              end
               else
              begin
                 // Здесь реализовано как у Патанкара - нет влияния от точки на границе.

                 // никакую сверрелаксацию применять по-моему не следует
                 SolveGZPamendment(bipifixpamendment,rescontinity); // на основе солвера Гаусса-Зейделя.
                 // передаваемое значение false означает,
                 // что фиксации поправки давления в центральной точке расчётной области не производится
                 // и поправка давления сама ищет свой уровень. Это гарантирует более быструю сходимость
                 // вычислительного процесса
              end;
          end;
      2 : // гибридный алгоритм метода прогонки и Гаусса-Зейделя.
          begin
             if (not(bPatankarPressure)) then
             begin

                if (bipifixpamendment) then
                begin
                   bpresflag:=false;
                   for i:=1 to GridGenForm.inumboundary do
                   begin
                      if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                   end;
                   if (not(bpresflag)) then
                   begin
                      ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                      while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                      mp[ipifix].dae:=0.0;
                      mp[ipifix].daw:=0.0;
                      mp[ipifix].dan:=0.0;
                      mp[ipifix].das:=0.0;
                      mp[ipifix].dap:=1.0;
                      db[ipifix]:=0.0; // давление в этой точке равно нулю.
                   end;
                end;

                i:=1;
                deviation:=1e300;
                while ((deviation > rcs.Pamendment) and (i <= iterSimple.iterPamendment)) do
                begin
                    // одна итерация методом переменных направлений
                    // для поля температур и граничных условий первого рода
                    TDMAGibridGZUniversal(Pamendment,inx,iny, mapPT, 'P',mp, db);
                   if (((2*i) mod (inx+iny)) = 0 ) then
                   begin
                      deviation:=myResidual(Pamendment, inx, iny, mapPT, 'P', mp, db);
                   end;
                   inc(i); // переход к следующей итерации
                end;

              end
               else
              begin
                 // Здесь реализовано как у Патанкара - нет влияния от точки на границе.

                 // метод не реализован
                 Application.MessageBox('abort','данная возможность не реализована',MB_OK);
                 MainMemo.Lines.Add('данная возможность не реализована');
                 bweShouldContinue:=false; // прекращение вычислений
              end;
          end;

      // Универсальный решатель для поправки давления
      3 : // прямой метод исключения Гаусса
          begin


             if (not(bPatankarPressure)) then
             begin

                // проверка все ребер, т.к. на одном из них может быть задано давление
                bpresflag:=false;
                for i:=1 to GridGenForm.inumboundary do
                begin
                   if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                end;
                if (not(bpresflag)) then
                begin
                   // ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                   // while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                   ipifix:=Random(inx*iny+1);
                   if (ipifix=0) then inc(ipifix);
                   while (mapPT[ipifix].itype <> 1) do
                   begin
                      ipifix:=Random(inx*iny+1); // точка именно внутренняя
                      if (ipifix=0) then inc(ipifix);
                   end;
                   mp[ipifix].dae:=0.0;
                   mp[ipifix].daw:=0.0;
                   mp[ipifix].dan:=0.0;
                   mp[ipifix].das:=0.0;
                   mp[ipifix].dap:=1.0;
                   db[ipifix]:=0.0; // давление в этой точке равно нулю.
                end;

                GaussUniversal(Pamendment,inx,iny,mapPT,'P',mp, db, false);

             end
              else
             begin
                // первый параметр false - без использования трансформации Гаусса
                // второй параметр false - без применения метода сопряжённых градиентов, т.к.
                // используется прямой метод исключения Гаусса.
                //SolveUniversalPamendment(false,false,rescontinity);
                // нужно фиксировать одну точку если необходимо,
                //  иначе система будет линейно зависима.
                Application.MessageBox('abort','данная возможность не реализована',MB_OK);
                MainMemo.Lines.Add('данная возможность не реализована');
                bweShouldContinue:=false; // прекращение вычислений
             end;
          end;
      4 : // на основе метода Сопряжёных Градиентов.
          begin
             // Хестенс и Штифель [1952]
             if (not(bPatankarPressure)) then
             begin
                // на основе условий Неймана.
                // проверка все ребер, т.к. на одном из них может быть задано давление
                bpresflag:=false;
                for i:=1 to GridGenForm.inumboundary do
                begin
                   if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                end;
                if (not(bpresflag)) then
                begin
                   //ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                   //while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                   ipifix:=Random(inx*iny+1);
                   if (ipifix=0) then inc(ipifix);
                   while (mapPT[ipifix].itype <> 1) do
                   begin
                      ipifix:=Random(inx*iny+1); // точка именно внутренняя
                      if (ipifix=0) then inc(ipifix);
                   end;
                   mp[ipifix].dae:=0.0;
                   mp[ipifix].daw:=0.0;
                   mp[ipifix].dan:=0.0;
                   mp[ipifix].das:=0.0;
                   mp[ipifix].dap:=1.0;
                   db[ipifix]:=0.0; // давление в этой точке равно нулю.
                end;

                // bconve = false;
                // bmessage = false;
                SoprGradCRSUniversal( Pamendment, inx, iny, mapPT, 'P', mp, false, false, iterSimple.iterPamendment, rcs.temp, 0,db); // хранение разреженной матрицы в формате CRS
             end
              else
             begin

                // метод сопряжённых градиентов с применением трансформации Гаусса
                // в методе SolveSoprGradCRSPamendment(true,false) параметр true означает,
                // что выполняется трансформация К.Ф. Гаусса
                // проверено на примере течения в изотермической каверне при Re=400,
                // что отказ от трансформации Гаусса приводит к расходимости
                // вычислительного процесса.

                //SolveSoprGradCRSPamendment(true,true,false,rescontinity); // на основе технологии CRS
                // первый параметр равный true - означает что нужно применить трансформацию Гаусса
                // второй параметр равный false - говорит о том, что не нужно фиксировать уровня поправки давления,
                // а дать ей самой искать свой уровень. Если он равен true то поправка давления фиксирована в одной точке.
                // третий параметр равный false - говорит о том что нужно использовать метод сопаряжённых градиентов

                 // метод не реализован с учётом карты
                 Application.MessageBox('abort','данная возможность не реализована',MB_OK);
                 MainMemo.Lines.Add('данная возможность не реализована');
                 bweShouldContinue:=false; // прекращение вычислений
             end;
          end;
      5 : // алгоритм Ю.Г. Соловейчика [1993]
          begin
             if (not(bPatankarPressure)) then
             begin
                // на основе условий Неймана.
                // проверка все ребер, т.к. на одном из них может быть задано давление
                bpresflag:=false;
                for i:=1 to GridGenForm.inumboundary do
                begin
                   if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                end;
                if (not(bpresflag)) then
                begin
                   //ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                   //while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                   ipifix:=Random(inx*iny+1);
                   if (ipifix=0) then inc(ipifix);
                   while (mapPT[ipifix].itype <> 1) do
                   begin
                      ipifix:=Random(inx*iny+1); // точка именно внутренняя
                      if (ipifix=0) then inc(ipifix);
                   end;
                   mp[ipifix].dae:=0.0;
                   mp[ipifix].daw:=0.0;
                   mp[ipifix].dan:=0.0;
                   mp[ipifix].das:=0.0;
                   mp[ipifix].dap:=1.0;
                   db[ipifix]:=0.0; // давление в этой точке равно нулю.
                end;
                 // bconve = true; данный параметр здесь не учитывается, алгоритм Соловейчика -
                 // локально оптимальная схема специально работает с несимметричными матрицами.
                // bmessage = false;
                SoprGradCRSUniversal( Pamendment, inx, iny, mapPT, 'P', mp, true, false, iterSimple.iterPamendment, rcs.temp*rcs.temp, 1,db); // используется формат хранения разреженной матрицы CRS
             end
              else
             begin

                // первый параметр true не используется.
                //SolveSoprGradCRSPamendment(true,true,true,rescontinity); // на основе технологии CRS

                 // метод не реализован с учётом карты
                 Application.MessageBox('abort','данная возможность не реализована',MB_OK);
                 MainMemo.Lines.Add('данная возможность не реализована');
                 bweShouldContinue:=false; // прекращение вычислений
             end;
          end;
      end;

end; // решает уравнение для поправки давления

// инициализация параметров в алгоритме SIMPLE
procedure TForm1.initparamSIMPLE(bposttemperature : Boolean);
var i : Integer;
begin
   // выделение оперативной памяти под исследуемые полевые величины
   // и присваивание им значения по умолчанию.
   initparam2;

   if (actiVibr.bOn) then
   begin
      kstreamdivision:=0;
      // перед началом гидродинамического вычисления с подвижными
      // сетками запоминаем начальную конфигурацию сетки.
      // запоминаем текущую сетку
      for i:=1 to Form1.iny do
      begin
         Form1.yposfix[i]:=Form1.ypos[i];
      end;
   end;

   if (btimedepend) then
   begin
      // инициализируем поле скорости на предыдущем временном слое
      // путём запоминания текущей скорости
      // примечание: данная реализация алгоритма SIMPLE стационарная
      // а массивы скорости просто фигурируют в дискретном аналоге из-за
      // общности алгоритма, т.к. один и тот же код с небольшими изменениями
      // используется как в нестационарном так и в стационарном случае.
      RememberXvel(VxOldTimeStep); // запоминаем горизонтальную компоненту скорости
      RememberYvel(VyOldTimeStep); // запоминаем вертикальную компоненту скорости
   end;
   // инициализация поля температур если требуется
   if (bposttemperature) then
   begin
      // решение уравнения теплопроводности
      // отдельное решение уравнения теплопроводности
      initparam; // инициализирует данные

      if ((not btimedepend) and (bBussinesk)) then
      begin
         SolveTempSteady(false,iterSimple.iterTemperature,false); // находит коэффициенты и решает
      end;
      // стационарное поле температур - это неплохое начальное приближение
      // к искомому полю температур, которое определяется также полем скорости

      // инициализация поля температур на предыдущем временном слое
      // память для хранения поля температур с предыдущего временного слоя
      // выделялась при необходимости в процедуре initparam.
      if (btimedepend) then RememberTOldTimeStep(true); // инициализация
   end;

end; //  initparamSIMPLE

// Вычисляет текущие невязки для компонент скорости
procedure TForm1.getrealresFlow(var resVx :  Float; var resVy :  Float);
var
   m : array of MatrixCoef; // все коэффициенты дискретного аналога
   db : array of  Float; // часть источникового члена
begin
   // выделение оперативной памяти  для горизонтальной скорости
   SetLength(m,(inx-1)*iny+1); // основные коэффициенты дискретного аналога
   SetLength(db,(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
   VxGlobalCoef(m,db);
   resVx:=myResidual(Vx,inx-1,iny,mapVx, 'U', m,db); // значение невязки
   // выделение оперативной памяти  для вертикальной скорости
   SetLength(m,inx*(iny-1)+1); // основные коэффициенты дискретного аналога
   SetLength(db,inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам
   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
   VyGlobalCoef(m,db);
   resVy:=myResidual(Vy,inx,iny-1,mapVy, 'V', m,db); // значение невязки
   Finalize(m); Finalize(db); // освобождение оперативной памяти
end; // getrealresFlow

// вычисляет невязку для температуры
procedure TForm1.getrealResTemp(var restemp : Float);
var
   m : array of MatrixCoef; // все коэффициенты дискретного аналога
   db : array of  Float; // часть источникового члена
begin
   SetLength(m,inx*iny+1); // основные коэффициенты дискретного аналога
   SetLength(db,inx*iny+1);
   TempConvCoef(m, db);
   restemp:=myResidual(T,inx,iny,mapPT, 'T', m,db);
end; // getrealResTemp

// алгоритмы: SIMPLE, SIMPLEC и SIMPLER.
// стационарный алгоритм SIMPLE
// если bposttemperature = true, то с учётом теплопроводности,
// но без учёта приближения Буссинеска,
// т.е. гидродинамика не зависит от теплопроводности,
// а теплопроводность зависит от гидродинамики через поле скорости
// За приближение Обербека-Буссинеска отвечает параметр bBussinesk.
procedure TForm1.myVersionSIMPLEAlgorithm(bposttemperature : Boolean);
var
    i : Integer; // счётчик числа итераций.
    j : Integer; // счётчик числа шагов по времени
    rescontinity :  Float; // нескомпенсированные источники массы
    resVx, resVy, restemp :  Float; // невязка по горизонтальной и вертикальной компонентам скорости

begin
   // Здесь реализована последовательность операций
   // алгоритма С. Патанкара SIMPLE, SIMPLEC и SIMPLER
   // на основе SIMPLE. (SIMPLER = SIMPLE Revised)

   (* SIMPLER  (SIMPLE Revised) *)
   (*
    *   Патанкар стр. 111.
    *  1. Ввести предположение о поле скорости.
    *  2. Рассчитать коэффициенты уравнения количества движения
    *     и затем рассчитать u~, v~ из уравнений, таких же, как (5.26).
    *  3. Рассчитать коэффициенты уравнения для давления (5.30) и
    *     решить его с целью получения поля давления.
    *  4. Обработать это поле давления в качестве p*, решить уравнение количества
    *      движения для получения u*, v*.
    *  5. Рассчитать массовый источник [уравнение (5.23)] и затем
    *     решить уравнение поля p`.
    *  6. Скорректировать поле скорости (но не поля давления) с помощью уравнений (5,17)-(5.19).
    *  7. Решить, если это надо, дискретные аналоги для других Ф.
    *  8. Вернуться к пункту 2 и повторить расчёты до тех пор пока не будет достигнута сходимость.
    *)

   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // вся необходимая инициализация параметров уже выполнена см. вкладку инициализации в меню.


      // шаг 1: задание поля давления
      // смотри процедуру  initparamSIMPLE.

      j:=1; // инициализация
      while ((bweShouldContinue) and (j<=inumbertimestep)) do
      begin
         // в стационарном случае inumbertimestep равно 1. И это указывается явно при запуске в Run Module.
         // глобальная переменная realFlowTime
         // используется как параметр при различных вибрационных воздействиях.
         if (btimedepend) then
         begin
            realFlowTime:=realFlowTime + dTimeStep; // Текущее время при нестационарном расчёте
            rememberDensity; // запоминание плотности с предыдущего временного слоя
         end;

         if (actiVibr.bOn) then
         begin
             // передвигаем динамическую сетку
             // и задаёт скорость
             mymovingmesh;
             UpdateMap;
         end;

         i:=0; // инициализация
         rescontinity:=1e300; // очень большое число

         while ((bweShouldContinue) and (i<itercount) and (rescontinity>rcs.continity))  do
         begin
            if (i mod 10 = 0) then
            begin
               if (not(bBussinesk)) then
               begin
                  MainMemo.Lines.Add('iter  continity   x-velocity   y-velocity');
               end
                else
               begin
                  MainMemo.Lines.Add('iter  continity   x-velocity   y-velocity  temperature');
               end;
            end;

            if (bsimpler) then
            begin
               // шаг 2 и 3 (SIMPLER). расчёт коэффициентов и
               // решение уравнения для давления
               SolveGZPressure(false);
            end;

            // шаг 2: решение нелинейных уравнений движения
            // требуется всеобъемлющее тестирование программного кода
            // решение нелинейного уравнения для горизонтальной скорости
            // содержит в себе и метод Зейделя и метод переменных направлений
            if (iterSimple.bCoupledVelocitySolver) then
            begin
               SolveVxVyCoupled; // совместный солвер для компонент скорости
            end
             else
            begin
               // раздельный солвер для компонент скорости
               SolveVx; // для горизонтальной компоненты скорости
               SolveVy; // для верикальной компоненты скорости
            end;
            getrealresFlow(resVx,resVy); // вычисление невязки для компонент скорости

            // шаг 3: решение линейного  уравнения для Pamendment
            initPamendmentZero; // инициализация нулём
            // решатель для поправки давления:
            SolvePamendment(rescontinity);


            // шаг 4: коррекция давления
            // замечание: нужно писать наверно вместе с граничными условиями
            if (not(bsimpler)) then CorrectNewPressure;
            //DisplayPressure; // визуализирует  давление
            // шаг 5: коррекция компонент скорости
            CorrectVx; // коррекция горизонтальной скорости
            //DisplayXvel; // отображаем горизонтальную скорость

            CorrectVy; // коррекция вертикальной скорости
            //DisplayYvel; // отображает вертикальную скорость

            // запоминаем поле скорости удовлетворяющее уравнению неразрывности
            RememberXvel(VxOld); // запоминаем горизонтальную компоненту скорости
            RememberYvel(VyOld); // запоминаем вертикальную компоненту скорости
            // шаг 6: решение других уравнений, например для поля температур, но
            // только в том случае если они влияют на течение жидкости
            // (см. например модель Обербека-Буссинеска).
            if (bBussinesk) then
            begin
               // запоминаем поле температур с предыдущей итерации
               RememberTOldTimeStep(false); // оно может использоваться для нижней релаксации
               SolveTempSteady(false,iterSimple.iterTemperature, true); // находит коэффициенты и решает
               getrealResTemp(restemp);
            end;
            // В противном случае решение подобных уравнений лучше произвести потом.
            // шаг 7: (зацикливающий) представление скоректированного давления как нового
            // и возвращение к шагу 2.
            // печать значения невязки на консоль
            if (not(bBussinesk)) then
            begin
               MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy));
               inc(imarker);
               SetLength(myresplot,imarker);
               myresplot[imarker-1].continity:=rescontinity; // нумерация начинается от нуля
               myresplot[imarker-1].Vx:=resVx;
               myresplot[imarker-1].Vy:=resVy;
               if (imarker>1) then updatemainpaintbox; // графики невязок
            end
             else
            begin
               MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',restemp));
               inc(imarker);
               SetLength(myresplot,imarker);
               myresplot[imarker-1].continity:=rescontinity; // нумерация начинается от нуля
               myresplot[imarker-1].Vx:=resVx;
               myresplot[imarker-1].Vy:=resVy;
               myresplot[imarker-1].temperature:=restemp;
               if (imarker>1) then updatemainpaintbox; // графики невязок
            end;
            // печать значения невязки в файл
            // freport.Add(FloatToStr(rescontinity));
            i:=i+1; // увеличиваем счётчик и переходим к шагу 2.
            inc(iglobalnumberiteration); // увеличиваем глобальное количество итераций на 1
            // временное прерывание расчётов
            // для того чтобы программа смогла
            // среагировать на другие события от
            // пользователя или операционной системы.
            Application.ProcessMessages;
         end; // конец стационарных итераций.

         if ((not bBussinesk) and (bposttemperature)) then
         begin
            // если требуется просто определить поле температур
            // в случае когда оно зависит от течения жидкости, а
            // течение жидкости от него не зависит.
            SolveTempSteady(false,iterSimple.iterTemperature, true); // находит коэффициенты и решает
         end;

         // Правка давления для нормальной графической визуализации
         // дополнение до граничных условий Неймана.
         PressurePathit; // устраняет дефекты графической визуализации
         VelXPachit; // устраняет дефекты графической визуализации для горизонтальной скорости

         // Вычисляет Вихрь
         CurlConstruct;
         // минус вихрь является правой частью в уравнении
         // Пуассона для нахождения функции тока.
         // Нахождение функции тока.
         // функция тока проинициализирована нулём внутри процедуры
         // initparam2 которая входит внутрь процедуры initparamSIMPLE.
         // При нестационарном расчёте с малым шагом можно предположить,
         // что функция тока меняется достаточно медленно поэтому значение
         // функции тока с предыдущей итерации по времени является хорошим начальным приближением.
         // необходимое количество итераций задаётся на вкладке контроля алгоритма SIMPLE.
         SolveStreamFunction(false, iterSimple.iterStreamFunction);
         if (actiVibr.bOn) then
         begin
             RememberStreamFunction; // функция тока
             RememberOmega1T; // вихрь
             RememberXVelDM; // горизонтальная скорость
             RememberYVelDM; // вертикальная скорость
             if (bposttemperature) then RememberTempDM; // температура
             if (inumbertimestep mod inumbertimestepDivisionPeriod = 0) then
             begin
                // закончился один период пора собрать статистику
                CalculateMeanStreamFunction; // функция тока
                CalculateMeanOmega1T; // вихрь
                CalculateMeanXVel; // горизонтальная скорость
                CalculateMeanYVel; // вертикальная скорость
                if (bposttemperature) then CalculateMeanTempreture;
                inc(kstreamdivision);
                initmeanSF('T'); // обнуление.
                initmeanOmega('T');
                initmeanXvel('T');
                initmeanYvel('T');
                if (bposttemperature) then initmeanTemp('T');
             end;
         end;

         if (btimedepend) then
         begin
            // В случае нестационарного солвера надо
            // запомнить распределения полевых величин
            // на данном временном слое
            // для использования их на следующем временном слое.

            // запоминание скорости на данном временном слое
            RememberXvel(VxOldTimeStep); // запоминаем горизонтальную компоненту скорости
            RememberYvel(VyOldTimeStep); // запоминаем вертикальную компоненту скорости
            if (bposttemperature) then
            begin
               // Только в том случае если также рассчитывается поле температур:
               // запоминаем поле температур в переменной ToldTimeStep
               RememberTOldTimeStep(true);
            end;
            // вывод текущего времени и номера шага по времени на консоль
            MainMemo.Lines.Add('time    iter');
            MainMemo.Lines.Add(FormatFloat('#.####e-0', realFlowTime)+'   '+IntToStr(j));
         end;
         j:=j+1; // переход к следующему шагу по времени.
      end; // j временные шаги

      if (actiVibr.bOn) then
      begin
         if (kstreamdivision <> 0) then
         begin
            CalculateMeanSF(kstreamdivision); // функция тока
            CalculateMeanOmega(kstreamdivision); // вихрь
            CalculateMeanVx(kstreamdivision); // горизонтальная скорость
            CalculateMeanVy(kstreamdivision); // вертикальная скорость
            if (bposttemperature) then CalculateMeanT(kstreamdivision);
         end;
      end;


      if (bweShouldContinue = false) then
      begin
         // если нижеследующего диагностического сообщения на консоль не поступает
         // значит переменная bweShouldContinue изменяется также внутри какого-то метода.
         // Нужно проследить за переменной bweShouldContinue
         MainMemo.Lines.Add('user terminate calculating process...');
         // восстанавливаем готовность к решению
         bweShouldContinue:=true;
      end;

      // закрывает визуальную форму
      // в которой отображалась анимация
      //DisplayForm.Close;
      // сообщает о том что решение получено
      freport.SaveToFile('reportPamendment.txt');
      freport.Clear; // очистка содержимого
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      MainMemo.Lines.Add('calculation complite');
      Application.MessageBox('calculation complite','',MB_OK);
   end;


end; // myVersionSIMPLEAlgorithm


// Выбор алгоритма солвера
procedure TForm1.SelectSolvertune;
begin
   // инициализация всех
   // панелей с учётом
   // выбранных типов солвера при
   // создании приложения или в процессе его работы

    // теплопроводность
    AlgoSolver.RadioGroup1.ItemIndex:=itypesolver.itemperature-1;
    // компоненты скорости
    AlgoSolver.RadioGroup2.ItemIndex:=itypesolver.ivelocity-1;
    // поправка давления
    AlgoSolver.RadioGroup3.ItemIndex:=itypesolver.ipamendment-1;

    AlgoSolver.ShowModal; // форма выбора алгоритма солвера
end;

// выбор алгоритма солвера: Гаусс-Зейдель или переменные направления
procedure TForm1.SelectSolver1Click(Sender: TObject);
begin
   SelectSolvertune;
end;

// контролирует одну итерацию алгоритма SIMPLE
procedure TForm1.controlSimpletune;
begin
   // передача параметров хранящихся в данный момент
   // или переданных при создании главной формы  MainUnit
   controlSIMPLEForm.EVxnonlin.Text:=IntToStr(iterSIMPLE.iterVxNonLin); // нелинейность Vx
   controlSIMPLEForm.EVynonlin.Text:=IntToStr(iterSIMPLE.iterVyNonLin); // нелинейность Vy
   controlSIMPLEForm.EVxlin.Text:=IntToStr(iterSIMPLE.iterVxLin); // линейная Vx
   controlSIMPLEForm.EVylin.Text:=IntToStr(iterSIMPLE.iterVyLin); // линейная Vy
   // применять ли coupled solver для компонент скорости.
   controlSIMPLEForm.CoupledVelSolverCheckBox.Checked:=iterSimple.bCoupledVelocitySolver;
   controlSIMPLEForm.EPamendment.Text:=IntToStr(iterSIMPLE.iterPamendment); // поправка давления
   controlSIMPLEForm.Etemperature.Text:=IntToStr(iterSIMPLE.iterTemperature); // поле температур
   controlSIMPLEForm.ESF.Text:=IntToStr(iterSIMPLE.iterStreamFunction); // для функции тока
   // давление в алгоритме SIMPLER 1979
   controlSIMPLEForm.EPressure.Text:=IntToStr(iterSIMPLE.iterPressure);
   if (bsimpler) then
   begin
      controlSIMPLEForm.PanelPressure.Visible:=true;
   end
    else
   begin
      controlSIMPLEForm.PanelPressure.Visible:=false;
   end;
   controlSIMPLEForm.ShowModal; // отображает форму где можно изменить параметры
end;



// норма внутренности универсальной полевой величины U по аналогии с
// пространством C
// возвращает максимальное значение невязки.
// кубическая норма.
function TForm1.mySupNorma(const U : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   k : Integer; // Счётчики цикла for
   r :  Float; // возвращаемое значение
begin
   r:=0.0;
   
   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype <> 0) then
         begin
            r:=max(r,abs(U[i+(j-1)*icolx]));
         end;
      end; // with
   end;

   Result:=r;  // возвращает норму внутренности универсальной величины U
end; // норма внутренности универсальной полевой величины

// евклидова норма внутренности универсальной полевой величины U
// возвращает корень квадратный из суммы квадратов компонентов вектора невязки.
// для внутренней части расчётной области.
// евклидова норма.
function TForm1.myEvklidNorma(const U : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   k : Integer; // Счётчик цикла for
   r, rbuf :  Float; // возвращаемое значение
   dsum : Extended;

begin
   // инициализация
   dsum:=0.0;

   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype = 1) then
         begin
            // внутренний узел
            rbuf:=U[i+(j-1)*icolx]; // помещаем во временное хранилище
            // здесь возможно переполнение
            dsum:= dsum + rbuf*rbuf/imaxnumbernode;
         end;
      end; // with
   end;

   r:=sqrt(dsum);
   Result:=r;  // возвращает норму внутренности универсальной величины U
end; // норма внутренности универсальной полевой величины

// октаэдрическая норма внутренности универсальной полевой величины U
// возвращает сумму модулей компонент вектора невязки.
// октаэдрическая норма.
function TForm1.mySup2Norma(const U : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   k : Integer; // Счётчики цикла for
   r :  Float; // возвращаемое значение
begin
   r:=0.0;
   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype <> 0) then
         begin
            // сумма модулей компонент
            r:= r + abs(U[i+(j-1)*icolx]);
         end;
      end; // with
   end;

   Result:=r;  // возвращает норму внутренности универсальной величины U
end; // норма внутренности универсальной полевой величины

// норма разности внутренностей двух универсальных полевых
// величин U1 и U2 по аналогии с
// пространством C
function TForm1.mySupNorma2(const U1 : array of  Float;const U2 : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   i, j : Integer; // Счётчики
   r :  Float; // возвращаемое значение
begin
   r:=abs(U1[2+icolx]-U2[2+icolx]);
   for i:=2 to (icolx-1) do
   begin
      for j:=2 to (icoly-1) do
      begin
         r:=max(r,abs(U1[i+(j-1)*icolx]-U2[i+(j-1)*icolx]));
      end; // j
   end; // i

   Result:=r;  // возвращает норму разности внутренностей универсальных величин U1 и U2
end; // норма разности U1 и U2

// функция вычисляет невязку уравнения
function TForm1.myResidual( const U : array of  Float;
                            icolx : Integer;
                            icoly : Integer;
                            const map : TdynArraymyNode; // карта обхода
                            chvariable : Char; // для какой переменной решается
                            const m : array of MatrixCoef;
                            const db : array of  Float) :  Float;

var
    myrU : array of  Float; // невязка
    ini, isi, iwi, iei, ipi : Integer; // индексы коэффициентов на пятиточечном шаблоне
    i1,j1,k : Integer; // Счётчики
    r :  Float; // возвращаемый результат
    ilengthmap : Integer;

begin
   // выделение памяти  под невязки
   SetLength(myrU,icolx*icoly+1);
   // инициализация
   for i1:=1 to icolx do
   begin
      for j1:=1 to icoly do
      begin
         myrU[i1+(j1-1)*icolx]:=0.0;
      end;
   end;

   r:=0.0;

   ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
          end;
    end;

   for k:=1 to (ilengthmap) do
   begin
      with map[k] do
      begin
         if (itype = 1) then
         begin
            ini:= i + j*icolx;  // север
            isi:= i + (j-2)*icolx; // юг
            iwi:= (i-1)+(j-1)*icolx; // запад
            iei:= (i+1)+(j-1)*icolx; // восток
            ipi:= i+(j-1)*icolx; // текущая точка
            myrU[ipi]:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi];
         end;
      end;
   end;


   case ibasenorma of
     1 : // евклидова норма
         begin
            r:=myEvklidNorma(myrU,icolx,icoly);
         end;
     2 : // кубическая норма
         begin
            r:=mySupNorma(myrU,icolx,icoly);
         end;
     3 : // октаэдрическая норма
         begin
            r:=mySup2Norma(myrU,icolx,icoly);
         end;
   end;

   Result:=r;

end; // myResidual

// вызывает форму где можно задать параметры релаксации
procedure TForm1.RelaxationFactorstune;
begin
   // передача в форму текущих параметров релаксации
    // для алгоритма SIMPLE
    RelaxFactorsForm.ExVel.Text:=FloatToStr(myrelaxfactors.xVelRelax); // Vx
    RelaxFactorsForm.EyVel.Text:=FloatToStr(myrelaxfactors.yVelRelax); // Vy
    if (bsimplec) then
    begin
       RelaxFactorsForm.GroupBoxPressure.Visible:=false;
    end
     else
    begin
       RelaxFactorsForm.GroupBoxPressure.Visible:=true;
       RelaxFactorsForm.EPressure.Text:=FloatToStr(myrelaxfactors.PressureRelax); // Pressure
    end;
    // SOR для уравнения поправки давления.
    RelaxFactorsForm.ESORPamendment.Text:=FloatToStr(myrelaxfactors.pSORPressure); // SOR для поправки давления
    RelaxFactorsForm.ESORVx.Text:=FloatToStr(myrelaxfactors.pSORVelocityVx); // горизонтальная скорость
    RelaxFactorsForm.ESORVy.Text:=FloatToStr(myrelaxfactors.pSORVelocityVy); // вертикальная скорость
    RelaxFactorsForm.ESORTempretrure.Text:=FloatToStr(myrelaxfactors.pSORTempreture); // температура
    if (bBussinesk) then
    begin
       RelaxFactorsForm.GroupBoxBussinesk.Visible:=true;
       // При моделировании естественной конвекции при больших
       // числах Релея желательно замедлить измение источникового члена от итерации к итерации.
       RelaxFactorsForm.EBodyForce.Text:=FloatToStr(myrelaxfactors.prelaxBodyForce); // нижняя релаксация
    end
     else
    begin
       RelaxFactorsForm.GroupBoxBussinesk.Visible:=false;
    end;
    // вызывает меню, где можно задать параметры релаксации
    RelaxFactorsForm.ShowModal;
end;

// вызывает форму где можно задать параметры релаксации
procedure TForm1.RelaxationFactors1Click(Sender: TObject);
begin
   RelaxationFactorstune;
end;

// аппроксимация конвективного члена и алгоритм решения
procedure TForm1.Methodstune;
begin
   // устанавливет текущую выбранную
   // схему аппроксимации конвективного члена
   ApproxConvectionForm.RadioGroup1.ItemIndex:=ishconv-1;
   // Устанавливает выбранный алгоритм решения:
   // Pressure-Velocity Coupling
   if (not bsimplec) then
   begin
      if (bsimpler) then
      begin
         // Алгоритм SimpleR
         ApproxConvectionForm.RadioGroup2.ItemIndex:=2;
      end
       else
      begin
         // Алгоритм SIMPLE
         ApproxConvectionForm.RadioGroup2.ItemIndex:=0;
      end;
   end
   else
   begin
      // Алгоритм SIMPLEC
      ApproxConvectionForm.RadioGroup2.ItemIndex:=1;
   end;
   // вызывает меню где можно выбрать аппроксимацию
   // конвективного члена
   ApproxConvectionForm.ShowModal;
end;

// выбор схемы аппроксимации конвективного члена
procedure TForm1.ApproxConvection1Click(Sender: TObject);
begin
   Methodstune;
end;

// решает стационарную задачу чистой теплопроводности
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций !
procedure TForm1.RunCleanThermalConductionSteady;
begin

   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // универсальная процедура решения,
      // содержащая вычисление коэффициентов дискретного аналога
      // а также два решателя: ГЗ и гибрид: ГЗ-Томас - метод продольно поперечной прогонки
      // Третий параметр false означает что конвективный член не учитывается.
      SolveTempSteady(true, itercount, false);

      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // сообщает о том что решение получено
      MainMemo.Lines.Add('calculation complite');
      Application.MessageBox('calculation complite','',MB_OK);
   end;
end; // RunCleanThermalConductionSteady

// решает стационарную задачу теплопроводности с учётом конвекции
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций !
procedure TForm1.RunConvectiveThermalConductionSteady;
begin
   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // универсальный решатель,
      // включающий в себя процедуру
      // нахождкения коэффициентов дискретного аналога,
      // а также содержащий два решателя:
      // 1 - ГЗ и 2 - гибридный ГЗ-Томас.
      // 3 - прямой метод Гаусса,
      // 4 - метод сопряжённых градиентов Хестенса и Штифеля
      SolveTempSteady(true, itercount, true);  // решает

      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // сообщает о том что решение получено
      MainMemo.Lines.Add('calculation complite');
      Application.MessageBox('calculation complite','',MB_OK);
   end;
end; // RunConvectiveThermalConductionSteady

// вызывает меню, где можно выбрать
// уравнения подлежащие решению
procedure TForm1.EquationTune;
begin
   // инициализирует форму выбора
    ModelEquationForm.RadioGroup1.ItemIndex:=imodelEquation - 1;
    ModelEquationForm.oldeq:=imodelEquation-1;
    // показывает форму выбора
    ModelEquationForm.ShowModal; // вызывает форму выбора
    myInitializationRestart; // всё придётся инициализировать заново: выделение памяти и присвоение значений.
end;

// вызывает меню, где можно выбрать
// уравнения подлежащие решению
procedure TForm1.Equation1Click(Sender: TObject);
begin
   EquationTune;
end; // Equation1Click

// решает нестационарную задачу чистой теплопроводности
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций,
// шаг по времени, количество шагов по времени, начальное время.
procedure TForm1.RunCleanThermalConductionUnsteady;
begin
   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // универсальная процедура,
      // включающая в себя нахождение коэффициентов
      // дискретного аналога и четыре солвера
      // 1 - Гаусс-Зейдель и 2 - метод переменных направлений.
      // 3 - прямой метод Гаусса, 4 - метод сопряжённых градиентов.
      // параметр false - означает что решается чистая теплопроводность.
      SolveTempUnsteady(false); // решает

      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // сообщает о том что решение получено
      MainMemo.Lines.Add('calculation complite');
      Application.MessageBox('calculation complite','',MB_OK);
   end;
end; // RunCleanThermalConductionUnsteady

// решает нестационарную задачу теплопроводности с учётом конвекции
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций на временном слое
// начальное время, шаг по времени и количество шагов по времени.
procedure TForm1.RunConvectiveThermalConductionUnsteady;
begin
   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // улучшенный универсальный солвер:
      // содержит код вычисляющий коэффициенты плюс
      // два солвера:
      // 1 - на основе Гаусса-Зейделя, а также
      // 2 - на основе алгоритма трёхдиагональной матрицы
      // 3 - прямой метод Гаусса, 4 - метод сопряжённых градиентов.
      // Параметр true - означает, что решается теплопроводность
      // с учётом конвективного члена
      SolveTempUnsteady(true);

      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // сообщает о том что решение получено
      MainMemo.Lines.Add('calculation complite');
      Application.MessageBox('calculation complite','',MB_OK);
   end;
end; // RunConvectiveThermalConductionUnsteady

// Реализация прямого метода исключения Гаусса.
// задача решить СЛАУ Ax = b
// Дано A и b. Найти x.
// Критика:
// 1. Данная реализация прямого метода исключения Гаусса
// не делает выбор главного разршающего элемента (это никчему т.к.
// консервативный метод дискретизации С. Патанкара МКО обеспечивает диагональное
// преобладание матрицы СЛАУ).
// 2.  Главный недостаток данной реализации использование огромного
// количества оперативной памяти для хранения нулевых элементов матрицы.
// Т.е. данный алгоритм никаким образом не использует 5-диагональную структуру матрицы СЛАУ.
// В этом плане реализация поточечного последовательного метода Гаусса-Зейделя гораздо более
// экономична по памяти. Более того учёт разреженности матрицы в алгоритме Гаусса чрезвычайно затруднителен
// и не имеет эффективного решения. См. Тьюарсон.
// Тем не менее сейчас хранится только лента для ленточной матрицы А размером
// 2*icolx+1 на isize. Это существенно ускоряет метод Гаусса и сокращает расходы по памяти.
// 3. Характер данного метода не уточняющий. Уточняющий метод берёт начальное приближение
// и в результате своей работы улучшает это начальное приближение до заданного значения невязки.
// Методу Гаусса неважно скакого начального приближения он стартует. Более того после окончания его работы
// мы имеем полностью сошедшееся решение (т.е. абсолютно точное в идеале, что не всегда нужно.)
// Достоинства.
// Если добавить в алгоритм выбор главного элемента, то получится
// робастый алгоритм работающий даже с очень плохими матрицами
// (под тем что матрица плоха понимается её плохая обусловленность.)
// Данный алгоритм запрограммирован при помощи книжки У.Г.Пирумова.
// Замечание: обрабатываемые матрицы достаточно велики, и передаются по ссылке,
// чтобы избежать потерь времени на выделение памяти. Данный алгоритм портит матрицу
// изменяя её элементы.
// Теперь в реализации данного метода учтено что ненулевые элементы
// матрицы содержатся только внутри ленты ширины 2*icolx+1. это учитывается
// и влияет на скорость работы алгоритма - теперь алгоритм действительно быстр
// и относительно немного времени уходит только на выделение оперативной памяти для хранения ленты.
// Гаусс Карл Фридрих 1777-1855.
procedure TForm1.GaussAlgorithm(isize : Integer; // размер квадратной матрицы
                                var dA : array of TmyDynArray; // матрица СЛАУ
                                icolx : Integer; // количество узлов по горизонтали
                                icoly : Integer; // количество узлов по вертикали
                                const move : array of Integer; // для ленточной матрицы
                                var dV : array of  Float; // вектор правой части
                                var dx : array of  Float; // результат вычисления
                                bmessage : Boolean);
const
    epsilon = 1e-3;

var
   i,j,k : Integer; // Счётчики циклов
   dCik, dSum :  Float;
   //str : string; // для распечатки матрицы

begin
   // ненулевые элменты матрицы содержатся только внутри полосы
   // шириной 2*icolx+1. В алгоритме это учитывается.
   // Есть задачи для которых inx мало для них ширина полосы мала
   // и эффективность алгоритма на таких задачах особенно высока


   (*
   // распечатка матрицы СЛАУ для анализа
   for i:=0 to (2*icolx) do
   begin
      for j:=0 to (isize-1) do
      begin
         str:=str+FloatToStr(dA[i][j]) + ' ';
      end;
      freport.Add(str);
      str:='';
   end;
   freport.SaveToFile('Gauss matrix.txt');
   freport.Clear; // очистка содержимого
   *)


   // массивы dA и dV передаются в данную
   // процедуру по ссылке, это означает что
   // на время работы данной процедуры
   // все операции производятся над самими данными
   // и массивы портятся.

   try

   for i:=0 to (isize-1) do dx[i]:=0.0; // инициализация вектора dx

   // прямой ход метода Гаусса
   // приведение к верхнетреуголному виду

   // по всем столбцам слева направо, т.е.
   // для k:= 0.. (isize-1)
   for k:=0 to (isize-1) do
   begin
      // цикл по всем строкам ниже строки с номером k
      for i:=k+1 to min((k+icolx),(isize-1)) do
      begin
         // применяется только в случае
         // если элемент ненулевой
         // это должно несколько ускорить счёт.
         if (abs(dA[i][k+move[i]])>1e-300) then
         begin
            if (dA[k][k+move[k]] < epsilon) then dA[k][k+move[k]]:=1.0;
            // обработка фиксированной строки с номером i
            dCik := (dA[i][k+move[i]]/dA[k][k+move[k]]);
            // здесь предполагается
            // что двумерные массивы
            // отображаются на одномерные
            // с учётом отображения i+(j-1)*inx.
            for j:=k to min((k+icolx),(isize-1)) do
            begin
               // преобразование матрицы к верхнетреугольному виду
               dA[i][j+move[i]] := dA[i][j+move[i]] - dCik*dA[k][j+move[k]];
            end;
            // преобразование правой части
            dV[i] := dV[i] - dCik*dV[k];
         end;
      end;
   end;

   // печать диагностического сообщения
   if (bmessage) then
   begin
      MainMemo.Lines.Add('матрица СЛАУ приведена к верхнетреугольному виду ');
   end;

   // Теперь, когда матрица СЛАУ приведена к верхнетреугольному виду
   // можно совершить обратный ход метода Гаусса.
   for k:=(isize-1) downto 0 do
   begin
      dSum:=0.0; // обнуление сумматора
      for i:= k+1 to min((k+icolx),(isize-1)) do
      begin
         dSum := dSum + dA[k][i+move[k]]*dx[i];
      end;
      if (dA[k][k+move[k]] < epsilon) then dA[k][k+move[k]]:=1.0;
      dx[k] := (dV[k] - dSum)/dA[k][k+move[k]];
   end;

   except
      MainMemo.Lines.Add('exception Gauss: division by zero');
   end;

end; // GaussAlgorithm()

// LU разложение
procedure TForm1.LUdecomposition(isize : Integer; // размер квадратной матрицы
                                var dA : array of TmyDynArray; // матрица СЛАУ
                                icolx : Integer; // количество узлов по горизонтали
                                icoly : Integer; // количество узлов по вертикали
                                const move : array of Integer; // для ленточной матрицы
                                var dV : array of  Float; // вектор правой части
                                var dx : array of  Float; // результат вычисления
                                bmessage : Boolean);
var
     i,j,k : Integer; // Счётчики циклов
     dy : array of Float;
     dsum : Float;
begin
    (*  сначала запишем алгоритм для полностью заполненой матрицы
     *  for k:=0 to isize-2 do
     *  begin
     *     for j:=k+1 to isize-1 do
     *     begin
     *        dA[k][j]:=dA[k][j]/dA[k][k];
     *        for i:=k+1 to isize-1 do
     *        begin
     *            dA[i][j]:=dA[i][j]-dA[i][k]*dA[k][j];
     *        end;
     *     end;
     *  end;
     *  Теперь для ленточной матрицы:
    *)
       // LU разложение:
       for k:=0 to (isize-2) do
       begin
          for j:=k+1 to min((k+icolx),(isize-1)) do
          begin
             dA[k][j+move[k]]:=dA[k][j+move[k]]/dA[k][k+move[k]];
             dV[k]:=dV[k]/dA[k][k+move[k]]; // преобразование правой части
             for i:=k+1 to min((k+icolx),(isize-1)) do
             begin
                 dA[i][j+move[i]]:=dA[i][j+move[i]]-dA[i][k+move[i]]*dA[k][j+move[k]];
             end;
          end;
       end;

       SetLength(dy,isize);
       for i:=0 to isize-1 do dy[i]:=0.0;
       // замена вперёд.
       (*  dy[0]:=dV[0]/L[1][1];
        *  dy[i]:=(1/L[i][i])*(dV[i]-Sum(j,i-1,L[i][j]*dy[j]));
        *  в матрице L на главной диагонали стоят единицы.
       *)
       dy[0]:=dV[0];
       for i:=1 to isize-1 do
       begin
          dsum:=0.0;
          for j:=max(0,i-icolx) to (i-1) do dsum:=dsum+dA[i][j+move[i]]*dy[j];
          dy[i]:=1.0*(dV[i]-dsum);
       end;

       for i:=0 to (isize-1) do dx[i]:=0.0;
       // обратная замена
       (*  dx[isize-1]:=dy[isize-1]/U[isize-1][isize-1];
        *  dx[i]:=(1/U[i][i])*(dy[i]-Sum(i+1,isize-1,U[i][j]*dx[j]));
        *                            j
        *)
        dx[isize-1]:=dy[isize-1]/dA[isize-1][isize-1+move[isize-1]];
        for i:=(isize-2) downto 0 do
        begin
           dsum:=0.0;
           for j:=(i+1) to min((i+icolx),(isize-1)) do dsum:=dsum + dA[i][j+move[i]]*dx[j];
           dx[i]:=(1/dA[i][i+move[i]])*(dy[i]-dsum);
        end;

end; // LUdecomposition

// Метод Сопряжённых Градиентов и всё что с ним связано

// скалярное произведение двух векторов
function TForm1.Scal(isize : Integer;
                     const dV1 : array of  Float;
                     const dV2 : array of  Float) :  Float;
var
    ds :  Float;
    i : Integer;
begin
   ds:=0.0; // инициализация
   for i:=0 to (isize-1) do
   begin
      ds:= ds + dV1[i]*dV2[i];
   end;
   Result:=ds;
end; // Scal

// умножение матрицы на вектор
procedure TForm1.MatrixByVector(isize : Integer;
                                const dH : array of TmyDynArray;
                                const dV : array of  Float;
                                var dx : array of  Float);
var i,j : Integer;
    dsum :  Float;
begin
   dsum:=0.0; // инициализация
   for i:=0 to (isize-1) do dx[i]:=0.0; // обнуление
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         dsum:= dsum + dV[j]*dH[i][j];
      end;
      dx[i]:=dsum;
      dsum:=0.0; // обнуление сумматора
   end;
end;  // MatrixByVector

// норма вектора
// как корень квадратный из суммы квадратов
function TForm1.NormaV(isize : Integer;
                       const dV : array of  Float) :  Float;
var
    i : Integer; // счётчик цикла
    dnorma, dsum :  Float;
begin
   // инициализация переменных
   dsum:=0.0;
   for i:=0 to (isize-1) do
   begin
      dsum:= dsum + dV[i]*dV[i];
   end;
   dnorma:=sqrt(dsum); // норма вектора
   Result:=dnorma;
end; // NormaV

// норма вектора
// как максимальное значение среди модулей компонент вектора
// кубическая норма.
function TForm1.NormaSupV(isize : Integer;
                       const dV : array of  Float) :  Float;
var
    i : Integer; // счётчик цикла
    dmax :  Float; // будущее значение нормы вектора
begin
   // инициализация переменных
   dmax:=-1.0; // отрицательное число
   for i:=0 to (isize-1) do
   begin
      dmax:= max(dmax, abs(dV[i]));
   end;
    // норма вектора
   Result:=dmax;
end; // NormaSupV

// норма вектора
// сумма модулей компонент вектора
// октаэдрическая норма.
function TForm1.NormaSup2V(isize : Integer;
                       const dV : array of  Float) :  Float;
var
    i : Integer; // счётчик цикла
    dsum :  Float; // будущее значение нормы вектора
begin
   // инициализация переменных
   dsum:=0.0; // обнуление сумматора
   for i:=0 to (isize-1) do
   begin
      dsum:= dsum + abs(dV[i]);
   end;
    // норма вектора
   Result:=dsum;
end; // NormaSup2V

// Для применения метода сопряжённых градиентов
// с использованием технологии
// хранения разреженной матрицы CRS
// потребуется реализация алгоритма быстрой сортировки

// Запрограммировано с использованием
// Брайан Керниган и Дени Ритчи "The C Programming Language".
// Swap : Обмен местами list[i] и list[j]
procedure TForm1.Swap(var list : array of TmyNonZeroElemMatrix;
                          i : Integer;
                          j : Integer);
var
    temp :  TmyNonZeroElemMatrix;

begin
   // Если стек переполнен и отладчик остановился здесь на
   // строке begin, значит скрее всего быстрая сортировка Хоара
   // вызвала переполнение стека вложеннных вызовов.
   // Выход заменить её пирамидальной сортировкой.

   // cgange list[i] <-> list [j]

   // temp = list[i];
   temp.i:=list[i].i;
   temp.j:=list[i].j;
   temp.aij:=list[i].aij;
   temp.key:=list[i].key;
   // list[i] = list[j];
   list[i].i:=list[j].i;
   list[i].j:=list[j].j;
   list[i].aij:=list[j].aij;
   list[i].key:=list[j].key;
   // list[j] = temp;
   list[j].i:=temp.i;
   list[j].j:=temp.j;
   list[j].aij:=temp.aij;
   list[j].key:=temp.key;

end; // Swap

// Вот алгоритм PivotList
// он возвращает точку деления элементов массива на две части.
// Запрограммировано с использованием книжки ДЖ. Макконел
// Анализ алгоритмов стр. 106.
function TForm1.PivotList(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer) : Integer;
var
   PivotValue : Integer;
   PivotPoint : Integer; // возвращаемая позиция точки разделения
   index : Integer; // счётчик цикла for

begin
   // list обрабатываемый список
   // first номер первого элемента
   // last номер последнего элемента

   PivotValue := list[first].key;
   PivotPoint := first;

   for index:=(first+1) to last do
   begin
      if (list[index].key < PivotValue) then
      begin
         PivotPoint := PivotPoint + 1;
         Swap(list, PivotPoint, index);
      end;
   end;

   Swap(list, first, PivotPoint);

   Result := PivotPoint;

end; // PivotList

// Быстрая сортировка Хоара.
// Это рекурсивный алгоритм который эффективен по быстродействию
// но возможно не эффективен по памяти.
// Быстрая сортировка применяется здесь для упорядочивания достаточно больших
// массивов данных.
// Запрограммировано с использованием Дж. Макконел Анализ алгоритмов стр. 106.
procedure TForm1.QuickSort(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer);
var
    Pivot : Integer;

begin
   // list упорядочиваемый список элементов
   // first номер первого элемента в сортируемой части списка
   // last номер последнего элемента в сортируемой части списка

   if (first < last) then
   begin
      Pivot := PivotList(list, first, last);
      QuickSort(list, first, Pivot-1);
      QuickSort(list, Pivot+1, last);
   end;

end; // QuickSort

// Пирамидальная сортировка

// Переформировать пирамиду
procedure TForm1.FixHeap(var list : array of TmyNonZeroElemMatrix;
                          root : Integer;
                          m : TmyNonZeroElemMatrix;
                          bound : Integer);
var
    vacant : Integer;
    largerChild : Integer;

begin
   // list сортируемый список пирамида
   // root номер корня пирамиды
   // m ключевое значение вставляемое в пирамиду
   // bound правая граница (номер) в пирамиде
   vacant:=root;
   while (2*vacant <= bound) do
   begin
      largerChild:=2*vacant;

      // поиск наибольшего из двух непосредственных потомков
      if ((largerChild<bound) and (list[largerChild+1].key>list[largerChild].key)) then
      begin
         largerChild:=largerChild + 1;
      end;

      // находится ли ключ выше текущего потомка ?
      if (m.key > list[largerChild].key) then
      begin
         // да, цикл завершается
         break;
      end
      else
      begin
         // нет, большего непосредственного потомка
         // следует поднять
         list[vacant].i:=list[largerChild].i;
         list[vacant].j:=list[largerChild].j;
         list[vacant].aij:=list[largerChild].aij;
         list[vacant].key:=list[largerChild].key;
         vacant:=largerChild;
      end;
   end;
   list[vacant].i:=m.i;
   list[vacant].j:=m.j;
   list[vacant].aij:=m.aij;
   list[vacant].key:=m.key;
end; // FixHeap

// Пирамидальная сортировка оптимальна как
// по памяти, так и по быстродействию, к тому же её алгоритм
// очень интересен.
// Ограничение состоит в том, что нумерация массива должна начинаться с 1.
procedure TForm1.HeapSort(var list : array of TmyNonZeroElemMatrix;
                              n : Integer);
var
   i : Integer; // счётчик
   max : TmyNonZeroElemMatrix; // элемент с наибольшим значением ключа

begin
    // конструирование пирамиды
    for i:=(n div 2) downto 1 do
    begin
       FixHeap(list, i, list[i], n);
    end;
    for i:=n downto 2 do
    begin
       // скопировать корень пирамиды в список
       // переформировать пирамиду
       max.i:=list[1].i;
       max.j:=list[1].j;
       max.aij:=list[1].aij;
       max.key:=list[1].key;
       FixHeap(list, 1, list[i], i-1);
       list[i].i:=max.i;
       list[i].j:=max.j;
       list[i].aij:=max.aij;
       list[i].key:=max.key;
    end;
end; // HeapSort

// умножение матрицы на вектор
// используя формат хранения CRS
// Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
// Запрограммировано с использованием
// 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
// 2. Р. Тьюарсон "Разреженные матрицы".
// Массивы передаются по ссылке дабы избежать переполнения стека.
procedure TForm1.MatrixCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of  Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of  Float; // заданный вектор на который производится умножение
                                var dx : array of  Float);  // результат умножения заносится в dx.
var
     i,j : Integer; // счётчики цикла for
begin

   for i:=0 to (isize-1) do
   begin
      dx[i]:=0.0;

      for j:=row_ptr[i] to (row_ptr[i+1]-1) do
      begin
         dx[i] := dx[i] + val[j]*dV[col_ind[j]];
      end;

   end;

end;  // MatrixCRSByVector

// умножение транспонированной матрицы на вектор
// используя формат хранения CRS
// Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
// Запрограммировано с использованием
// 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
// 2. Р. Тьюарсон "Разреженные матрицы".
procedure TForm1.MatrixTransposeCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of  Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of  Float; // заданный вектор на который производится умножение
                                var dx : array of  Float);  // результат умножения заносится в dx.
var i,j : Integer; // счётчики цикла for
begin

   for i:=0 to (isize-1) do dx[i]:=0.0; // обнуление

   for j:=0 to (isize-1) do
   begin

      for i:=row_ptr[j] to (row_ptr[j+1]-1) do
      begin
         dx[col_ind[i]] := dx[col_ind[i]] + val[i]*dV[j];
      end;

   end;

end;  // MatrixTransposeCRSByVector

// Метод Сопряжённых градиентов
// Хестенса Штифеля
// см. например, дисер Н.Г. Бураго
// или Г.И. Марчук методы вычислительной математики
// Метод сопряжённых градиентов также описан в книжке
// С.М. Устинов, В.А. Зимницкий Вычислительная математика на стр. 86-90.
// Есть некоторые отличия, требуется исследование.
procedure TForm1.SoprGrad(isize : Integer; // размер квадратной матрицы
                          const dA : array of TmyDynArray; // матрица СЛАУ
                          const dV : array of  Float;  // вектор правой части
                          const dX0 : array of  Float; // вектор начального приближения
                          var dres : array of  Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение сверху на количество итераций
                          epsilon :  Float); // точность вычисления
var
    i,k : Integer; // счётчики
    dy, dx, dax, dap, dz, dz1, dp : array of  Float;  // динамические массивы
    dar, dbr, dnz :  Float;

begin

   // выделение памяти
   // под динамические массивы
   SetLength(dy,isize);
   SetLength(dx,isize);
   SetLength(dax,isize);
   SetLength(dap,isize);
   SetLength(dz,isize);
   SetLength(dz1,isize);
   SetLength(dp,isize);

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for i:=0 to (isize-1) do dx[i]:=dX0[i+1];

   MatrixByVector(isize, dA, dx, dax); // результат dA*dx занесён в dax
   // вычисление вектора невязки начального приближения
   for i:=0 to (isize-1) do dz[i]:= dV[i] - dax[i];

   if (Scal(isize, dz, dz) <> 0.0) then
   begin
      for i:=0 to (isize-1) do dp[i]:=dz[i];
      k:=0; // номер итерации
      dnz:=1e300; // начальное значение невязки (инициализация)
      while ((k < kend) and (dnz > epsilon)) do
      begin
         MatrixByVector(isize, dA, dp, dap); // результат dA*dp занесён в dap
         dar := Scal(isize, dz, dp) / Scal( isize, dz, dap);
         for i:=0 to (isize-1) do
         begin
            dy[i] := dx[i] + dar*dp[i];
            dz1[i] := dz[i] - dar*dap[i];
         end;
         // здесь реализованы все три нормы
         // вообще говоря они все эквивалентны
         case ibasenorma of
            1 : dnz := NormaV(isize, dz1); // евклидова
            2 : dnz := NormaSupV(isize, dz1); // кубическая норма
            3 : dnz := NormaSup2V(isize, dz1);// октаэдрическая норма
         end;
         if (bconsole_message) then
         begin
            // печать значения невязки на консоль
            if (k mod 10 = 0) then MainMemo.Lines.Add('residual ');
            MainMemo.Lines.Add(FloatToStr(dnz));
         end;
         dbr := Scal(isize, dz1, dap) / Scal(isize, dp, dap);
         for i:=0 to (isize-1) do
         begin
            dp[i] := dz1[i] - dbr*dp[i];
            dz[i] := dz1[i];
            dx[i] := dy[i];
         end;
         k:= k+1; // переход к следующей итерации
         // если процесс расходится его надо остановить
         if (dnz > 1e7) then
         begin
            // восстановление начального приближения
            for i:=0 to (isize-1) do dy[i]:=dX0[i+1];
            MainMemo.Lines.Add('вычислительный процесс расходится ');
            Application.MessageBox('divergence SoprGrad solver ','',MB_OK);
            break; // и останов процесса
         end;
      end;
      // возвращение результата
      for i:=0 to (isize-1) do dres[i]:=dy[i];
   end
   else
   begin
      // возвращает начальное приближение
      for i:=0 to (isize-1) do dres[i]:=dx[i];
   end;

   // освобождение памяти выделенной под динамические массивы
   Finalize(dy);  Finalize(dx);
   Finalize(dax); Finalize(dap);
   Finalize(dz); Finalize(dz1);
   Finalize(dp);

end;  // SoprGrad


// Метод Сопряжённых градиентов
// Хестенса и Штифеля 1952 год.
// см. например, диссертацию Н.Г. Бураго  стр. 88.
// или Г.И. Марчук методы вычислительной математики
// здесь применена технология CRS хранения и обработки разреженной матрицы.
// Этот алгоритм подходит не только для SPD - Symmetric and Positively Defined матриц.
// SPD - Самосопряжённые и положительно определённые матрицы.
// В зависимости от значения передаваемого параметра bGaussTransform
// в нём примененяется или не применяется трансформация Гаусса.
// Трансформация Гаусса состоит в домножении СЛАУ на транспонированную матрицу слева,
// что позволяет из любой СЛАУ получить СЛАУ с положительно определённой самосопряжённой матрицей.
// Однако трансформация Гаусса сильно портит число обусловленности матрицы (спектр матрицы) возводя его в квадрат.
procedure TForm1.SoprGradCRS(isize : Integer; // размер квадратной матрицы
                          const val : array of  Float; // матрица СЛАУ
                          const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                          const row_ptr : array of Integer; // информация о началах строк
                          const dV : array of  Float;  // вектор правой части
                          const dX0 : array of  Float; // вектор начального приближения
                          var dres : array of  Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение на максимальное количество итераций
                          bGaussTransform : Boolean; // выполнять ли трансформацию Гаусса
                          epsilon :  Float); // точность вычисления
var
    i,k : Integer; // счётчики
    dx, dax, dap, dg, dp : array of  Float;  // динамические массивы
    dbuf : array of  Float; // временное хранилище необходимое при трансформации Гаусса
    dar, dbr, dnz, dscalgg :  Float;

begin

   // выделение памяти
   // под динамические массивы
   SetLength(dx,isize);  // искомое решение системы
   SetLength(dax,isize); // результаты умножения
   SetLength(dap,isize); // матрицы на вектор
   SetLength(dg,isize); // вектор градиента
   SetLength(dp,isize); // вектор сопряжённого направления поиска
   // для трансформации Гаусса
   SetLength(dbuf,isize); // временное хранилище при выполнении трансформации Гаусса

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for i:=0 to (isize-1) do dx[i]:=dX0[i+1];

   // Первоначально без применения трансформации Гаусса.
   MatrixCRSByVector(isize, val, col_ind, row_ptr, dx, dax); // результат занесён в dax
   for i:=0 to (isize-1) do dg[i]:= dV[i] - dax[i];  // начальная невязка

   if ( bGaussTransform) then
   begin
      // Если трансформация Гаусса всё-же требуется.
      for i:=0 to (isize-1) do dbuf[i]:= dg[i];  // временная копия начальной невязки
      MatrixTransposeCRSByVector(isize, val, col_ind, row_ptr, dbuf, dg); // результат занесён в dg:=At*dbuf;
   end;

   if (Scal(isize, dg, dg) <> 0.0) then
   begin
      for i:=0 to (isize-1) do dp[i]:=dg[i]; // p0:=g0;
      k:=0; // номер итерации
      dnz:=1e300; // начальное значение невязки (инициализация)
      while ((k < kend) and (dnz > epsilon)) do
      begin
         if ( bGaussTransform) then
         begin
            // выполняется трансформация Гаусса.
            MatrixCRSByVector(isize, val, col_ind, row_ptr, dp, dbuf); // результат занесён в dbuft1
            MatrixTransposeCRSByVector(isize, val, col_ind, row_ptr, dbuf, dap); // результат At*A*dp занесён в dap
         end
         else
         begin
            // Трансформация Гаусса не выполняется.
            MatrixCRSByVector(isize, val, col_ind, row_ptr, dp, dap); // результат A*dp занесён в dap
         end;
         dscalgg:= Scal(isize, dg, dg);
         dar :=  dscalgg / Scal( isize, dap, dp);
         for i:=0 to (isize-1) do
         begin
            dx[i] := dx[i] + dar*dp[i];
            dg[i] := dg[i] - dar*dap[i];
         end;
         // здесь реализованы все три нормы
         // вообще говоря они все эквивалентны
         case ibasenorma of
            1 : dnz:=NormaV(isize, dg); // евклидова
            2 : dnz:=NormaSupV(isize, dg); // кубическая норма
            3 : dnz:=NormaSup2V(isize, dg);// октаэдрическая норма
         end;
         if (imodelEquation < 3) then
         begin
            // график невязки
            inc(imarker);
            SetLength(myresplot,imarker);
            myresplot[imarker-1].temperature:=dnz; // нумерация начинается от нуля
            if (imarker>1) then updatemainpaintbox; // графики невязок
         end;
         if (bconsole_message) then
         begin
            // печать значения невязки на консоль
            if (k mod 10 = 0) then MainMemo.Lines.Add('residual');
            MainMemo.Lines.Add(FormatFloat('#.####e-0',dnz));
         end;
         dbr := Scal(isize, dg, dg) / dscalgg;
         for i:=0 to (isize-1) do
         begin
            dp[i] := dg[i] + dbr*dp[i];
         end;
         k:= k+1; // переход к следующей итерации
         // если процесс расходится его надо остановить
         if (dnz > 1e7) then
         begin
            // восстановление начального приближения
            for i:=0 to (isize-1) do dx[i]:=dX0[i+1];
            MainMemo.Lines.Add('вычислительный процесс расходится ');
            Application.MessageBox('divergence SoprGrad solver ','',MB_OK);
            break; // и останов процесса
         end;
      end;
      // возвращение результата
      for i:=0 to (isize-1) do dres[i]:=dx[i];
   end
    else
   begin
      // возвращает начальное приближение
      for i:=0 to (isize-1) do dres[i]:=dX0[i+1];
   end;

   // освобождение памяти выделенной под динамические массивы
   Finalize(dx); // уточняемая величина в результате итерационного процесса
   Finalize(dax); Finalize(dap); // результаты умножения матрицы на вектор
   Finalize(dg); Finalize(dp); // векторы градиента и сопряжённого направления поиска.
   Finalize(dbuf);

end;  // SoprGradCRS

// алгоритм Ю.Г.Соловейчика [1993]
// для возможно несимметричных матриц.
// Запрограммировано по практикуму
// "Численные методы решения систем уравнений" [2004]
// Новосибирского Государственного Технического Университета.
procedure TForm1.SoloveichikAlg(isize : Integer; // размер квадратной матрицы
                         const val : array of  Float; // матрица СЛАУ
                         const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                         const row_ptr : array of Integer; // информация о началах строк
                         const dV : array of  Float;  // вектор правой части
                         const dX0 : array of  Float; // вектор начального приближения
                         var dres : array of  Float; // вектор результата
                         bconsole_message : Boolean; // выводить ли значения невязки на консоль
                         kend : Integer; // ограничение на максимальное количество итераций
                         epsilon :  Float); // точность вычисления
var
     i,k : Integer; // счётчики
     dx, dax, dr, dz, dp, dar1 : array of  Float;
     dar, dbr, dnz, dscalp :  Float;

begin
   // Выделение памяти под динамические массивы
   SetLength(dx,isize);  SetLength(dax,isize); SetLength(dr,isize);
   SetLength(dz,isize);  SetLength(dp,isize);  SetLength(dar1,isize);

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for i:=0 to (isize-1) do dx[i]:=dX0[i+1];

   MatrixCRSByVector(isize, val, col_ind, row_ptr, dx, dax); // результат занесён в dax
   for i:=0 to (isize-1) do dr[i]:= dV[i] - dax[i];  // начальная невязка
   dnz:=Scal(isize,dr,dr); // начальное значение невязки
   for i:=0 to (isize-1) do dz[i]:=dr[i];  // вектор спуска (сопряжённое направление поиска).
   MatrixCRSByVector(isize, val, col_ind, row_ptr, dz, dp); // результат занесён в dp

   if (abs(Scal(isize, dp, dp))>1e-270) then
   begin
      k:=1; // нумерация начинается именно с 1
      // начальное значение невязки вычислено выше
      while ((bweShouldContinue) and (k <= kend) and (dnz > epsilon)) do
      begin
         dscalp:=1/Scal(isize, dp, dp);
         dar:=Scal(isize, dp, dr)*dscalp;
         for i:=0 to (isize-1) do
         begin
            dx[i]:=dx[i]+dar*dz[i];
            dr[i]:=dr[i]-dar*dp[i];
         end;
         dnz:=dnz-dar*dar/dscalp; // норма невязки
         if (imodelEquation < 3) then
         begin
            // график невязки
            inc(imarker);
            SetLength(myresplot,imarker);
            myresplot[imarker-1].temperature:=dnz; // нумерация начинается от нуля
            if (imarker>1) then updatemainpaintbox; // графики невязок
         end;
         if (bconsole_message) then
         begin
            // печать значения невязки на консоль
            if (k mod 10 = 0) then MainMemo.Lines.Add('residual');
            MainMemo.Lines.Add(FormatFloat('#.####e-0',dnz));
         end;
         MatrixCRSByVector(isize, val, col_ind, row_ptr, dr, dar1); // результат занесён в dar1
         dbr:=-Scal(isize,dp,dar1)*dscalp;
         for i:=0 to (isize-1) do
         begin
            dz[i]:=dr[i]+dbr*dz[i];
            dp[i]:=dar1[i]+dbr*dp[i];
         end;
         k:=k+1;
         // если процесс расходится его надо остановить
         if (dnz > 1e7) then
         begin
            // восстановление начального приближения
            for i:=0 to (isize-1) do dx[i]:=dX0[i+1];
            MainMemo.Lines.Add('вычислительный процесс Ю.Г. Соловейчика  расходится ');
            Application.MessageBox('divergence Soloveichik solver ','',MB_OK);
            bweShouldContinue:=false;
            break; // выход из цикла while
         end;
         Application.ProcessMessages; // микропауза пауза
      end; // while
      // возвращение результата
      for i:=0 to (isize-1) do dres[i]:=dx[i];
   end
   else
   begin
      // возвращает начальное приближение
      for i:=0 to (isize-1) do dres[i]:=dX0[i+1];
   end;

   if (imodelEquation < 3) then bweShouldContinue:=true; // восстанавливаем готовность к решению.
   // освобождение памяти выделенной под динамические массивы
   Finalize(dx); Finalize(dax); Finalize(dr);
   Finalize(dz); Finalize(dp); Finalize(dar1);

end; // SoloveichikAlg


// Вызывает меню где можно определить
// невязки.
procedure TForm1.Solution1Click(Sender: TObject);
begin
   // инициализация
   // задаёт текущие значения невязок
   MyResControlForm.EditTemperature.Text:=FloatToStr(rcs.temp); // температура
   MyResControlForm.EditXVel.Text:=FloatToStr(rcs.Vx); // горизонтальная скорость
   MyResControlForm.EditYVel.Text:=FloatToStr(rcs.Vy); // вертикальная скорость
   MyResControlForm.EditPamendment.Text:=FloatToStr(rcs.Pamendment); // поправка давления
   MyResControlForm.Editcontinity.Text:=FloatToStr(rcs.continity); // нескомпенсированные источники массы
   MyResControlForm.Estreamfunc.Text:=FloatToStr(rcs.streamfunction); // функция тока
   MyResControlForm.EditPressure.Text:=FloatToStr(rcs.Pressure); // Давление
   if (bsimpler) then
   begin
      // алгоритм SIMPLER
      // вкладки для давления сделаны видимыми.
      MyResControlForm.EditPressure.Visible:=true;
      MyResControlForm.LabelPressure.Visible:=true;
   end
    else
   begin
       // иначе вкладки для давления сделаны невидимыми.
      MyResControlForm.EditPressure.Visible:=false;
      MyResControlForm.LabelPressure.Visible:=false;
   end;
   // Показывает форму где можно
   // определить значения невязок
   // по достижению которых
   // наступит сходимость.
   MyResControlForm.Show;
end;  

// здесь можно настроить решатель на снове
// солвера сопряжённых градиентов
procedure TForm1.SoprGrad1Click(Sender: TObject);
begin
   // учёт разреженности матрицы на основе CRS
   // выбор используемого алгоритма сортировки.
   SoprGradForm.RadioGroup2.ItemIndex:=itypesorter-1;
   // вызывает меню настроек SoprGrad
   SoprGradForm.ShowModal;
end;

// для задания ускорения свободного падения
procedure TForm1.Gravity1Click(Sender: TObject);
begin
   // вызывает меню где можно задать силу тяжести
   // инициализация формы
   GravityForm.Egx.Text:=FloatToStr(dgx);
   GravityForm.Egy.Text:=FloatToStr(dgy);
   GravityForm.ShowModal; // вызывает форму
end;

// Этот участок кода находится на стадии тестирования
// Вычисление функции тока.
// 1: реализовано вычисление коэффициентов дискретного аналога.
// 2: Содержит четыре решателя: ГЗ, гибрид ГЗ-Томас, а также
// прямой метод исключения Гаусса и метод сопряжённых градиентов Хестенса и Штифеля.
// ГЗ - стационарный поточечный последовательный
// метод Гауса-Зейделя сходимость
// которого гарантируется критерием
// Скарбороу.
// Недостатки:
// Очень медленная сходимость.
// Но здесь представлена его более быстрая модификация
// которая, к сожалению,  требует несколько больше оперативной памяти.
// гибрид ГЗ-Томас - на основе гибридного метода: итерационный плюс прямой
// с использованием алгоритма Томаса
// (алгоритма трёхдиагональной матрицы или
// метода прогонки)
// сходимость
// которого гарантируется критерием
// Скарбороу.
// Недостатки:
// несколько более сложен для программирования чем Гаусс-Зейдель.
procedure TForm1.SolveStreamFunction(bmessage : Boolean; kend : Integer);
var
   k : Integer; // счётчик количества итераций
   m : array of MatrixCoef; // матрица коэффициетов
   db : array of  Float;  // коэффициент который зависит от x и y
   ipi : Integer; // номера узлов на пятиточечном шаблоне
   k1 : Integer; // счётчики
   resudualstreamfunc :  Float; // текущее значение невязки по функции тока
   bneiman : Boolean; // поставлено ли условие Неймана
   qb : Float; // значение "теплового потока" в терминах функции тока.

begin

   // коэффициенты дискретного аналога постоянны
   // их нужно вычислить один раз и дальше только использовать.
   // Коэффициенты зависят от x и y, но геометрия неизменна (нету dynamicmesh).
   SetLength(m,inx*iny+1); // выделение памяти под коэффициенты
   SetLength(db,inx*iny+1); // выделение памяти под коэффициент

   // проход по всем внутренним точкам
   // для вычисления значений коэффициентов

   for k1:=1 to imaxnumbernode do
   begin
       with mapPT[k1] do
       begin
          ipi:=i+(j-1)*inx; // текущая точка
          if (itype=1) then
          begin
             // внутренний узел
             m[ipi].dae:=dy/dxe;  // коэффициенты
             m[ipi].daw:=dy/dxw;  // дискретного
             m[ipi].dan:=dx/dyn;  // аналога
             m[ipi].das:=dx/dys;
             db[ipi]:=-Omega[ipi]*dV; // постоянная составляющая источникового члена
             m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das-dSp*dV;
          end;
          if (itype=2) then
          begin
             if (iugol=0) then
             begin
                // iboundary - уникальный номер границы
                bneiman:=GridGenForm.isneimanqb(iboundary, 'S', qb);
                if (bneiman) then
                begin
                   // точка не является угловой
                   case chnormal of
                     'N' : begin
                              // нижняя граница
                              m[ipi].dae:=dy/dxe;  // коэффициенты
                              m[ipi].daw:=dy/dxw;  // дискретного
                              m[ipi].dan:=dx/dyn;  // аналога
                              m[ipi].das:=0.0;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan-dSp*dV;
                           end;
                     'S' : begin
                              // верхняя граница
                              m[ipi].dae:=dy/dxe;  // коэффициенты
                              m[ipi].daw:=dy/dxw;  // дискретного
                              m[ipi].dan:=0.0;  // аналога
                              m[ipi].das:=dx/dys;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].das-dSp*dV;
                           end;
                     'W' : begin
                              // правая стенка
                              m[ipi].dae:=0.0;  // коэффициенты
                              m[ipi].daw:=dy/dxw;  // дискретного
                              m[ipi].dan:=dx/dyn;  // аналога
                              m[ipi].das:=dx/dys;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].daw+m[ipi].dan+m[ipi].das-dSp*dV;
                           end;
                     'E' : begin
                              // левая стенка
                              m[ipi].dae:=dy/dxe;  // коэффициенты
                              m[ipi].daw:=0.0;  // дискретного
                              m[ipi].dan:=dx/dyn;  // аналога
                              m[ipi].das:=dx/dys;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].dae+m[ipi].dan+m[ipi].das-dSp*dV;
                           end;
                   end; // case
                end; // Нейман
             end;
          end;
       end; // with
   end;

   // теперь когда коэффициенты вычислены можно запускать
   // основной тройной цикл.

   if (itypesolver.istreamfunction < 3 ) then
   begin
      resudualstreamfunc:=1e300; // очень большое число
      k:=0; // инициализация
      // здесь должен быть предусмотрен выход из цикла по
      // достижению заданной невязки
      while ((resudualstreamfunc > rcs.streamfunction) and (k < kend)) do
      begin

         case itypesolver.istreamfunction of
           1: // последовательный поточечный метод Гаусса - Зейделя
              begin
                 // ниже представлен более быстрый солвер,
                 // но он ограничен только случаями
                 // статической сетки
                 // данный метод предназначен для небольших сеток
                 //  иначе время счёта будет весьма существенным.
                 GZUniversal(SF,inx,iny, mapPT, 'S',  m,db);
              end;
           2: // метод переменных направлений
              // (гибридный метод Гаусс-Зейдель плюс алгоритм ТОМАСА для 3 диагональной СЛАУ).
              begin
                // одна итерация методом переменных направлений
                // для поля функции тока и граничных условий первого рода (нулевых)
                // солвер основанный на гибридном алгоритме,
                // сочетающем в себе как итерационный метод Гаусса-Зейделя
                // так и прямой алгоритм Томаса для трёхдиагональной матрицы.
                TDMAGibridGZUniversal(SF,inx,iny, mapPT, 'S', m,db);
              end;
         end; // case

         resudualstreamfunc:=myResidual(SF,inx,iny,mapPT, 'S', m,db);

         if (bmessage) then
         begin
            if (k mod 10 = 0) then MainMemo.Lines.Add('stream function ');
            MainMemo.Lines.Add(FloatToStr(resudualstreamfunc));
         end;

         k:=k+1; // увеличение счётчика: переход к следующей итерации.
      end;  // while
   end
   else
   begin
      case itypesolver.istreamfunction of
        3 :  // решение задачи прямым методом Гаусса
           begin
              GaussUniversal(SF,inx,iny, mapPT, 'S' ,m,db,false);
           end;
        4 : // метод Сопряжённых Градиентов
           begin
              SoprGradCRSUniversal( SF, inx, iny, mapPT, 'S', m, false, bmessage, kend, rcs.streamfunction, 0, db); //на основе технологии хранения CRS
           end;
        end; // case
   end;

end; // SolveStreamFunction

// Это исправление граничных условий для давления
// до граничных условий Неймана для корректного
// отображения при визуализации.
procedure TForm1.PressurePathit;
var
    k : Integer;
begin
   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype=2) then
         begin
            if (iugol=0) then
            begin
               case chnormal of
               'N' : begin
                        P[i+(j-1)*inx]:=P[i+j*inx];
                     end;
               'S' : begin
                        P[i+(j-1)*inx]:=P[i+(j-2)*inx];
                     end;
               'W' : begin
                        P[i+(j-1)*inx]:=P[(i-1)+(j-1)*inx];
                     end;
               'E' : begin
                        P[i+(j-1)*inx]:=P[(i+1)+(j-1)*inx];
                     end;
               end; // case
            end
             else
            begin
               // обработка угловых точек
               case iugol of
                1 :  // левый нижний угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i+1)+(j-1)*inx]+ P[i+j*inx]);
                  end;
                2 : // правый нижний угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i-1)+(j-1)*inx]+ P[i+j*inx]);
                  end;
                3 : // верхний левый угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i+1)+(j-1)*inx]+ P[i+(j-2)*inx]);
                  end;
                4 : // верхний правый угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i-1)+(j-1)*inx]+ P[i+(j-2)*inx]);
                  end;
                5 : // пятиточечная звезда
                  begin
                     P[i+(j-1)*inx]:=0.25*(P[(i+1)+(j-1)*inx]+ P[i+j*inx]);
                     P[i+(j-1)*inx]:=P[i+(j-1)*inx]+ 0.25*(P[(i-1)+(j-1)*inx]+ P[i+(j-2)*inx]);
                  end;
               end; // case
            end;
         end;
      end;
   end;

end; // PressurePathit

// Для исследования вибрационного воздействия
// Возвращает текущее значение силы тяжести
// в зависимости от текущего момента времени.
function TForm1.GetRealGravity(chDirect : Char) :  Float;
var
    r :  Float; // возвращаемое значение
begin
   // rgravVib - глобальная переменная содержащая вибрационные параметры:
   // амплитуду и частоту вибраций.
   // realFlowTime - глобальная переменная содержащая текущее время.
   if (rgravVib.chDirect = chDirect) then
   begin
      // направление вибрационного воздействия
      // совпадает с заданным.
      r:=-4*Pi*Pi;
      r:=r*rgravVib.Amplitude*rgravVib.Frequency*rgravVib.Frequency;
      r:=r*Sin(2*Pi*rgravVib.Frequency*realFlowTime);
   end
    else
   begin
      // направление вибрационного воздействия лежит в другой плоскости.
      r:=0.0;
   end;

   Result:=r;
end; // GetRealGravity

// вызывает форму создания геометрии
// и генерации расчётной сетки
procedure TForm1.CreateGeom1Click(Sender: TObject);
begin
     // все необходимые инициализирующие
     // действия производятся при создании формы.
    // вызывает форму создания геометрии
    GridGenForm.ShowModal;
end; // вызывает форму создания геометрии


// определение угловых точек и их типов
// для карт горизонтальной и вертикальной скорости
// вызывается внутри модуля GridGenUnit.
procedure TForm1.ugoldetect(var map : TdynArraymyNode; icolx, icoly : Integer);
var
    i,k : Integer; // счётчики
begin
   // определение угловых точек
   // Все угловые точки определяются,
   // классифицируются и отмечаются специальной пометкой (особым номером).
   for i:=1 to icolx do
   begin
      for k:=1 to icoly do
      begin
         map[i + (k-1)*icolx].iugol:=8; // инициализация
         if  (map[i + (k-1)*icolx].itype=2) then
         begin
            // граничный узел
            map[i + (k-1)*icolx].iugol:=0; // инициализация
            // для гарантированно внутренней точки
            if ((i<icolx) and (i>1) and (k<icoly) and (k>1)) then
            begin
               // левый нижний угол
               if ((map[i + (k)*icolx].itype=2) and (map[(i+1) + (k-1)*icolx].itype=2) and
               (map[(i-1) + (k-1)*icolx].itype<>2) and (map[i + (k-2)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=1; // левый нижний угол
                end;
                // правый нижний угол
                if ((map[i + (k)*icolx].itype=2) and (map[(i-1) + (k-1)*icolx].itype=2) and
               (map[(i+1) + (k-1)*icolx].itype<>2) and (map[i + (k-2)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=2; // правый нижний угол
                end;
                // верхний левый угол
                if ((map[i + (k-2)*icolx].itype=2) and (map[(i+1) + (k-1)*icolx].itype=2) and
                (map[(i-1) + (k-1)*icolx].itype<>2) and (map[i + (k)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=3; // левый нижний угол
                end;
                // правый верхний угол
                if ((map[i + (k-2)*icolx].itype=2) and (map[(i-1) + (k-1)*icolx].itype=2) and
               (map[(i+1) + (k-1)*icolx].itype<>2) and (map[i + (k)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=4; // правый верхний угол
                end;
                // пятиточечная звезда как особая угловая точка
                if ((map[i + (k-2)*icolx].itype=2) and (map[(i-1) + (k-1)*icolx].itype=2) and
               (map[(i+1) + (k-1)*icolx].itype=2) and (map[i + (k)*icolx].itype=2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=5; // пятиточечная звезда
                end;
            end
             else
            begin
                if (i=icolx) then
               begin
                  // поиск углов вдоль правой стенки
                  if ( map[(i-1) + (k-1)*icolx].itype=2) then
                  begin
                      if ((k<icoly) and (map[i + (k)*icolx].itype=2)) then
                      begin
                         // правый нижний угол
                         map[i + (k-1)*icolx].iugol:=2;
                      end;
                      if ((k>1) and (map[i + (k-2)*icolx].itype=2)) then
                      begin
                         // правый верхний угол
                         map[i + (k-1)*icolx].iugol:=4;
                      end;
                  end;
               end;
                if (i=1) then
               begin
                  // поиск углов вдоль левой стенки
                  if ( map[(i+1) + (k-1)*icolx].itype=2) then
                  begin
                      if ((k<icoly) and (map[i + (k)*icolx].itype=2)) then
                      begin
                         map[i + (k-1)*icolx].iugol:=1;
                      end;
                      if ((k>1) and (map[i + (k-2)*icolx].itype=2)) then
                      begin
                         map[i + (k-1)*icolx].iugol:=3;
                      end;
                  end;
               end;
               if (k=icoly) then
               begin
                  // поиск углов вдоль верхней стенки
                  if (map[i + (k-2)*icolx].itype=2) then
                  begin
                     if ((i>1) and (map[(i-1) + (k-1)*icolx].itype=2)) then
                     begin
                        // правый верхний угол
                        map[i + (k-1)*icolx].iugol:=4;
                     end;
                     if ((i<icolx) and (map[(i+1) + (k-1)*icolx].itype=2)) then
                     begin
                        // левый верхний угол
                        map[i + (k-1)*icolx].iugol:=3;
                     end;
                  end;
               end;
               if (k=1) then
               begin
                  // поиск углов вдоль нижней стенки
                  if (map[i + k*icolx].itype=2) then
                  begin
                     if ((i>1) and (map[(i-1) + (k-1)*icolx].itype=2)) then
                     begin
                        // правый нижний угол угол
                        map[i + (k-1)*icolx].iugol:=2;
                     end;
                     if ((i<icolx) and (map[(i+1) + (k-1)*icolx].itype=2)) then
                     begin
                        // левый нижний угол
                        map[i + (k-1)*icolx].iugol:=1;
                     end;
                  end;
               end;

            end;
         end;
       end;
   end;
end;

// вызов менюшки по двойному щелчку
procedure TForm1.TreeView1DblClick(Sender: TObject);
var
    str : String;
begin
   // TODO   19 марта и 29 марта
   str:=TreeView1.Selected.Text;
   case str[1] of
     'C' : begin
              case str[2] of
              'r' : begin
                       // все необходимые инициализирующие
                       // действия производятся при создании формы.
                       // вызывает форму создания геометрии
                       GridGenForm.ShowModal;
                    end;
              'o' : begin
                      // контролирует одну итерацию алгоритма
                      // SIMPLE
                      controlSimpletune;
                    end;
              end;
           end;
     'D' : begin
              // динамические сетки
              DynamMeshtune;
           end;
     'G' : begin
              // главные параметры солвера:
              // стационарный и нестационарный
              myGeneraltune;
           end;
     'E' : begin
              // выбор набора уравнений для решения
              EquationTune;
           end;
     'M' : begin
              case str[2] of
                'a' : begin
                         // параметры материалов
                         materialtune;
                      end;
                'e' : begin
                         // аппроксимация конвективного члена
                         // и выбор алгоритма солвера
                         Methodstune;
                      end; 
                end;
           end;
     'B' : begin
              // задание граничных условий
              BoundaryConditionTune;
           end;
     'S' : begin
              // Выбор алгоритма солвера
              SelectSolvertune;
           end;
       'I' : begin
                // инициализация перед началом вычисления 
                Initializationtune;
             end;
       'R' : begin
                case str[2] of
                  'e' : begin
                           // настройка параметров релаксации.
                           RelaxationFactorstune;
                        end;
                  'u' : begin
                          // вызывает солвер
                          RunTune;
                        end;
                  end;
             end;
       'P' : begin
                // дополнительная инициализация
                // используется, например, в VOF методе.
                patchtune;
             end;
   end; // case

end;

// управление простейшей динамической сеткой
procedure TForm1.DynamMeshtune;
var i : Integer;
begin
   // очистка списка границ расчётной области
    DynMeshForm.ComboBox1.Clear;
    // загрузка списка границ
    for i:=1 to GridGenForm.inumboundary do
    begin
       DynMeshForm.ComboBox1.Items.Add(GridGenForm.edgelist[i].boundaryname);
    end;

    DynMeshForm.ShowModal;
end;

// управление простейшей динамической сеткой
procedure TForm1.DynamicMesh1Click(Sender: TObject);
begin
   DynamMeshtune;
end; // динамические сетки

// передвигает координаты сетки
procedure TForm1.mymovingmesh;
var
    dy, dH1, dH2 : Float; // приращение при вибрации
    k, k1 : Integer; // счётчик
    rVy : Float; // скорость на подвижной границе
begin

   dy:=actiVibr.Amplitude*(Sin(2*Pi*actiVibr.Frequency*realFlowTime));
   rVy:=2*Pi*actiVibr.Amplitude*actiVibr.Frequency*(Cos(2*Pi*actiVibr.Frequency*realFlowTime));
   for k:=actiVibr.jdend to actiVibr.jupstart do
   begin
      ypos[k]:=yposfix[k] + dy;
   end;
   dH1:= (yposfix[actiVibr.jdend] - yposfix[actiVibr.jdstart]+dy)/(actiVibr.jdend-actiVibr.jdstart);
   k1:=0;
   for k:=(actiVibr.jdstart+1) to  (actiVibr.jdend-1) do
   begin
      inc(k1);
      ypos[k]:=yposfix[actiVibr.jdstart] + (k1)*dH1;
   end;
   dH2:=(yposfix[actiVibr.jupend] - yposfix[actiVibr.jupstart]-dy)/(actiVibr.jupend - actiVibr.jupstart);
   k1:=0;
   for k:= (actiVibr.jupend - 1) downto (actiVibr.jupstart+1) do
   begin
      inc(k1);
      ypos[k]:=yposfix[actiVibr.jupend] - (k1)*dH2;
   end;
   GridGenForm.bricklist[actiVibr.unickbricknum].yS:=DynMeshForm.rblockpos+dy;
   if (actiVibr.bBridshmen) then
   begin
      GridGenForm.bricklist[actiVibr.uniccontacktupbricknum].yS:=DynMeshForm.rblockpositionBridgmen+dy;
      GridGenForm.bricklist[actiVibr.uniccontacktupbricknum].yL:=dLy-GridGenForm.bricklist[actiVibr.uniccontacktupbricknum].yS;
   end;
   // TODO now
   // задание модуля скорости на границе подвижного объекта
   for k:=1 to  imaxnumbernodeVy do
   begin
      if (mapVy[k].iboundary = actiVibr.unicalidentifire) then
      begin
         with mapVy[k] do
         begin
            Vy[i+(j-1)*inx]:=rVy;
         end;
      end;
   end;

end; // осуществляет движение динамической сетки

//при динамической сетке надо обновлять карты.
// процедура обновления карты только для основных переменных.
procedure TForm1.UpdateMap;
var
    i,k : Integer;
begin
   // сначала обычная карта
   for i:=1 to inx do
   begin
      for k:=1 to iny do
      begin
         with  (mapPT[i + (k-1)*inx]) do
         begin
         if (itype=1) then
         begin
            // внутренний узел
            dx:=0.5*(xpos[i+1]-xpos[i-1]);
            dy:=0.5*(ypos[k+1]-ypos[k-1]);
            dV:=dx*dy;
            dxe:=(xpos[i+1]-xpos[i]);
            dxw:=(xpos[i]-xpos[i-1]);
            dyn:=(ypos[k+1]-ypos[k]);
            dys:=(ypos[k]-ypos[k-1]);
         end;
         if (itype=2) then
         begin
            // граничный узел
            if (iugol=0) then
            begin
               case chnormal of
                  'N' : // нижняя стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i-1]);
                          dy:=0.5*(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dxw:=(xpos[i]-xpos[i-1]);
                          dyn:=(ypos[k+1]-ypos[k]);
                       end;
                  'S' : // верхняя стенка
                        begin
                           dx:=0.5*(xpos[i+1]-xpos[i-1]);
                           dy:=0.5*(ypos[k]-ypos[k-1]);
                           dV:=dx*dy;
                           dxw:=(xpos[i]-xpos[i-1]);
                           dxe:=(xpos[i+1]-xpos[i]);
                           dys:=(ypos[k]-ypos[k-1]);
                        end;
                  'W' : // правая стенка
                        begin
                           dx:=0.5*(xpos[i]-xpos[i-1]);
                           dy:=0.5*(ypos[k+1]-ypos[k-1]);
                           dV:=dx*dy;
                           dxw:=(xpos[i]-xpos[i-1]);
                           dyn:=(ypos[k+1]-ypos[k]);
                           dys:=(ypos[k]-ypos[k-1]);
                        end;
                  'E' : // левая стенка
                        begin
                           dx:=0.5*(xpos[i+1]-xpos[i]);
                           dy:=0.5*(ypos[k+1]-ypos[k-1]);
                           dV:=dx*dy;
                           dxe:=(xpos[i+1]-xpos[i]);
                           dyn:=(ypos[k+1]-ypos[k]);
                           dys:=(ypos[k]-ypos[k-1]);
                        end;
               end; // case
            end
             else
            begin
               // угловая точка
               case iugol of
                1 : // левый нижний угол
                  begin
                     dx:=0.5*(xpos[i+1]-xpos[i]);
                     dy:=0.5*(ypos[k+1]-ypos[k]);
                     dV:=dx*dy;
                     dxe:=(xpos[i+1]-xpos[i]);
                     dyn:=(ypos[k+1]-ypos[k]);
                  end;
                2 : // правый нижний угол
                  begin
                     dx:=0.5*(xpos[i]-xpos[i-1]);
                     dy:=0.5*(ypos[k+1]-ypos[k]);
                     dV:=dx*dy;
                     dxw:=(xpos[i]-xpos[i-1]);
                     dyn:=(ypos[k+1]-ypos[k]);
                  end;
                3 : // верхний левый угол
                  begin
                     dx:=0.5*(xpos[i+1]-xpos[i]);
                     dy:=0.5*(ypos[k]-ypos[k-1]);
                     dV:=dx*dy;
                     dxe:=(xpos[i+1]-xpos[i]);
                     dys:=(ypos[k]-ypos[k-1]);
                  end;
                4 : // верхний правый угол
                  begin
                     dx:=0.5*(xpos[i]-xpos[i-1]);
                     dy:=0.5*(ypos[k]-ypos[k-1]);
                     dV:=dx*dy;
                     dxw:=(xpos[i]-xpos[i-1]);
                     dys:=(ypos[k]-ypos[k-1]);
                  end;
                5 : // пятиточечная звезда
                  begin
                     dx:=0.5*(xpos[i+1]-xpos[i-1]);
                     dy:=0.5*(ypos[k+1]-ypos[k-1]);
                     dV:=3*dx*dy/4; // объём
                     dxe:=(xpos[i+1]-xpos[i]);
                     dxw:=(xpos[i]-xpos[i-1]);
                     dyn:=(ypos[k+1]-ypos[k]);
                     dys:=(ypos[k]-ypos[k-1]);
                  end;
                end; // case
            end;
         end;
         end; // with mapPT

         // наверно нужно сделать обновления ещё и для
         // горизонтальной и вертикальной компонент скорости.

      end;
   end;
   for i:=1 to (inx-1) do
   begin
      for k:=1 to iny do
      begin
         with  (mapVx[i + (k-1)*(inx-1)]) do
         begin
            if (itype=1) then
            begin
               // внутренний узел
               dx:=(xpos[i+1]-xpos[i]);
               dy:=0.5*(ypos[k+1]-ypos[k-1]);
               dV:=dx*dy;
               dxe:=0.5*(xpos[i+2]-xpos[i]);
               dxw:=0.5*(xpos[i+1]-xpos[i-1]);
               dyn:=(ypos[k+1]-ypos[k]);
               dys:=(ypos[k]-ypos[k-1]);
            end;
            if (itype=2) then
            begin
               // граничный узел
               if (iugol=0) then
               begin
                  case chnormal of
                   'N' : // нижняя стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=0.5*(xpos[i+2]-xpos[i]);
                          dxw:=0.5*(xpos[i+1]-xpos[i-1]);
                          dyn:=(ypos[k+1]-ypos[k]);
                       end;
                   'S' : // верхняя стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k]-ypos[k-1]);
                          dV:=dx*dy;
                          dxe:=0.5*(xpos[i+2]-xpos[i]);
                          dxw:=0.5*(xpos[i+1]-xpos[i-1]);
                          dys:=(ypos[k]-ypos[k-1]);
                       end;
                   'W' : // правая стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k+1]-ypos[k-1]);
                          dV:=dx*dy;
                          dxw:=0.5*(xpos[i+1]-xpos[i-1]);
                          dyn:=(ypos[k+1]-ypos[k]);
                          dys:=(ypos[k]-ypos[k-1]);
                       end;
                   'E' : // левая стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k+1]-ypos[k-1]);
                          dV:=dx*dy;
                          dxe:=0.5*(xpos[i+2]-xpos[i]);
                          dyn:=(ypos[k+1]-ypos[k]);
                          dys:=(ypos[k]-ypos[k-1]);
                       end;
                   end; // case
               end; // iugol 0
            end;
         end;
      end;
   end;
   for i:=1 to inx do
   begin
      for k:=1 to (iny-1) do
      begin
         with  (mapVy[i + (k-1)*inx]) do
         begin
            if (itype=1) then
            begin
               // внутренний узел
               dx:=0.5*(xpos[i+1]-xpos[i-1]);
               dy:=(ypos[k+1]-ypos[k]);
               dV:=dx*dy;
               dxe:=(xpos[i+1]-xpos[i]);
               dxw:=(xpos[i]-xpos[i-1]);
               dyn:=0.5*(ypos[k+2]-ypos[k]);
               dys:=0.5*(ypos[k+1]-ypos[k-1]);
            end;
            if (itype=2) then
            begin
               // граничный узел
               if (iugol=0) then
               begin
                  case chnormal of
                   'N' : // нижняя стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i-1]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dxw:=(xpos[i]-xpos[i-1]);
                          dyn:=0.5*(ypos[k+2]-ypos[k]);
                       end;
                   'S' : // верхняя стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i-1]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dxw:=(xpos[i]-xpos[i-1]);
                          dys:=0.5*(ypos[k+1]-ypos[k-1]);
                       end;
                   'W' : // правая стенка
                       begin
                          dx:=0.5*(xpos[i]-xpos[i-1]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxw:=(xpos[i]-xpos[i-1]);
                          dyn:=0.5*(ypos[k+2]-ypos[k]);
                          dys:=0.5*(ypos[k+1]-ypos[k-1]);
                       end;
                   'E' : // левая стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dyn:=0.5*(ypos[k+2]-ypos[k]);
                          dys:=0.5*(ypos[k+1]-ypos[k-1]);
                       end;
                   end; // case
               end;
            end;
         end;
      end;
   end;
   // TODO
end;

// графики невязок
procedure TForm1.updatemainpaintbox;
const   // импирические значения константы: 60, 104, 208
    imaxline = 208; // константа отвечающая за подробность визуализации
    epsilon = 1e-30; // точность с которой определяется вещественный ноль

var
   w,h,i : Integer;
   rmin, rmax : Float;
   ix,iy, istep : Integer;
   myresplotcopy : array of TResidualPlot;
   imarkercopy : Integer;

begin
    // очистка фона белым
   with MainPaintBox do
   begin
      w:=Width; // ширина в пикселах
      h:=Height div 5;  // высота в пикселах

      // Градиентная заливка.
      Canvas.Brush.Color:=RGB(250,255,255);
      Canvas.Pen.Color:=RGB(250,255,255);
      Canvas.Rectangle(0,4*h,w,Height);
      for i:=4 downto 1 do
      begin
         if (i<>1) then
         begin
            Canvas.Brush.Color:=RGB(130+i*25,255,255);
            Canvas.Pen.Color:=RGB(130+i*25,255,255);
         end
          else
         begin
            Canvas.Brush.Color:=RGB(0,250,255);
            Canvas.Pen.Color:=RGB(0,250,255);
         end;
         Canvas.Rectangle(0,(i-1)*h,w,i*h);
      end;
      // сейчас установлен голубой цвет фона
      Canvas.TextOut(w-130,20,'DAVIS test v.14.06.2010');
      if (imarker>1) then Canvas.TextOut(20,20,'residual');


      if (imodelEquation<3) then
      begin
         Canvas.Pen.Color:=clRed;
         Canvas.TextOut(20,35,'temperature');
         // табулирование функции -
         // определение максимумов и минимумов.
         rmin:=1e300;
         rmax:=-1e300;
         for i:=0 to imarker-1 do
         begin
             if (rmin > log10(abs(myresplot[i].temperature))) then
             rmin:=log10(abs(myresplot[i].temperature));
             if (rmax < log10(abs(myresplot[i].temperature))) then
             rmax:=log10(abs(myresplot[i].temperature));
         end;
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            iy:=Height-round((Height-40)*(log10(abs(myresplot[0].temperature))-rmin)/(rmax-rmin));
         end;
         Canvas.MoveTo(ix,iy);
         if (imarker > imaxline) then
         begin
            // отсев половины значений
            imarkercopy:=0; // инициализация
            for i:=1 to imarker do
            begin
               if (i=1) then
               begin
                  imarkercopy:=1;
                  SetLength(myresplotcopy,imarkercopy);
                  myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
               end
                else
               begin
                  if ((i mod 2) =0) then
                  begin
                     inc(imarkercopy);
                     SetLength(myresplotcopy,imarkercopy);
                     myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
                  end;
               end;
            end;
            // обратное копирование просеянного вдвое массива
            imarker:=imarkercopy;
            for i:=1 to imarker do myresplot[i-1].temperature:= myresplotcopy[i-1].temperature;
         end;
         istep:=round(Width/(imarker+1));
         for i:=1 to imarker-1 do
         begin
            ix:=25+(i)*istep;
            iy:=Height-round((Height-40)*(log10(abs(myresplot[i-1].temperature)) - rmin)/(rmax-rmin));
            Canvas.LineTo(ix,iy);
         end;
      end
       else
      begin
         // Навье-Стокс
         // TODO

         //Canvas.TextOut(20,35,'continity');
         // табулирование функции -
         // определение максимумов и минимумов.
         rmin:=1e300;
         rmax:=-1e300;
         for i:=0 to imarker-1 do
         begin
             // предотвращение деления на ноль
             if (abs(myresplot[i].continity)<epsilon) then
                   myresplot[i].continity:=1e-2;
             if (abs(myresplot[i].Vx)<epsilon) then
                   myresplot[i].Vx:=1e-2;
             if (abs(myresplot[i].Vy)<epsilon) then
                   myresplot[i].Vy:=1e-2;
             if (bBussinesk) then
             begin
                if (abs(myresplot[i].temperature)<epsilon) then
                   myresplot[i].temperature:=1e-2;
             end;
             // поиск экстремумов
             if (rmin > log10(abs(myresplot[i].continity))) then
             rmin:=log10(abs(myresplot[i].continity));
             if (rmin > log10(abs(myresplot[i].Vx))) then
             rmin:=log10(abs(myresplot[i].Vx));
             if (rmin > log10(abs(myresplot[i].Vy))) then
             rmin:=log10(abs(myresplot[i].Vy));
             if (bBussinesk) then
             begin
                if (rmin > log10(abs(myresplot[i].temperature))) then
                   rmin:=log10(abs(myresplot[i].temperature));
             end;
             if (rmax < log10(abs(myresplot[i].continity))) then
             rmax:=log10(abs(myresplot[i].continity));
             if (rmax < log10(abs(myresplot[i].Vx))) then
             rmax:=log10(abs(myresplot[i].Vx));
             if (rmax < log10(abs(myresplot[i].Vy))) then
             rmax:=log10(abs(myresplot[i].Vy));
             if (bBussinesk) then
             begin
                if (rmax < log10(abs(myresplot[i].temperature))) then
                    rmax:=log10(abs(myresplot[i].temperature));
             end;
         end;

         if (imarker > imaxline) then
         begin
            // отсев половины значений
            imarkercopy:=0; // инициализация
            for i:=1 to imarker do
            begin
               if (i=1) then
               begin
                  imarkercopy:=1;
                  SetLength(myresplotcopy,imarkercopy);
                  myresplotcopy[imarkercopy-1].continity:=myresplot[i-1].continity;
                  myresplotcopy[imarkercopy-1].Vx:=myresplot[i-1].Vx;
                  myresplotcopy[imarkercopy-1].Vy:=myresplot[i-1].Vy;
                  if (bBussinesk) then
                  begin
                     myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
                  end;
               end
                else
               begin
                  if ((i mod 2) =0) then
                  begin
                     inc(imarkercopy);
                     SetLength(myresplotcopy,imarkercopy);
                     myresplotcopy[imarkercopy-1].continity:=myresplot[i-1].continity;
                     myresplotcopy[imarkercopy-1].Vx:=myresplot[i-1].Vx;
                     myresplotcopy[imarkercopy-1].Vy:=myresplot[i-1].Vy;
                     if (bBussinesk) then
                     begin
                        myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
                     end;
                  end;
               end;
            end;
            // обратное копирование просеянного вдвое массива
            imarker:=imarkercopy;
            for i:=1 to imarker do
            begin
                myresplot[i-1].continity:= myresplotcopy[i-1].continity;
                myresplot[i-1].Vx:= myresplotcopy[i-1].Vx;
                myresplot[i-1].Vy:= myresplotcopy[i-1].Vy;
                if (bBussinesk) then
                begin
                    myresplot[i-1].temperature:= myresplotcopy[i-1].temperature;
                end;
            end;
         end;

         // несбалансированные источники массы
         Canvas.Pen.Color:=clBlack;
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            iy:=Height-round((Height-40)*(log10(abs(myresplot[0].continity))-rmin)/(rmax-rmin));
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=1 to imarker-1 do
         begin
            ix:=25+(i)*istep;
            iy:=Height-round((Height-40)*(log10(abs(myresplot[i-1].continity)) - rmin)/(rmax-rmin));
            Canvas.LineTo(ix,iy);
         end;

         // горизонтальная скорость
         Canvas.Pen.Color:=RGB(0,0,255); // синий
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            iy:=Height-round((Height-40)*(log10(abs(myresplot[0].Vx))-rmin)/(rmax-rmin));
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=1 to imarker-1 do
         begin
            ix:=25+(i)*istep;
            iy:=Height-round((Height-40)*(log10(abs(myresplot[i-1].Vx)) - rmin)/(rmax-rmin));
            Canvas.LineTo(ix,iy);
         end;

          // вертикальная скорость
         Canvas.Pen.Color:=clGreen; // зелёный
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            iy:=Height-round((Height-40)*(log10(abs(myresplot[0].Vy))-rmin)/(rmax-rmin));
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=1 to imarker-1 do
         begin
            ix:=25+(i)*istep;
            iy:=Height-round((Height-40)*(log10(abs(myresplot[i-1].Vy)) - rmin)/(rmax-rmin));
            Canvas.LineTo(ix,iy);
         end;

         if (bBussinesk) then
         begin
            // температура
            Canvas.Pen.Color:=clRed;
            // прорисовка графика:
            ix:=25; iy:=0;
            if (imarker > 1) then
            begin
               // чтобы избежать деления на ноль.
               iy:=Height-round((Height-40)*(log10(abs(myresplot[0].temperature))-rmin)/(rmax-rmin));
            end;
            Canvas.MoveTo(ix,iy);
            istep:=round(Width/(imarker+1));
            for i:=1 to imarker-1 do
            begin
               ix:=25+(i)*istep;
               iy:=Height-round((Height-40)*(log10(abs(myresplot[i-1].temperature)) - rmin)/(rmax-rmin));
               Canvas.LineTo(ix,iy);
            end;
         end;

      end;

    end;
end;

// графики невязок
procedure TForm1.FormPaint(Sender: TObject);
begin
   updatemainpaintbox; // прорисовка графиков невязок
end;

// вызывает меню, где можно задать структуру одной итерации
// алгоритма SIMPLE
procedure TForm1.SIMPLE1Click(Sender: TObject);
begin
   controlSimpletune;
end;  // структура одной итерации алгоритма SIMPLE

// настройка параметров с которыми решается
// уравнение для поправки давления
procedure TForm1.Pressure1Click(Sender: TObject);
begin
   // инициализация:
   if (bPatankarPressure) then
     PamendmendcontrolForm.RadioGroup1.ItemIndex:=0
    else
     PamendmendcontrolForm.RadioGroup1.ItemIndex:=1;

    if (bipifixpamendment) then
        PamendmendcontrolForm.CheckBoxipifixpamendment.Checked:=true
      else
        PamendmendcontrolForm.CheckBoxipifixpamendment.Checked:=false;
        
   // задание параметров решения уравнения
   // для поправки давления.
   PamendmendcontrolForm.ShowModal;
end;

// осуществляет инициализацию
// искомых величин
procedure TForm1.initialize2Click(Sender: TObject);
begin
   Initializationtune;
end;  // задание параметров инициализации искомых величин перед началом расчёта

// инициализирует решение в VOF методе и не только
procedure TForm1.patchtune;
begin
   // инициализация
   PatchForm.Llen.Caption:=FloatToStr(dLx);
   PatchForm.Lhight.Caption:=FloatToStr(dLy);
   // вызов модального диалога.
   PatchForm.ShowModal; // вызов формы для дальнейшей инициализации
end;

// инициализирует решение в VOF методе и не только
procedure TForm1.Patch1Click(Sender: TObject);
begin
   patchtune;
end;

// плотность
function TForm1.density(ipi : Integer) : Float;
var
    res : Float; // возвращаемый результат
begin
   if (imodelEquation<5) then
   begin
      // всё кроме VOF метода
      res:=matprop[0].drho;
   end
    else
   begin
      // для VOF метода
      res:=matprop[1].drho*VOF[ipi]+(1-VOF[ipi])*matprop[0].drho;
   end;
   Result:=res;
end; // возвращает текущую плотность

// динамическая вязкость
function TForm1.viscosity(ipi : Integer) : Float;
var
    res : Float; // возвращаемый результат
begin
   if (imodelEquation<5) then
   begin
      // всё кроме VOF метода
      res:=dmu[ipi]; // переменная динамическая вязкость
   end
    else
   begin
      // для VOF метода
      res:=matprop[1].dmu*VOF[ipi]+(1-VOF[ipi])*matprop[0].dmu;
   end;
   Result:=res;
end; // возвращает текущую динамическую вязкость

// решение уравнения для давления
procedure TForm1.SolveGZPressure(bipifix : Boolean); // фиксировать ли уровень давления  ?
const
      epsilon = 1e-200; // для предотвращения деления на ноль
var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для давления
   mu : array of MatrixCoef; // К.Д.А. для горизонтальных компонент скорости
   mv : array of MatrixCoef; // К.Д.А. для вертикальных компонент скорости
   db : array of  Float; // коэффициенты источникового члена
   dbu, dbv : array of Float; // правая часть.
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   iecvi1, iwcvi1, incvi1, iscvi1 : Integer; // для  скорости
   Uw_cup, Ue_cup, Vs_cup, Vn_cup: Float; // псевдоскорости
   i1,j1,k,k1 : Integer;
   myrP : array of  Float; // невязка для  давления
   // следующая переменная используется для сверхрелаксации
   Ptilda :  Float; // новое приближение i-ой компоненты поправки давления
   deviation :  Float; // критерий выхода из цикла
   dapvel, rhointerpol :  Float;
   bnei, bvisit : Boolean;
   rbuf : Float; // для того чтобы избежать деления на ноль
   bcalc : array [1..4] of Boolean;

begin
   // если передаваемый параметр bipifix = true, то нужно фиксировать уровень  давления
   // на нулевом уровне, иначе если bipifix = false, то  давление само будет искать свой уровень.
   // Когда давление само ищет свой уровень, то это может означать более быструю сходимость,
   // т.к. отсутствует точка ipifix в центре расчётной области которая всё портит.
   // Однако для прямого методаисключения Гаусса фиксировать точку ipifix обязательно.

   // выделение памяти
   SetLength(mp,inx*iny+1); // массив коэффициентов
   SetLength(mu,(inx-1)*iny+1); // Vx coef
   SetLength(mv,inx*(iny-1)+1); // Vy coef
   SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
   SetLength(dbu,(inx-1)*iny+1);
   SetLength(dbv,inx*(iny-1)+1);
   VxGlobalCoef(mu,dbu);
   VyGlobalCoef(mv,dbv);
   SetLength(myrP,inx*iny+1); // выделение памяти под невязку
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
   while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя

   // инициализация.
   for i1:=2 to inx-1 do
   begin
      for j1:=2 to iny-1 do
      begin
         // инициализация значений переменных
         ipi:=i1+(j1-1)*inx;  // текущая точка
         // нулевыми значениями
         db[ipi]:=0.0;
         mp[ipi].dae:=0.0;
         mp[ipi].daw:=0.0;
         mp[ipi].dan:=0.0;
         mp[ipi].das:=0.0;
         mp[ipi].dap:=1.0; // т.к. на эту точку возможно деление
         myrP[ipi]:=0.0; // обнуление невязки
      end;
   end;


   // вычисление коэффициентов в уравнении для давления
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел

            bvisit:=false; // если true то здесь задаётся давление

            // координаты узлов для давления
            // используется обыкновенная сетка
            ipi:=i+(j-1)*inx;  // текущая точка
            iei:=(i+1)+(j-1)*inx; // восток
            iwi:=(i-1)+(j-1)*inx; // запад
            ini:=i+(j)*inx; // север
            isi:=i+(j-2)*inx; // юг
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для  давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
            // требуется покрайней мере в четыре раза больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.
            // Здесь граничные коэффициенты дискретного аналога обнуляюся
            // и физически это означает, что граничные значения не влияют
            // на поле давления внутри расчётной области.
            // По этому поводу см. Патанкар ст. 108, 109.


            // в линейной струкруре карты mapPT
            // ориентация по сторонам света
            // юг, север, восток и запад происходит
            // всё по тем же правилам
            rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
            if (mapPT[iei].itype <> 2) then
            begin
               // если северная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               mp[ipi].dae:=rhointerpol*dy*dy/dapvel;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[iei].iboundary, 'P',mapPT[iei].chnormal);
               if (not(bnei)) then
               begin
                   // давление принимает заданное значение
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dae:=0; // нет влияния от давления на границе
               end;
           end;

           rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
           if (mapPT[iwi].itype <> 2) then
           begin
              // если южная точка не является граничной
              dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
              mp[ipi].daw:=rhointerpol*dy*dy/dapvel;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[iwi].iboundary, 'P',mapPT[iwi].chnormal);
              if (not(bnei)) then
              begin
                  // давление принимает заданное значение
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].daw:=0; // нет влияния от давления на границе
              end;
           end;

           rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
           if (mapPT[ini].itype <> 2) then
           begin
              // если северная точка не является граничной
              dapvel:=Vcoefpam(i,j,2); // Vycoef
              mp[ipi].dan:=rhointerpol*dx*dx/dapvel;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[ini].iboundary, 'P', mapPT[ini].chnormal);
              if (not(bnei)) then
              begin
                  // давление принимает заданное значение
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].dan:=0; // нет влияния граничных условий
              end;
            end;

            rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
            if (mapPT[isi].itype <> 2) then
            begin
               // если южная точка не является граничной
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               mp[ipi].das:=rhointerpol*dx*dx/dapvel;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[isi].iboundary, 'P',mapPT[isi].chnormal);
               if (not(bnei)) then
               begin
                   // давление принимает заданное значение
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].das:=0; // нет влияния граничных значений
               end;
            end;

            if (bvisit) then
            begin
               // давление принимает заданное значение
               mp[ipi].dap:=1.0;
               db[ipi]:=P[ipi];
               mp[ipi].dae:=0.0;
               mp[ipi].daw:=0.0;
               mp[ipi].dan:=0.0;
               mp[ipi].das:=0.0;
            end
             else
            begin
               mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
               db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
               rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
               // 1..(inx-1)*iny
               iecvi1:=(i)+(j-1)*(inx-1);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx-1)*(iny))) then bcalc[1]:=true;
               iwcvi1:=(i-2)+(j-1)*(inx-1);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx-1)*(iny))) then bcalc[2]:=true;
               incvi1:=(i-1)+(j)*(inx-1);    // север
               if ((incvi1>=1) and (incvi1<=(inx-1)*(iny))) then bcalc[3]:=true;
               iscvi1:=(i-1)+(j-2)*(inx-1);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx-1)*(iny))) then bcalc[4]:=true;
               // вычислим псевдоскорость
               rbuf:=0.0; // инициализация
               if (bcalc[1]) then rbuf:=rbuf+mu[iwcvi].dae*Vx[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mu[iwcvi].daw*Vx[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mu[iwcvi].dan*Vx[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mu[iwcvi].das*Vx[iscvi1];
               rbuf:=rbuf+dbu[iwcvi];
               if (abs(rbuf)<epsilon) then
               begin
                  Uw_cup:=0.0;
               end
                else
               begin
                  Uw_cup:=rbuf/mu[iwcvi].dap;
               end;
               db[ipi]:=db[ipi] + rhointerpol*Uw_cup*dy; // на основе псевдоскорости.

               rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
               // 1..(inx-1)*iny
               iecvi1:=(i+1)+(j-1)*(inx-1);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx-1)*(iny))) then bcalc[1]:=true;
               iwcvi1:=(i-1)+(j-1)*(inx-1);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx-1)*(iny))) then bcalc[2]:=true;
               incvi1:=(i)+(j)*(inx-1);    // север
               if ((incvi1>=1) and (incvi1<=(inx-1)*(iny))) then bcalc[3]:=true;
               iscvi1:=(i)+(j-2)*(inx-1);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx-1)*(iny))) then bcalc[4]:=true;
               // вычислим псевдоскорость
               rbuf:=0.0; // инициализация
               if (bcalc[1]) then rbuf:=rbuf+mu[iecvi].dae*Vx[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mu[iecvi].daw*Vx[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mu[iecvi].dan*Vx[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mu[iecvi].das*Vx[iscvi1];
               rbuf:=rbuf+dbu[iecvi];
               if (abs(rbuf) < epsilon) then
               begin
                  Ue_cup:=0.0;
               end
                else
               begin
                  Ue_cup:=rbuf/mu[iecvi].dap;
               end;
               db[ipi]:=db[ipi] - rhointerpol*Ue_cup*dy; // на основе псевдоскорости

               rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
               // 1..(inx)*(iny-1)
               for i1:=1 to 4 do bcalc[i1]:=false;
               iecvi1:=(i+1)+(j-2)*(inx);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx)*(iny-1))) then bcalc[1]:=true;
               iwcvi1:=(i-1)+(j-2)*(inx);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx)*(iny-1))) then bcalc[2]:=true;
               incvi1:=(i)+(j-1)*(inx);    // север
               if ((incvi1>=1) and (incvi1<=(inx)*(iny-1))) then bcalc[3]:=true;
               iscvi1:=(i)+(j-3)*(inx);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx)*(iny-1))) then bcalc[4]:=true;
               rbuf:=0.0;
               if (bcalc[1]) then rbuf:=rbuf+mv[iscvi].dae*Vy[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mv[iscvi].daw*Vy[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mv[iscvi].dan*Vy[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mv[iscvi].das*Vy[iscvi1];
               rbuf:=rbuf+dbv[iscvi];
               if (abs(rbuf) < epsilon) then
               begin
                  Vs_cup:=0.0;
               end
                else
               begin
                  Vs_cup:=rbuf/mv[iscvi].dap;
               end;
               db[ipi]:=db[ipi] + rhointerpol*Vs_cup*dx; // на основе псевдоскорости


               rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
               // 1..(inx)*(iny-1)
               for i1:=1 to 4 do bcalc[i1]:=false;
               iecvi1:=(i+1)+(j-1)*(inx);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx)*(iny-1))) then bcalc[1]:=true;
               iwcvi1:=(i-1)+(j-1)*(inx);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx)*(iny-1))) then bcalc[2]:=true;
               incvi1:=(i)+(j)*(inx);    // север
               if ((incvi1>=1) and (incvi1<=(inx)*(iny-1))) then bcalc[3]:=true;
               iscvi1:=(i)+(j-2)*(inx);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx)*(iny-1))) then bcalc[4]:=true;
               rbuf:=0.0;
               if (bcalc[1]) then rbuf:=rbuf+mv[incvi].dae*Vy[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mv[incvi].daw*Vy[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mv[incvi].dan*Vy[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mv[incvi].das*Vy[iscvi1];
               rbuf:=rbuf+dbv[incvi];
               if (abs(rbuf)<epsilon) then
               begin
                  Vn_cup:=0.0;
               end
                else
               begin
                  Vn_cup:=rbuf/mv[incvi].dap;
               end;
               db[ipi]:=db[ipi] - rhointerpol*Vn_cup*dx; // на основе псевдоскорости

            end;
         end;
      end; // with
   end;

  
   // теперь когда все коэффициенты вычислены
   // можно приступить к решению.
   deviation:=1e300; // очень большое число
   k:=1;


   while ((deviation > rcs.Pressure) and (k<=iterSimple.iterPressure)) do
   begin
      for k1:=1 to imaxnumbernode do
      begin
         with mapPT[k1] do
         begin
            if (itype = 1) then
            begin
               // внутренний узел

               // координаты узлов для поправки давления
               // используется обыкновенная сетка
               ini:=i+j*inx; // север
               isi:=i+(j-2)*inx; // юг
               iwi:=(i-1)+(j-1)*inx; // запад
               iei:=(i+1)+(j-1)*inx; // восток
               ipi:=i+(j-1)*inx;  // текущая точка
               // здесь может быть деление на ноль, его надо исключить
               if (abs(mp[ipi].dap) > 1e-300) then
               begin
                  // здесь гарантировно нет деления на ноль
                  if ((bipifix) and (ipi=ipifix)) then
                  begin
                     P[ipifix]:=0.0; // фиксируем уровень
                  end
                   else
                  begin
                     // Сверхрелаксация с коэффициентом 1.9 убрана, т.к.
                     // по-моему, препятствует сходимости вычислительного
                     // процесса: невязки уменьшаются до определённого значения,
                     // скажем 1e-5 и дальше не падают.
                     // Если убрать какую-бы то ни было релаксацию и оставить
                     // чистого Гаусса-Зейделя то сходимость гарантирована.
                     // Здесь оставлен чистый Гаусс-Зейдель (соответствует значению 1.0).
                     Ptilda:=(mp[ipi].dae*P[iei]+mp[ipi].daw*P[iwi]+mp[ipi].dan*P[ini]+mp[ipi].das*P[isi]+db[ipi])/mp[ipi].dap;
                     // исходя из физического смысла задачи давление ограничено снизу значением 0.
                     P[ipi]:=max(0,P[ipi]+myrelaxfactors.pSORpresr*(Ptilda-P[ipi]));
                  end;
               end;
            end; // проход по
         end; // with
      end; // внутренним точкам

      // для существенного ускорения
      // времени счёта невязка будет вычисляться
      // каждую 0.5*(inx+iny) итерацию солвера Гаусса и Зейделя.
      // Время вычисления невязки равно времени одной итерации Г-З
      if (((2*k) mod (inx+iny)) = 0) then
      begin
         // отслеживаем невязку Pamendment
         for k1:=1 to imaxnumbernode do
         begin
            with (mapPT[k1]) do
            begin
               if (itype = 1) then
               begin
                  // внутренний узел

                  // используется обыкновенная сетка
                  ipi:=i+(j-1)*inx;  // текущая точка
                  if ((bipifix) and (ipi = ipifix)) then
                  begin
                     myrP[ipifix]:=0.0; // одно уравнение выполняется точно
                  end
                   else
                  begin
                     ini:=i+j*inx; // север
                     isi:=i+(j-2)*inx; // юг
                     iwi:=(i-1)+(j-1)*inx; // запад
                     iei:=(i+1)+(j-1)*inx; // восток
                     myrP[ipi]:=mp[ipi].dae*P[iei];
                     myrP[ipi]:=myrP[ipi]+mp[ipi].daw*P[iwi];
                     myrP[ipi]:=myrP[ipi]+mp[ipi].dan*P[ini];
                     myrP[ipi]:=myrP[ipi]+mp[ipi].das*P[isi];
                     myrP[ipi]:=myrP[ipi]+db[ipi]-mp[ipi].dap*P[ipi];
                  end;
               end;
            end; // with
         end;


         // проверка того насколько точно выполняется
         // дискретный аналог
         case ibasenorma of
           1 : // евклидова норма
             begin
                // насколько точно выполняется дискретный аналог
                deviation:=myEvklidNorma(myrP,inx,iny);
             end;
           2 : // кубическая
             begin
                // насколько точно выполняется дискретный аналог
                deviation:=mySupNorma(myrP,inx,iny);
             end;
           3 : // октаэдрическая
             begin
                // насколько точно выполняется дискретный аналог
                deviation:=mySup2Norma(myrP,inx,iny);
             end;
         end;

         //freport.Add(FloatToStr(deviation));
      end;

      k:=k+1; // переход к следующей итерации
   end; // k

end; // SolveGZPressure

// находит вихрь.
procedure TForm1.SolveOmegaSteady;
var
    m : array of MatrixCoef; // матрица коэффициетов
   db : array of Float;  // коэффициенты
begin
   // выделение оперативной памяти
   SetLength(m, inx*iny+1);
   SetLength(db, inx*iny+1);

   // расчёт коэффициентов дискретного аналога
   OmegaConvCoef(m,db);

   // решение СЛАУ
   // Алгоритм Соловейчика [1993]
   // локально оптимальная схема.
   SoprGradCRSUniversal(Omega,inx,iny, mapPT, 'O', m, true, false, 2*inx*iny, 1e-7, 1, db);

end; // SolveOmegaSteady

// решает Навье-Стокса в переменных Вихрь - Функция тока
procedure TForm1.VorcityStreamfunctionSolveEquation;
var
    j : Integer; // счётчик числа шагов по времени
    i : Integer; // счётчик числа итераций.
begin

   // Роуч. стр. 37.
   // шаг 1.  Наступает новый момент времени, и рассчитывается новое значение Вихря.
   // шаг 2. Находим функцию тока.
   // шаг 3. Рассчитываем новую скорость выполняя дифференцирование функции тока.
   // шаг 4. рассчёт новых граничных условий для вихря.
   // шаг 5. решить, если это надо, дискретные аналоги для других Ф.
   // шаг 6. вернуться к шагу 1 и повторять расчёты до тех пор пока не будет достигнута сходимость.

   j:=1; // инициализация
   while ((bweShouldContinue) and (j<=inumbertimestep)) do
   begin
       // в стационарном случае inumbertimestep равно 1.
       // Это указывается явно при запуске в Run Module.
       // глобальная переменная realFlowTime
       // используется как параметр при различных вибрационных воздействиях.
       if (btimedepend) then
       begin
          realFlowTime:=realFlowTime + dTimeStep; // текущее время при нестационарном расчёте
          rememberDensity; // запоминание плотности с предыдущего временного слоя.
       end;

       if (actiVibr.bOn) then
       begin
          // передвигает динамическую сетку
          // и задаёт скорость
          mymovingmesh;
          UpdateMap;
       end;

       i:=0; // инициализация
       while ((bweShouldContinue) and (i<itercount)) do
       begin
          // шаг 1. нахождение вихря
          SolveOmegaSteady;
          // шаг 2. нахождение функции тока
          SolveStreamFunction(false, iterSimple.iterStreamFunction);
          // шаг 3. рассчитываем новую скорость,
          // выполняя дифференцирование функции тока.
          VxConstruct; // горизонтальная скорость
          VyConstruct; // вертикальная скорость
          // шаг 4. расчёт новых граничных условий для вихря,
          // на основе условий Тома.
          // шаг 5. решить, если это надо, дискретные аналоги для других Ф.
          if (bBussinesk) then
          begin
             // запоминаем поле температур с предыдущей итерации
             RememberTOldTimeStep(false); // оно может использоваться для нижней релаксации
             SolveTempSteady(false,iterSimple.iterTemperature, true); // находит коэффициенты и решает
          end;
          // шаг 6. переход на шаг 1 если сходимость не достигнута.

          i:=i+1; // переход к следующей итерации
       end;
       j:=j+1; // переход к следующему временному слою.
   end; // j

end; // VorcityStreamfunctionSolveEquation

// записывает файл с расчётной сеткой
procedure TForm1.Mesh4Click(Sender: TObject);
var
   CaptionStr : string; // имя записываемого файла
begin
   // пишет сетку в файл
   if not InputQuery('Ввод имени', 'Введите уникальное имя записываемого файла', CaptionStr)
         then exit; // срочное завершение обработки данного события, т.к. имя не введено
    CaptionStr:='msh\'+ CaptionStr+'.txt';
    GridGenForm.writeMesh(CaptionStr);
end; // записывает файл с расчётной сеткой

// считывает файл с рачётной сеткой
procedure TForm1.Mesh3Click(Sender: TObject);
begin
   // считывает файл с расчётной сеткой
   OpenDialog1.Filter := 'Текстовые файлы|*.txt';
   if OpenDialog1.Execute and FileExists(OpenDialog1.FileName) then
       // Результат успешный - пользователь выбрал файл.
       // Загружаем файл .
       GridGenForm.ReadMesh(OpenDialog1.FileName);

    Application.MessageBox('файл считан успешно','считывание сетки',MB_OK);
end; // считывает файл с расчётной сеткой

end.  // конец кода главного модуля MainUnit
