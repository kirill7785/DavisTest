
unit MainUnit;
// Цели.
// Не нужно гнаться за наращиванием функциональности,
// надо стремиться писать небольшой по объёму код,
// хорошо отлаженый, прошедший тестирование и
// решающий свою задачу на должном уровне.

// главный модуль программы
// Консервация: 19 августа 09.
// Среда Программирования Delphi 6.
// Текст программы очищен  от устаревшего кода и содержит порядка 4000 строк.
// Настало время консервации и дальнейшего пересмотра всей
// логики программы, чтобы её можно было продолжать писать после перерыва или в свободное время.
// Код готов к распечатке и анализу.
// Замечания:
// Хорошо бы повозится с дискретным аналогом и улучшить его:
// добавить нестационарность, Обербека-Буссинеска ускорение свободного падения в виде
// гармонической функции времени.
// также возможно имеет смысл предусмотреть другие геометрии (например Чохральского)
// и неравномерность секи по способу 2.
// Решатели дискретных аналогов самая сложная тема для рассмотрения:
// градиентные итерационные методы (применимы ли они ?).
// больной вопрос уравнение для поправки давления как его корректно решить и как составить.

// Универсальность требует применения универсальных вычислительных процедур.
// Не нужно писать двадцать функций делающих примерно одно и тоже с незначительными изменениями
// Нужно писать одну универсальную функцию. Объём сопровождаемого года должен быть невысок.
// Однако если универсальность кода сильно препятствует его простоте следует от неё отказаться
// или написать высококачественные коментарии из которых ясен принцип действия универсальной процедуры.
// Создание матричных солверов путь к универсальности.
// Здесь встаёт задача эффективного использования технологии разреженных матриц.

// 11 июня 2010 .
// Задачи: 1. реализация алгоритма SIMPLER. 2. VOF метод.
// Динамическая сетка по прежнему не работает. Надо исправить.
// переписать ядро солвера на чистый С с использованием Open MP в Visual Studio 2010.

// 11 июня 2013 .
// Несмотря на то что появился Visual Studio 2012 и несколько моих программ на нём уже написаны
// или находятся в процессе написания, этот код по видимому будет на Delphi. Код на языке Си
// можно вставить через подсоединение СИ dll, но видимо будут некие проблемы с передачей даных.
// Итак к данному моменту в этой проге вполне работоспособен SIMPLER алгоритм, (всё на основе метода Зейделя,
// и я считаю что метода Зейделя для двумерных задач вполне хватает), также устранена ошибка в Dynamic Mesh
// ошибка была вызвана тем что при обновлении вертикальной скорости, память под вертикальную скорость выделена не была.
// Итак программа за последние несколько дней немного ожила. Двумерные задачи хороши тем что они быстреее считают нежели трёхмерные,
// поэтому данная программа достойна существовать.

// 1 июля 2013.
// Для VOF метода реализовано согласно диссертации Минакова явная локально одномерная схема,
// с заданным числом Куранта (иначе говоря на большом внешнем шаге по времени с которым решается гидродинамическая
// составляющая организуется дополнительный внутренний цикл для функции цвета явной схемой с шагом
// определяемым из условия Куранта. Для аппроксимации конвективного члена для VOF используется схема с ограничителем SUPERBEE.
// Исправлена антидиффузионная корекция из диссертации Н.Г.Бураго, тепер она вполне работоспособна.
// Добавлена анимация работающая в режиме старт - финиш SIMPLE алгоритма.
// Метод сопряжённых градиентов отказывается работать там где работает метод Зейделя.
// Начата разработка User-Defined Scalar.

// 3 июня 2013 солвер переведён на Паскаль метод Писмена и Рекфорда что дало
// замедление счёта на 62 процента в среднем.
// границы симметрии для скоростей методом Писмена Рекфорда обрабатываются неправильно.
// 5 июня 2013 : внедрение интерпретатора в код солвера !!! (первые 3 UDS)
// 22 июля 2013 : внедрение 4-ой UDS. (Например для возможности моделирования уравнений Симоненко-Зиньковской).
// 27 июля было закончено добаление 4 скалярного уравнения. Нет только анимации для uds.
// 26 июля день посвящён тестированию программного обеспечения. Выяснено:
// VOF method не работает для отношения плотностей 1000, маленьких вязкостей даже 0.1 и реальных ускорений
// свободного падения. Надо искать ошибки!. Не работает уже с первой итерации. уменьшение шага по времени до
// 1e-16 не помагает.
// Надо добавить VOF на uds.
// 27 июля. Сделаны изменения в VOF методе и теперь не работает simpler algorithm.
// немного улучшен User Defined Segregated Solver.
// 1 августа 2013 начато добавление силы поверхностного натяжения continuum surface force.
// 2 августа 2013 года добавлена схема Пейре Second order transient formulation для постоянного шага по времени.
// 7 августа добавлены Surface Integrals (для анализа работы ПТШ).
// 12 августа 2013 года. Исправлен ряд ошибок. Немного улучшено построение сетки (добавлена возможность
// добавить несколько сеточных линий). Метод Гауса теперь поддерживает условие ток равен нулю.
// Возможно Segregated Solver недостаточно хорош в плане сходимости. Возможно метод Ньютона позволит
// существенно улучшить характеристики сходимости. Для этого можно посмотреть препринт Федюшкина А.И.
// про прораммный солвер МАРЕНА.
// 15 августа 2013 года. Добавлен дополнительный Буссинесковский член на основе всех UDS.
// Работает только при Буссинесковской плотности.
// 1 октября 2013 Введены переменные в условие Дирихле для UDS и сделан Parametric Trials.

// строка 12151 метод Ньютона для ВАХ GaAs.
// 16 ноября 2014 : Раздельный решатель оказался способен решить все что нужно и метод Ньютона оказался ненужен.
// Делаем Marangoni Convection : на основе метода Зейделя. 

// 22 ноября 2015 добавлен свой собственный алгебраический многосеточный метод
// для всех UDS1-4, температуры и компонент скорости на основе dll.
// 22 ноября 2015 года осуществлён переход на компилятор RAD Studio 10 Seattle

// 17 ноября 2019 добавил High Resolution Scheme для Flow и Temperature.

interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, StdCtrls, ExtCtrls, Menus, Math, ShellAPI, ComCtrls, Unitdeclar;

// Мы выделяем память с двукратным запасом, чтобы избежать проблем
// инструкция обратилась не по адресу.
const mzapas=2;

type
   // типы данных смотри в Unitdeclar модуле.



   // Коэффициент разреженной матрицы
  // в агломеративном алгебраическом многосеточном методе.
  TnodeAMG = record
     val : Real;
     i,j : Integer;
  end;

  // не больше 20 различных границ, не больше 4 UDS.
  TQneiC = array[1..20, 1..4] of Boolean;

  // Двухсеточный метод Радия Петровича.
  TmyFedorenko1961 = record
     q : Integer; // отношение между количеством узлов на подробной и грубой
     inxc : Integer; // соответствующая inx размерность на грубой сетке.
     inyc : Integer;
     // сетках в двухсеточном методе.
     bready : Boolean;
  end;

  // Транслятор формул.
  TmyVariable = record
     svar : String;  // имя переменной
     sval : String;  // значение переменной
  end;

  // типы для вычисления параметризованного выражения
  setChar=set of char; // тип множество символов
  pTop=^Top;
  Top=record
  private
     //operator : string[5]; // знак операции
     Fmyoperator : string; // знак операции
     Fvalue : Float; // значение константы
     Fleft, Fright : pTop; // указатели на левое и правое поддерево
     procedure Setmyoperator(const valuestr : string);
     procedure Setvalue(const rval : Real);
     procedure Setleft(const lval : pTop);
     procedure Setright(const rval : pTop);
  public
      property myoperator: String read Fmyoperator write Setmyoperator;
      property value : Real read Fvalue write  Setvalue;
      property left : pTop read Fleft write  Setleft;
      property right : pTop read Fright write  Setright;
  end;
  // конец транслятор формул.

  // Структура данных для метода переменных направлений Писмена и Речфорда 1955.
  Tprogonka = record
     istart, iend : Integer;
     boncond, bonconup : Integer; // 0 - I рода, 1 - II рода.
     //  условие симметрии представляется композицией услови 0 и 1.
  end;

  TPeacemanRachford = array of array of Tprogonka;

  TmyNode = record
    private
     // структура одного узла
     // 0 - пустой узел не принадлежащий расчётной сетке (hollow point).
     Fitype : Integer; // тип узла ( 1 - внутренний, 2 - граничный узел)
     Fi,Fj : Integer; // координаты узла
     // для узла также возможно имеет смысл хранить и другую информацию:
     // объём контрольного объёма, длина стенки контрольного объёма по x,
     // длина стенки контрольного объёма по y. и т.д.
     Fdx, Fdy, FdV : Float;
     Fdxe, Fdxw, Fdyn, Fdys : Float;
     // Для граничного условия Неймана
     Fiboundary : Integer; // уникальный номер границы к которой принадлежит эта точка.
     Fchnormal : Char; // внутренняя нормаль к границе
     // виды угловых точек
     // 0 - не угловая
     // 1 - левый нижний угол,
     // 2 - правый нижний угол,
     // 3 - левый верхний угол,
     // 4 - правый верхний угол
     // 5 - угол пятиточечный крест.
     Fiugol : Integer;
     // в уравнении для поправки давления
     // важно знать соседние с угловыми точками
     // это можно определить без дополнительной структуры данных

     // для ускорения вычислений.
     Fini, Fisi, Fiwi, Fiei, Fipi : Integer;

     procedure Setdxe(const ldxe : Float);
     procedure Setdxw(const ldxw : Float);
     procedure Setdyn(const ldyn : Float);
     procedure Setdys(const ldys : Float);
     procedure SetdV(const ldV : Float);
     procedure Setdx(const ldx : Float);
     procedure Setdy(const ldy : Float);
     procedure Setiugol(const liugol : Integer);
     procedure Seti(const li : Integer);
     procedure Setj(const lj : Integer);
     procedure Setini(const lini : Integer);
     procedure Setisi(const lisi : Integer);
     procedure Setiwi(const liwi : Integer);
     procedure Setiei(const liei : Integer);
     procedure Setipi(const lipi : Integer);
     procedure Setiboundary(const liboundary : Integer);
     procedure Setitype(const litype : Integer);
     procedure Setchnormal(const lchnormal : Char);
     public
      property dxe : Float read Fdxe write  Setdxe;
      property dxw : Float read Fdxw write  Setdxw;
      property dyn : Float read Fdyn write  Setdyn;
      property dys : Float read Fdys write  Setdys;
      property dV : Float read FdV write  SetdV;
      property dx : Float read Fdx write  Setdx;
      property dy : Float read Fdy write  Setdy;
      property iugol : Integer read Fiugol write Setiugol;
      property i : Integer read Fi write  Seti;
      property j : Integer read Fj write  Setj;
     property ini : Integer read Fini write  Setini;
     property isi : Integer read Fisi write  Setisi;
     property iwi : Integer read Fiwi write  Setiwi;
     property iei : Integer read Fiei write  Setiei;
     property ipi : Integer read Fipi write  Setipi;
     property iboundary : Integer read Fiboundary write Setiboundary;
     property itype : Integer read Fitype write Setitype;
     property chnormal : Char read Fchnormal write Setchnormal;

  end;

  TdynArraymyNode = array of TmyNode;
  TPdynArraymyNode = ^TdynArraymyNode;

  TmyNodeold = record
     // структура одного узла
     // 0 - пустой узел не принадлежащий расчётной сетке (hollow point).
     itype : Integer; // тип узла ( 1 - внутренний, 2 - граничный узел)
     i,j : Integer; // координаты узла
     // для узла также возможно имеет смысл хранить и другую информацию:
     // объём контрольного объёма, длина стенки контрольного объёма по x,
     // длина стенки контрольного объёма по y. и т.д.
     dx, dy, dV : Float;
     dxe, dxw, dyn, dys : Float;
     // Для граничного условия Неймана
     iboundary : Integer; // уникальный номер границы к которой принадлежит эта точка.
     chnormal : Char; // внутренняя нормаль к границе
     // виды угловых точек
     // 0 - не угловая
     // 1 - левый нижний угол,
     // 2 - правый нижний угол,
     // 3 - левый верхний угол,
     // 4 - правый верхний угол
     // 5 - угол пятиточечный крест.
     iugol : Integer;
     // в уравнении для поправки давления
     // важно знать соседние с угловыми точками
     // это можно определить без дополнительной структуры данных

     // для ускорения вычислений.
     ini, isi, iwi, iei, ipi : Integer;
  end;

  TdynArraymyNodeold = array of TmyNodeold;
  TPdynArraymyNodeold = ^TdynArraymyNodeold;

  MatrixCoef = record
     // структура данных со значением
     // коэффициентов для одного уравнения системы
     // на пятиточечном шаблоне.
     // Данная структура используется
     // в уравнениях для каждой из компонент скорости
     // а также в уравнении для поправки давления.
     dae : Float; // восток
     daw : Float; // запад
     dan : Float; // север
     das : Float; // юг
     dap : Float; // центральная точка
  end; // MatrixCoef

  // Для двух уравнений и метода Ньютона-Канторовича
  // будет реализована сборка матрицы (после сборки
  // СЛАУ будет решаться методом верхней релаксации
  // с параметром верхней релаксации предложенным
  // в работе Ильина 1985 год.
  MatrixCoefNewton = record
      // первое уравнение для электрического потенциала :
      ap1phi, aw1phi, ae1phi, as1phi, an1phi, ap1n, aw1n, ae1n, an1n, as1n : Float;
      // второе уравнение для концентрации электронов :
      ap2phi, aw2phi, ae2phi, as2phi, an2phi, ap2n, aw2n, ae2n, an2n, as2n : Float;
      // коэффициенты для правой части.
      // правая часть для первого уравнения (электрического потенциала) :
      apr1phi, awr1phi, aer1phi, asr1phi, anr1phi, apr1n, awr1n, aer1n, anr1n, asr1n, b1 : Float;
      // правая часть для второго уравнения ( концентрации электронов) :
      apr2phi, awr2phi, aer2phi, asr2phi, anr2phi, apr2n, awr2n, aer2n, anr2n, asr2n, b2 : Float;
  end;

  TdynArrayMatrixCoef = array of MatrixCoef;
  TPdynArrayMatrixCoef = ^TdynArrayMatrixCoef;
  TamgArray = array of TnodeAMG;
  TPamgArray = ^TamgArray;

  InitializeValue = record
     // Данная структура данных используется
     // для начальной инициализации
     // полевых величин являющихся искомыми функциями:
     // поля температуры,
     // скорости, давления и т.д.
     TempInit : Float; // начальное значение поля температур
     XvelInit : Float; // начальное поле горизонтальной скорости
     YvelInit : Float; // начальное поле вертикальной скорости
     VofInit : Float; // начальное значение функции цвета.
     // параметризованные значения только $x и $y.
     UDS1Init : String; // начальное значение для uds1.
     UDS2Init : String; // начальное значение для uds2.
     UDS3Init : String; // начальное значение для uds3.
     UDS4Init : String; // начальное значение для uds4.
  end; // InitializeValue

  MaterialProperties = record
      // данная структура
      // содежит постоянные параметры
      // материалов
      drho : Float; // плотность
      dlambda : Float; // теплопроводность
      dcp : Float; // теплоёмкость
      dmu : Float; // динамическая вязкость
      beta : Float; // коэффициент линейного температурного расширения
  end; // MaterialProperties

  SourceInEquation = record
      // линеаризованный источниковый
      // член в уравнении
      dSc : Float; // постоянная составляющая
      dSp : Float; // линеаризованная
  end; // SourceInEquation

  // Этот тип данных введён, но
  // код программы на него ещё пока не перешёл.
  MySource = record
     // источниковые члены всех уравнений
     Temperature : SourceInEquation; // источниковый член уравнения теплопроводности
     VxVelocity  : SourceInEquation; // для горизонтальной скорости
     VyVelocity  : SourceInEquation; // для вертикальной скорости
     Omega : SourceInEquation; // для вихря
  end; // MySource

  // структура данных для алгоритма
  // ТОМАСА (трёхдиагональной матрицы или
  // метода прогонки).
  TOMASelem = record
       // коэффициенты одного уравнения
       // СЛАУ с трёхдиагональной матрицей
       // обозначения в соответствии
       //  с книжкой Патанкара стр. 47
       a : Float;
       b : Float;
       c : Float;
       d : Float;
       // прогоночные коэффициенты
       P : Float;
       Q : Float;
  end; // TOMASelem

  // структура данных
  // для параметров релаксации
  TRelaxFactors = record
     // параметры релаксации  для алгоритма SIMPLE
     Momentum : Float; // для уравнения сохранения импульса.
     PressureRelax : Float; // для давления
     // параметр релаксации для SOR:
     // последовательной верхней релаксации.
     // используется при нахождении поправки давления методом Гаусса-Зейделя
     pSORPressure : Float;
     pSORpresr : Float; // для давления в алгоритме SIMPLER
     // для поля температур
     pSORTempreture : Float;
     // User-Defined Scalar
     uds1 : Float;
     uds2 : Float;
     uds3 : Float;
     uds4 : Float;
     // иногда требуется замедлить скорость изменения
     // источникового члена от итерации к итерации.
     // Это может потребоваться при моделировании естественной конвекции
     // при очень больших числах Рэлея.
     prelaxBodyForce : Float; // для естественной конвекции при очень больших числах Рэлея.
  end; // TRelaxFactors

  // структура данных с количеством итераций
  // внутри одной итерации алгоритма SIMPLE
  TIterCountSIMPLE = record
      // количество итераций
      // внутри одной итерации
      // алгоритма SIMPLE

      // количество итераций для решения номинально линейной системы
      iterVxLin : Integer; // для Vx
      iterVyLin : Integer; // для Vy
      

      // количество итераций для
      //  уравнения поправки давления
      iterPamendment : Integer;
      // количество итераций для давления в алгоритме SIMPLER
      iterPressure : Integer;

      // для задач с учётом естественной конвекции
      // внутри одной итерации алгоритма SIMPLE
      // требуется решать также уравнение теплопроводности
      // с учётом конвективного члена.
      iterTemperature : Integer;  // поле температур

      // количество итераций для
      // определения функции тока
      iterStreamFunction : Integer;  // функция тока

      // количество итераций для определения функции цвета.
      iterVof : Integer; // функция цвета (VOF method).

      // Количество итераций для пользовательских скаляров.
      iteruds1 : Integer;
      iteruds2 : Integer;
      iteruds3 : Integer;
      iteruds4 : Integer;

  end; // TIterCountSIMPLE

  // структура данных позволяющая
  // индивидуально выбрать солвер к каждому уравнению
  TMyiTypeSolver = record
     // перечислим типы солверов
     // 1 - последовательный поточечный метод Гаусса-Зейделя (ГЗ)
     // 2 - метод переменных направлений (гибрид ГЗ и алгоритма ТОМАСА)
     // 3 - прямой метод исключения Гаусса
     // 4 - метод сопряжённых градиентов Хестенса и Штифеля
     // 5 - алгоритм Ю.Г. Соловейчика [1993]

     // для температуры
     itemperature : Integer; // солвер для поля температур
     // солвер для компонент скорости
     ivelocity : Integer;
     // солвер для поправки давления
     ipamendment : Integer;
     // для функции тока
     istreamfunction : Integer;

     // для функции цвета
     ivof : Integer;

     // User-Defined Scalar
     iuds1 : Integer;
     iuds2 : Integer;
     iuds3 : Integer;
     iuds4 : Integer;

  end; // TMyiTypeSolver

  // структура данных для
  // формирования разреженной матрицы
  // в формате CRS для метода Сопряжённых Градиентов
  TmyNonZeroElemMatrix = record
     // нужно хранить индексы
     // i,j определяющие местоположение
     // элемента в массиве
     i : Integer;
     j : Integer;
     // значение ненулевого элемента
     aij : Float;
     // специальный ключ для упорядочивания
     // по строкам
     key : Integer;

  end; // TmyNonZeroElemMatrix

  // структура со значением невязок
  // для контроля сходимости вычислительного
  // процесса
  TmyResidualControlSolution = record
     // здесь задаётся пороговое
     // значение невязки по
     // достижению которого
     // решение считается сошедшимся
     temp : Float; // невязка по температуре
     Vx, Vy : Float; // невязки по компонентам скорости
     Pamendment : Float; // невязка для поправки давления
     continity : Float; // нескомпенсированные источники массы
     streamfunction : Float; // невязка для функции тока
     Pressure : Float; // невязка для давления в алгоритме SIMPLER
     vof : Float; // для функции цвета.
     uds1,uds2,uds3,uds4 : Float; // невязка User-Defined Scalar.
  end; // TmyResidualControlSolution

  // структура с вибрационными параметрами при
  // ускорении свободного падения меняющемуся
  // по гармоническому закону.
  TGravityVibrations = record
     bOn : Boolean; // Булево значение показывающее включены ли вибрации
     // по умолчанию вибрации выключены, см. метод FormCreate.
     // В случае вибраций сила
     // тяжести меняется по гармоническому закону:
     // g_vibr = -4*((MPI*Frequency)^2)*Amplitude*Sin(2*MPI*Frequency*realFlowTime);
     Amplitude : Float; // амплитуда вибраций
     Frequency : Float; // частота вибраций
     // Информация о направлении вибраций содержится в следующей переменной:
     // chDirect принимающей только два значения: x или y. Они указывают на направление вибраций.
     chDirect : Char; // направление вибраций
  end; // TGravityVibrations

  // структура с параметрами вибрации погруженного вибратора
  TVibrations = record
      bOn : Boolean; // Включены ли вибрации
      Amplitude : Float; // амплитуда вибраций
      Frequency : Float; // частота вибраций
      // Метод послойной упругой деформации
      // начальная фиксированная граница
      jdstart : Integer; // нижнего деформируемого блока
      // подвижная верхняя граница
      jdend : Integer; // нижнего деформируемого блока
      // начальная подвижная граница
      jupstart : Integer; // верхнего деформируемого блока
      // конечная фиксированная граница
      jupend : Integer;  // верхнего деформируемого блока
      // уникальный идентификатор вибрирующей границы
      unicalidentifire : Integer;
      bOn2 : Boolean; // прорисовывать ли вибрирующее тело
      // уникальный номер вибрирующего блока
      unickbricknum : Integer;
      // уникальный номер контактирующего с подвижным блока
      // он расположен сверху подвижного блока как в методе Бриджмена.
      bBridshmen : Boolean;
      uniccontacktupbricknum : Integer;
  end;

  // Построение графика невязки
  TResidualPlot = record
      temperature : Float; // невязка температуры
      continity : Float; // нескомпенсированные источники массы
      Vx,Vy : Float; // невязка - скорость
      uds1,uds2,uds3,uds4 : Float; // невязка User-Defined Scalar.
  end;

  // Установим масштаб длины для
  // графической визуализации.
  TLengthScalePlot = record
     xscale, yscale : Float; // масштабы длины.
  end;

  TForm1 = class(TForm)
    // здесь перечислены  различные пункты меню.
    MainMenu1: TMainMenu;  // главное меню программы
    File1: TMenuItem; // операции с файлами
    Mesh1: TMenuItem; // меню генерации расчётной сетки
    Define1: TMenuItem;
    Solve1: TMenuItem;  // вызывает солвер
    Display1: TMenuItem;
    Mesh2: TMenuItem;
    General1: TMenuItem;
    N2Dplot1: TMenuItem;
    UseInterpolate1: TMenuItem;
    mainMemo: TMemo;
    // выбор решателя для каждого из
    // решаемых уравнений
    SelectSolver1: TMenuItem;
    // выбор схемы аппроксимации
    // конвективного члена
    ApproxConvection1: TMenuItem;
    // выбор решаемого набора уравнений
    // или уравнения
    Equation1: TMenuItem;
    // меню задания свойств материалов
    Materials1: TMenuItem;
    // меню задания граничных условий
    BoundaryCondition1: TMenuItem;
    // меню где можно задать источниковый член
    Source1: TMenuItem;
    Controls1: TMenuItem;
    Solution1: TMenuItem;
    RelaxationFactors1: TMenuItem;
    // задаёт параметры инициализации
    // которые потом используются для инициализации решения
    // перед расчётом
    Initialize1: TMenuItem;
    // вызывает меню
    // из которого потом можно будет запустить вычисление
    Run1: TMenuItem;
    // пункт меню где можно настроить
    // метод сопряжённых градиентов
    SoprGrad1: TMenuItem;
    // пункт меню где можно задать ускорение свободного падения
    Gravity1: TMenuItem;
    CreateGeom1: TMenuItem;
    TreeView1: TTreeView;
    DynamicMesh1: TMenuItem;
    MainPaintBox: TPaintBox;
    SIMPLE1: TMenuItem;
    Pressure1: TMenuItem;
    initialize2: TMenuItem;
    Patch1: TMenuItem;
    Read1: TMenuItem;
    Write1: TMenuItem;
    Export1: TMenuItem;
    Close1: TMenuItem;
    ecplot1: TMenuItem;
    Mesh3: TMenuItem;
    Mesh4: TMenuItem;
    OpenDialog1: TOpenDialog;
    guiParallel1: TMenuItem;
    guilanguage1: TMenuItem;
    UserDefined1: TMenuItem;
    Memory1: TMenuItem;
    Scalars1: TMenuItem;
    Animation1: TMenuItem;
    CustomFieldFunctions1: TMenuItem;
    guiInterpritator1: TMenuItem;
    guiest1: TMenuItem;
    guinotepad1: TMenuItem;
    Help1: TMenuItem;
    Report1: TMenuItem;
    SurfaceIntegrals1: TMenuItem;
    cbbdisplay: TComboBox;
    Limits1: TMenuItem;
    rials1: TMenuItem;
    guiBenarFLOW1: TMenuItem;
    AliceFlow2D1: TMenuItem;
    // Отладочная печать массива скоростей по оси Ох на визуализацию.
    procedure exportVx();
    // закрывает главное приложение
    procedure Close1Click(Sender: TObject);
    // вызывает простейший генератор сеток
    procedure Mesh2Click(Sender: TObject);
    // загружает МАРЕНА тест
    procedure MARENAtest1Click(Sender: TObject);
    // вызывает меню где можно настроить солвер
    procedure General1Click(Sender: TObject);
    // данный метод вызывается при создании
    // главной экранной формы приложения
    procedure FormCreate(Sender: TObject);
    // вызывает модуль с графической оболочкой
    // в котором производится высокоуровневое
    // управление решением
    procedure Run1Click(Sender: TObject);
    // вызывает менюшку где можно
    // изменить или задать параметры материалов
    procedure Materials1Click(Sender: TObject);
    // вызывает меню где можно передать картинку
    // в программу tecplot
    procedure ecplot1Click(Sender: TObject);
    // вызывает меню где можно изменить
    // или задать граничные условия
    procedure BoundaryCondition1Click(Sender: TObject);
    // вызывает меню где можно изменить или задать источниковые члены
    procedure Source1Click(Sender: TObject);
    // вызывает меню где можно вызвать реализованную визуализацию
    procedure N2Dplot1Click(Sender: TObject);
    // выбор способа интерполяции
    procedure UseInterpolate1Click(Sender: TObject);
    // выбор решателя: ГЗ или гибрид-ГЗ-Томас
    // также есть прямой метод исключения Гаусса и
    // метод сопряжённых градиентов.
    // Предусмотрена возможность выбора отдельного решателя
    // для каждого из уравнений.
    procedure SelectSolver1Click(Sender: TObject);
    // параметры релаксации
    procedure RelaxationFactors1Click(Sender: TObject);
    // выбор аппроксимации конвективных членов
    procedure ApproxConvection1Click(Sender: TObject);
    // выбор набора решаемых уравнений
    procedure Equation1Click(Sender: TObject);
    // вызывает меню где выставляются пороговые значения
    // невязок по достижению которых решение считается сошедшимся.
    procedure Solution1Click(Sender: TObject);
    // позволяет настроить солвер сопряжённых градиентов
    procedure SoprGrad1Click(Sender: TObject);
    // вызывает меню где можно задать ускорение свободного падения
    procedure Gravity1Click(Sender: TObject);
    procedure CreateGeom1Click(Sender: TObject);
    // доступ к менюшкам по древовидному дереву
    procedure TreeView1DblClick(Sender: TObject);
    // здесь задаются параметры динамической сетки
    procedure DynamicMesh1Click(Sender: TObject);
    // прорисовка графиков невязок
    procedure FormPaint(Sender: TObject);
    // задаёт структуру однй итерации алгоритма simple
    procedure SIMPLE1Click(Sender: TObject);
    // настройки для поправки давления:
    // выбор условий Неймана или подхода Патанкара.
    procedure Pressure1Click(Sender: TObject);
    // вызывает меню где можно изменить
    // или задать параметры инициализации
    // искомых величин
    procedure initialize2Click(Sender: TObject);
    procedure Patch1Click(Sender: TObject);
    procedure Mesh4Click(Sender: TObject);
    procedure Mesh3Click(Sender: TObject);
    // осуществляет выбор языка реализации
    procedure guilanguage1Click(Sender: TObject);
    // задаёт User-Define Memory
    procedure Memory1Click(Sender: TObject);
    // задаёт User-Define Scalar
    procedure Scalars1Click(Sender: TObject);
    // задаёт частоту сохранения анимационных кадров в программе tecplot360.
    procedure Animation1Click(Sender: TObject);
    // Custom Field Function
    procedure CustomFieldFunctions1Click(Sender: TObject);
    // тестирование интерпритатора команд
    procedure guiest1Click(Sender: TObject);
    // Вызов блокнота для записи заметок по ходу моделирования.
    procedure guinotepad1Click(Sender: TObject);
    // Вызов формы справки.
    procedure Help1Click(Sender: TObject);
    // Вычисление поверхностных интегралов на границах расчётной области.
    procedure SurfaceIntegrals1Click(Sender: TObject);
    // пределы измения пользовательских скаляров.
    procedure Limits1Click(Sender: TObject);
    // настройка много-параметрических расчётов.
    procedure rials1Click(Sender: TObject);
    procedure cbbdisplayChange(Sender: TObject);
    procedure guiBenarFLOW1Click(Sender: TObject);
    procedure AliceFlow2D1Click(Sender: TObject);



  private
    { Private declarations }

    // Транслятор формул.

    // поиск подстроки в строке
    //function Find(const S, P : String) : Integer;
    // подстановка значений переменных в строку
    // patterns - исходная неизменяемая строка.
    // workstring - преобразованная исходная строка.
    procedure my_substitutional_of_value(patterns : String; var workstring : String);
    // рекурсивная функция конструирования поддерева
    // выражения с корнем r из строки st
    procedure Constr_Tree(var r : pTop; var st : string);
    // рекурсивное вычисление значения функции
    // если key=false, то значение не существует
    function my_count(r : pTop;  var key : Boolean) : Float;
    // освобождение оперативной памяти занимаемой двоичным деревом
    procedure my_delete(var r : pTop);
    // конец транслятор формул.

  public
    { Public declarations }
    // к данным можно получить доступ из других модулей
    // а методы можно вызывать из других модулей

    // данные
    bIlyin : Boolean; // автоматическое вычисление параметра верхней релаксации.
    bIlyinvel : Boolean;  // автоматическое определение параметра релаксации для компонент скорости.
    relaxIlyin : Float; // оптимальный параметр релаксации.

    lengthscaleplot : TLengthScalePlot; // масштаб длины.

    // показ анимации решения прямо во время вычислений.
    banimationnow : Boolean;

    bGarberArtDiffusion : Boolean; // Искуственная диффузия предложенная вработе Г.З.Гарбера.

    bISezai : Boolean; // увеличивает реалистичность течения в счёт ослабления сходимости.
    brealisticflow, brealistictemperature : Boolean; // включает схему второго порядка с помощью метода отложенной коррекции.

    bVOFExplicit : Boolean; // явная схема для VOF.
    iantidiffusionBuragoevery : Integer; // через сколько шагов по времени применять антидиффузионную корекцию.

    // язык на котором реализованы критические участки кода.
    // 0 - Pascal (Никлауса Вирта)
    // 1 - С (Керниган и Риччи)
    // 2 - C and OpenMP
    // 3 - cuda C
    ilanguage : Integer;
    // количество потоков на cpu
    ig_nNumberOfThreads : Integer;
    bNICENO : Boolean; // использовать или нет код EasyMesh.

    // Следующие три переменные нужны для ускорения работы метода
    // сопряжённых градиентов.
    pointerlist_gl : array of Integer;
    pointerlistrevers_gl : array of Integer;
    bconstr : Boolean; // флаг указывающий на то производить ли построение указанных массивов или нет.

    // для исследования сходимости гидродинамических
    // алгоритмов SIMPLE
    freport : TStrings;
    // Последовательность узлов сетки (контрольных объёмов)
    mapPT : TdynArraymyNode;  // карта для обычных переменных T и P.
    mapVx : TdynArraymyNode;  // карта для горизонтальной скорости
    mapVy : TdynArraymyNode;  // карта для вертикальной скорости
    // максимальное количество контрольных объёмов
    // для обыкновенных переменных
    imaxnumbernode : Integer;
    // для шахматной сетки.
    imaxnumbernodeVx : Integer; // горизонтальная скорость
    imaxnumbernodeVy : Integer; // вертикальная скорость
    // для управления солвером
    bweShouldContinue : Boolean; // для преостановки вычислений как только становится false
    // для выполнения инициализации:
    // 1 - чистая теплопроводность,
    // 2 - теплопроводность с учётом конвективного члена на основе MARENA тест,
    // 3 - чистый Навье-Стокс без теплопроводности,
    // 4 - Навье-Стокс с учётом теплопроводности.
    // 5 - VOF метод.
    bweShouldInitialize : array [1..5] of Boolean; // проверка нужно ли инициализировать переменные и выделить память перед началом счёта.
    // индивидуальный выбор солвера для каждого уравнения в отдельности
    // 1 <=> Гаусса-Зейделя, 2 <=> метод переменных направлений.
    // 3 <=> прямой метод исключения Гаусса, 4 <=> метод сопряжённых градиентов Хестенса и Штифеля
    itypesolver : TMyiTypeSolver;

    // Информация о двухсеточном методе Федоренко.
    sFedor : TmyFedorenko1961;

    // Метод сопряжённых градиентов Хестенса и Штифеля требует от матрицы
    // только реализации умножения её на некоторый вектор.
    // более эффективной реализацией метода сопряжённых градиентов
    // как  по памяти так и по быстродействию является его
    // реализация на основе технологии хранения матрицы CRS.
    // В данной программе метод сопряжённых градиентов реализован с учётом CRS технологии хранения разреженной матрицы.
    // для реализации такого подхода требуется сортировка.
    // Здесь реализована быстрая сортировка Хоара и Пирамидальная сортировка.
    // у пользователя должна быть возможность выбора алгоритма сортировки.
    itypesorter : Integer; // 1 - quick sort, 2 - Heap sort.
    // контроль сходимости
    // пороговые значения невязок.
    rcs : TmyResidualControlSolution;
    // какую норму использовать ?
    // 1 - евклидову, 2 - кубическую норму, 3 - октаэдрическую норму
    ibasenorma : Integer;

    myrelaxfactors : TRelaxFactors; // параметры релаксации
    iterSimple :  TIterCountSIMPLE; // структура одной итерации алгоритма SIMPLE
    btimedepend : Boolean; // стационарная или нестационарная разностная схема
    // для алгоритма SIMPLEC возможно могут потребоваться
    // совсем другие параметры релаксации.
    bsimplec : Boolean; // применять ли алгоритм SIMPLEC ?
    bsimpler : Boolean; // применять ли алгоритм SIMPLER ?
    ishconv : Integer; // тип схемы для конвективного члена для всего кроме UDS.
    ishconvtemp : Integer; // схема аппроксимации конвективного члена в уравнении теплопроводности.
    ishconvvof : Integer; // схема аппроксимации конвективного члена для vof.
    ishconv1, ishconv2, ishconv3, ishconv4 : Integer; // схема аппроксимации конвективного члена для UDS.
    // выбор граничного условия на выходной границе потока
    // 0 - условия Патанкара, 1 - F[i]=2*F[i-1]-F[i-2], 2 - равенство значений в граничной и ближайшей к границе точкам;
    ioutflow : Integer;
    // выбор мат модели (набора уравнений и граничных, начальных условий)
    // значения переменной imodelEquation:
    // 1 - чистая теплопроводность,
    // 2 - User-Defined Segregated Solver,
    // 3 - чистая гидродинамика,
    // 4 - гидродинамика с учётом теплопроводности.
    // 5 - гидродинамика и VOF метод.
    imodelEquation : Integer; // уравнения и их комбинации  которые подвержены решению сейчас
    itercount : Integer; // количество итераций
    iglobalnumberiteration : Integer; // глобальный номер итерации
    dTimeStep : Float; // постоянный шаг по времени
    inumbertimestep : Integer; // количество шагов по времени
    // текущее расчётное время при нестационарном расчёте
    realFlowTime : Float; // оно устанавливается при инициализации решения, а так сохраняется
    // число шагов за период при периодических процессах
    inumberTimeStepDivisionPeriod : Integer;
    // количество периодов
    inumberPeriod : Integer;

    // Некоторые параметры расчётной сетки.
    // При создании (первом запуске) приложения желательно, чтобы
    // избежать сбоев программы вызванных попыткой
    // выполнить расчёт на непостроенной сетке,
    // генерировать некую расчётную сетку по умолчанию:
    // например, равномерную 10 на 10.
    // сейчас это реализовано сразу при создании главной формы.
    dLx,dLy : Float; // размеры расчётной области
    inx, iny : Integer; // количество узлов расчётной сетки по x и y
    xpos, ypos : array of Float; // координаты узлов сетки

    // запись с начальными значениями
    // искомых полевых величин:
    // содержатся начальные значения для
    // температуры, компонент скорости и т.д.
    InitVal : InitializeValue;

    // это одномерное представление двумерного массива [i][j]
    // в соответствии с отображением k=i+(j-1)*inx;
    T      : array of Float; // поле температур
    TOldIteration : array of Float; // поле температур с предыдущей итерации
    ToldTimeStep : array of Float; // поле температур с предыдущего временного слоя
    bsecondordertemp : Boolean; // использовать ли схему Пейре.
    ToldoldTimeStep : array of Float; // для схемы Пейре.
    SF     : array of Float; // функция тока
    Omega  : array of Float; // Вихрь
    OmegaoldTimeStep : array of Float; // вихрь с предыдущего шага по времени
    // скорости рассчитываются на смещённой шахматной сетке
    Vx, Vy : array of Float; // горизонтальная и вертикальная компоненты скорости
    VxOld  : array of Float; // поле скорости Vx с предыдущей итерации
    VyOld  : array of Float; // поле скорости Vy с предыдущей итерации
    VxActing  : array of Float; // горизонтальная скорость на основе которой собираются матрицы.
    VyActing : array of Float; // вертикальная скорость на основе которой собираются матрицы.
    VxOldTimeStep : array of Float; // поле скорости Vx с предыдущего временного шага
    VyOldTimeStep : array of Float; // поле скорости Vy с предыдущего временного шага
    bsecondorderflow : Boolean; // использовать ли схему Пейре ?
    VxOldOldTimeStep : array of Float; // поле скорости Vx с двойного предыдущего временного шага
    VyOldOldTimeStep : array of Float; // поле скорости Vy с двойного предыдущего временного шага
    P      : array of Float; // давление
    Pamendment : array of Float; // поправка давления
    D, D2, D3  : array of Real; // массив для визуализации

    // Полное давление с учётом гидростатического.
    // Точка к которой привязывается вычисление гидростатического давления
    // есть начало координат (координаты 0,0) - левый нижний угол квадрата.
    Pressureabsolute : array of Float;
    OperatingPressure : Float;
    CourantNumber : Float; // Число Куранта
    VOF : array of Float; // VOF метод
    bCSF : Boolean; // Continuum surface force.
    rsigma : Float; // коэффициент поверхностного натяжения.
    bWallAdhesion : Boolean; // краевые углы смачивания.
    CSFx, CSFy : array of Float; // сила поверхностного натяжения.
    bVOFsecondorder : Boolean; // использовать ли формулу Пейре для аппроксимации по времени в VOF методе.
    VOFOldOldTimeStep : array of Float; // функция цвета с двойного предыдущего временного слоя.
    VOFOldTimeStep : array of Float; // функция цвета с предыдущего временного слоя.
    DensityOldTimeStep : array of Float; // значение плотности с предыдущего временного слоя

    kstreamdivision : Integer; // для глобальной средней функции тока
    // массив горизонтальных координат
    // на невозмущённой сетке.
    // используется при анимации движения сетки
    // и при расчёте с вибрацией
    yposfix : array of Float;
    // функция тока
    meanSF1T : array of Float; // средняя функция тока на одном периоде.
    meanSFGl : array of Float; // глобальная средняя функция тока
    meanSF : array of Float; // математическое ожидание функции тока
    // вихрь
    meanOmega1T : array of Float; // средний вихрь на одном периоде
    meanOmegaGl : array of Float; // глобальный средний вихрь
    meanOmega : array of Float;  // математическое ожидание от вихря
    // давление
    meanPressure1T : array of Float; // среднее давление за период
    meanPressureGl : array of Float; // глобальное среднее давление
    meanPressure : array of Float; // математическое ожидание от давления
    // поле температур
    meanT1T : array of Float; // среднеее от температуры на одном периоде
    meanTGl : array of Float; // глобальная средняя температура
    meanT : array of Float; // математическое ожидание от температуры
    // горизонтальная скорость
    meanVx1T : array of Float; // среднее от горизонтальной скорости на одном периоде
    meanVxGl : array of Float; // глобальная средняя горизонтальная скорость
    meanVx : array of Float; // мат. ожидание от горизонтальной компоненты скорости
    // вертикальная скорость
    meanVy1T : array of Float; // среднее от вертикальной скорости на одном периоде
    meanVyGl : array of Float; // глобальная средняя вертикальная скорость
    meanVy : array of Float; // мат. ожидание от  вертикальной компонены скорости


    // значения источниковых членов уравнений
    // используется в специальном меню для
    // изменения или задания источниковых членов
    defmysource : MySource; // источниковые члены уравнений

    // Источниковые члены
    // источниковый член для темперауры
    dSc : array of Float; // постоянная составляющая источникового члена
    dSp : Float; // второй член при линеаризации источникового члена
    // источниковый член для Vx компоненты скорости
    dScVx : Float; // постоянная составляющая (например Буссинесковская dbeta*drho*dgravityx*T)
    dSpVx : Float; // линеаризованная составляющая (в большинстве случаев отсутствует)
    // источниковый член для Vy компоненты скорости
    dScVy : Float; // постоянная составляющая (например Буссинесковская dbeta*drho*dgravityy*T)
    dSpVy : Float; // линеаризованная составляющая (в большинстве случаев отсутствует)


    // постоянные параметры материалов
    // хранятся в структуре MaterialProperties.
    // Схема работы такая:
    // при создании главной формы MainUnit
    // полям этой структуры присваиваются определённые
    // значения.
    // если нужно изменить параметры материалов
    // то это делается в отдельной экраной  форме
    // после посещения которой параметры материалов
    // будут записаны в эту стрктуру.
    // при реализации численных процедур пока правда используются
    // параметры материалов из полей данных приведённых ниже.
    // Полное взаимодействие этих двух представлений пока не налажено.
    matprop : array [0..1] of MaterialProperties;

    // параметры материалов
    lambda : array of Float; // теплопроводность
    drho   : Float; // постоянная плотность
    dcp    : Float; // постоянная теплоёмкость
    dmu    : array of Float; // динамическая вязкость жидкости
    // приближение Буссинеска
    bBussinesk : Boolean; // нужно ли учитывать приближение Буссинеска.
    dgx, dgy : Float; // ускорение свободного падения
    dbeta : Float; // коэффициент температурного расширения
    // Сила тяжести является гармонической функцией времени
    rgravVib : TGravityVibrations; // параметры вибрационного воздействия
    actiVibr : TVibrations; // вибрации погруженного активатора

    imarker : Integer; // маркер конца для отображения графика невязок
    myresplot : array of TResidualPlot; // массив со значениями невязки

    // Граничные условия в уравнении для поправки давления:
    // если = true значит нет влияния от точки на границе как у Патанкара в книжке,
    // а если = false значит условие Неймана равенство нулю нормальной производной.
    bPatankarPressure : Boolean;
    // фиксировать ли уровень поправки давления в одной точке ?
    // true - надо, false - не надо ( только если это допускается методом
    // решения СЛАУ).
    // Например метод Гаусса - Зейделя это допускает, а прямой метод Гаусса нет.
    bipifixpamendment : Boolean;

    // Дополнительные данные, например, для физики полупроводников
    // и не только.

    // 26 июня 2013 года.
    // User Defined Scalar (связаны только с основной картой mapPT)
    // Для скаляров решается уравнение переноса.
    imaxUDS : Integer; // максимальное число User-Defined Scalar`ов не более 3. (1, 2, 3).
    // Маски сужающие (формирующие форму) расчётной области.
    // На границе маски стоит однородное условие Неймана.
    // Это позволит вести расчёт на декартовых прямоугольных сетках в условиях
    // геометрии произвольной сложности.
    // пока возможна лишь одна маска по умолчанию занимающая всю расчётную область.
    bMask : array of Boolean; // TRue внутренность, False - выпадает.
    // Записано ли уравнение для User-Defined Scalar`a на маске или нет.
    // Узлы не принадлежащие маске заморожены в момент инициализации.
    imaskuds1 : Integer; // рассчитывать ли uds1 используюя маску 0 - нет (вся расчётная область), 1 - использовать маску.
    imaskuds2 : Integer;
    imaskuds3 : Integer;
    imaskuds4 : Integer;

    // Для User-Defined Scalar нужно указать :
    // 0. граничные условия !!!.
    // 1. коэффициент диффузии. 2. источниковый член. 3. конвективный член.
    // User-Defined Scalar.
    // имена при показе невязок совпадают UDS<number>, number начинается с единицы.
    UDS1 : array of Float;
    UDS2 : array of Float;
    UDS3 : array of Float;
    UDS4 : array of Float;
    // Скаляры с предыдущего шага по времени.
    UDS1oldTimeStep : array of Float;
    UDS2oldTimeStep : array of Float;
    UDS3oldTimeStep : array of Float;
    UDS4oldTimeStep : array of Float;
    // Соответствующие постоянные коэффициенты диффузии :
    // пока просто в виде строк которые интерпретируются внутренним интерпретатором.
    gamma1str : String;
    gamma2str : String;
    gamma3str : String;
    gamma4str : String;
    // Диффузионный член в пользовательском скаляре.
    uds1diffusivity : array of Float;
    uds2diffusivity : array of Float;
    uds3diffusivity : array of Float;
    uds4diffusivity : array of Float;
    // Источниковые члены :
    // По умолчанию источниковые члены определены на сетке mapPT и для
    // них изначально задаётся нулевое значение  (или любая константа
    // на вкладке Define-Source).
    // определены на сетке mapPT.
    // постонная составляющая источникового члена.
    dSc1 : array of Float;
    dSc2 : array of Float;
    dSc3 : array of Float;
    dSc4 : array of Float;
    // параметризованный источник.
    dsc1str : String;
    dsc2str : String;
    dsc3str : String;
    dsc4str : String;
    // линеаризованная составляющая источникового
    // члена должна быть меньше либо равна нулю.
    // Определено на основной сетке mapPT.
    dSp1 : array of Float;
    dSp2 : array of Float;
    dSp3 : array of Float;
    dSp4 : array of Float;
    // параметризованный источник.
    dsp1str : String;
    dsp2str : String;
    dsp3str : String;
    dsp4str : String;
    // Конвективный член пока полностью выключен (отсутствует).
    itypemassFluxuds1 : Integer; // 0 нет конвективного члена (он тождественный ноль)
    itypemassFluxuds2 : Integer; // 1 - стандартный конвективный член на основе гидродинамических компонент скорости.
    itypemassFluxuds3 : Integer; // 2 - определённый пользователем вариант.
    itypemassFluxuds4 : Integer;
    // компоненты uds скоростей должны инициализироваться перед каждым решением uds скаляра.
    Vxuds : array of Float;
    Vyuds : array of Float;
    // символьное представление.
    // Можно использовать операторы:
    // $gradxuds1, $gradyuds2 и т.п.
    Vxuds1str : String;
    Vyuds1str : String;
    Vxuds2str : String;
    Vyuds2str : String;
    Vxuds3str : String;
    Vyuds3str : String;
    Vxuds4str : String;
    Vyuds4str : String;
    // Нестационарный член :
    itypeuds1unsteadyfunction : Integer; // 0 - стационарная задача.
    itypeuds2unsteadyfunction : Integer; // 1 - стандартная нестационарная задача.
    itypeuds3unsteadyfunction : Integer;
    itypeuds4unsteadyfunction : Integer;
    // Плотность.
    // 0 - константа равная единице (потом можно сделать константу задаваемую пользователем),
    // гидродинамическая плотность задаваемая пользователем для гидродинамики в частности и для VOF метода.
    iuds1typerho : Integer;
    iuds2typerho : Integer;
    iuds3typerho : Integer;
    iuds4typerho : Integer;

    // Буссинесковская сила всплытия в которой роль температуры играет соответсвующая UDS.
    // подстёгивается к гидродинамическому солверу на шахматных сетках.
    dbetaUDS1 : Float;
    dbetaUDS2 : Float;
    dbetaUDS3 : Float;
    dbetaUDS4 : Float;

    // Пределы изменения каждой из UDS.
    // Возможно позволит решить проблемы сходимости для систем нелинейных уравнений.
    sollimuds1min : Float;
    sollimuds1max : Float;
    sollimuds2min : Float;
    sollimuds2max : Float;
    sollimuds3min : Float;
    sollimuds3max : Float;
    sollimuds4min : Float;
    sollimuds4max : Float;

    // Вещественный параметр характеризующий уникальность поллескоростной характеристики кремния.
    ruds_silicon  : Float;
    // Два вещественных параметра указывающие уникальность полескоростной характеристики GaAs :
    ruds_GaAs_top : Float;
    ruds_GaAs_bottom : Float;
    // Источниковый член в первом уравнении для диффузионно-дрейфовой модели имеет стандартную форму и это надо
    // учесть для увеличения Быстродействия. ДДМ очень важна поэтому имеет смысл прилагать все усилия чтобы она быстро считала.
    // 0 - стандартный user-defined шаблон.
    // 1 - источниковый член в диффузионно дрейфовой модели (из двух уравнений первое для электрического потенциала, для
    // этого уравнения как раз и задаётся источниковый член, а второе уравнение для переноса электронного газа (именно электронного).
    // ) вида K1*(1.0-$uds2), где K1=rdsc1K1 - заданная пользователем постоянная.
    // 2 - аналогично с 1 но источник имеет вид $udm1-K1*$uds2, здесь $udm1 - неоднородное легирование,
    // $uds2 - концентрация электронов, K1=rdsc1K1 - константа определённая пользователем.
    idsc1type : Integer;
    rdsc1K1 : Float;
    // Следующая булева переменная равна True только тогда когда в момент вычисления
    // для первого уравнения имеем константу dSpравную нулю тождественно, и константный коэффициент диффузии.
    // а dsc определяется по быстрму встроенному шаблону!!!.
    // Значение True проверяется и в случае необходимости присваивается внутри simple algorithm`a
    // в ручную значение False здесь менять ни в коем случае нельзя !!!
    buds1coefconst : Boolean;
    diffuds1const : Float; // константный коэффициент диффузии для первого уравнения во всей расчётной области,
    // используется только при buds1coefconst=true;

    // номер текущей uds 1,2 или 3 необходимо при решении.
    // показывает какую из UDS решать в данный момент.
    icurentuds : Integer; // задаётся из SIMPLE алгоритма.

    // User - Defined Memory (предполагается что её можно будет выбирать
    // в качестве источниковых членов и не только).
    imaxUDM : Integer; // максимальное количество пользовательской памяти (1,2 или 3).
    // Для UDM требуется определить только значения уравнение для неё не решается.
    // UDM определено на сетке mapPT и только на ней.
    UDM1 : array of Float;
    UDM2 : array of Float;
    UDM3 : array of Float;


    fanimationtecplot : TStrings; // анимация в программе tecplot 360.
    // запись (сохранение) анимационного кадра каждые
    ianimateeverytimestep : Integer;  // шагов по времени.
    // Если расчётная сетка сгенерирована и границы занесены в список то
    // bcreateboundary=True, а если генерация сетки ещё не произведена то
    // список границ не сформирован и нельзя вызывать форму задания граничных условий.
    bcreateboundary : Boolean;

    ivar : Integer; // количество переменных
    parametric : array of TmyVariable; // список переменных и их значений.

    // Переменные для parametric trial.
    ivar_trial : Integer; // количество переменных    для parametric trial
    base_value_trial : array of TmyVariable; // список переменных и их значений для parametric trial.
    // список принимаемых значений для каждой переменной.
    series_value_of_the_variable : array of array of Float;


    // Функции определённые пользователем только для визуализации.
    inumCFF : Integer; // количество активных пользовательских функций.
    cff1str : String;  // пользовательские функции всего не более 10
    cff2str : String;
    cff3str : String;
    cff4str : String;
    cff5str : String;
    cff6str : String;
    cff7str : String;
    cff8str : String;
    cff9str : String;
    cff10str : String;
    cff1name : String; // имена пользовательских функций всего не более 10
    cff2name : String;
    cff3name : String;
    cff4name : String;
    cff5name : String;
    cff6name : String;
    cff7name : String;
    cff8name : String;
    cff9name : String;
    cff10name : String;



    // методы
    // транслятор формул:
    // преобразует параметризованую строку содержащую переменные в вещественное число.
    // если bOk = true то операция преобразования прошла успешно, если bOk=false
    // то операция преобразования содержит ошибку и операцию преобразования надо отменить
    function my_real_convert(s : String; var bOk : Boolean) : Float;

    // конец транслятора формул.


    // используется для уравнения теплопроводности
    // передаёт параметры из формы в программу,
    // задаёт постоянные параметры материалов,
    // задаёт постоянные источникового члена,
    // выделяет память под массивы использующиеся
    // при решениии уравнения теплопроводности
    procedure initparam;
    // используется для решения уравнений Навье-Стокса
    // передаёт параметры из формы в программу
    // задаёт парамеры материалов,
    // выделяет память под массивы для компонент скорости
    // и для давления
    procedure initparam2;
    // инициализация материалов
    // инициализация коэффициента теплопроводности
    procedure initlambda;
    // инициализация коэффициента динамической вязкости
    procedure initmu;
    // инициализация поля температур
    procedure initTemp;
    // инициализация постоянной составляющей источникового члена
    procedure initdSc;
    // инициализация распределения давления
    procedure initPressure;
    // инициализация распределения поправки давления
    // О важности начального распеределения поправки давления
    // в данном случае:
    // Любой итерационный метод решения алгебраических
    // уравнений даёт сходимость решения, абсолютное значение
    // которого определяется начальным приближением.
    procedure initPamendmentZero;
    // инициализация горизонтальной
    // компоненты скорости
    procedure initXvel;
    // инициализация вертикальной
    // компоненты скорости
    procedure initYvel;
    // задание граничных условий для поля температур
    procedure initBoundaryConditionTempreture;
    // задание граничных условий
    // первого рода
    // для горизонтальной компоненты скорости
    procedure initBoundaryConditionVx;
    // задание граничных условий
    // первого рода
    // для вертикальной компоненты скорости
    procedure initBoundaryConditionVy;
    // вызывает визуализатор для функции D
    procedure myDisp;
    // запоминание поля температуры
    // для того чтобы использовать эти значения
    // на следующем временном слое
    // В случае если передаваемый параметр bcopyoldtimetempreture принимает значение true.
    // Если этот параметр принимает значение false то копируется поле температур с предыдущей итерации.
    // Это нужно для сильно нелинейных задач для применения нижней релаксации.
    procedure RememberTOldTimeStep(bcopyoldtimetempreture : Boolean);
    // возвращает наибольшую из величин da, db.
    // используется при аппроксимации конвективного члена
    function maxoper(da,db : Float) : Float;
    // функция A(|P|) для различных схем
    // ishconvection - номер схемы
    // используется при аппроксимации конвективного члена
    function ApproxConvective(fp : Float; ishconvection : Integer) : Float;
    // данная процедура по позиции i,j в матрице для Vx
    // возвращает значения коэффициентов на пятиточечном шаблоне
    procedure Vxcoef(i, j : Integer; var m : MatrixCoef; var mf : Float; var attrs : Float);
    // данная процедура по позиции i,j в матрице для Vx
    // возвращает значения коэффициентов на пятиточечном шаблоне
    // для данного узла i,j в случае когда этот узел находится на правой выходной границе
    procedure VxcoefRight(i, j : Integer; var m : MatrixCoef; var db : Float);
    // данная процедура по позиции i,j в матрице для Vx
    // возвращает значения коэффициентов на пятиточечном шаблоне
    // для данного узла i,j
    // в случае когда выходная граница находится слева
    procedure VxcoefLeft(i, j : Integer; var m : MatrixCoef; var db : Float);
    // для верхней границы
    procedure VxcoefTop(i, j : Integer; var m : MatrixCoef; var db : Float);
    // для нижней границы
    procedure VxcoefBottom(i, j : Integer; var m : MatrixCoef; var db : Float);
    // коэффициенты дискретного аналога для
    // горизонтальной компоненты скорости
    procedure VxGlobalCoef(var mglobal : array of MatrixCoef;  // все коэффициенты дискретного аналога
                           var dbglobal : array of Float;
                           bPressureSimpler : Boolean);  // часть источникового члена
    // решение нелинейного уравнения для горизонтальной скорости
    // на основе метода переменных направлений.
    procedure SolveVx(var mglobal : array of MatrixCoef;
                         var dbglobal : array of  Float);
    // данная процедура по позиции i,j в матрице для Vy
    // возвращает значения коэффициентов на пятиточечном шаблоне
    // для данного узла i,j
    procedure Vycoef(i, j : Integer; var m : MatrixCoef; var mf : Float; var attrs : Float);
    // для верхней границы
    procedure VycoefTop(i, j : Integer; var m : MatrixCoef; var db : Float);
    // нижняя граница
     procedure VycoefBottom(i, j : Integer; var m : MatrixCoef; var db : Float);
     // левая стенка
     procedure VycoefLeft(i, j : Integer; var m : MatrixCoef; var db : Float);
     // правая стенка.
     procedure VycoefRight(i, j : Integer; var m : MatrixCoef; var db : Float);
    // коэффициенты дискретного аналога для
    // вертикальной компоненты скорости
    procedure VyGlobalCoef(var mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
                           var dbglobal : array of Float;
                           bPressureSimpler : Boolean); // часть источникового члена
    // решение нелинейного уравнения для вертикальной скорости
    // методом переменных направлений.
    // в стационарном случае
    procedure SolveVy(var mglobal : array of MatrixCoef;
                         var dbglobal : array of  Float);

    // загружает основной тест
    // программного комплекса МАРЕНА
    // загрузка должна производится только после генерации сетки
    // эти функции можно использовать для инициализации
    // всех обрабатываемых матриц.
    // Такая инициализация сделана при загрузке программы.
    procedure MARENAload;
    // Делает одну иерацию методом Гаусса - Зейделя
    // для универсальной искомой функции U.
    procedure GZUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         var map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         var db : array of Float;  // коэффициенты правой части, содержащие источниковый член
                         var QneiC : TQneiC);
    // решение СЛАУ с трёхдиагональной матрицей
    // при вертикальной прошивке расчётной области
    procedure TDMAGibridGZUniversalVertical(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           boncond : Integer; // тип граничных условий снизу
                           bonconup : Integer; // тип граничных условий сверху
                           jstart, jend : Integer; // маркеры начала и конца прогонки
                           i : Integer; // номер вертикальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // решение СЛАУ с трёхдиагональной матрицей
    // при горизонтальной прошивке расчётной области
    procedure TDMAGibridGZUniversalGorizontal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           bonconl : Integer; // тип граничных условий слева
                           bonconr : Integer; // тип граничных условий справа
                           istart, iend : Integer; // маркеры на чала и конца прогонки
                           j : Integer; // номер горизонтальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // делает одну итерацию методом переменных направлений
    // для универсальной полевой величины U.
    // За тип граничных условий отвечает переменная iboncon.
    // этому методу передаются на вход коэффициенты дискретного аналога
    procedure TDMAGibridGZUniversal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           const map : array of TmyNode; // карта
                           chvariable : Char; // какая переменная рассматривается
                           var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           var db : array of Float;
                           var Aseqx : TPeacemanRachford;
                           var Aseqy : TPeacemanRachford;
                           bpreprocessing : Boolean); // коэффициенты правой части, содержащие источниковый член
    // Граничное условие II рода на левой стенке
    procedure TempBoundaryCoefLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                   var db : array of Float; // правая часть
                                   qbleft : Float; // заданный тепловой поток на границе
                                   place : TmyNode); // место на карте
    // Граничное условие II рода на правой стенке
    procedure TempBoundaryCoefRight(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                    var db : array of Float; // правая часть
                                    qbright : Float; // заданный тепловой поток на границе
                                    place : TmyNode); // место на карте
    // Граничное условие II рода на нижней стенке
    procedure TempBoundaryCoefBottom(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                     var db : array of Float; // правая часть
                                     qbbottom : Float; // заданный тепловой поток на границе
                                     place : TmyNode); // место на карте
    // Граничное условие II рода на верхней стенке
    procedure TempBoundaryCoefTop(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                  var db : array of Float; // правая часть
                                  qbtop : Float; // заданный тепловой поток на границе
                                  place : TmyNode); // место на карте
    // вычисление коэффициентов дискретного аналога для уравнения
    // теплопроводности.
    procedure TempCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                          var db : array of Float); // правая часть
    // Граничное условие II рода на левой стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                       var db : array of Float; // правая часть
                                       qbleft : Float; // заданный тепловой поток на границе
                                       place : TmyNode); // место на карте
    // Граничное условие II рода на правой стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvRight(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                        var db : array of Float; // правая часть
                                        qbright : Float; // заданный тепловой поток на границе
                                        place : TmyNode); // место на карте
    // Граничное условие II рода на нижней стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvBottom(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                         var db : array of Float; // правая часть
                                         qbbottom : Float; // заданный тепловой поток на границе
                                         place : TmyNode); // место на карте
    // Граничное условие II рода на верхней стенке
    // для уравнения теплопроводности с учётом конвективного члена.
    procedure TempBoundaryCoefConvTop(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                      var db : array of Float; // правая часть
                                      qbtop : Float; // заданный тепловой поток на границе
                                      place : TmyNode); // место на карте
    // вычисляет коэффициенты дискретного аналога для
    // уравнения теплопроводности с учётом конвективного члена
    // Внимание: перед использованием этой процедуры массиву
    // ToldTimeStep должна быть выделена оперативная память и
    //  он должен быть проинициализирован.
    procedure TempConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                            var db : array of Float);   // правая часть
    // Решает задачу стационарной теплопроводности
    // с учётом конвекции или без учёта конвекции
    // в зависимости от параметра bconv: true - с конвективным членом,
    // false - без конвективного члена.
    // Все операции по вычислению коэффициентов
    // дискретного аналога вынесены за пределы цикла.
    // Это можно сделать потому, что значения этих
    // коэффициентов зависят только от координат x и y
    // а сетка неизменна, зависимости коэффициентов
    // дискретного аналога от искомой функции тоже нет,
    // так что задача линейна.
    // недостатком является использование несколько большего
    // количества оперативной памяти.
    // В эту универсальную процедуру включены два решателя:
    // первый на основе метода Гауса-Зейделя, а второй
    // на основе процедуры TDMAGibridGZforT.
    procedure SolveTempSteady(bmessage : Boolean; kfinish : Integer; bconv : Boolean);
    // нестационарный температурный солвер
    // с учётом или без учёта конвективного члена
    // в зависимости от булева параметра bconv: true - с учётом конвективного члена
    // false - чистая теплопроводность.
    procedure SolveTempUnsteady(bconv : Boolean);
    // преобразованные коэффициенты дискретного аналога
    // компонент скорости (см. idirect : 1 - x, 2 - y)
    // которые используются в уравнении для поправки давления.
    function Vcoefpam(i : Integer; j : Integer; idirect : Integer) : Float;
    // решает линейное уравнение для поправки давления
    // ускоренным методом Гаусса-Зейделя
    // ускорение достигается за счёт того, что коэффициенты
    // дискретного аналога не зависят от искомой функции
    // т.е. уравнение линейно и эти коэффициенты можно
    // вычислить только один раз и запомнить.
    procedure SolveGZPamendment(bipifix : Boolean; // фиксировать ли уровень поправки давления  ?
                                   var rescontinity : Float); // нескомпенсированные источники массы
    // коррекция Давления
    procedure CorrectNewPressure;
    // поправочная формула для горизонтальной скорости
    procedure CorrectVx;
    // поправочная формула для вертикальной скорости
    procedure CorrectVy;
    // решает стационарную задачу чистой теплопроводности
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    procedure RunCleanThermalConductionSteady;
    // решает стационарную задачу теплопроводности с учётом конвекции
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    procedure RunConvectiveThermalConductionSteady;
    // алгоритм SIMPLE
    // стационарный алгоритм SIMPLE
    // если bposttemperature = true то с учётом теплопроводности,
    // но без учёта приближения Буссинеска,
    // т.е. гидродинамика не зависит от теплопроводности,
    // а теплопроводность зависит.
    // Приближение Буссинеска также реализовано, за него
    // отвечает глобальный параметр bBussinesk
    procedure myVersionSIMPLEAlgorithm(bposttemperature : Boolean);
    // запоминание горизонтальной компоненты скорости
    // удовлетворяющей уравнению неразрывности
    procedure RememberXvel(var U : array of Float);
    // запоминание вертикальной
    // компоненты скорости
    // удовлетворяющей уравнению неразрывности
    procedure RememberYvel(var U : array of Float);
    // норма внутренности универсальной полевой величины U по аналогии с
    // пространством C
    function mySupNorma(const U : array of Float;
                        icolx : Integer;
                        icoly : Integer): Float;
    // норма разности внутренностей двух универсальных полевых
    // величин U1 и U2 по аналогии с
    // пространством C
    function mySupNorma2(const U1 : array of Float; // первая полевая величина
                         const U2 : array of Float; // вторая полевая величина
                                icolx : Integer;
                                icoly : Integer): Float;
    // функция вычисляет невязку уравнения
function myResidual( var U : array of  Float;
                            var myrU : array of  Float; // невязка
                            icolx : Integer;
                            icoly : Integer;
                            var map : TdynArraymyNode; // карта обхода
                            chvariable : Char; // для какой переменной решается
                            var m : array of MatrixCoef;
                            var db : array of  Float) :  Float;
    // решает нестационарную задачу чистой теплопроводности
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    // Перед вызовом данного сценария, в модуле myRunModule
    // обязательно должно быть задано количество итераций,
    // шаг по времени, количество шагов по времени, начальное время.
    procedure RunCleanThermalConductionUnsteady;
    // решает нестационарную задачу теплопроводности с учётом конвекции
    // Здесь прописан сценарий решения, включающий
    // инициализации (полевых величин и параметров материалов),
    // задание граничных условий и запуск процедуры решения.
    // Перед вызовом данного сценария, в модуле myRunModule
    // обязательно должно быть задано количество итераций на временном слое
    // начальное время, шаг по времени и количество шагов по времени.
    procedure RunConvectiveThermalConductionUnsteady;
    // Реализация прямого метода исключения Гаусса.
    // задача решить СЛАУ Ax = b
    // Дано A и b. Найти x.
    // Алгоритм прямого исключения Гаусса портит матрицу СЛАУ
    // изменяя её элементы, так что после Алгоритма Гаусса этой матрицей
    // пользоваться уже нельзя. Матрица передаётся по ссылке, чтобы избежать
    // потерь памяти и быстродействия на копирование такой большой матрицы.
    procedure GaussAlgorithm(isize : Integer; // размер квадратной матрицы
                                var dA : array  of TmyDynArray; // матрица СЛАУ
                                icolx : Integer; // количество узлов по горизонтали
                                icoly : Integer; // количество узлов по вертикали
                                const move : array of Integer; // для ленточной матрицы
                                var dV : array of Float; // вектор правой части
                                var dx : array of Float; // вектор результата
                                bmessage : Boolean);
    // скалярное произведение двух векторов
    function Scal(isize : Integer;
                    const dV1 : array of Float;
                    const dV2 : array of Float) : Float;
    // умножение матрицы на вектор
    // результат содержится в векторе dx.
    procedure MatrixByVector(isize : Integer;
                                const dH : array of TmyDynArray;
                                const dV : array of Float;
                                var dx : array of Float);
    // норма вектора
    function NormaV(isize : Integer;
                       const dV : array of Float) : Float;
    // Метод Сопряжённых градиентов
    // Хестенса и Штифеля
    // см. например, диссертацию Н.Г. Бураго
    procedure SoprGrad(isize : Integer; // размер квадратной матрицы
                          const dA : array of TmyDynArray; // матрица СЛАУ
                          const dV : array of Float;  // вектор правой части
                          const dX0 : array of Float; // вектор начального приближения
                          var dres : array of Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение сверху на количество итераций
                          epsilon : Float); // точность вычисления
    // Решает задачу прямым методом исключения Гаусса
    // для универсальной искомой функции U.
    procedure GaussUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // выводить ли диагностические сообщения на консоль
    // Решает задачу методом сопряжённых градиентов
    // для универсальной искомой функции U.
    // Для того чтобы вычислительный процесс
    // сходился необходимо потребовать от матрицы dA
    // составленной по матрице U
    // положительной определённости и самосопряжённости.
    // Положительная определённость и самосопряжённость присущи
    // задаче с чистой теплопроводностью без учёта конвективного члена.
    // Как только мы учитываем конвективный член (а он нужен в подовляющем большинстве случаев)
    // приходится по-видимому использовать Трансформацию Гаусса.
    procedure SoprGradUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль


                         // Решает задачу самобытным классическим алгебраическим многосеточным методом
// для универсальной искомой функции U.
procedure classical_aglomeration_amg(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль


    // трансформация Гаусса.
    // выполняется и над матрицей СЛАУ dA и над вектором правой части dV.
    procedure GaussTransform(isize : Integer;
                            var dA : array of TmyDynArray;
                            var dV : array of Float);
    // находился на стадии тестирования
    // есть множество вопросов и сложностей по реализации.
    // Операции по определению поля давления самые ресурсоёмкие.
    // Перед решением уравнения для поправки давления поле поправки давления
    // надо инициализировать нулевым значением.
    // решает линейное уравнение для поправки давления
    //  методом сопряжённых градиентов Хестенса и Штифмена.
    // Здесь формируется матрица СЛАУ которая затем передаётся
    // уточняющему солверу SoprGrad или прямому GaussAlgorithm.
    // Это универсальный метод решения уравнения для поправки давления
    // содержащий прямой метод исключения Гаусса, а также метод
    // сопряжённых градиентов Хестенсена и Штифеля.
    // Также в него встроена возможность применения трансформации Гаусса.
    // Если булева переменная bGaussTransform равна true то применяется трансформация
    // Гаусса. Если булева переменнная bHestensenShtifiel равна true то применяется
    // метод сопряжённых градиентов иначе прямой метод исключения Гаусса.
    procedure SolveUniversalPamendment(bGaussTransform : Boolean;
                                       bHestensenShtifiel : Boolean;
                                       var rescontinity : Float);
    // решает уравнение для поправки давления
    // с учётом выбранного солвера
    procedure SolvePamendment(var rescontinity : Float); // вызывает соответствующие солверы

    // Следующие несколько методов оптимизируют метод Сопряжённых градиентов
    // как по объёму используемой им памяти так и по скорости его работы.
    // Это алгоритмы 1. Быстрой сортировки, 2. Эффективного умножения разреженной
    // матрицы на вектор с учётом формата хранения CRS, 3. Реализации генерации
    // разреженной матрицы в формате хранения CRS.

    // Запрограммировано с использованием
    // Брайан Керниган и Дени Ритчи "The C Programming Language".
    // Swap : Обмен местами list[i] и list[j] (для QuickSort).
    procedure Swap(var list : array of TmyNonZeroElemMatrix;
                          i : Integer;
                          j : Integer);
    // Вот алгоритм PivotList (для QuickSort).
    // он возвращает точку деления элементов массива на две части.
    // Запрограммировано с использованием книжки ДЖ. Макконел
    // Анализ алгоритмов стр. 106.
    function PivotList(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer) : Integer;
    // Быстрая сортировка Хоара.
    // Это рекурсивный алгоритм который эффективен по быстродействию
    // но возможно не эффективен по памяти.
    // Запрограммировано с использованием Дж. Макконел
    // Анализ алгоритмов стр. 106.
    procedure QuickSort(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer);
    // умножение матрицы на вектор
    // используя формат хранения CRS
    // Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
    // Запрограммировано с использованием
    // 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
    // 2. Р. Тьюарсон "Разреженные матрицы".
    // Матрицы передаются по ссылке чтобы избежать возможного переполнения стека.
    procedure MatrixCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of Float; // заданный вектор на который производится умножение
                                var dx : array of Float);  // результат умножения заносится в dx.
    // умножение транспонированной матрицы на вектор
    // используя формат хранения CRS
    // Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
    // Запрограммировано с использованием
    // 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
    // 2. Р. Тьюарсон "Разреженные матрицы".
    // Матрицы передаются по ссылке чтобы избежать возможного переполнения стека.
    procedure MatrixTransposeCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of Float; // заданный вектор на который производится умножение
                                var dx : array of Float);  // результат умножения заносится в dx.
    // Решает задачу методом сопряжённых градиентов
    // Хестенса и Штифеля
    // для универсальной искомой функции U.
    // данный метод имеет итерационный характер с хорошей скоростью сходимости,
    // т.к. он строит базис и поэтому сходится за количество итераций
    // равных размерности вектора правой части СЛАУ.
    // Ещё одним достоинством данного метода является то, что он
    // стартуя с некоторого начального приближения уточняет решение.
    // Данная версия реализована с использованием технологии CRS хранения
    // и обработки разреженных матриц. Учёт разреженности матрицы позволяет
    // более эффективно использовать оперативную память компьютера и повысить
    // скорость операций по решению большой СЛАУ. После того как данный метод
    // пройдёт тестирование он может быть рекомендован к использованию.
    procedure SoprGradCRSUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         bmessage : Boolean; // выводить ли значение невязки на консоль: true - ДА, false - НЕТ
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         itypealg : Integer; // тип алгоритма: 0 - Сопряжённые градиенты, 1 - Ю.Г. Соловейчика.
                         const db : array of Float); // коэффициенты правой части, содержащие источниковый член
    // Метод Сопряжённых градиентов
    // Хестенса и Штифеля
    // см. например, диссертацию Н.Г. Бураго
    // или Г.И. Марчук методы вычислительной математики
    // здесь применена технология CRS хранения и обработки разреженной матрицы.
    // Этот алгоритм подходит не только для SPD - Symmetric and Positively Defined матриц.
    // SPD - Самосопряжённые и положительно определённые матрицы.
    // В зависимости от значения передаваемого параметра bGaussTransform
    // в нём примененяется или не применяется трансформация Гаусса.
    // Трансформация Гаусса состоит в домножении СЛАУ на транспонированную матрицу слева,
    // что позволяет из любой СЛАУ получить СЛАУ с положительно определённой самосопряжённой матрицей.
    // Однако трансформация Гаусса сильно портит число обусловленности матрицы (спектр матрицы) возводя его в квадрат.
    procedure SoprGradCRS(isize : Integer; // размер квадратной матрицы
                          const val : array of Float; // матрица СЛАУ
                          const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                          const row_ptr : array of Integer; // информация о началах строк
                          const dV : array of Float;  // вектор правой части
                          const dX0 : array of Float; // вектор начального приближения
                          var dres : array of Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение на максимальное количество итераций
                          bGaussTransform : Boolean; // выполнять ли трансформацию Гаусса
                          epsilon : Float); // точность вычисления
    // Переформировать пирамиду
    procedure FixHeap(var list : array of TmyNonZeroElemMatrix;
                          root : Integer;
                          m : TmyNonZeroElemMatrix;
                          bound : Integer);
    // Пирамидальная сортировка оптимальна как
    // по памяти, так и по быстродействию, к тому же её алгоритм
    // очень интересен.
    // Ограничение состоит в том, что нумерация массива должна начинаться с 1.
    procedure HeapSort(var list : array of TmyNonZeroElemMatrix;  // упорядочиваемый список элементов
                              n : Integer); // число элементов в списке
    // находится на стадии тестирования
    // Операции по определению поля давления самые ресурсоёмкие.
    // Перед решением уравнения для поправки давления поле поправки давления
    // надо инициализировать нулевым значением.
    // решает линейное уравнение для поправки давления
    //  методом сопряжённых градиентов Хестенса и Штифмена.
    // Здесь формируется матрица СЛАУ в формате CRS которая затем передаётся
    // уточняющему солверу SoprGrad.
    // этот метод эффективен по памяти т.к. здесь используется алгоритм хранеия доступа CRS.
    procedure SolveSoprGradCRSPamendment(bGaussTransform : Boolean; bipifix : Boolean;
                                         bSoloveichikAlg : Boolean; // применять ли алгоритм Ю.Г. Соловейчика 93 года
                                         var rescontinity : Float);
    // норма вектора
    // как максимальное значение среди компонент вектора
    function NormaSupV(isize : Integer; // размерность вектора
                               const dV : array of Float) : Float;
    // норма вектора
    // сумма модулей компонент вектора
    // октаэдрическая норма.
    function NormaSup2V(isize : Integer; // размерность вектора
                       const dV : array of Float) : Float;
    // восстановление вихря с интерполяцией на основную сетку
    procedure CurlConstruct;
    // вычисление функции тока
    // bmessage - выводить ли сообщения на системную консоль
    // kend - максимальное количество итераций по достижению которого вычисление заканчивается.
    procedure SolveStreamFunction(bmessage : Boolean; kend : Integer);
    // инициализация функции тока
    procedure initStreamFunction;
    // евклидова норма внутренности универсальной полевой величины U
    // возвращает корень квадратный из суммы квадратов компонентов вектора невязки.
    // для внутренней части расчётной области.
    // евклидова норма.
    function myEvklidNorma(const U : array of Float; icolx : Integer; icoly : Integer): Float;
    // октаэдрическая норма внутренности универсальной полевой величины U
    // возвращает сумму модулей компонент вектора невязки.
    // октаэдрическая норма.
    function mySup2Norma(const U : array of Float; icolx : Integer; icoly : Integer): Float;
    // создаёт файл для программы tecplot
    // переменная  ifuncexport отвечает за то какое значение передавать
    // в программу tecplot.
    // 1 - со значением вихря,
    // 2 - со значением функции тока.
    procedure exporttecplotUniversal(ifuncexport : Integer);
    // Это исправление граничных условий для давления
    // до граничных условий Неймана для корректного
    // отображения при визуализации.
    procedure PressurePathit;
    // Для исследования вибрационного воздействия
    // Возвращает текущее значение силы тяжести
    // в зависимости от текущего момента времени.
    function GetRealGravity(chDirect : Char) : Float;
    // алгоритм Ю.Г.Соловейчика [1993]
    // для возможно несимметричных матриц.
    procedure SoloveichikAlg(isize : Integer; // размер квадратной матрицы
                         const val : array of Float; // матрица СЛАУ
                         const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                         const row_ptr : array of Integer; // информация о началах строк
                         const dV : array of Float;  // вектор правой части
                         const dX0 : array of Float; // вектор начального приближения
                         var dres : array of Float; // вектор результата
                         bconsole_message : Boolean; // выводить ли значения невязки на консоль
                         kend : Integer; // ограничение на максимальное количество итераций
                         epsilon : Float); // точность вычисления
    // универсальная функция визуализации
    // основная сетка
    procedure DisplayUniversalInternal(ival : Integer; bonlyupdateD : Boolean);
    // инициализация параметров в алгоритме SIMPLE
    procedure initparamSIMPLE(bposttemperature : Boolean);
    // Щас реализуется возможность приостановки и последующего
    // продолжения вычисления с остановленного места. Это приводит
    // к необходимости в случае малейших изменений, например в граничных условиях, производить
    // инициализацию решения заново. Иначе новые граничные условия не будут учтены.
    procedure myInitializationRestart;
    // Вычисляет текущие невязки для компонент скорости
    procedure getrealresFlow(var resVx : Float; var resVy : Float);
    // определение угловых точек и их типов
    procedure ugoldetect(var map : TdynArraymyNode; icolx, icoly : Integer);
                               // нескомпенсированные источники массы
    procedure PamendmentCoef(var rescontinity :  Float;
            var mp : array of MatrixCoef; // коэффициенты дискретного аналога
            var db : array of  Float); // коэффициенты источникового члена
     // передвигает координаты сетки
     procedure mymovingmesh;
     //при динамической сетке надо обновлять карты
     procedure UpdateMap;
     // инициализация функции тока
     procedure initmeanSF(str : String);
     // вычисление осреднённой на периоде функции тока
     procedure RememberStreamFunction;
     // вычисление осреднённой на периоде функции тока
     procedure CalculateMeanStreamFunction;
     // вычисление осреднённой на периоде функции тока
     procedure CalculateMeanSF(inum : Integer);
     // контролирует одну итерацию алгоритма SIMPLE
     procedure controlSimpletune;
     // создаёт файл для программы tecplot
     // со всеми расчитанными функциями.
     // в программу tecplot:
     // 1 - со значением вихря,
     // 2 - со значением функции тока,
     // 3 - со значением распределения давления.
     // 4 - со значением горизонтальной скорости,
     // 5 - со значением вертикальной скорости.
     // 7 - математическое ожидание функции тока
     procedure exporttecplotmeanUniversalComplete;
     // генеральные настройки
     procedure myGeneraltune;
     // параметры материалов
     procedure materialtune;
     // задание граничных условий
     procedure BoundaryConditionTune(Sender : TObject);
     // вызывает меню, где можно выбрать
     // уравнения подлежащие решению
     procedure EquationTune(Sender: TObject);
     // Выбор алгоритма солвера
     procedure SelectSolvertune;
     // вызывает форму где можно задать параметры релаксации
     procedure RelaxationFactorstune;
     // инициализация перед началом счёта
     procedure Initializationtune;
     // запуск на вычисление
     procedure RunTune;
     // аппроксимация конвективного члена и алгоритм решения
     procedure Methodstune;
     // управление простейшей динамической сеткой
     procedure DynamMeshtune;
     // инициализация осредненнной горизонтальной
     // компоненты скорости
     procedure initmeanXvel(str : String);
     // инициализация осреднённой вертикальной
     // компоненты скорости
     procedure initmeanYvel(str : String);
     // инициализация осреднённого поля температур
     procedure initmeanTemp(str : String);
      // инициализация осреднённого вихря
     procedure initmeanOmega(str : String);
     // вычисление осреднённой на периоде горизонтальной скорости
     procedure RememberXVelDM;
     // вычисление осреднённой на периоде вертикальной скорости
     procedure RememberYVelDM;
     // вычисление осреднённой на периоде температуры
     procedure RememberTempDM;
     // вычисление осреднённого вихря
     procedure RememberOmega1T;
     // вычисление осреднённого на периоде вихря
     procedure CalculateMeanOmega1T;
     // вычисление осреднённой на периоде
     // горизонтальной компоненты скорости
     procedure CalculateMeanXVel;
     // вычисление осреднённой на периоде
     // вертикальной компоненты скорости
     procedure CalculateMeanYVel;
     // вычисление осреднённой на периоде температуры
     procedure CalculateMeanTempreture;
     // вычисление математического ожидания от температуры
     procedure CalculateMeanT(inum : Integer);
     // вычисление мат ожидания горизонтальной скорости
     procedure CalculateMeanVx(inum : Integer);
     // вычисление математического ожидания от вертикальной скорости
     procedure CalculateMeanVy(inum : Integer);
     // вычисление мат ожидания от вихря
     procedure CalculateMeanOmega(inum : Integer);
     // задание граничных условий
     // первого рода  для Давления
     procedure initBoundaryConditionPressure;
     // устраняет дефекты графической визуализации
     procedure VelXPachit;
     // вычисляет невязку для температуры
     procedure getrealResTemp(var restemp : Float);
     // графики невязок
     procedure updatemainpaintbox; // графики невязок
     // создаёт файл для программы tecplot
    // со всеми расчитанными функциями.
    // в программу tecplot:
    //
    // 1 -  вихрь,
    // 2 -  температура,
    // 3 -  горизонтальная скорость,
    // 4 -  вертикальная скорость,
    // векторное поле скоростей может быть автоматически
    // сгенерировано используя пункты 3 и 4.
    // 5 -  модуль скорости,
    // 6 -  функция тока,
    // 7 - функция цвета.
    //
    procedure exporttecplotUniversalComplete;
    // инициализация функции цвета
    procedure initVOF;
    // плотность
    function density(ipi : Integer) : Float;
    // динамическая вязкость
    function viscosity(ipi : Integer) : Float;
    // инициализирует решение в VOF методе и не только
    procedure patchtune;
    // запоминает текущую плотность в массив
    // DensityOldTimeStep
    procedure rememberDensity;
    // LU разложение
    procedure LUdecomposition(isize : Integer; // размер квадратной матрицы
                              var dA : array of TmyDynArray; // матрица СЛАУ
                              icolx : Integer; // количество узлов по горизонтали
                              icoly : Integer; // количество узлов по вертикали
                              const move : array of Integer; // для ленточной матрицы
                              var dV : array of  Float; // вектор правой части
                              var dx : array of  Float; // результат вычисления
                              bmessage : Boolean);
    // решение уравнения для давления
    procedure SolveGZPressure(bipifix : Boolean); // фиксировать ли уровень давления  ?
    // задание граничных условий
    // первого рода
    // для функции тока
    procedure initBoundaryConditionStreamFunction;
    // вычисляет коэффициенты дискретного аналога для
    // уравнения переноса завихрённости с учётом конвективного члена
    //  Операция составления дискретного аналога выполнена универсальным
    // образом. Т.е. она подходит и для процессов не зависящих от времени, а также
    // для нестационарных процессов.
    // Внимание: перед использованием этой процедуры массиву
    // OmegaoldTimeStep должна быть выделена оперативная память и
    //  он должен быть проинициализирован соответствующим образом.
    procedure OmegaConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                               var db : array of Float); // правая часть
    // по значениям функции тока находит
    // горизонтальную скорость.
    procedure VxConstruct;
    // по значениям функции тока находит
    // вертикальную скорость.
    procedure VyConstruct;
    // найти вихрь.
    procedure SolveOmegaSteady;
    // решает Навье-Стокса в переменных Вихрь - Функция тока
    procedure VorcityStreamfunctionSolveEquation;
    // Поячеечная сборка матрицы:
    procedure TempCoefCell(var m : array of MatrixCoef;
                          var db : array of Float); // правая часть

    // организация нижней релаксации для компонент скорости.
    procedure Lower_relaxation_Velocity;
    // копирование в VxActing заданной полевой величины U.
    procedure CopyToVxActing(var U : array of Float);
    // копирование в VyActing заданной полевой величины V.
    procedure CopyToVyActing(var V : array of Float);
    // вычисляет коэффициенты дискретного аналога для
    // уравнения переноса непрерывного маркера.
    //  Операция составления дискретного аналога выполнена универсальным
    // образом. Т.е. она подходит и для процессов не зависящих от времени, а также
    // для нестационарных процессов. Уравнение переноса функции цвета должно быть именно нестационарным.
    // Внимание: перед использованием этой процедуры массиву
    // ToldTimeStep должна быть выделена оперативная память и
    //  он должен быть проинициализирован соответствующим образом.
    // Вообще говоря уравнение для функции цвета содержит нулевой коэффициент диффузии,
    // но здесь оставлена возможность задать в ручную нужный небольшой коэффициент диффузии.
    procedure VOFCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                              var db : array of Float); // правая часть

    // Граничное условие II рода на нижней стенке
    // для уравнения переноса непрерывного маркера с учётом конвективного члена.
    // коэффициенты дискретного аналога
    procedure VofBoundaryCoefConvBottom(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                       qbbottom : Float; // заданный поток функции цвета на границе
                                           place : TmyNode; artificaldiffusion : Float); // место на карте
    // Граничное условие II рода на верхней стенке
    // для уравнения переноса непрерывного маркера с учётом конвективного члена.
    // коэффициенты дискретного аналога
    procedure VofBoundaryCoefConvTop(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                          qbtop : Float; // заданный тепловой поток на границе
                                         place : TmyNode; artificaldiffusion : Float); // место на карте

    // Граничное условие II рода на правой стенке
    // для уравнения переноса функции цввета с учётом конвективного члена.
    // коэффициенты дискретного аналога
    procedure VofBoundaryCoefConvRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                        qbright : Float; // заданный тепловой поток на границе
                        place : TmyNode; artificaldiffusion : Float); // место на карте
    // Граничное условие II рода на левой стенке
    // для уравнения функции цвета с учётом конвективного члена.
    procedure VofBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                          var db : array of Float; // правая часть
                                          qbleft : Float; // заданный тепловой поток на границе
                                          place : TmyNode; artificaldiffusion : Float); // место на карте
    // Решение уравнения для функции цвета.
    // Сходимость методов гарантируется критерием Скарбороу.
    procedure SolveVOF(kfinish : Integer);
    // запоминание функции цвета с предыдущей итерации.
    procedure RememberVOF;
    // Функция реализующая антидиффузионную корекцию из диссертации Н.Г. Бураго.
    procedure anti_diffusionVOF;
    // минимум из двух чисел.
    function fmin(fA : Float; fB : Float) : Float;
    // Возвращает минимум из трёх чисел.
    function fmin3(fA : Float; fB : Float; fC : Float) : Float;
    // Возвращает минимум из четырёх чисел.
    function fmin4(fA : Float; fB : Float; fC : Float; fD : Float) : Float;
    // Возвращает максимум из трёх чисел.
    function fmax3(fA : Float; fB : Float; fC : Float) : Float;
    // см. дискретизация конвективных потоков в уравнениях Навье-Стокса
    // на основе разностных схем высокой разрешающей способности.
    // К.Н. Волков. стр. 135.
    // Вычислительные методы и программирование. 2004. Т. 5.
    function linear_flux_limiter(kappa : Float; r : Float) : Float;
    // по мотивам программы проф. Сполдинга PHOENICS
    // К сожалению это многообразие пригодно лишь для равномерной сетки.
    function limiter_function(ishconvection : Integer; r : Float) : Float;
    // по мотивам программы проф. Сполдинга PHOENICS
    // Возвращает значение искомой величины на грани контрольного объёма.
    function cell_face_value_local(ishconvection : Integer; Fc : Float; Fd : Float; Fu :  Float) : Float ;
    // поддержка консервативности VOF.
    // по мотивам диссертации Н.Г.Бураго.
    // Так как консервативность ниоткуда не следует, особенно при включённой антидиффузионной
    // коррекции, то её следует поддерживать искусственно.
    procedure conservationVOF;
    // Hirt-Nichols`VOF
    procedure Hirt_NicholsVOF;
    // максимум из двух чисел.
    function fmax(fA : Float; fB : Float) : Float;
    // Возвращает значение плотности на грани контрольного объёма.
    // На основе статьи Хирта и Николса.
    // Линейная интерполяция на грань а была средняя гармоническая.
    function densuty_in_surface(ipi1 : Integer; ipi2 : Integer) : Float;
    // Чтобы для грани можно было использовать схему высокого порядка,
    // требуется чтобы все четыре узла были внутренними.
    // Здесь проверяется это условие.
    function is_internal_HO(ipi1 : Integer; ipi2 : Integer; ipi3 : Integer; ipi4 : Integer) : Boolean;
    // Чтобы для грани можно было использовать схему высокого порядка,
    // требуется чтобы все четыре узла были внутренними.
    // Здесь проверяется это условие для горизонтальной скорости Vx.
    function is_internal_HO_Vx(
              ipi1 : Integer; ipi2 : Integer;
              ipi3 : Integer; ipi4 : Integer) : Boolean;
    // Чтобы для грани можно было использовать схему высокого порядка,
    // требуется чтобы все четыре узла были внутренними.
    // Здесь проверяется это условие для вертикальной скорости Vy.
    function is_internal_HO_Vy(
              ipi1 : Integer; ipi2 : Integer;
              ipi3 : Integer; ipi4 : Integer) : Boolean;

    // по мотивам программы проф. Сполдинга PHOENICS
    // Возвращает значение искомой величины на грани контрольного объёма.
    function cell_face_value_global(ischeme : Integer; uf : Float; fa : Float;
                                    fb : Float; fc : Float; fd : Float) : Float;
    // записывает заголовок для анимации очищая хранилище анимационных кадров.
    procedure writeanimationTitle;
    // Запускает файл с анимацией !.
    procedure animationStart;
    // записывает тело анимации каждый шаг по времени
    // создаёт файл для программы tecplot
    // со всеми расчитанными функциями.
    // в программу tecplot:
    //
    // 1 -  вихрь,
    // 2 -  температура,
    // 3 -  горизонтальная скорость,
    // 4 -  вертикальная скорость,
    // векторное поле скоростей может быть автоматически
    // сгенерировано используя пункты 3 и 4.
    // 5 -  модуль скорости,
    // 6 -  функция тока,
    // 7 - давление.
    procedure AnimationBody(cadrname : string);
    // Находит решение уравнения для пользовательского скаляра.
    // bmessage - сообщения на консоль,
    // kfinish - заданное количество итераций.
    procedure SolveUDS(bmessage : Boolean; kfinish : Integer; var res : Float; bquickcalc : array of Boolean;
                        var bquickcalcVx : array of Boolean;
                        var bquickcalcVy : array of Boolean;
                        var value_of_equation : array of Float);
    // вычисляет коэффициенты дискретного аналога для
    // User-Defined Scalar с учётом конвективного члена
    //  Операция составления дискретного аналога выполнена универсальным
    // образом. Т.е. она подходит и для процессов не зависящих от времени, а также
    // для нестационарных процессов.
    // Внимание: перед использованием этой процедуры массиву
    // UDS<number>oldTimeStep должна быть выделена оперативная память и
    //  он должен быть проинициализирован соответствующим образом,
    // здесь number - номер соответствующей UDS.
    procedure UDSCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                              var db : array of Float); // правая часть
    // Граничное условие II рода на нижней стенке
    // для уравнения UDS с учётом конвективного члена.
    // коэффициенты дискретного аналога
    procedure UDSBoundaryCoefConvBottom(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                       qbbottom : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте

// Граничное условие II рода на верхней стенке
// для уравнения User-Defined Scalar`a с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure UDSBoundaryCoefConvTop(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                          qbtop : Float; // заданный тепловой поток на границе
                                      place : TmyNode); // место на карте

// Граничное условие II рода на правой стенке
// для уравнения переноса User-Defined Scalar`а учётом конвективного члена.
// коэффициенты дискретного аналога
procedure UDSBoundaryCoefConvRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                        qbright : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте

// Граничное условие II рода на левой стенке
// для уравнения переноса User-Defined Scalar`a с учётом конвективного члена.
procedure UDSBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                          var db : array of Float; // правая часть
                                          qbleft : Float; // заданный тепловой поток на границе
                                          place : TmyNode); // место на карте
// Вычисляет производную по x.
// U - задано на сетке mapPT, gradxU - задано на сетке для горизонтальной скорости.
procedure universalgradx(var U : array of Float; var gradxU : array of Float);
// Вычисляет производную по y.
// U - задано на сетке mapPT, gradyU - задано на сетке для вертикальной скорости.
procedure universalgrady(var U : array of Float; var gradyU : array of Float);
// Вычисляет производную по x.
// U - задано на сетке mapPT, gradxU - задано на сетке для вертикальной скорости.
procedure universalgradx_mapy(var U : array of Float; var gradxU_mapy : array of Float);
// Вычисляет производную по y.
// U - задано на сетке mapPT, gradyU - задано на сетке для горизонтальной скорости.
procedure universalgrady_mapx(var U : array of Float; var gradyU_mapx : array of Float);
// инициализация параметров для UDS.
procedure inituds();
// задание граничных условий
// первого рода
// для поля User Defined Scalar`a.
procedure initBoundaryConditionUDS;
// Вычисляет лапласиан функции.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure universallaplas(U : array of Float; var laplasU : array of Float);
// Вычисляет лапласиан функции по икс.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure universallaplasx(U : array of Float; var laplasU : array of Float);
// Вычисляет лапласиан функции по игрик.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure universallaplasy(U : array of Float; var laplasU : array of Float);
// Вычисляет градиент функции по х.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure universalgradx_mapPT(U : array of Float; var laplasU : array of Float);
// Вычисляет градиент функции по y.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure universalgrady_mapPT(U : array of Float; var laplasU : array of Float);
// Вычисляет градиент функции по х и сразу потом градиент по y.
// Таким образом мы имеем смешанную производную.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure universalgradxy_mapPT(U : array of Float; var laplasU : array of Float);
// Готовит калькулятор к вычислениям
// Custom - Field Function
procedure getreadycalc(var fex : T2myDynArray);
// Вспомогательные функции для алгоритма Федоренко 1961.
procedure my_restriction1(var r : array of Float; var r_coarse : array of Float);
// препроцессор для quickcalc
// для ускорения вычислений.
procedure preprocessing_quick_calc(var bquickcalc :  TmyDynArrayb;
                                          var bquickcalcVx :  TmyDynArrayb;
                                          var bquickcalcVy :  TmyDynArrayb);
// Вычисляет силу поверхностного натяжения.
procedure calc_continuum_surface_force();
// организация запоминания для аппроксимации по времени вторго порядка Пейре.
procedure RememberXvelSO();
// запоминание для схемы Пейре.
procedure RememberYvelSO();
// Второй способ мониторинга сходимости отслеживать
// эволюцию рассчитываемых величин.
// index :
// 0 - вернуть объём расчётной области,
// 1 - вернуть максимум UDS1,
// 2 - вернуть максимум UDS2,
// 3 - вернуть максимум UDS3,
// 4 - вернуть максимум UDS4,
// 5 - вернуть минимум UDS1,
// 6 - вернуть минимум UDS2,
// 7 - вернуть минимум UDS3,
// 8 - вернуть минимум UDS4,
// 9 - вернуть Volume Integral UDS1,
// 10 - вернуть Volume Integral UDS2,
// 11 - вернуть Volume Integral UDS3,
// 12 - вернуть Volume Integral UDS4,
// 13 - вернуть сумму UDS1,
// 14 - вернуть сумму UDS2,
// 15 - вернуть сумму UDS3,
// 16 - вернуть сумму UDS4,
// 17 - вернуть Volume Average UDS1,
// 18 - вернуть Volume Average UDS2,
// 19 - вернуть Volume Average UDS3,
// 20 - вернуть Volume Average UDS4,
// и т.д. см реализацию.
function getVolumeMonitor(index : Integer): Float;
// Метод Ньютона-Канторовича в GaAs,
// решение с помощью метода последовательной
// верхней релаксации.
procedure solvegaas();
// Вычисляет невязку включая граничные узлы :
// Используется в методе Ньютона.
procedure myResidual_all(
                         var residual : array of Float; // вектор невязки.
                         var res : Float;  // норма невязки.
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         var map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         var db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         var QneiC : TQneiC);





  end;

var
  Form1: TForm1;

  procedure seidel_pressure(eps : Float;
							imaxiter : Integer;
							imaxnumbernode_loc : Integer;
              icolx : Integer;
              icoly : Integer;
							bipifix_loc : Boolean;
						  ipifix_loc : Integer;
							ibasenorma_loc : Integer;
							mp_loc : TPdynArrayMatrixCoef;
							mapPT_loc : TPdynArraymyNodeold;
							P_loc : TPmyDynArray;
							db_loc : TPmyDynArray;
							myrP_loc : TPmyDynArray;
              URF : Float); cdecl;  external  'mgf.dll';
  // Солвер Гаусса-Зейделя для UDS.
  procedure seidel_uds(eps : Float;
							                imaxiter : Integer;
						                	imaxnumbernode_loc : Integer;
                              icolx : Integer;
                              icoly : Integer;
						                	ibasenorma_loc : Integer;
							                mp_loc : TPdynArrayMatrixCoef;
						                	mapPT_loc : TPdynArraymyNodeold;
							                UDS_loc : TPmyDynArray;
						                	db_loc : TPmyDynArray;
							                myrP_loc : TPmyDynArray;
                              QneiC_loc :  TPmyDynArrayb;
                              bzerocurrenrorzerodiff_loc :  TPmyDynArrayb;
                              icurentuds : Integer); cdecl;  external  'mgf.dll';
  procedure seidel_pressure_omp(eps : Float;
							imaxiter : Integer;
							imaxnumbernode_loc : Integer;
              icolx : Integer;
              icoly : Integer;
							bipifix_loc : Boolean;
						  ipifix_loc : Integer;
							ibasenorma_loc : Integer;
							mp_loc : TPdynArrayMatrixCoef;
							mapPT_loc : TPdynArraymyNodeold;
							P_loc : TPmyDynArray;
							db_loc : TPmyDynArray;
              myrP_loc : TPmyDynArray;
              icore : Integer;
              URF : Float); cdecl;  external  'mgfp.dll';
              // Солвер Гаусса-Зейделя для UDS.
  procedure seidel_uds_omp(eps : Float;
							                imaxiter : Integer;
						                	imaxnumbernode_loc : Integer;
                              icolx : Integer;
                              icoly : Integer;
						                	ibasenorma_loc : Integer;
							                mp_loc : TPdynArrayMatrixCoef;
						                	mapPT_loc : TPdynArraymyNodeold;
							                UDS_loc : TPmyDynArray;
						                	db_loc : TPmyDynArray;
							                myrP_loc : TPmyDynArray;
                              QneiC_loc :  TPmyDynArrayb;
                              bzerocurrenrorzerodiff_loc :  TPmyDynArrayb;
                              g_nNumberOfThreads : Integer;
                              icurentuds : Integer); cdecl;  external  'mgfp.dll';
  // метод сопряжённых градиентов для давления и поправки давления.
  procedure cg_pressure(eps: Float;
							 imaxiter: Integer;
							 imaxnumbernode_loc: Integer;
							 icolx: Integer; icoly: Integer;
							 bipifix_loc : Boolean;
							 ipifix_loc: Integer;
							 ibasenorma_loc: Integer;
							 mp_loc: TPdynArrayMatrixCoef;
							mapPT_loc: TPdynArraymyNodeold;
							P_loc : TPmyDynArray;
							db_loc: TPmyDynArray;
							myrP_loc : TPmyDynArray;
							residual_history: TPmyDynArray; // история изменеия невязок
							itypesorter_loc : Integer;
              pointerlist_loc : TPmyDynArrayi;
              pointerlistrevers_loc : TPmyDynArrayi;
              bconstr_loc : Boolean;
              ialg_loc : Integer); cdecl;  external  'cg_davis.dll';

  // Самобытный алгебраический многосеточный метод.
 // Запрограммированный по статье К.Н.Волкова.
 // 20 november 2015
 // Нумерация и хранение в массивах db, resultat, MatrixAmg начинаются
 // с нуля.
 procedure my_aglomerative_external_amg(n : Integer; // число неизвестных
                                        nnz : Integer; // число хранимых элементов в передаваемой ма
                                        db : TPmyDynArray; // правая часть.
                                        resultat : TPmyDynArray;
                                        MatrixAmg : TPamgArray;
                                        var bamgdivergencedetected : Boolean); cdecl; external 'my_cl_amg.dll';




implementation

uses  // список используемых самописных модулей
   DisplayUnit, MeshGen, myGeneralSolver, InitializeUnit, myRunmodule,
   MaterialUnit, ExportTecplotUnit, BoundaryConditionUnit,
   SourceInEquationUnit, Unit2DPlot, InterpolateCaseUnit, myProgressBarUnit,
   myProgressBarUnsteadyUnit, AlgoSolverUnit, controlSIMPLEUnit,
   RelaxFactorsUnit, ApproxConvectionUnit, ModelEquationUnit, MyResControlUnit,
   SoprGradUnit, GravityUnit, TerminateProcessUnit, GridGenUnit, DynMeshUnit,
   PamendmentcontrolUnit, PatchUnit, Unitlanguage, UnitUserDefinedMemory,
  UnitUserDefinedScalar, Unitanimation, UnitAddVariable,
  UnitCustomFieldFunction, UnitInterpritatortest, Unitnotepad, Unithelp1,
  UnitSurfaceIntegrals, UnitPatternCFF, UnitSolutionLimits,
  UnitDefineTrials, Unitlengthscaleplot, UnitParametricTrialsOnlineReport,
  UnitOpenGL;

{$R *.dfm}

(*
{$DEFINE Debug}

{$IFDEF Debug}

оператор отладки

{$ENDIF}
*)

//{$DEFINE dSourceBoundary} // источниковый член к граничным узлам применяется !!!


procedure TmyNode.Setdxe(const ldxe : Float);
begin
   Fdxe:=ldxe;
end;

procedure TmyNode.Setdxw(const ldxw : Float);
begin
   Fdxw:=ldxw;
end;

procedure TmyNode.Setdyn(const ldyn : Float);
begin
   Fdyn:=ldyn;
end;

procedure TmyNode.Setdys(const ldys : Float);
begin
   Fdys:=ldys;
end;

procedure TmyNode.SetdV(const ldV : Float);
begin
   FdV:=ldV;
end;

procedure TmyNode.Setdx(const ldx : Float);
begin
   Fdx:=ldx;
end;

procedure TmyNode.Setdy(const ldy : Float);
begin
   Fdy:=ldy;
end;

procedure Top.Setmyoperator(const valuestr: string);
begin
   Fmyoperator:=valuestr;
end;

procedure Top.Setvalue(const rval: Real);
begin
   Fvalue:=rval;
end;

procedure Top.Setleft(const lval: pTop);
begin
   Fleft:=lval;
end;

procedure Top.Setright(const rval: pTop);
begin
   Fright:=rval;
end;

procedure TmyNode.Setiugol(const liugol : Integer);
begin
   Fiugol:=liugol;
end;

procedure TmyNode.Seti(const li : Integer);
begin
   Fi:=li;
end;

procedure TmyNode.Setj(const lj : Integer);
begin
   Fj:=lj;
end;

procedure TmyNode.Setini(const lini : Integer);
begin
   Fini:=lini;
end;

procedure TmyNode.Setisi(const lisi : Integer);
begin
   Fisi:=lisi;
end;

procedure TmyNode.Setiwi(const liwi : Integer);
begin
   Fiwi:=liwi;
end;

procedure TmyNode.Setiei(const liei : Integer);
begin
   Fiei:=liei;
end;

procedure TmyNode.Setipi(const lipi : Integer);
begin
   Fipi:=lipi;
end;

procedure TmyNode.Setiboundary(const liboundary : Integer);
begin
   Fiboundary:=liboundary;
end;

procedure TmyNode.Setitype(const litype : Integer);
begin
   Fitype:=litype;
end;

procedure TmyNode.Setchnormal(const lchnormal : Char);
begin
   Fchnormal:=lchnormal;
end;
// Вычисляет силу поверхностного натяжения.
// CSF - continum surface force
procedure TForm1.calc_continuum_surface_force();
var
   normx, normy, buf  : array of Float;
   normxVx, normyVy  : array of Float;
   i1, j1, ipi : Integer;
   igi1, igi2 : Integer;
   divr : Float;

begin
   SetLength(buf,mzapas*inx*iny+1);
   SetLength(normx,mzapas*inx*iny+1);
   SetLength(normy,mzapas*inx*iny+1);
   SetLength(normxVx,mzapas*(inx-1)*iny+1);
   SetLength(normyVy,mzapas*inx*(iny-1)+1);
   if (bWallAdhesion) then
   begin
   end
   else
   begin
      universalgradx_mapPT(VOF,normx);
      universalgrady_mapPT(VOF,normy);
      for i1:=1 to inx do
      begin
         for j1:=1 to iny do
         begin
            ipi:=i1+(j1-1)*inx;
            buf[ipi]:=sqrt(normx[ipi]*normx[ipi]+normy[ipi]*normy[ipi]);
            if (buf[ipi]>1.0e-12) then
            begin
               divr:=1.0/buf[ipi];
               normx[ipi]:=normx[ipi]*divr;
               normy[ipi]:=normy[ipi]*divr;
            end
             else
            begin
               normx[ipi]:=0.0;
               normy[ipi]:=0.0;
            end;
         end;
      end;
      universalgradx_mapPT(normx,buf);
      for i1:=1 to inx do
      begin
         for j1:=1 to iny do
         begin
            ipi:=i1+(j1-1)*inx;
            normx[ipi]:=buf[ipi];
         end
      end;
      universalgrady_mapPT(normy,buf);
      for i1:=1 to inx do
      begin
         for j1:=1 to iny do
         begin
            ipi:=i1+(j1-1)*inx;
            normy[ipi]:=buf[ipi];
         end
      end;
      for i1:=1 to inx do
      begin
         for j1:=1 to iny do
         begin
            // Кривизна поверхности в терминах нормали без учёта
            // углов смачиваемости.
            // без Wall Adhesion.
            ipi:=i1+(j1-1)*inx;
            buf[ipi]:=normx[ipi]+normy[ipi];
         end
      end;
      // Вычисляем нормали на сетках для скоростей.
      universalgradx(VOF,normxVx);
      universalgrady(VOF,normyVy);
      for i1:=1 to inx-1 do
      begin
         for j1:=1 to iny do
         begin
            igi1:=i1+(j1-1)*inx;
            igi2:=i1+1+(j1-1)*inx;
            CSFx[i1+(j1-1)*(inx-1)]:=rsigma*normxVx[i1+(j1-1)*(inx-1)]*0.5*(buf[igi1]+buf[igi2])/densuty_in_surface(igi1,igi2);
         end;
      end;

      for i1:=1 to inx do
      begin
         for j1:=1 to iny-1 do
         begin
            igi1:=i1+(j1-1)*inx;
            igi2:=i1+(j1)*inx;
            CSFy[i1+(j1-1)*inx]:=rsigma*normyVy[i1+(j1-1)*inx]*0.5*(buf[igi1]+buf[igi2])/densuty_in_surface(igi1,igi2);
         end;
      end;

   end;

   // Освободим память.
   SetLength(buf, 0);
   SetLength(normx, 0);
   SetLength(normy, 0);
   SetLength(normxVx, 0);
   SetLength(normyVy, 0);

end; // continuum surface force


// Вспомогательные функции для алгоритма Федоренко 1961.
// Это простейшая и первейшая реализация операции restriction.
procedure TForm1.my_restriction1(var r : array of Float; var r_coarse : array of Float);
var
  i,j : Integer;
  ic, jc : Integer;

begin

	 //ic:=0;
   //jc:=0; // c- coarse.

   for i:=0 to inx-1 do
   begin
	   	for j:=0 to iny-1 do
      begin
	 		   if ((i mod sFedor.q = 0) and (j mod sFedor.q =0))  then
         begin
	 			    ic:=round(i div sFedor.q);
	 			    jc:=round(j div sFedor.q);

	 			    r_coarse[ic+1+jc*sFedor.inxc]:=r[i+1+j*inx];

	 		   end;
	    end;
	 end;

end; // RESTRICTION

// инициализация параметров для UDS.
procedure TForm1.inituds();
var
    p : Integer;
    bOk : Boolean;
begin
   case imaxUDS of
      0 : //нет User Define Scalar`ов
      begin
         SetLength(UDS1,0);
         SetLength(UDS2,0);
         SetLength(UDS3,0);
         SetLength(UDS4,0);
         SetLength(uds1diffusivity,0);
         SetLength(uds2diffusivity,0);
         SetLength(uds3diffusivity,0);
         SetLength(uds4diffusivity,0);
         SetLength(dSc1,0);
         SetLength(dSc2,0);
         SetLength(dSc3,0);
         SetLength(dSc4,0);
         SetLength(dSp1,0);
         SetLength(dSp2,0);
         SetLength(dSp3,0);
         SetLength(dSp4,0);
         SetLength(Vxuds,0);
         SetLength(Vyuds,0);
         SetLength(uds1oldTimeStep,0);
         SetLength(uds2oldTimeStep,0);
         SetLength(uds3oldTimeStep,0);
         SetLength(uds4oldTimeStep,0);
      end;
      1 : //один UDS
      begin
         SetLength(UDS1,mzapas*inx*iny+1);
         SetLength(UDS2,0);
         SetLength(UDS3,0);
         SetLength(UDS4,0);
         SetLength(uds1diffusivity,mzapas*inx*iny+1);
         SetLength(uds2diffusivity,0);
         SetLength(uds3diffusivity,0);
         SetLength(uds4diffusivity,0);
         SetLength(dSc1,mzapas*inx*iny+1);
         SetLength(dSc2,0);
         SetLength(dSc3,0);
         SetLength(dSc4,0);
         SetLength(dSp1,mzapas*inx*iny+1);
         SetLength(dSp2,0);
         SetLength(dSp3,0);
         SetLength(dSp4,0);
         SetLength(Vxuds,mzapas*(inx-1)*iny+1);
         SetLength(Vyuds,mzapas*inx*(iny-1)+1);
         SetLength(uds1oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds2oldTimeStep,0);
         SetLength(uds3oldTimeStep,0);
         SetLength(uds4oldTimeStep,0);
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               UDS1[ipi]:=0.0;
               uds1oldTimeStep[ipi]:=0.0;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               if (itype<>0) then
               begin
                  ivar:=5;
                  SetLength(parametric,ivar);
                  parametric[0].svar:='$x';
                  parametric[1].svar:='$y';
                  parametric[2].svar:='$udm1'; // User - Defined Memory
                  parametric[3].svar:='$udm2';
                  parametric[4].svar:='$udm3';
                  parametric[0].sval:=FloatToStr(xpos[i]);
                  parametric[1].sval:=FloatToStr(ypos[j]);
                  case imaxUDM of
                    0 : begin
                            parametric[2].sval:='0.0'; // User-Defined Memory
                            parametric[3].sval:='0.0';
                            parametric[4].sval:='0.0';
                        end;
                    1 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:='0.0';
                            parametric[4].sval:='0.0';
                        end;
                    2 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:=FloatToStr(UDM2[p]);
                            parametric[4].sval:='0.0';
                        end;
                    3 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:=FloatToStr(UDM2[p]);
                            parametric[4].sval:=FloatToStr(UDM3[p]);
                        end;
                  end;

                  bOk:=true;

                  // только внутренние узлы и граничные узлы
                  // постоянная темпеатура
                  // В структуре InitVal содержится необходимое начальное значение
                  UDS1[i+(j-1)*inx]:=my_real_convert(InitVal.UDS1Init,bOk);
               end;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               uds1oldTimeStep[ipi]:=UDS1[ipi];
            end;
         end;
         // Учёт граничных условий Дирихле !!!
         icurentuds:=1;
         initBoundaryConditionUDS;
      end;
      2 : //два UDS
      begin
         SetLength(UDS1,mzapas*inx*iny+1);
         SetLength(UDS2,mzapas*inx*iny+1);
         SetLength(UDS3,0);
         SetLength(UDS4,0);
         SetLength(uds1diffusivity,mzapas*inx*iny+1);
         SetLength(uds2diffusivity,mzapas*inx*iny+1);
         SetLength(uds3diffusivity,0);
         SetLength(uds4diffusivity,0);
         SetLength(dSc1,mzapas*inx*iny+1);
         SetLength(dSc2,mzapas*inx*iny+1);
         SetLength(dSc3,0);
         SetLength(dSc4,0);
         SetLength(dSp1,mzapas*inx*iny+1);
         SetLength(dSp2,mzapas*inx*iny+1);
         SetLength(dSp3,0);
         SetLength(dSp4,0);
         SetLength(Vxuds,mzapas*(inx-1)*iny+1);
         SetLength(Vyuds,mzapas*inx*(iny-1)+1);
         SetLength(uds1oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds2oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds3oldTimeStep,0);
         SetLength(uds4oldTimeStep,0);
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               UDS1[ipi]:=0.0;
               uds1oldTimeStep[ipi]:=0.0;
               UDS2[ipi]:=0.0;
               uds2oldTimeStep[ipi]:=0.0;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               if (itype<>0) then
               begin
                  ivar:=5;
                  SetLength(parametric,ivar);
                  parametric[0].svar:='$x';
                  parametric[1].svar:='$y';
                  parametric[2].svar:='$udm1'; // User - Defined Memory
                  parametric[3].svar:='$udm2';
                  parametric[4].svar:='$udm3';
                  parametric[0].sval:=FloatToStr(xpos[i]);
                  parametric[1].sval:=FloatToStr(ypos[j]);
                  case imaxUDM of
                    0 : begin
                            parametric[2].sval:='0.0'; // User-Defined Memory
                            parametric[3].sval:='0.0';
                            parametric[4].sval:='0.0';
                        end;
                    1 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:='0.0';
                            parametric[4].sval:='0.0';
                        end;
                    2 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:=FloatToStr(UDM2[p]);
                            parametric[4].sval:='0.0';
                        end;
                    3 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:=FloatToStr(UDM2[p]);
                            parametric[4].sval:=FloatToStr(UDM3[p]);
                        end;
                  end;

                  bOk:=true;

                  // только внутренние узлы и граничные узлы
                  // постоянная темпеатура
                  // В структуре InitVal содержится необходимое начальное значение
                  UDS1[i+(j-1)*inx]:=my_real_convert(InitVal.UDS1Init,bOk);
                  UDS2[i+(j-1)*inx]:=my_real_convert(InitVal.UDS2Init,bOk);
               end;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               uds1oldTimeStep[ipi]:=UDS1[ipi];
               uds2oldTimeStep[ipi]:=UDS2[ipi];
            end;
         end;
         // Учёт граничных условий Дирихле !!!
         icurentuds:=1;
         initBoundaryConditionUDS;
         icurentuds:=2;
         initBoundaryConditionUDS;
      end;
      3 : //три UDS
      begin
         SetLength(UDS1,mzapas*inx*iny+1);
         SetLength(UDS2,mzapas*inx*iny+1);
         SetLength(UDS3,mzapas*inx*iny+1);
         SetLength(UDS4,0);
         SetLength(uds1diffusivity,mzapas*inx*iny+1);
         SetLength(uds2diffusivity,mzapas*inx*iny+1);
         SetLength(uds3diffusivity,mzapas*inx*iny+1);
         SetLength(uds4diffusivity,0);
         SetLength(dSc1,mzapas*inx*iny+1);
         SetLength(dSc2,mzapas*inx*iny+1);
         SetLength(dSc3,mzapas*inx*iny+1);
         SetLength(dSc4,0);
         SetLength(dSp1,mzapas*inx*iny+1);
         SetLength(dSp2,mzapas*inx*iny+1);
         SetLength(dSp3,mzapas*inx*iny+1);
         SetLength(dSp4,0);
         SetLength(Vxuds,mzapas*(inx-1)*iny+1);
         SetLength(Vyuds,mzapas*inx*(iny-1)+1);
         SetLength(uds1oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds2oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds3oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds4oldTimeStep,0);
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               UDS1[ipi]:=0.0;
               uds1oldTimeStep[ipi]:=0.0;
               UDS2[ipi]:=0.0;
               uds2oldTimeStep[ipi]:=0.0;
               UDS3[ipi]:=0.0;
               uds3oldTimeStep[ipi]:=0.0;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               if (itype<>0) then
               begin
                  ivar:=5;
                  SetLength(parametric,ivar);
                  parametric[0].svar:='$x';
                  parametric[1].svar:='$y';
                  parametric[2].svar:='$udm1'; // User - Defined Memory
                  parametric[3].svar:='$udm2';
                  parametric[4].svar:='$udm3';
                  parametric[0].sval:=FloatToStr(xpos[i]);
                  parametric[1].sval:=FloatToStr(ypos[j]);
                  case imaxUDM of
                    0 : begin
                            parametric[2].sval:='0.0'; // User-Defined Memory
                            parametric[3].sval:='0.0';
                            parametric[4].sval:='0.0';
                        end;
                    1 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:='0.0';
                            parametric[4].sval:='0.0';
                        end;
                    2 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:=FloatToStr(UDM2[p]);
                            parametric[4].sval:='0.0';
                        end;
                    3 : begin
                            parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                            parametric[3].sval:=FloatToStr(UDM2[p]);
                            parametric[4].sval:=FloatToStr(UDM3[p]);
                        end;
                  end;
                  bOk:=true;

                  // только внутренние узлы и граничные узлы
                  // постоянная темпеатура
                  // В структуре InitVal содержится необходимое начальное значение
                  UDS1[i+(j-1)*inx]:=my_real_convert(InitVal.UDS1Init,bOk);
                  UDS2[i+(j-1)*inx]:=my_real_convert(InitVal.UDS2Init,bOk);
                  UDS3[i+(j-1)*inx]:=my_real_convert(InitVal.UDS3Init,bOk);
               end;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               uds1oldTimeStep[ipi]:=UDS1[ipi];
               uds2oldTimeStep[ipi]:=UDS2[ipi];
               uds3oldTimeStep[ipi]:=UDS3[ipi];
            end;
         end;
         // Учёт граничных условий Дирихле !!!
         icurentuds:=1;
         initBoundaryConditionUDS;
         icurentuds:=2;
         initBoundaryConditionUDS;
         icurentuds:=3;
         initBoundaryConditionUDS;

      end;
      4 : //четыре UDS
      begin
         SetLength(UDS1,mzapas*inx*iny+1);
         SetLength(UDS2,mzapas*inx*iny+1);
         SetLength(UDS3,mzapas*inx*iny+1);
         SetLength(UDS4,mzapas*inx*iny+1);
         SetLength(uds1diffusivity,mzapas*inx*iny+1);
         SetLength(uds2diffusivity,mzapas*inx*iny+1);
         SetLength(uds3diffusivity,mzapas*inx*iny+1);
         SetLength(uds4diffusivity,mzapas*inx*iny+1);
         SetLength(dSc1,mzapas*inx*iny+1);
         SetLength(dSc2,mzapas*inx*iny+1);
         SetLength(dSc3,mzapas*inx*iny+1);
         SetLength(dSc4,mzapas*inx*iny+1);
         SetLength(dSp1,mzapas*inx*iny+1);
         SetLength(dSp2,mzapas*inx*iny+1);
         SetLength(dSp3,mzapas*inx*iny+1);
         SetLength(dSp4,mzapas*inx*iny+1);
         SetLength(Vxuds,mzapas*(inx-1)*iny+1);
         SetLength(Vyuds,mzapas*inx*(iny-1)+1);
         SetLength(uds1oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds2oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds3oldTimeStep,mzapas*inx*iny+1);
         SetLength(uds4oldTimeStep,mzapas*inx*iny+1);
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               UDS1[ipi]:=0.0;
               uds1oldTimeStep[ipi]:=0.0;
               UDS2[ipi]:=0.0;
               uds2oldTimeStep[ipi]:=0.0;
               UDS3[ipi]:=0.0;
               uds3oldTimeStep[ipi]:=0.0;
               UDS4[ipi]:=0.0;
               uds4oldTimeStep[ipi]:=0.0;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               if (itype<>0) then
               begin
                  ivar:=5;
                  SetLength(parametric,ivar);
                  parametric[0].svar:='$x';
                  parametric[1].svar:='$y';
                   parametric[2].svar:='$udm1'; // User - Defined Memory
                  parametric[3].svar:='$udm2';
                  parametric[4].svar:='$udm3';
                  parametric[0].sval:=FloatToStr(xpos[i]);
                  parametric[1].sval:=FloatToStr(ypos[j]);
                  case imaxUDM of
                    0 : begin
                           parametric[2].sval:='0.0'; // User-Defined Memory
                           parametric[3].sval:='0.0';
                           parametric[4].sval:='0.0';
                        end;
                    1 : begin
                           parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                           parametric[3].sval:='0.0';
                           parametric[4].sval:='0.0';
                        end;
                    2 : begin
                           parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                           parametric[3].sval:=FloatToStr(UDM2[p]);
                           parametric[4].sval:='0.0';
                        end;
                    3 : begin
                           parametric[2].sval:=FloatToStr(UDM1[p]); // User-Defined Memory
                           parametric[3].sval:=FloatToStr(UDM2[p]);
                           parametric[4].sval:=FloatToStr(UDM3[p]);
                        end;
                  end;
                  bOk:=true;

                  // только внутренние узлы и граничные узлы
                  // постоянная темпеатура
                  // В структуре InitVal содержится необходимое начальное значение
                  UDS1[i+(j-1)*inx]:=my_real_convert(InitVal.UDS1Init,bOk);
                  UDS2[i+(j-1)*inx]:=my_real_convert(InitVal.UDS2Init,bOk);
                  UDS3[i+(j-1)*inx]:=my_real_convert(InitVal.UDS3Init,bOk);
                  UDS4[i+(j-1)*inx]:=my_real_convert(InitVal.UDS4Init,bOk);
               end;
            end;
         end;
         for p:=1 to imaxnumbernode do
         begin
            with mapPT[p] do
            begin
               ipi:=i+(j-1)*inx;
               uds1oldTimeStep[ipi]:=UDS1[ipi];
               uds2oldTimeStep[ipi]:=UDS2[ipi];
               uds3oldTimeStep[ipi]:=UDS3[ipi];
               uds4oldTimeStep[ipi]:=UDS4[ipi];
            end;
         end;
         // Учёт граничных условий Дирихле !!!
         icurentuds:=1;
         initBoundaryConditionUDS;
         icurentuds:=2;
         initBoundaryConditionUDS;
         icurentuds:=3;
         initBoundaryConditionUDS;
         icurentuds:=4;
         initBoundaryConditionUDS;
      end;
   end;
end;

// Вычисляет лапласиан функции по х.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure TForm1.universallaplasx(U : array of Float; var laplasU : array of Float);
var
    i,j,ipi,ini,iei, isi, iwi : Integer;
begin
   // инициализация
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         //ini:=i+(j)*(inx);
         //isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=1) then
         begin
            laplasU[ipi]:=2.0*((U[iei]-U[ipi])*(xpos[i]-xpos[i-1])+(U[iwi]-U[ipi])*(xpos[i+1]-xpos[i]))/((xpos[i+1]-xpos[i])*(xpos[i]-xpos[i-1])*(xpos[i+1]-xpos[i-1]));
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            if(mapPT[ipi].iugol=0) then
            begin
               case mapPT[ipi].chnormal of
                 'N' : begin
                          laplasU[ipi]:=laplasU[ini];
                       end;
                 'S' : begin
                          laplasU[ipi]:=laplasU[isi];
                       end;
                 'W' : begin
                          laplasU[ipi]:=laplasU[iwi];
                       end;
                 'E' : begin
                          laplasU[ipi]:=laplasU[iei];
                       end;
               end;
            end;
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            case mapPT[ipi].iugol of
              1 : begin
                     laplasU[ipi]:=0.5*(laplasU[iei]+laplasU[ini]);
                  end;
              2 : begin
                     laplasU[ipi]:=0.5*(laplasU[iwi]+laplasU[ini]);
                  end;
              3 : begin
                     laplasU[ipi]:=0.5*(laplasU[iei]+laplasU[isi]);
                  end;
              4 : begin
                     laplasU[ipi]:=0.5*(laplasU[iwi]+laplasU[isi]);
                  end;
              5 : begin
                     laplasU[ipi]:=0.25*(laplasU[iwi]+laplasU[isi]+laplasU[ini]+laplasU[iei]);
                  end;
            end;
         end;
      end;
   end;
end;





// Вычисляет градиент функции по х.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure TForm1.universalgradx_mapPT(U : array of Float; var laplasU : array of Float);
var
    i,j : Integer;
    ipi,iei, iwi : Integer; // уже есть в mapPT
begin
   // инициализация
   for i:=1 to inx do
   begin
       for j:=1 to iny do
       begin
         ipi:=i+(j-1)*inx;

         if (mapPT[ipi].itype=1) then
         begin
            iei:=i+1+(j-1)*inx;
            iwi:=i-1+(j-1)*inx;
            //ini:=i+(j)*(inx);
            //isi:=i+(j-2)*(inx);

            if (mapPT[ipi].itype=1) then
            begin
               laplasU[ipi]:=((U[iei]-U[ipi])*(xpos[i]-xpos[i-1])*(xpos[i]-xpos[i-1])-(U[iwi]-U[ipi])*(xpos[i+1]-xpos[i])*(xpos[i+1]-xpos[i]))/((xpos[i+1]-xpos[i])*(xpos[i]-xpos[i-1])*(xpos[i+1]-xpos[i-1]));
            end;
         end;
      end;
   end;
   // снесение градиента по x в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         //ini:=i+(j)*(inx);
         //isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            if(mapPT[ipi].iugol=0) then
            begin
               // Внутренняя нормаль.
               case mapPT[ipi].chnormal of
                'N' : begin
                         laplasU[ipi]:=((U[iei]-U[ipi])*(xpos[i]-xpos[i-1])*(xpos[i]-xpos[i-1])-(U[iwi]-U[ipi])*(xpos[i+1]-xpos[i])*(xpos[i+1]-xpos[i]))/((xpos[i+1]-xpos[i])*(xpos[i]-xpos[i-1])*(xpos[i+1]-xpos[i-1]));
                      end;
                'S' : begin
                         laplasU[ipi]:=((U[iei]-U[ipi])*(xpos[i]-xpos[i-1])*(xpos[i]-xpos[i-1])-(U[iwi]-U[ipi])*(xpos[i+1]-xpos[i])*(xpos[i+1]-xpos[i]))/((xpos[i+1]-xpos[i])*(xpos[i]-xpos[i-1])*(xpos[i+1]-xpos[i-1]));
                      end;
                'W' : begin
                         laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[i]-xpos[i-1]);
                      end;
                'E' : begin
                         laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[i+1]-xpos[i]);
                      end;
               end;
            end;
         end;
      end;
   end;
   (*
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         //ini:=i+(j)*(inx);
         //isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            case mapPT[ipi].iugol of
              1 : begin
                     // левый нижний угол.
                      laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[i+1]-xpos[i]);
                  end;
              2 : begin
                     // правый нижний угол.
                     laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[i]-xpos[i-1]);
                  end;
              3 : begin
                     // левый верхний угол
                     laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[i+1]-xpos[i]);
                  end;
              4 : begin
                     // правый верхний угол.
                     laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[i]-xpos[i-1]);
                  end;
              5 : begin
                     // пятиузловой шаблон.
                     laplasU[ipi]:=((U[iei]-U[ipi])*(xpos[i]-xpos[i-1])*(xpos[i]-xpos[i-1])-(U[iwi]-U[ipi])*(xpos[i+1]-xpos[i])*(xpos[i+1]-xpos[i]))/((xpos[i+1]-xpos[i])*(xpos[i]-xpos[i-1])*(xpos[i+1]-xpos[i-1]));

                  end;
            end;
         end;
      end;
   end;
   *)

   for i:=1 to imaxnumbernode do
   begin
         if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
              ipi:=mapPT[i].i+(mapPT[i].j-1)*(inx);
         iei:=mapPT[i].i+1+(mapPT[i].j-1)*(inx);
         iwi:=mapPT[i].i-1+(mapPT[i].j-1)*(inx);
         if (mapPT[ipi].itype=2) then
         begin
            case mapPT[ipi].iugol of
              1 : begin
                     // левый нижний угол.
                     if ((iwi>=1) and (iwi<=imaxnumbernode) and (mapPT[iwi].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]);
                     end;
                  end;
              2 : begin
                     // правый нижний угол.
                     if ((iei>=1) and (iei<=imaxnumbernode) and (mapPT[iei].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]);
                     end;
                  end;
              3 : begin
                     // левый верхний угол
                     if ((iwi>=1) and (iwi<=imaxnumbernode) and (mapPT[iwi].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]);
                     end;
                  end;
              4 : begin
                     // правый верхний угол.
                     if ((iei>=1) and (iei<=imaxnumbernode) and (mapPT[iei].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]);
                     end
                     else
                     begin
                         // обычная ситуация
                         laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]);
                     end;
                  end;
              5 : begin
                     if (mapPT[iei].itype=1) then
                     begin
                        // iei - внутренний узел.
                        laplasU[ipi]:=(U[iei]-U[ipi])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]);
                     end
                     else  if (mapPT[iwi].itype=1) then
                     begin
                        // iwi - внутренний узел.
                        laplasU[ipi]:=(U[ipi]-U[iwi])/(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]);
                     end
                      else
                     begin

                        // пятиузловой шаблон.
                        laplasU[ipi]:=((U[iei]-U[ipi])*(xpos[mapPT[i].i]-xpos[mapPT[i].i-1])*(xpos[mapPT[i].i]-xpos[mapPT[i].i-1])-(U[iwi]-U[ipi])*(xpos[mapPT[i].i+1]-xpos[mapPT[i].i])*(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]))/((xpos[mapPT[i].i+1]-xpos[mapPT[i].i])*(xpos[mapPT[i].i]-xpos[mapPT[i].i-1])*(xpos[mapPT[i].i+1]-xpos[mapPT[i].i-1]));
                     end;
                  end;
            end;
         end;


          end;
   end;
end;

// Вычисляет градиент функции по y.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure TForm1.universalgrady_mapPT(U : array of Float; var laplasU : array of Float);
var
    i,j,ipi,ini, isi : Integer;
begin
   // инициализация
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         if (mapPT[ipi].itype=1) then
         begin
            ini:=i+(j)*(inx);
            isi:=i+(j-2)*(inx);

            if (mapPT[ipi].itype=1) then
            begin
               laplasU[ipi]:=((U[ini]-U[ipi])*(ypos[j]-ypos[j-1])*(ypos[j]-ypos[j-1])-(U[isi]-U[ipi])*(ypos[j+1]-ypos[j])*(ypos[j+1]-ypos[j]))/((ypos[j+1]-ypos[j])*(ypos[j]-ypos[j-1])*(ypos[j+1]-ypos[j-1]));
            end;
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            if(mapPT[ipi].iugol=0) then
            begin
               case mapPT[ipi].chnormal of
                'N' : begin
                         laplasU[ipi]:=(U[ini]-U[ipi])/(ypos[j+1]-ypos[j]);
                      end;
                'S' : begin
                         laplasU[ipi]:=(U[ipi]-U[isi])/(ypos[j]-ypos[j-1]);
                      end;
                'W' : begin
                         laplasU[ipi]:=((U[ini]-U[ipi])*(ypos[j]-ypos[j-1])*(ypos[j]-ypos[j-1])-(U[isi]-U[ipi])*(ypos[j+1]-ypos[j])*(ypos[j+1]-ypos[j]))/((ypos[j+1]-ypos[j])*(ypos[j]-ypos[j-1])*(ypos[j+1]-ypos[j-1]));
                      end;
                'E' : begin
                         laplasU[ipi]:=((U[ini]-U[ipi])*(ypos[j]-ypos[j-1])*(ypos[j]-ypos[j-1])-(U[isi]-U[ipi])*(ypos[j+1]-ypos[j])*(ypos[j+1]-ypos[j]))/((ypos[j+1]-ypos[j])*(ypos[j]-ypos[j-1])*(ypos[j+1]-ypos[j-1]));
                      end;
               end;
            end;
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            case mapPT[ipi].iugol of
              1 : begin
                     // левый нижний угол.
                     if ((isi>=1) and (isi<=imaxnumbernode) and (mapPT[isi].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[ipi]-U[isi])/(ypos[mapPT[ipi].j]-ypos[mapPT[ipi].j-1]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[ini]-U[ipi])/(ypos[j+1]-ypos[j]);
                     end;
                  end;
              2 : begin
                      // правый нижний угол.
                       if ((isi>=1) and (isi<=imaxnumbernode) and (mapPT[isi].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[ipi]-U[isi])/(ypos[mapPT[ipi].j]-ypos[mapPT[ipi].j-1]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[ini]-U[ipi])/(ypos[j+1]-ypos[j]);
                     end;
                  end;
              3 : begin
                     // левый верхний угол.
                      if ((ini>=1) and (ini<=imaxnumbernode) and (mapPT[ini].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[ini]-U[ipi])/(ypos[mapPT[ipi].j+1]-ypos[mapPT[ipi].j]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[ipi]-U[isi])/(ypos[j]-ypos[j-1]);
                     end;
                  end;
              4 : begin
                     // правый верхний угол.
                     if ((ini>=1) and (ini<=imaxnumbernode) and (mapPT[ini].itype=1)) then
                     begin
                        laplasU[ipi]:=(U[ini]-U[ipi])/(ypos[mapPT[ipi].j+1]-ypos[mapPT[ipi].j]);
                     end
                     else
                     begin
                        // обычная ситуация
                        laplasU[ipi]:=(U[ipi]-U[isi])/(ypos[j]-ypos[j-1]);
                    end;
                  end;
              5 : begin
                     if (mapPT[ini].itype=1) then
                     begin
                        // ini - внутренний узел.
                        laplasU[ipi]:=(U[ini]-U[ipi])/(ypos[j+1]-ypos[j]);
                     end
                     else
                     if (mapPT[isi].itype=1) then
                     begin
                        // isi - внутренний узел.
                        laplasU[ipi]:=(U[ipi]-U[isi])/(ypos[j]-ypos[j-1]);
                     end
                     else
                     begin
                        laplasU[ipi]:=((U[ini]-U[ipi])*(ypos[j]-ypos[j-1])*(ypos[j]-ypos[j-1])-(U[isi]-U[ipi])*(ypos[j+1]-ypos[j])*(ypos[j+1]-ypos[j]))/((ypos[j+1]-ypos[j])*(ypos[j]-ypos[j-1])*(ypos[j+1]-ypos[j-1]));
                     end;
                  end;
            end;
         end;
      end;
   end;
end;

// Вычисляет градиент функции по х и сразу потом градиент по y.
// Таким образом мы имеем смешанную производную.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure TForm1.universalgradxy_mapPT(U : array of Float; var laplasU : array of Float);
var
   buf : array of Float;
begin
   SetLength(buf,inx*iny+1);
   universalgradx_mapPT(U,buf);
   universalgrady_mapPT(buf,laplasU);
   SetLength(buf,0);
end;


// Вычисляет лапласиан функции по игрик.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure TForm1.universallaplasy(U : array of Float; var laplasU : array of Float);
var
    i,j,ipi,ini,iei, isi, iwi : Integer;
begin
   // инициализация
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         //iei:=i+1+(j-1)*(inx);
         //iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=1) then
         begin
            laplasU[ipi]:=2.0*((U[ini]-U[ipi])*(ypos[j]-ypos[j-1])+(U[isi]-U[ipi])*(ypos[j+1]-ypos[j]))/((ypos[j+1]-ypos[j])*(ypos[j]-ypos[j-1])*(ypos[j+1]-ypos[j-1]));
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            if(mapPT[ipi].iugol=0) then
            begin
               case mapPT[ipi].chnormal of
                'N' : begin
                         laplasU[ipi]:=laplasU[ini];
                      end;
                'S' : begin
                         laplasU[ipi]:=laplasU[isi];
                      end;
                'W' : begin
                         laplasU[ipi]:=laplasU[iwi];
                      end;
                'E' : begin
                         laplasU[ipi]:=laplasU[iei];
                      end;
               end;
            end;
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            case mapPT[ipi].iugol of
              1 : begin
                     laplasU[ipi]:=0.5*(laplasU[iei]+laplasU[ini]);
                  end;
              2 : begin
                     laplasU[ipi]:=0.5*(laplasU[iwi]+laplasU[ini]);
                  end;
              3 : begin
                     laplasU[ipi]:=0.5*(laplasU[iei]+laplasU[isi]);
                  end;
              4 : begin
                     laplasU[ipi]:=0.5*(laplasU[iwi]+laplasU[isi]);
                  end;
              5 : begin
                     laplasU[ipi]:=0.25*(laplasU[iwi]+laplasU[isi]+laplasU[ini]+laplasU[iei]);
                  end;
            end;
         end;
      end;
   end;
end;

// Вычисляет лапласиан функции.
// U - задано на сетке mapPT, laplasU - задано на сетке mapPT.
procedure TForm1.universallaplas(U : array of Float; var laplasU : array of Float);
var
    i,j,ipi,ini,iei, isi, iwi : Integer;
begin
   // инициализация
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=1) then
         begin
            laplasU[ipi]:=2.0*((U[iei]-U[ipi])*(xpos[i]-xpos[i-1])+(U[iwi]-U[ipi])*(xpos[i+1]-xpos[i]))/((xpos[i+1]-xpos[i])*(xpos[i]-xpos[i-1])*(xpos[i+1]-xpos[i-1]));
            laplasU[ipi]:=laplasU[ipi]+2.0*((U[ini]-U[ipi])*(ypos[j]-ypos[j-1])+(U[isi]-U[ipi])*(ypos[j+1]-ypos[j]))/((ypos[j+1]-ypos[j])*(ypos[j]-ypos[j-1])*(ypos[j+1]-ypos[j-1]));
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            if(mapPT[ipi].iugol=0) then
            begin
               case mapPT[ipi].chnormal of
                 'N' : begin
                          laplasU[ipi]:=laplasU[ini];
                       end;
                 'S' : begin
                          laplasU[ipi]:=laplasU[isi];
                       end;
                 'W' : begin
                          laplasU[ipi]:=laplasU[iwi];
                       end;
                 'E' : begin
                          laplasU[ipi]:=laplasU[iei];
                       end;
               end;
            end;
         end;
      end;
   end;
   // снесение лапласиана в граничные узлы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx);
         iei:=i+1+(j-1)*(inx);
         iwi:=i-1+(j-1)*(inx);
         ini:=i+(j)*(inx);
         isi:=i+(j-2)*(inx);

         if (mapPT[ipi].itype=2) then
         begin
            case mapPT[ipi].iugol of
              1 : begin
                     laplasU[ipi]:=0.5*(laplasU[iei]+laplasU[ini]);
                  end;
              2 : begin
                     laplasU[ipi]:=0.5*(laplasU[iwi]+laplasU[ini]);
                  end;
              3 : begin
                     laplasU[ipi]:=0.5*(laplasU[iei]+laplasU[isi]);
                  end;
              4 : begin
                     laplasU[ipi]:=0.5*(laplasU[iwi]+laplasU[isi]);
                  end;
              5 : begin
                     laplasU[ipi]:=0.25*(laplasU[iwi]+laplasU[isi]+laplasU[ini]+laplasU[iei]);
                  end;
            end;
         end;
      end;
   end;
end;

// Вычисляет производную по x.
// U - задано на сетке mapPT, gradxU - задано на сетке для горизонтальной скорости.
procedure TForm1.universalgradx(var U : array of Float; var gradxU : array of Float);
var
    i,j,ipi,ipii,ieii : Integer;
    // i - internal
begin
   (*  // инициализация для ускорения вычислений выключена !!!
   // инициализация
   for i:=1 to inx-1 do
   begin
       for j:=1 to iny do
       begin
         ipi:=i+(j-1)*(inx-1);
        // if ((ipi>=1) and (ipi<=(inx-1)*iny)) then
        // begin // закоментировано для ускорения вычислений.
            gradxU[ipi]:=0.0;
         (*end
         else
         begin
            Application.MessageBox('error',PAnsiChar('gradxU вышла за границы ipi='+IntToStr(ipi)),MB_OK);
         end;
         *) (*
      end;
   end;
   *)

   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);
         ipii:=i+(j-1)*inx;
         //ieii:=i+1+(j-1)*inx;
         ieii:=ipii+1;

         //if ((ipi>=1) and (ipi<=(inx-1)*iny) and (ieii>=1) and (ieii<=inx*iny) and (ipii>=1) and (ipii<=inx*iny)and (i+1<=inx)) then
         //begin  // закоментировано  для ускорения вычислений.
            gradxU[ipi]:=(U[ieii]-U[ipii])/(xpos[i+1]-xpos[i]);
         (*end
          else
         begin
            Application.MessageBox('error','gradxU вышла за границы при вычислении',MB_OK);
         end;
         *)
      end;
   end;

end;

// Вычисляет производную по y.
// U - задано на сетке mapPT, gradyU - задано на сетке для вертикальной скорости.
procedure TForm1.universalgrady(var U : array of Float; var gradyU : array of Float);
var
    i,j,ipi,ini : Integer;
begin
   // инициализация для ускорения вычислений выключена !!!
   // инициализация
   (*
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;

         if ((ipi>=1) and (ipi<=inx*(iny-1))) then
         begin
            gradyU[ipi]:=0.0;
         end
          else
         begin
            Application.MessageBox(PChar('gradyU вышла за границы ipi='+IntToStr(ipi)),'error',MB_OK);
         end;
      end;
   end;
   *)

   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;
         //ini:=i+j*inx;
         ini:=ipi+inx;
         (*
         if ((ipi>=1) and (ipi<=inx*(iny-1)) and (i+(j-1+1)*inx>=1) and (i+(j-1+1)*inx<=inx*iny) and (i+(j-1)*inx>=1) and (i+(j-1)*inx<=inx*iny) and (j+1<=iny)) then
         begin
           *)
            //gradyU[ipi]:=(U[i+(j-1+1)*inx]-U[i+(j-1)*inx])/(ypos[j+1]-ypos[j]);
            gradyU[ipi]:=(U[ini]-U[ipi])/(ypos[j+1]-ypos[j]);
         (*end
          else
         begin
            Application.MessageBox(PChar('gradyU вышла за границы при вычислении'),'error',MB_OK);
         end;
         *)
      end;
   end;

end; // universal grady

// Вычисляет производную по y.
// U - задано на сетке mapPT, gradyU - задано на сетке для горизотальной скорости.
procedure TForm1.universalgrady_mapx(var U : array of Float; var gradyU_mapx : array of Float);
var
    i1,j1,i,j,ipi : Integer;
    gradyU : array of Float;
begin
   // на сетке для вертикальной скорости
   SetLength(gradyU,inx*(iny-1)+1);
   // инициализация
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;
         if ((ipi>=1) and (ipi<=inx*(iny-1))) then
         begin
            gradyU[ipi]:=0.0;
         end
          else
         begin
            Application.MessageBox(PChar('gradyU вышла за границы ipi='+IntToStr(ipi)),'error',MB_OK);
         end;
      end;
   end;

   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;

         if ((ipi>=1) and (ipi<=inx*(iny-1)) and (i+(j-1+1)*inx>=1) and (i+(j-1+1)*inx<=inx*iny)) then
         begin
            gradyU[ipi]:=(U[i+(j-1+1)*inx]-U[i+(j-1)*inx])/(ypos[j+1]-ypos[j]);
         end
          else
         begin
            Application.MessageBox(PChar('gradyU вышла за границы при вычислении'),'error',MB_OK);
         end;

      end;
   end;

   // инициализация
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);
         if ((ipi>=1) and (ipi<=(inx-1)*iny)) then
         begin
            gradyU_mapx[ipi]:=0.0;
         end
          else
         begin
            Application.MessageBox('gradyU_mapx при инициализации вышла за границы','error',MB_OK);
         end;
      end;
   end;

   for i1:=1 to inx-1 do
   begin
      for j1:=1 to iny do
      begin

         if ((j1>=2)and(j1<=iny-1)) then
         begin
            if ((i1+(j1-1)*(inx-1)>=1) and (i1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1+(j1-1)*inx>=1) and (i1+(j1-1)*inx<=inx*(iny-1)) and (i1+(j1-1-1)*inx>=1) and (i1+(j1-1-1)*inx<=inx*(iny-1)) and (i1+1+(j1-1)*inx>=1) and (i1+1+(j1-1)*inx<=inx*(iny-1)) and (i1+1+(j1-1-1)*inx>=1) and (i1+1+(j1-1-1)*inx<=inx*(iny-1))) then
            begin
               gradyU_mapx[i1+(j1-1)*(inx-1)]:=0.25*(gradyU[i1+(j1-1)*inx]+gradyU[i1+(j1-1-1)*inx]+gradyU[i1+1+(j1-1)*inx]+gradyU[i1+1+(j1-1-1)*inx]);
            end
             else
            begin
               Application.MessageBox('gradyU_mapx при вычислении вышла за границы','error',MB_OK);
            end;
         end
          else if (j1=1) then
         begin
           if ((i1+(j1-1)*(inx-1)>=1) and (i1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1+(j1-1)*inx>=1) and (i1+(j1-1)*inx<=inx*(iny-1)) and (i1+1+(j1-1)*inx>=1) and (i1+1+(j1-1)*inx<=inx*(iny-1))) then
           begin
              gradyU_mapx[i1+(j1-1)*(inx-1)]:=0.5*(gradyU[i1+(j1-1)*inx]+gradyU[i1+1+(j1-1)*inx]);
           end
            else
           begin
              Application.MessageBox('gradyU_mapx при вычислении j1=1 вышла за границы','error',MB_OK);
           end;
         end
          else if (j1=iny) then
         begin
            if ((i1+(j1-1)*(inx-1)>=1) and (i1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1+(j1-1-1)*inx>=1) and (i1+(j1-1-1)*inx<=inx*(iny-1)) and (i1+1+(j1-1-1)*inx>=1) and (i1+1+(j1-1-1)*inx<=inx*(iny-1))) then
            begin
               gradyU_mapx[i1+(j1-1)*(inx-1)]:=0.5*(gradyU[i1+(j1-1-1)*inx]+gradyU[i1+1+(j1-1-1)*inx]);
            end
             else
            begin
               Application.MessageBox('gradyU_mapx при вычислении j1=iny вышла за границы','error',MB_OK);
            end;
         end;
      end;
   end;



end; // universal grady_mapx


// Вычисляет производную по x.
// U - задано на сетке mapPT, gradxU - задано на сетке для вертикальной скорости.
procedure TForm1.universalgradx_mapy(var U : array of Float; var gradxU_mapy : array of Float);
var
    i1,j1, i,j,ipi : Integer;
    gradxU : array of Float;
begin
   // на сетке для вертикальной скорости
   SetLength(gradxU,mzapas*(inx-1)*iny+1);

    // инициализация
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);
         if ((ipi>=1) and (ipi<=(inx-1)*iny)) then
         begin
            gradxU[ipi]:=0.0;
         end
          else
         begin
            Application.MessageBox('gradxU вышла за границы в grax_mapy','error',MB_OK);
         end;
      end;
   end;

   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);

         if ((ipi>=1) and (ipi<=(inx-1)*iny) and (i+1+(j-1)*inx>=1) and (i+1+(j-1)*inx<=inx*iny) and (i+(j-1)*inx>=1) and (i+(j-1)*inx<=inx*iny)) then
         begin
            gradxU[ipi]:=(U[i+1+(j-1)*inx]-U[i+(j-1)*inx])/(xpos[i+1]-xpos[i]);
         end
          else
         begin
            Application.MessageBox('gradxU вышла за границы в grax_mapy при вычислении','error',MB_OK);
         end;
      end;
   end;


   // инициализация
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;
         if ((ipi>=1) and (ipi<=inx*(iny-1))) then
         begin
            gradxU_mapy[ipi]:=0.0;
         end
          else
         begin
            Application.MessageBox('gradxU_mapy вышла за границы при инициализации','error',MB_OK);
         end;
      end;
   end;

   for i1:=1 to inx do
   begin
      for j1:=1 to iny-1 do
      begin

         if ((i1>=2)and(i1<=inx-1)) then
         begin
            if ((i1+(j1-1)*inx>=1) and (i1+(j1-1)*inx<=inx*(iny-1)) and (i1+(j1-1)*(inx-1)>=1) and (i1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1-1+(j1-1)*(inx-1)>=1) and (i1-1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1+(j1-1+1)*(inx-1)>=1) and (i1+(j1-1+1)*(inx-1)<=(inx-1)*iny) and (i1-1+(j1-1+1)*(inx-1)>=1) and (i1-1+(j1-1+1)*(inx-1)<=(inx-1)*iny)) then
            begin
               gradxU_mapy[i1+(j1-1)*inx]:=0.25*(gradxU[i1+(j1-1)*(inx-1)]+gradxU[i1-1+(j1-1)*(inx-1)]+gradxU[i1+(j1-1+1)*(inx-1)]+gradxU[i1-1+(j1-1+1)*(inx-1)]);
            end
             else
            begin
               Application.MessageBox('gradxU_mapy  вышла за границы при вычислении','error',MB_OK);
            end;
         end
         else if (i1=1) then
         begin
             if ((i1+(j1-1)*inx>=1) and (i1+(j1-1)*inx<=inx*(iny-1)) and (i1+(j1-1)*(inx-1)>=1) and (i1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1+(j1-1+1)*(inx-1)>=1) and (i1+(j1-1+1)*(inx-1)<=(inx-1)*iny) ) then
             begin
                gradxU_mapy[i1+(j1-1)*inx]:=0.5*(gradxU[i1+(j1-1)*(inx-1)]+gradxU[i1+(j1-1+1)*(inx-1)]);
             end
              else
             begin
                Application.MessageBox('gradxU_mapy i1=1 вышла за границы при вычислении','error',MB_OK);
             end;
         end
         else if (i1=inx) then
         begin
             if ((i1+(j1-1)*inx>=1) and (i1+(j1-1)*inx<=inx*(iny-1)) and (i1-1+(j1-1)*(inx-1)>=1) and (i1-1+(j1-1)*(inx-1)<=(inx-1)*iny) and (i1-1+(j1-1+1)*(inx-1)>=1) and (i1-1+(j1-1+1)*(inx-1)<=(inx-1)*iny) ) then
             begin
                gradxU_mapy[i1+(j1-1)*inx]:=0.5*(gradxU[i1-1+(j1-1)*(inx-1)]+gradxU[i1-1+(j1-1+1)*(inx-1)]);
             end
              else
             begin
                Application.MessageBox('gradxU_mapy i1=inx вышла за границы при вычислении','error',MB_OK);
             end;
         end;
      end;
   end;

end; // universal gradx_mapy



// поиск подстроки в строке
// аналог встроенной функции pos.
(*
function TForm1.Find(const S, P : String) : Integer;
var
  i, j : Integer;
begin
  Result := 0;
  if Length(P) > Length(S)
   then Exit;
  for i := 1 to Length(S) - Length(P) + 1 do
  for j := 1 to Length(P) do
  if P[j] <> S[i+j-1]
  then Break
  else
    if j = Length(P)
    then
     begin
       Result := i;
       Exit;
     end;
end;
*)

 // подстановка значений переменных в строку
// patterns - исходная неизменяемая строка.
// workstring - преобразованная исходная строка.
procedure TForm1.my_substitutional_of_value(patterns : String; var workstring : String);
var
   s : String;
   i,ir,ipos,ivarloc, iposfirst : Integer;
   bcont, bfirst : Boolean;
begin
   // ivar - глобальная переменная.
   s:=patterns;
   if (ivar>0) then
   begin
      bcont:=true;
      while (bcont) do
      begin
         // инициализация
         bcont:=false;
         ipos:=0;
         bfirst:=true;
         iposfirst:=0;
         ivarloc:=-1; // несуществующая переменная
         for i:=0 to ivar-1 do
         begin
            ir:=Pos(parametric[i].svar,s);
            //ipos:=Find(s,Laplas.parametric[i].svar);

            // здесь корректно обрабатывается случай если две переменные
            // имеют похожие имена например $lg и $lgg. Если мы всречаем
            // $lgg то нужно подставить именно $lgg а не $lg. Так как вхождение обоих
            // начинается с одинаковой позиции.
            if ((bfirst or (ir=iposfirst)) and (ir>0)) then
            begin
               // если для одной и той же позиции в тексте
               // нашлось более одного вхождения то нужно
               // заменять вхождение наибольшей длины.
               bfirst:=false;
               iposfirst:=ir;
               ipos:=ir;
               if (ivarloc=-1) then
               begin
                  ivarloc:=i;
               end
                else
               begin
                  if (length(parametric[i].svar)>length(parametric[ivarloc].svar)) then
                  begin
                     ivarloc:=i;
                  end;
               end;
            end;
         end;
         if (ipos > 0) then
         begin
            // подстрока найдена, надо осуществить подстановку.
            bcont:=true; // успешная подстановка требуется продолжить поиск вхождений в дальнейшем.
            Delete(s,ipos,length(parametric[ivarloc].svar));
            Insert('('+parametric[ivarloc].sval+')',s,ipos);
         end;
      end;
   end;
   workstring:=s; // присваиваем преобразованную строку.
   //Application.MessageBox(PChar(s),'message',MB_OK);
end;

// рекурсивная функция конструирования поддерева
// выражения с корнем r из строки st
procedure TForm1.Constr_Tree(var r : pTop; var st : string);
// AnsiString - это длинный стринг без ограничения на длину в 255 символов.
var
    po,code : Integer;
    stl, stri : String;
    c : Float;
    bOk : Boolean;
    sbuf : String; // временная строка для корректного введения новой переменной.
    bcont : Boolean;
    // bunary : Boolean; // унарный минус.
    bfound : Boolean; // найдена ли новая переменная в списке обнаруженных переменных.
    i1, ifound : Integer; // вспомогательный счётчик.
    sbuf1 : String;
    stxe8 : String;
    rootbuf : pTop;

procedure patch_string();
var
   i7 : Integer;
begin
   for i7:=1 to length(sbuf1) do
   begin
      if (FormatSettings.DecimalSeparator='.') then
      begin
          if (sbuf1[i7]=',') then
          begin
             sbuf1[i7]:='.';
          end;
      end;
      if (FormatSettings.DecimalSeparator=',') then
      begin
          if (sbuf1[i7]='.') then
          begin
             sbuf1[i7]:=',';
          end;
      end;
   end;
end;

// внутренняя функция поиска разделительного знака в строке st:
// SetOp - множество знаков; функция возвращает позицию разделительного знака или 0.
function PosOp(st : String; SetOp : setChar(*; var bunaryloc : Boolean*)) : Integer;
var i,j,k,p : Integer;
begin
   //bunaryloc:=False;
   j:=0; k:=0; p:=0;
   i:=length(st);//i:=1; // Внимание !!! строку обязательно нужно сканировать из конца в начало.
   while ((i>=1) and (i<=length(st)) and (p=0)) do
   begin
      if st[i]='(' then inc(j) // считаем количество открывающихся скобок
      else if st[i]=')' then inc(k) // считаем количество закрывающихся скобок
      else if (j=k) and (st[i] in SetOp) then
      begin
         if (((st[i]='-')or(st[i]='+')) and (i-2>=1) and ((st[i-1]='E') or (st[i-1]='e')) and (st[i-2] in ['0'..'9'])) then
         begin
            // это экспоненциальная запись вещественного числа а не разделительный знак операции.
         end (*else
         if ((st[i]='-') and ((i=1) or ((i=2) and (st[1]=' ')))) then
         begin
            // это унарный минус.
            bunaryloc:=True;
            p:=i;
         end
         *)
         else
         begin
            p:=i;
         end;
      end;
      dec(i); //inc(i); // Внимание строку обязательно нужно сканировать из конца в начало.
   end;
   PosOp:=p;
end;

// раздел операторов функции конструирования дерева выражения

begin
   bcont:=True;
   while (bcont) do
   begin
      st:=Trim(st); // Убираем пробелы.
      if ((st[1]='(') and (PosOp(st,['*','/','+','-','^'](*,bunary*))=0)) then
      begin
         st:=copy(st,2,length(st)-2); // убираем скобки
      end
       else
      begin
         bcont:=False;
      end;
   end;

   po:=PosOp(st,['+','-'](*,bunary*)); // ищем разделительный знак оперпации + или -
   (*if ((po<>0) and (bunary)) then
   begin
      r^.operator[1]:='-';
      r^.left:=nil;

   end
    else
   begin

   end;*)
   if po=0 then po:=PosOp(st,['*','/'](*,bunary*)); // ищем разделительный знак операции  * или /
   if po=0 then po:=PosOp(st,['^'](*,bunary*)); // ищем разделительный знак операции возведения в степень
   if (po<>0) then  // разделяющий знак найден
   begin
      stxe8:=' ';
      stxe8[1]:=st[po];
      //(r^).myoperator[1]:=st[po]; // записываем знак операции в вершину
      (r^).myoperator:=stxe8;

      //r^.operator[1]:=st[po]; // записываем знак операции в вершину
      stl:=Trim(copy(st,1,po-1)); // копируем подстроку первого операнда
      if (length(stl)>0) then
      begin

         bcont:=True;
         while (bcont) do
         begin
            stl:=Trim(stl);
            if (stl[1]='(') and (PosOp(stl,['*','/','+','-','^'](*,bunary*))=0) then
            begin
               stl:=copy(stl,2,length(stl)-2); // убираем скобки
            end
             else
            begin
               bcont:=False;
            end;
         end;
      end
       else
      begin
         // унарный минус
         stl:='';
         bOk:=false;
         if ((r^.myoperator[1]='-') or (r^.myoperator[1]='+')) then
         begin
            bOk:=true;  //b1:=true;
         end;
         if (not bOk) then
         begin
            // дерево конечно построится но вычислить значение выражения по
            // нему будет нельзя. Этот случай нужно корректно обработать, т.е.
            // сообщить об ошибке наверх по иерархии вызовывов, что бы избежать
            // вызова приводящего к ошибке вычисления выражения по такому днреву.
            MainMemo.Lines.Add('Error! tree can not be construct... ');
            Application.MessageBox(PChar('tree can not be construct...'),'Error!',MB_OK);
         end;
      end;

      stri:=Trim(copy(st,po+1,length(st)-po)); // копируем подстроку второго операнда
      bcont:=True;
      while (bcont) do
      begin
         stri:=Trim(stri);
         if (stri[1]='(') and (PosOp(stri,['*','/','+','-','^'](*,bunary*))=0) then
         begin
            stri:=copy(stri,2,length(stri)-2); // убираем скобки
         end
          else
         begin
            bcont:=False;
         end;
      end;


      if (length(stl)>0) then
      begin
         rootbuf:=nil;
         new(rootbuf);
         //new(r^.left);  // создаём левое поддерево
         //Constr_Tree(r^.left,stl); // конструируем левый операнд
         Constr_Tree(rootbuf,stl);
         r^.left:=rootbuf;
         rootbuf:=nil;
      end
       else
      begin
         // унарный минус
         r^.left:=nil; // левое поддерево пустое.
      end;
      rootbuf:=nil;
      new(rootbuf);
      //new(r^.right); // создаём правое поддерево
      //Constr_Tree(r^.right,stri); // конструируем правый операнд
      Constr_Tree(rootbuf,stri);
      r^.right:=rootbuf;
      rootbuf:=nil;

    end
     else
    begin
       // Здесь предполагается что все переменные были заранее исключены
       // применением процедуры  my_substitutional_of_value.
       bcont:=True;
       while (bcont) do
       begin
          st:=Trim(st); // Убираем пробелы.
          if ((st[1]='(') and (PosOp(st,['*','/','+','-','^'](*,bunary*))=0)) then
          begin
             st:=copy(st,2,length(st)-2); // убираем скобки
          end
           else
          begin
             bcont:=False;
          end;
       end;


       st:=Trim(st);
       // убираем лишние скобки.
       while ((st[1]='(') and (st[Length(st)]=')') and (PosOp(st,['*','/','+','-','^'])=0)) do
       begin
          if ((st[1]='(') and (st[Length(st)]=')')) then
          begin
             st:=Copy(st,2,Length(st)-2);
             st:=Trim(st);
          end;
       end;
       val(st,c,code); // пытаемся получить число
       if code=0 then // константа
       begin
          r^.myoperator:='o';
          r^.left:=nil;
          r^.right:=nil;
          r^.value:=c;
       end
        else // функция
       begin
          st:=Trim(st);
          // убираем лишние скобки.
          while ((st[1]='(') and (st[Length(st)]=')') and (PosOp(st,['*','/','+','-','^'])=0)) do
          begin
             if ((st[1]='(') and (st[Length(st)]=')')) then
             begin
                st:=Copy(st,2,Length(st)-2);
                st:=Trim(st);
             end;
          end;
          po:=Pos('(',st);
          if (po=0) then
          begin
             sbuf:=st;
             my_substitutional_of_value(sbuf,st); // результат записан в st.
             // Это точно новая переменная.
             st:=Trim(st);
             while ((st[1]='(') and (st[Length(st)]=')') and (PosOp(st,['*','/','+','-','^'])=0)) do
             begin
                if ((st[1]='(') and (st[Length(st)]=')')) then
                begin
                   st:=Copy(st,2,Length(st)-2);
                   st:=Trim(st);
                end;
             end;

             // Теперь если переменная уже была введена, то st будет просто
             //  константой и вводить новую переменную не нужно.
             val(st,c,code); // пытаемся получить число
             if (code=0) then
             begin
                // Ранее по ходу построения дерева эта переменная уже была введена,
                // и поэтому теперь мы записываем просто её константное значение.

                r^.myoperator:='o';
                r^.left:=nil;
                r^.right:=nil;
                r^.value:=c;
             end
              else
             begin
                // Это точно новая переменная.
                st:=Trim(st);
                while ((st[1]='(') and (st[Length(st)]=')') and (PosOp(st,['*','/','+','-','^'])=0)) do
                begin
                   if ((st[1]='(') and (st[Length(st)]=')')) then
                   begin
                      st:=Copy(st,2,Length(st)-2);
                      st:=Trim(st);
                   end;
                end;
                // надо искать в списке переменных переменную с именем хранящимся в st.
                // В случае обнаружения сочитать оттуда значение и форму больше не вызывать.
                bfound:=False;
                ifound:=-1; // ненайдена.
                for i1:=0 to ivar-1 do
                begin
                   if ((Pos(st,parametric[i1].svar)=1) and (Length(st)=Length(parametric[i1].svar))) then
                   begin
                      ifound:=i1;
                      bfound:=True;
                      break; // досрочный выход из цикла for.
                   end;
                end;

                if (not(bfound)) then
                begin
                   // Переменная в сиске не найдена это новая переменная
                   // которая должна быть занесена в список.
                   AddVariableForm.lblname.Caption:=st; // предполагаемое имя переменной.
                   if (FormatSettings.DecimalSeparator='.') then
                   begin
                      AddVariableForm.edtvalue.Text:='0.0'; // предполагаемое значение.
                   end;
                   if (FormatSettings.DecimalSeparator=',') then
                   begin
                      AddVariableForm.edtvalue.Text:='0,0'; // предполагаемое значение.
                   end;
                   AddVariableForm.bcanclose:=False; // не даём форме закрываться
                   AddVariableForm.ShowModal;

                   // переменная воспринимается как константное значение этой переменной.
                   r^.myoperator:='o';
                   r^.left:=nil;
                   r^.right:=nil;
                   sbuf1:=AddVariableForm.edtvalue.Text;
                   patch_string();
                   val(sbuf1,c,code);
                   if (code=0) then
                   begin
                      r^.value:=c;
                      Inc(ivar);
                      SetLength(parametric,ivar);
                      parametric[ivar-1].svar:=st;
                      sbuf1:=AddVariableForm.edtvalue.Text;
                      patch_string();
                      parametric[ivar-1].sval:=sbuf1;
                      if (FormInterpritator.bInterpretatortest) then
                      begin
                         // Мы находимся в режиме тестирования интерпретатора.
                         // добавляем новую переменную в список переменных.
                         FormInterpritator.strngrdinterpritator.Cells[1,ivar]:=Trim(st);
                         FormInterpritator.strngrdinterpritator.Cells[2,ivar]:=Trim(FloatToStr(c));
                      end
                       else
                      begin
                         // Мы находимся в рабочем режиме !!!
                         inc(ivar_trial); // количество переменных  для parametric trial
                         SetLength(base_value_trial,ivar_trial);
                         base_value_trial[ivar_trial-1].svar:=st;
                         sbuf1:=AddVariableForm.edtvalue.Text;
                         patch_string();
                         base_value_trial[ivar_trial-1].sval:=sbuf1;
                         // дополнительно нужно инициализировать и поддерживать список значений
                         // для каждой переменной многопарметрического решателя.
                         SetLength(series_value_of_the_variable, ivar_trial);
                         SetLength(series_value_of_the_variable[ivar_trial-1],1);
                         sbuf1:=AddVariableForm.edtvalue.Text;
                         patch_string();
                         series_value_of_the_variable[ivar_trial-1][0]:=StrToFloat(sbuf1);
                      end;
                   end
                    else
                   begin
                     // Данного случая просто не может быть, см модуль AddVariableUnit !!!
                   end;
                end
                else
                begin
                   // Переменная найдена в списке переменных в позиции ifound
                   r^.myoperator:='o';
                   r^.left:=nil;
                   r^.right:=nil;
                   sbuf1:=parametric[ifound].sval;
                   patch_string();
                   r^.value:=StrToFloat(sbuf1);
                end;
             end;
          end
           else
          begin
             r^.myoperator:=copy(st,1,po-1); // выделяем имя функции
             r^.right:=nil;
             stl:=copy(st,po+1,length(st)-po-1); // выделяем подстроку параметра
             rootbuf:=nil;
             new(rootbuf);

             //new(r^.left);
             //Constr_Tree(r^.left,stl); // конструируем параметр
             Constr_Tree(rootbuf,stl); // конструируем параметр
             r^.left:=rootbuf;
             rootbuf:=nil;
          end;
       end;
    end;
end;   // Constr_Tree

// рекурсивное вычисление значения функции
// если key=false, то значение не существует
function TForm1.my_count(r : pTop; var key : Boolean) : Float;
var
    s,s1 : Float;
begin
   my_count:=0.0; // инициализация
   if not key then // значение функции не существует
   begin
      my_count:=0.0;
      MainMemo.Lines.Add('Error! expression can not be calculated... ');
      Application.MessageBox(PChar('expression can not be calculated...'),'Error!',MB_OK);
   end
   else
   begin
      if r^.myoperator[1]='o' then my_count:=r^.value // константа
      else
       case r^.myoperator[1] of
         '+' :  begin
                    if (r^.left=nil) then
                   begin
                      // унарный плюс (есть вероятность что он может встретиться.
                      my_count:=my_count(r^.right,key);
                   end
                   else
                   begin
                      my_count:=my_count(r^.left,key)+my_count(r^.right,key);
                   end;
                end;
         '-' :  begin
                   if (r^.left=nil) then
                   begin
                      // унарный минус
                      my_count:=-my_count(r^.right,key);
                   end
                   else
                   begin
                      my_count:=my_count(r^.left,key)-my_count(r^.right,key);
                   end;
                end;
         '*' :  my_count:=my_count(r^.left,key)*my_count(r^.right,key);
         '/' :  begin
                   s:=my_count(r^.right,key);
                   s1:=my_count(r^.left,key);
                   try
                      if ((Abs(s)<1.0e-40) and (Abs(s1)<1.0e-40)) then
                      begin
                         // При неопределённости ноль на ноль возвращаем ноль.
                         // такого вида неопределённость появляется в полескоростной характеристике GaAs.
                         my_count:=0.0;
                      end
                      else
                      begin
                         my_count:=s1/s;
                      end;
                   except
                      Application.MessageBox('division by zero in tree calculation','error',MB_OK);
                      my_count:=0.0;
                      key:=false;
                   end;
                end;
         '^' : begin
                  s:=my_count(r^.left,key);
                  s1:=my_count(r^.right,key);
                  try
                      my_count:=exp(s1*ln(abs(s)));
                  except
                     Application.MessageBox('это может быть неопределённость 0.0 ^ 0.0 при вычислении с помощью пользовательского дерева','error',MB_OK);
                     if (( abs(s)<1e-10) and (abs(s1)<1e-10)) then  my_count:=1.0
                     else  my_count:=0.0;
                  end;
               end;
         // некоторые немногие основные математические функции
         'a' : begin
                  // abs
                  my_count:=abs(my_count(r^.left,key));
               end;
         's' : begin
                  if  r^.myoperator[2]='i' then
                  begin
                     // sin
                     my_count:=sin(my_count(r^.left,key));
                  end;
                  if  r^.myoperator[2]='h' then
                  begin
                     // sh - гиперболический синус
                     s:=my_count(r^.left,key);
                     my_count:=0.5*(exp(s)-exp(-s));
                  end;
                  if  r^.myoperator[2]='q' then
                  begin
                     if (length(r^.myoperator)=4) then
                     begin
                        // sqrt(abs(s)) квадратный корень
                        my_count:=sqrt(abs(my_count(r^.left,key)));
                     end
                     else
                     begin
                        // sqr - возведение в квадрат
                        my_count:=sqr(my_count(r^.left,key));
                     end;
                  end;
               end;
         'c' : begin
                  if  r^.myoperator[2]='o' then
                  begin
                     // cos
                     my_count:=cos(my_count(r^.left,key));
                  end;
                  if  r^.myoperator[2]='h' then
                  begin
                     // ch гиперболический косинус
                     s:=my_count(r^.left,key);
                     my_count:=0.5*(exp(s)+exp(-s));
                  end;
               end;
         'e' : begin
                   // exp   экспонента
                   my_count:=exp(my_count(r^.left,key));
               end;
         'l' : begin
                  // ln(abs(s))  натуральный логарифм
                  s:=my_count(r^.left,key);
                  my_count:=ln(abs(s));
               end;
         else // неопределённая операция
          begin
             my_count:=0.0;
             key:=false;
          end;
       end; // case

   end;
end; // my_count

 // освобождение оперативной памяти занимаемой двоичным деревом
procedure TForm1.my_delete(var r : pTop);
var
 rootbuf : pTop;
begin
    if (r<>nil) then
    begin

         rootbuf:=nil;
        rootbuf:=r^.left;
        r^.left:=nil;
        //my_delete(r^.left);
        my_delete(rootbuf);
        rootbuf:=nil;
        rootbuf:=r^.right;
        r^.right:=nil;
        //my_delete(r^.right);
        my_delete(rootbuf);
        rootbuf:=nil;
        Dispose(r);
    end;
end;  // my_delete

// преобразует параметризованую строку содержащую переменные в вещественное число.
function TForm1.my_real_convert(s : String; var bOk : Boolean) : Float;
var
   s1 : String;  // рабочая строка
   Root : pTop; // корень дерева выражения
   key : Boolean; // признак существования выражения в заданной точке
   r1 : Float; // возвращаемое значение

begin
    // подстановка - замена всех переменных их значениями:
    my_substitutional_of_value(s ,s1);
    // Если переменные остались, то их необходимо добавить в список пользовательских переменных.
    // построение дерева.
    new(Root); // выделение оперативной памяти
    Constr_Tree(Root, s1); // построение дерева выражения
    key:=true;
    r1:=my_count(Root, key);
    my_delete(Root); // освобождение оперативной памяти
    bOk:=key; // передаваемый наверх признак успешности операции.
    if not key then
    begin
       r1:=0.0;
       MainMemo.Lines.Add('Error! expression :');
       MainMemo.Lines.Add(s);
       MainMemo.Lines.Add('can not be calculated... ');
       Application.MessageBox(PChar('expression '+s+' can not be calculated...'),'Error!',MB_OK);
       Application.MessageBox(PChar('work expression '+s1+' can not be interpretated...'),'Error!',MB_OK);
    end;
    my_real_convert:=r1;
end;


// Пример использования :
(*
// цикл по всем блокам в расчётной области.
      bOk:=true; // признак правильности ввода

      // координаты блока

      if bOk then r1:=FormVariables.my_real_convert(Laplas.body[i].sxS,bOk);
*)


// Чтобы для грани можно было использовать схему высокого порядка,
// требуется чтобы все четыре узла были внутренними.
// Здесь проверяется это условие.
function TForm1.is_internal_HO(
  ipi1 : Integer;
  ipi2 : Integer;
  ipi3 : Integer;
  ipi4 : Integer) : Boolean;
begin
   if ((ipi1>=1)and(ipi1<=inx*iny)
   and(ipi2>=1)and(ipi2<=inx*iny)
   and(ipi3>=1)and(ipi3<=inx*iny)
   and(ipi4>=1)and(ipi4<=inx*iny)) then
   begin
      if ((mapPT[ipi1].itype=1)and
      (mapPT[ipi2].itype=1)and
      (mapPT[ipi3].itype=1)and
      (mapPT[ipi4].itype=1)) then
      begin
         Result:=True;
      end
      else
      begin
         Result:=False;
      end;
   end
    else
   begin
      Result:=False;
   end;
end;

// Чтобы для грани можно было использовать схему высокого порядка,
// требуется чтобы все четыре узла были внутренними.
// Здесь проверяется это условие для горизонтальной скорости Vx.
function TForm1.is_internal_HO_Vx(
  ipi1 : Integer;
  ipi2 : Integer;
  ipi3 : Integer;
  ipi4 : Integer) : Boolean;
begin
   if ((ipi1>=1)and(ipi1<=(inx-1)*iny)
   and(ipi2>=1)and(ipi2<=(inx-1)*iny)
   and(ipi3>=1)and(ipi3<=(inx-1)*iny)
   and(ipi4>=1)and(ipi4<=(inx-1)*iny)) then
   begin
      if ((mapVx[ipi1].itype=1)and
      (mapVx[ipi2].itype=1)and
      (mapVx[ipi3].itype=1)and
      (mapVx[ipi4].itype=1)) then
      begin
         Result:=True;
      end
      else
      begin
         Result:=False;
      end;
   end
    else
   begin
      Result:=False;
   end;
end;

// Чтобы для грани можно было использовать схему высокого порядка,
// требуется чтобы все четыре узла были внутренними.
// Здесь проверяется это условие.
function TForm1.is_internal_HO_Vy(
  ipi1 : Integer;
  ipi2 : Integer;
  ipi3 : Integer;
  ipi4 : Integer) : Boolean;
begin
   if ((ipi1>=1)and(ipi1<=inx*(iny-1))
   and(ipi2>=1)and(ipi2<=inx*(iny-1))
   and(ipi3>=1)and(ipi3<=inx*(iny-1))
   and(ipi4>=1)and(ipi4<=inx*(iny-1))) then
   begin
      if ((mapVy[ipi1].itype=1)and
      (mapVy[ipi2].itype=1)and
      (mapVy[ipi3].itype=1)and
      (mapVy[ipi4].itype=1)) then
      begin
         Result:=True;
      end
      else
      begin
         Result:=False;
      end;
   end
    else
   begin
      Result:=False;
   end;
end;

// Функция реализующая антидиффузионную корекцию из диссертации Н.Г. Бураго.
procedure TForm1.anti_diffusionVOF;
var
   i,j : Integer;
begin
   // Функции VOF и VOFOldTimeStep принимают значения от нуля до единицы.
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         VOF[i+(j-1)*inx]:=min(1.0,Max(0.0,VOF[i+(j-1)*inx])); // все значения должны быть от нуля до единицы.


         if ((VOF[i+(j-1)*inx]>=0.5) and (VOF[i+(j-1)*inx]>VOFOldTimeStep[i+(j-1)*inx])) then
         begin
             // По видимому это ошибка в диссертации Н.Г.Бураго на странице 110.
             //VOF[i+(j-1)*inx]:=0.25*(1.0-VOF[i+(j-1)*inx]*VOF[i+(j-1)*inx])
             // По видимому правильная формула имеет вид:
             VOF[i+(j-1)*inx]:=1.0-0.25*(1.0-VOF[i+(j-1)*inx])*(1.0-VOF[i+(j-1)*inx]);

         end
          else  if ((VOF[i+(j-1)*inx]>=0.5) and (VOF[i+(j-1)*inx]<=VOFOldTimeStep[i+(j-1)*inx])) then
         begin
            VOF[i+(j-1)*inx]:=VOF[i+(j-1)*inx];
         end
          else if ((VOF[i+(j-1)*inx]<=0.5)and(VOF[i+(j-1)*inx]<VOFOldTimeStep[i+(j-1)*inx])) then
         begin
            VOF[i+(j-1)*inx]:=0.25*VOF[i+(j-1)*inx]*VOF[i+(j-1)*inx];
         end
          else if ((VOF[i+(j-1)*inx]<=0.5) and (VOF[i+(j-1)*inx]>=VOFOldTimeStep[i+(j-1)*inx])) then
         begin
            VOF[i+(j-1)*inx]:=VOF[i+(j-1)*inx];
         end;

         // Чтобы величина не вышла за границы [0..1]
         VOF[i+(j-1)*inx]:=min(1.0,Max(0.0,VOF[i+(j-1)*inx]));
      end;
   end;
end;

// поддержка консервативности VOF.
// по мотивам диссертации Н.Г.Бураго.
// Так как консервативность ниоткуда не следует, особенно при включённой антидиффузионной
// коррекции, то её следует поддерживать искусственно.
procedure TForm1.conservationVOF;
var
   k : Integer;
   Vol : Float;
   Integral : Float;
begin
   // Функции VOF и VOFOldTimeStep принимают значения от нуля до единицы.
   Vol:=0.0;
   Integral:=0.0;
   for k:=1 to imaxnumbernode do
   begin
      // Вычисляем объём расчётной областии, а также интеграл от приращения функции цвета.
      Vol:=Vol+mapPT[k].dV;
      Integral:=Integral+(VOF[mapPT[k].i+(mapPT[k].j-1)*inx]-VOFOldTimeStep[mapPT[k].i+(mapPT[k].j-1)*inx])*mapPT[k].dV;
   end;

    for k:=1 to imaxnumbernode do
   begin
      // Собственно коррекция обеспечивающая сохранение количества функции цвета.
      // Мы сохраняем интеграл от приращения функции цвета равным нулю, т.к. у нас нет
      // источников и стоков а также свбодных открытых границ с которых втекает и вытекает функция цвета.
      VOF[mapPT[k].i+(mapPT[k].j-1)*inx]:=VOFOldTimeStep[mapPT[k].i+(mapPT[k].j-1)*inx]+((VOF[mapPT[k].i+(mapPT[k].j-1)*inx]-VOFOldTimeStep[mapPT[k].i+(mapPT[k].j-1)*inx])-Integral/Vol);
   end;
end;

// используется для уравнения теплопроводности
// передаёт параметры из формы в программу,
// задаёт постоянные параметры материалов,
// задаёт постоянные источникового члена,
// выделяет память под массивы использующиеся
// при решениии уравнения теплопроводности.
procedure TForm1.initparam;
begin
   // выделение памяти под динамические массивы
   SetLength(lambda, mzapas*inx*iny+1); // теплопроводность dlambda(x,y);
   initlambda; // инициализирует теплопроводность
   SetLength(T, mzapas*inx*iny+1); // поле температур.
   if (actiVibr.bOn) then
   begin
      SetLength(meanT1T,mzapas*inx*iny+1);
      SetLength(meanTGl,mzapas*inx*iny+1);
      SetLength(meanT,mzapas*inx*iny+1);
   end;
   initTemp; // инициализирует поле темпеатур
   initBoundaryConditionTempreture; // задаёт граничные условия
   if (actiVibr.bOn) then
   begin
      initmeanTemp('T'); // на одном периоде
      initmeanTemp('G'); // глобальное среднее
      initmeanTemp('M'); // мат ожидание
   end;
   // выделяем память для хранения поля температур с предыдущей итерации
   SetLength(TOldIteration, mzapas*inx*iny+1); // поле температур с предыдущей итерации
   // запоминаем поле температур с предыдущей итерации
   RememberTOldTimeStep(false);
   // выделяем память для хранения поля температур с прошлого временного слоя
   // только в случае нестационарного солвера
   if (btimedepend) then
   begin
      SetLength(ToldTimeStep, mzapas*inx*iny+1);
      if (bsecondordertemp) then
      begin
         SetLength(ToldoldTimeStep, mzapas*inx*iny+1);
         RememberTOldTimeStep(true); // для правильной инициализации Toldoldtimestep нужно вызывать повторно!!!
      end;
      RememberTOldTimeStep(true);
   end;
   // источниковый член
   SetLength(dSc, mzapas*inx*iny+1); // постоянная составляющая источникового члена
   initdSc; // инициализация постоянной составляющей источникового члена
   dSp:=defmysource.Temperature.dSp; // линейная составляющая источникового члена
   // параметры материалов
   // хранятся в структуре MaterialProperties
   drho:=matprop[0].drho; // постоянная плотность
   dcp:=matprop[0].dcp; // постоянная теплоёмкость
   dbeta:=matprop[0].beta; // коэффициент линейного температурного расширения
   SetLength(VOF,mzapas*inx*iny+1);
   initVOF;
end; // initparam

// Используется для решения уравнений Навье-Стокса
// задаёт парамеры материалов,
// выделяет память под массивы для компонент скорости:
// с учётом текущей сетки для расчитываемой скорости,
// для скорости с прошлой итерации, для скорости с прошлого шага по времени,
// давления, поправки давления. Заполняет эти массивы значениями по умолчанию.
// Инициализирует значения источниковых членов для уравнений импульса.
procedure TForm1.initparam2;
begin
   // выделение памяти под динамические массивы
   // Для давления надо ставить условия II рода (Условия Неймана).
   SetLength(P,mzapas*inx*iny+1); // давление
   // для поправки давления
   SetLength(Pamendment,mzapas*inx*iny+1); // поправка давления на основной сетке
   // Полное давление с учётом гидростатического:
   SetLength(Pressureabsolute,mzapas*inx*iny+1);
   SetLength(Vx,mzapas*(inx-1)*iny+1); // Vx на смещённой по оси x сетке
   SetLength(Vy,mzapas*inx*(iny-1)+1); // Vy на смещённой по оси y сетке
   SetLength(VxOld,mzapas*(inx-1)*iny+1); // Vx с прошлой итерации
   SetLength(VyOld,mzapas*inx*(iny-1)+1); // Vy с прошлой итерации
   if (bsecondorderflow) then
   begin
      SetLength(VxOldOldTimeStep,mzapas*(inx-1)*iny+1); // Vx с двойного прошлого временного шага
      SetLength(VyOldOldTimeStep,mzapas*inx*(iny-1)+1); // Vy с двойного прошлого временого шага
   end;
   SetLength(VxActing,mzapas*(inx-1)*iny+1); // Vx на основе которой собираются матрицы
   SetLength(VyActing,mzapas*inx*(iny-1)+1); // Vy на основе которой собираются матрицы.
   SetLength(VxOldTimeStep,mzapas*(inx-1)*iny+1); // Vx с прошлого временного слоя
   SetLength(VyOldTimeStep,mzapas*inx*(iny-1)+1); // Vy с прошлого временного слоя
   SetLength(SF,mzapas*inx*iny+1); // функция тока
   SetLength(Omega,mzapas*inx*iny+1); // вихрь
   if (actiVibr.bOn) then
   begin
      //средние характеристики для сбора статистики
      SetLength(meanSF1T,mzapas*inx*iny+1); // средняя функция тока на одном периоде
      // средняя функция тока в глобальном смысле на нескольких периодах
      SetLength(meanSFGl,mzapas*inx*iny+1);
      // истинное математическое ожидание функции тока
      SetLength(meanSF,mzapas*inx*iny+1); // выделение оперативной памяти
      // вихрь
      SetLength(meanOmega1T,mzapas*inx*iny+1);
      SetLength(meanOmegaGl,mzapas*inx*iny+1);
      SetLength(meanOmega,mzapas*inx*iny+1);
      // горизонтальная скорость
      SetLength(meanVx1T,mzapas*(inx-1)*iny+1);
      SetLength(meanVxGl,mzapas*(inx-1)*iny+1);
      SetLength(meanVx,mzapas*(inx-1)*iny+1);
      // вертикальная скорость
      SetLength(meanVy1T,mzapas*inx*(iny-1)+1);
      SetLength(meanVyGl,mzapas*inx*(iny-1)+1);
      SetLength(meanVy,mzapas*inx*(iny-1)+1);
   end;
   // параметры материалов
   SetLength(dmu,mzapas*inx*iny+1); // динамическая вязкость dmu(x,y)
   // здесь надо не забыть задать плотность
   drho:=matprop[0].drho; // постоянная плотность
   // задаём динамическую вязкость
   initmu; // инициализация динамической вязкости mu(x,y);
   // инициализация поля скорости
   initXvel; // инициализация горизонтальной скорости
   initYvel; // инициализация вертикальной скорости
   initPressure; // задание начального поля давления
   initPamendmentZero; // инициализация поправки давления нулём.
   // задание граничных условий для скорости
   // это нужно делать именно после инициализациии скоростей внутри расчётной области.
   initBoundaryConditionVx; // граничные условия для горизонтальной скорости
   initBoundaryConditionVy; // граничные условия для вертикальной скорости
   initBoundaryConditionPressure; // граничные условия для давления
   // запоминаем начальное поле скорости
   // инициализируя тем самым вспомогательные массивы VxOld, VyOld
   // Они инициализируются уже с учётом граничных условий.
   RememberXvel(VxOld); // запоминаем горизонтальную компоненту скорости
   RememberYvel(VyOld); // запоминаем вертикальную компоненту скорости
   RememberXvel(VxOldTimeStep); // запоминаем горизонтальную компоненту скорости
   RememberYvel(VyOldTimeStep); // запоминаем вертикальную компоненту скорости
   if (bsecondorderflow) then
   begin
       RememberXvel(VxOldOldTimeStep); // запоминаем горизонтальную компоненту скорости
       RememberYvel(VyOldOldTimeStep); // запоминаем вертикальную компоненту скорости
   end;
   RememberXvel(VxActing); // запоминаем горизонтальную компоненту скорости
   RememberYvel(VyActing); // запоминаем вертикальную компоненту скорости
   // инициализация источниковых членов для Vx
   dScVx:=defmysource.Vxvelocity.dSc; // постоянная составляющая источникового члена для горизонтальной компоненты скорости
   dSpVx:=defmysource.Vxvelocity.dSp; // линеаризованная составляющая источникового члена для Vx
   // инициализация источниковых членов для Vy
   dScVy:=defmysource.Vyvelocity.dSc; // постоянная составляющая источникового члена для Vy
   dSpVy:=defmysource.Vyvelocity.dSp; // линеаризованная составляющая источникового члена для Vy
   // Здесь краевые условия для функции тока нулевые.
   // Это верно для ряда задач: течения в изотермической каверне,
   // т.к. стенки непроницаемы для жидкости и ряда других задач
   // например задач  с естественной конвекцией в прямоугольной области стенки которой
   // непроницаемы для жидкости.
   initStreamFunction; // инициализация функции тока нулём включая граничные точки
   initBoundaryConditionStreamFunction; // задание граничных условий
   if (actiVibr.bOn) then
   begin
      // функция тока
      initmeanSF('T'); // на одном периоде
      initmeanSF('G'); // глобальное среднее
      initmeanSF('M'); // мат ожидание
      // вихрь
      initmeanOmega('T'); // на одном периоде
      initmeanOmega('G'); // глобальное среднее
      initmeanOmega('M'); // мат ожидание
      // горизонтальная скорость
      initmeanXvel('T'); // на одном периоде
      initmeanXvel('G'); // глобальное среднее
      initmeanXvel('M'); // мат ожидание
      // вертикальная скорость
      initmeanYvel('T'); // на одном периоде
      initmeanYvel('G'); // глобальное среднее
      initmeanYvel('M'); // мат ожидание
   end;
   SetLength(VOF,mzapas*inx*iny+1);
   SetLength(VOFOldTimeStep,mzapas*inx*iny+1);
   if (bVOFsecondorder) then
   begin
      SetLength(VOFOldOldTimeStep,mzapas*inx*iny+1);
   end;
   if (bCSF) then
   begin
      SetLength(CSFx,mzapas*(inx-1)*iny+1);
      SetLength(CSFy,mzapas*inx*(iny-1)+1);
   end;
   initVOF; // функция цвета
   RememberVOF; // занесение информации в функцию цвета с предыдущего шага по времени.
   SetLength(DensityOldTimeStep,mzapas*inx*iny+1); // плотность на предыдущем временном шаге
   rememberDensity; // запоминание плотности с предыдущего временного слоя
   // здесь плотность не инициализируется, т.к. сначала надо
   // соответствующим образом инициализировать VOF функцию цвета: Solve->Initialize->Patch.
   // инициализация происходит внутри алгоритма SIMPLE.
end; // initparam2

// запоминает текущую плотность в массив
// DensityOldTimeStep
procedure TForm1.rememberDensity;
var
    i,j : Integer; // счётчики
    ipi : Integer; // текущая точка
begin
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*inx;
         DensityOldTimeStep[ipi]:=density(ipi);
      end;
   end;
end; // rememberDensity

// инициализация материалов
// инициализация теплопроводности
procedure TForm1.initlambda;
var
   i1 : Integer; // Счётчик
begin
   for i1:=1 to imaxnumbernode do
   begin
     with mapPT[i1] do
     begin
        if (itype<>0) then
        begin
           // точка расчётной области
           // либо внутренняя либо граничная

           // постоянная теплопроводность
           lambda[i+(j-1)*inx]:=matprop[0].dlambda;
        end;
     end;
   end;
end; // initlambda

// инициализация коэффициента динамической вязкости
procedure TForm1.initmu;
var
   i1 : Integer; // Счётчик
begin

   for i1:=1 to imaxnumbernode do
   begin
      with (mapPT[i1]) do
      begin
         if (itype<>0) then
         begin
            // точка расчётной области
            // либо внутренняя либо граничная

            // инициализация динамической вязкости
            dmu[i+(j-1)*inx]:=matprop[0].dmu;
         end;
      end;
    end;
end; // initmu

// инициализация поля температур
procedure TForm1.initTemp;
var
   i : Integer; // счётчики
begin

   for i:=1 to imaxnumbernode do
   begin
      with mapPT[i] do
      begin
         if (itype<>0) then
         begin
            // только внутренние узлы и граничные узлы
            // постоянная темпеатура
            // В структуре InitVal содержится необходимое начальное значение
            T[i+(j-1)*inx]:=InitVal.TempInit;
         end;
     end; // with
   end;
end; // initTemp

// инициализация осреднённого поля температур
procedure TForm1.initmeanTemp(str : String);
var
   i : Integer; // счётчик

begin
   for i:=1 to imaxnumbernode do
   begin
      with mapPT[i] do
      begin
         if (itype<>0) then
         begin
            // только внутренние узлы и граничные узлы
            // постоянная темпеатура
            //  значение равное нулю.
            case str[1] of
             'T' : meanT1T[i+(j-1)*inx]:=0.0;  // среднее за период
             'G' : meanTGl[i+(j-1)*inx]:=0.0;  // глобальное среднее
             'M' : meanT[i+(j-1)*inx]:=0.0;   // математическое ожидание
            end;
         end;
     end; // with
   end;
end; // initmeanTemp

// инициализация распределения давления
procedure TForm1.initPressure;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // постоянное давление равное 0
            P[i+(j-1)*inx]:=0.0;
            // инициализация абсолютного давления.
            Pressureabsolute[i+(j-1)*inx]:=0.0;
         end;
      end;
   end;
end; // initPressure

// инициализация функции цвета
procedure TForm1.initVOF;
var
   k,k1 : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            if (bVOFsecondorder) then
            begin
               // аппроксимация второго порядка по времени.
               // формула Пейре.
               VOFOldTimeStep[i+(j-1)*inx]:=InitVal.VofInit;
            end;
            VOF[i+(j-1)*inx]:=InitVal.VofInit;
         end;
     end;
   end;
   if (bCSF) then
   begin
      for k:=1 to inx-1 do
      begin
         for k1:=1 to iny do
         begin
            CSFx[k+(k1-1)*(inx-1)]:=0.0;
         end;
      end;
      for k:=1 to inx do
      begin
         for k1:=1 to iny-1 do
         begin
            CSFy[k+(k1-1)*inx]:=0.0;
         end;
      end;
   end;
end; // initVOF

// инициализация функции тока
procedure TForm1.initStreamFunction;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            SF[i+(j-1)*inx]:=0.0;
         end;
     end;
   end;
end; // initStreamFunction

// инициализация функции тока
procedure TForm1.initmeanSF(str : String);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            case str[1] of
              'T' : meanSF1T[i+(j-1)*inx]:=0.0;
              'G' : meanSFGl[i+(j-1)*inx]:=0.0;
              'M' : meanSF[i+(j-1)*inx]:=0.0; // мат ожидание
            end; // case
         end;
     end; // with
   end;
end; // initmeanSF

// инициализация осреднённого вихря
procedure TForm1.initmeanOmega(str : String);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            case str[1] of
              'T' : meanOmega1T[i+(j-1)*inx]:=0.0;
              'G' : meanOmegaGl[i+(j-1)*inx]:=0.0;
              'M' : meanOmega[i+(j-1)*inx]:=0.0; // мат ожидание
            end; // case
         end;
     end; // with
   end;
end; // initmeanOmega

// вычисление осреднённой на периоде функции тока
procedure TForm1.RememberStreamFunction;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanSF1T[i+(j-1)*inx]:=meanSF1T[i+(j-1)*inx] + SF[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberStreamFunction

// вычисление осреднённого вихря
procedure TForm1.RememberOmega1T;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanOmega1T[i+(j-1)*inx]:=meanOmega1T[i+(j-1)*inx] + Omega[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberOmega1T

// вычисление осреднённой на периоде горизонтальной скорости
procedure TForm1.RememberXVelDM;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVx1T[i+(j-1)*(inx-1)]:=meanVx1T[i+(j-1)*(inx-1)] + Vx[i+(j-1)*(inx-1)];
         end;
     end;
   end;
end; // RememberXVelDM

// вычисление осреднённой на периоде вертикальной скорости
procedure TForm1.RememberYVelDM;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVy do
   begin
      with mapVy[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVy1T[i+(j-1)*inx]:=meanVy1T[i+(j-1)*inx] + Vy[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberYVelDM


// вычисление осреднённой на периоде температуры
procedure TForm1.RememberTempDM;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanT1T[i+(j-1)*inx]:=meanT1T[i+(j-1)*inx] + T[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberTempDM

// запоминание функции цвета с предыдущей итерации.
procedure TForm1.RememberVOF;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            if (bVOFsecondorder) then
            begin
               VOFOldOldTimeStep[i+(j-1)*inx]:=VOFOldTimeStep[i+(j-1)*inx];
            end;
            VOFOldTimeStep[i+(j-1)*inx]:=VOF[i+(j-1)*inx];
         end;
     end;
   end;
end; // RememberVOF


// вычисление осреднённой на периоде функции тока
procedure TForm1.CalculateMeanStreamFunction;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanSFGl[i+(j-1)*inx]:=meanSFGl[i+(j-1)*inx] + meanSF1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanStreamFunction

// вычисление осреднённого на периоде вихря
procedure TForm1.CalculateMeanOmega1T;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanOmegaGl[i+(j-1)*inx]:=meanOmegaGl[i+(j-1)*inx] + meanOmega1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanOmega1T;


// вычисление осреднённой на периоде
// горизонтальной компоненты скорости
procedure TForm1.CalculateMeanXVel;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVxGl[i+(j-1)*(inx-1)]:=meanVxGl[i+(j-1)*(inx-1)] + meanVx1T[i+(j-1)*(inx-1)]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanXVel;

// вычисление осреднённой на периоде
// вертикальной компоненты скорости
procedure TForm1.CalculateMeanYVel;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVy do
   begin
      with mapVy[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVyGl[i+(j-1)*inx]:= meanVyGl[i+(j-1)*inx] + meanVy1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanYVel;

// вычисление осреднённой на периоде температуры
procedure TForm1.CalculateMeanTempreture;
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanTGl[i+(j-1)*inx]:=meanTGl[i+(j-1)*inx] + meanT1T[i+(j-1)*inx]/inumbertimestepdivisionPeriod;
         end;
     end;
   end;
end; // CalculateMeanTempreture

// вычисление мат ожидания функции тока
procedure TForm1.CalculateMeanSF(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanSF[i+(j-1)*inx]:=meanSFGl[i+(j-1)*inx]/(1.0*inum);
         end;
     end;
   end;
end; // CalculateMeanSF

// вычисление мат ожидания от вихря
procedure TForm1.CalculateMeanOmega(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanOmega[i+(j-1)*inx]:=meanOmegaGl[i+(j-1)*inx]/(1.0*inum);
         end;
     end;
   end;
end; // CalculateMeanOmega

// вычисление математического ожидания от температуры
procedure TForm1.CalculateMeanT(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanT[i+(j-1)*inx]:=meanTGl[i+(j-1)*inx]/(1.0*inum);
         end;
     end;
   end;
end; // CalculateMeanT

// вычисление мат ожидания горизонтальной скорости
procedure TForm1.CalculateMeanVx(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVx[i+(j-1)*(inx-1)]:=meanVxGl[i+(j-1)*(inx-1)]/(1.0*inum);
         end;
     end;
   end;
end; // CalculateMeanVx


// вычисление математического ожидания от вертикальной скорости
procedure TForm1.CalculateMeanVy(inum : Integer);
var
   k : Integer; // счётчик
begin
   for k:=1 to imaxnumbernodeVy do
   begin
      with mapVy[k] do
      begin
         if (itype<>0) then
         begin
            // только для узлов принадлежащих расчётной области

            // изначально функция тока всюду
            // равна нулю, включая границы
            meanVy[i+(j-1)*inx]:=meanVyGl[i+(j-1)*inx]/(1.0*inum);
         end;
     end;
   end;
end; // CalculateMeanVy

// инициализация распределения поправки давления
// О важности начального распеределения поправки давления
// в данном случае:
// Любой итерационный метод решения алгебраических
// уравнений даёт сходимость решения, абсолютное значение
// которого определяется начальным приближением.
procedure TForm1.initPamendmentZero;
var
   i : Integer; // счётчики
begin
   for i:=1 to imaxnumbernode do
   begin
      if (mapPT[i].itype<>0) then
      begin
        // только для узлов принадлежащих расчётной области

        // инициализация распределения поправки давления нулём !
        Pamendment[mapPT[i].i+(mapPT[i].j-1)*inx]:=0.0;
     end; // j
   end; // i
end; // initPamendmentZero

// инициализация постоянной составляющей источникового члена
// для уравнения теплопроводности
// хорошо бы переименовать метод в что-то типа
// initTempdSc
procedure TForm1.initdSc;
var
   i : Integer; // счётчики циклов
begin
   // инициализация постоянной составляющей
   // источникового члена
   // для уравнения теплопрооводности
   for i:=1 to imaxnumbernode do
   begin
      if (mapPT[i].itype<>0) then
      begin
        // только внутренние узлы и граничные узлы

        // постоянная составляющая источникового члена
        dSc[mapPT[i].i+(mapPT[i].j-1)*inx]:=defmysource.Temperature.dSc;
     end; // j
   end; // i
end; // initdSc

// инициализация горизонтальной
// компоненты скорости
procedure TForm1.initXvel;
var
   i : Integer; // счётчик при обходе по карте

begin
   // инициализация горизонтальной
   // компоненты скорости

   for i:=1 to imaxnumbernodeVx do
   begin
      with mapVx[i] do
      begin
         if (itype<>0) then
         begin
            // если узел внутренний
            // горизонтальная компонента скорости
            // В структуре InitVal содержится необходимое начальное значение
            Vx[i+(j-1)*(inx-1)]:=InitVal.XvelInit;
         end;
      end; // with
   end;
end; // initXvel

// инициализация осредненнной горизонтальной
// компоненты скорости
procedure TForm1.initmeanXvel(str : String);
var
   i : Integer; // счётчик при обходе по карте

begin
   // инициализация горизонтальной
   // компоненты скорости

   for i:=1 to imaxnumbernodeVx do
   begin
      with mapVx[i] do
      begin
         if (itype<>0) then
         begin
            // если узел внутренний
            // горизонтальная компонента скорости
            // присваивается значение 0.0
            ipi:=i+(j-1)*(inx-1);

            case str[1] of
              'T' :  meanVx1T[ipi]:=0.0; // на одном периоде
              'G' :  meanVxGl[ipi]:=0.0; // глобальная
              'M' :  meanVx[ipi]:=0.0; // просто мат ожидание
            end;

         end;
      end; // with
   end;
end; // initmeanXvel1T


// запоминание поля температуры
// для того чтобы использовать эти значения
// на следующем временном слое
// В случае если передаваемый параметр bcopyoldtimetempreture принимает значение true.
// Если этот параметр принимает значение false то копируется поле температур с предыдущей итерации.
// Это нужно для сильно нелинейных задач для применения нижней релаксации.
procedure TForm1.RememberTOldTimeStep(bcopyoldtimetempreture : Boolean);
var
   i,ipi : Integer; // счётчики циклов
begin
   // запоминание поля температур
   // для использования на следующем временном слое
   for i:=1 to imaxnumbernode do
   begin
      if (mapPT[i].itype<>0) then
      begin
         // если точка принадлежит расчётной области
         // предварительное вычисление данного индекса ускоряет вычисление,
         // особенно для схемы Пейре.
         ipi:=mapPT[i].i+(mapPT[i].j-1)*inx;

         if (bcopyoldtimetempreture) then
         begin
            if (bsecondordertemp) then
            begin
               // Для схемы Пейре !!!
               ToldoldTimeStep[ipi]:=ToldTimeStep[ipi];
            end;
            // копирование температуры с предыдущего временного слоя
            ToldTimeStep[ipi]:=T[ipi];
         end
          else
         begin
            // копирование поля температур с предыдущей итерации
            TOldIteration[ipi]:=T[ipi];
         end;
      end;
   end;
end; // RememberTOldTimeStep


// запоминание горизонтальной компоненты скорости
// удовлетворяющей уравнению неразрывности
procedure TForm1.RememberXvel(var U : array of Float);
var
   i,j,ipi : Integer; // счётчики циклов
begin
   // запоминание горизонтальной
   // компоненты скорости
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);
         U[ipi]:=Vx[ipi];
      end; // j
   end; // i
end; // RememberXvel

// организация запоминания для аппроксимации по времени вторго порядка Пейре.
procedure TForm1.RememberXvelSO();
var
   i,j,ipi : Integer; // счётчики циклов
begin
   // запоминание горизонтальной
   // компоненты скорости
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);
         VxOldOldTimeStep[ipi]:=VxOldTimeStep[ipi];
      end; // j
   end; // i
end; // RememberXvelSO

// копирование в VxActing заданной полевой величины U.
procedure TForm1.CopyToVxActing(var U : array of Float);
var
   i,j,ipi : Integer; // счётчики циклов
begin
   // запоминание горизонтальной
   // компоненты скорости
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         ipi:=i+(j-1)*(inx-1);
         VxActing[ipi]:=U[ipi];
      end; // j
   end; // i
end; // CopyToVxActing

// инициализация вертикальной
// компоненты скорости
procedure TForm1.initYvel;
var
    i : Integer; // счётчик при обходе по карте
begin

   // инициализация вертикальной
   // компоненты скорости
   // При этом граничные значения тоже учитываются.

   for i:=1 to imaxnumbernodeVy do
   begin
      with mapVy[i] do
      begin
         if (itype<>0) then
         begin
            // если внутренний узел

            // инициализация:
            // вертикальная компонента скорости
            // В структуре InitVal содержится необходимое начальное значение
            Vy[i+(j-1)*inx]:=InitVal.YvelInit;
         end;
      end; // with
   end;
end; // initYvel

// инициализация осреднённой вертикальной
// компоненты скорости
procedure TForm1.initmeanYvel(str : String);
var
    i : Integer; // счётчик при обходе по карте
begin

   // инициализация вертикальной
   // компоненты скорости
   // При этом граничные значения тоже учитываются.

   for i:=1 to imaxnumbernodeVy do
   begin
      with mapVy[i] do
      begin
         if (itype<>0) then
         begin
            // если внутренний узел

            // инициализация:
            // вертикальная компонента скорости
            // нулевыми значениями
            ipi:=i+(j-1)*inx;

            case str[1] of
              'T' : meanVy1T[ipi]:=0.0;
              'G' : meanVyGl[ipi]:=0.0;
              'M' : meanVy[ipi]:=0.0;
            end; // case
         end;
      end; // with
   end;
end; // initmeanYvel

// запоминание вертикальной
// компоненты скорости
// удовлетворяющей уравнению неразрывности
procedure TForm1.RememberYvel(var U : array of Float);
var
    i,j,ipi : Integer; // счётчик циклов
begin
   // запоминание вертикальной
   // компоненты скорости
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;
         U[ipi]:=Vy[ipi];
      end; // j
   end; // i
end; // RememberYvel

// запоминание для схемы Пейре.
procedure TForm1.RememberYvelSO();
var
    i,j,ipi : Integer; // счётчик циклов
begin
   // запоминание вертикальной
   // компоненты скорости
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;
         VyOldOldTimeStep[ipi]:=VyOldTimeStep[ipi];
      end; // j
   end; // i
end; // RememberYvelSO

// копирование в VyActing полевой величины V.
procedure TForm1.CopyToVyActing(var V : array of Float);
var
    i,j,ipi : Integer; // счётчик циклов
begin
   // запоминание вертикальной
   // компоненты скорости
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         ipi:=i+(j-1)*inx;
         VyActing[ipi]:=V[ipi];
      end; // j
   end; // i
end; // CopyToVyActing

// задание граничных условий
// первого рода
// для поля температур
procedure TForm1.initBoundaryConditionTempreture;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный номер границы

begin
    // проход по всем узлам
    for i:=1 to imaxnumbernode do
    begin
       // если узел является граничным
       if (mapPT[i].itype = 2) then
       begin
          // уникальный номер границы
          iunicalnumber:=mapPT[i].iboundary;
          // поиск границы с уникальным номером.
          for j:=1 to GridGenForm.inumboundary do
          begin
             if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
             begin
                T[mapPT[i].i + (mapPT[i].j-1)*inx]:=GridGenForm.edgelist[j].temperaturecondition;
             end;
          end;
       end;
    end;

end; // initBoundaryConditionTempreture

// задание граничных условий
// первого рода
// для поля User Defined Scalar`a.
procedure TForm1.initBoundaryConditionUDS;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный номер границы
  bOk : Boolean;
  //CaptionStr : string; //  тестирование калькулятора.
  bcont : Boolean; // продолжать ?
  ierrorpos : Integer;
  rbon : Float;

begin
    ivar:=15+ivar_trial;
    SetLength(parametric,ivar);
    parametric[0].svar:='$x';
    parametric[1].svar:='$y';
    parametric[2].svar:='$d'; // расстояние от граничного узла до ближайшего внутреннего
    parametric[3].svar:='$uds1w'; // значение UDS1 на стенке.
    parametric[4].svar:='$uds2w'; // значение UDS2 на стенке.
    parametric[5].svar:='$uds3w'; // значение UDS3 на стенке.
    parametric[6].svar:='$uds4w'; // значение UDS4 на стенке.
    parametric[7].svar:='$uds1i'; // значение UDS1 в ближайшем внутреннем узле.
    parametric[8].svar:='$uds2i'; // значение UDS2 в ближайшем внутреннем узле.
    parametric[9].svar:='$uds3i'; // значение UDS3 в ближайшем внутреннем узле.
    parametric[10].svar:='$uds4i'; // значение UDS4 в ближайшем внутреннем узле.
    parametric[11].svar:='$uds1ii'; // значение UDS1 во 2  ближайшем внутреннем узле.
    parametric[12].svar:='$uds2ii'; // значение UDS2 во 2  ближайшем внутреннем узле.
    parametric[13].svar:='$uds3ii'; // значение UDS3 во 2 ближайшем внутреннем узле.
    parametric[14].svar:='$uds4ii'; // значение UDS4 во 2 ближайшем внутреннем узле.
    // дополнительные переменные для многопараметрического моделирования.
    for i:=15 to 14+ivar_trial do
    begin
       parametric[i].svar:=base_value_trial[i-15].svar;
       parametric[i].sval:=base_value_trial[i-15].sval;
    end;


    // проход по всем узлам
    for i:=1 to imaxnumbernode do
    begin
       // если узел является граничным
       if (mapPT[i].itype = 2) then
       begin
          // уникальный номер границы
          iunicalnumber:=mapPT[i].iboundary;
          // поиск границы с уникальным номером.
          for j:=1 to GridGenForm.inumboundary do
          begin
             if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
             begin
                bcont:=False;
                case icurentUDS of
                  1 : begin
                         Val(GridGenForm.edgelist[j].uds1condition,rbon,ierrorpos);

                         if ( GridGenForm.edgelist[j].uds1clan=1) then
                         begin
                            if (ierrorpos<>0) then
                            begin
                               bcont:=true;
                            end
                            else
                            begin
                               UDS1[mapPT[i].i + (mapPT[i].j-1)*inx]:=rbon;
                            end;
                         end;
                      end;
                  2 : begin

                         Val(GridGenForm.edgelist[j].uds2condition,rbon,ierrorpos);
                         if ( GridGenForm.edgelist[j].uds2clan=1) then
                         begin
                            if (ierrorpos<>0) then
                            begin
                               bcont:=true;
                            end
                            else
                            begin
                               UDS2[mapPT[i].i + (mapPT[i].j-1)*inx]:=rbon;
                            end;
                         end;
                      end;
                  3 : begin
                         Val(GridGenForm.edgelist[j].uds3condition,rbon,ierrorpos);
                         if ( GridGenForm.edgelist[j].uds3clan=1) then
                         begin
                            if (ierrorpos<>0) then
                            begin
                               bcont:=true;
                            end
                            else
                            begin
                               UDS3[mapPT[i].i + (mapPT[i].j-1)*inx]:=rbon;
                            end;
                         end;
                      end;
                  4 : begin
                         Val(GridGenForm.edgelist[j].uds4condition,rbon,ierrorpos);
                         if ( GridGenForm.edgelist[j].uds4clan=1) then
                         begin
                            if (ierrorpos<>0) then
                            begin
                               bcont:=true;
                            end
                            else
                            begin
                               UDS4[mapPT[i].i + (mapPT[i].j-1)*inx]:=rbon;
                            end;
                         end;
                      end;
                end;

               if ( bcont) then
               begin


                  if (mapPT[i].iugol=0) then
                  begin


                           parametric[0].sval:=FloatToStr(xpos[mapPT[i].i]);
                           parametric[1].sval:=FloatToStr(ypos[mapPT[i].j]);

                           // внутренняя нормаль.

                           case mapPT[i].chnormal of
                              'N' : begin
                                       // нижняя стенка.
                                       case imaxUDS of
                                         1 : begin
                                                //parametric[2].sval:=FloatToStr(ypos[mapPT[i].j+1]-ypos[mapPT[i].j]); // расстояние между внутренним и граничным узлами.
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j+1]-ypos[mapPT[i].j]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:='0.0'; // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:='0.0'; // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:='0.0'; // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         2 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j+1]-ypos[mapPT[i].j]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         3 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j+1]-ypos[mapPT[i].j]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         4 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j+1]-ypos[mapPT[i].j]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1+1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1+1)*inx]);; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1+2)*inx]); // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                       end;



                                    end;
                               'S' : begin
                                       // верхняя стенка.
                                        case imaxUDS of
                                         1 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j]-ypos[mapPT[i].j-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:='0.0'; // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:='0.0'; // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:='0.0'; // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         2 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j]-ypos[mapPT[i].j-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         3 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j]-ypos[mapPT[i].j-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         4 : begin
                                                parametric[2].sval:=FloatToStr(ypos[mapPT[i].j]-ypos[mapPT[i].j-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1-1)*inx]); // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1-2)*inx]); // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                       end;

                                    end;
                               'E' : begin
                                       // левая стенка.
                                        case imaxUDS of
                                         1 : begin
                                                 parametric[2].sval:=FloatToStr(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]); // расстояние между внутренним и граничным узлами.
                                                 parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                 parametric[4].sval:='0.0'; // значение UDS2 на стенке.
                                                 parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                 parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                 parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                 parametric[8].sval:='0.0'; // значение UDS2 в ближайшем внутреннем узле.
                                                 parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                 parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                 parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                 parametric[12].sval:='0.0'; // значение UDS2 во 2  ближайшем внутреннем узле.
                                                 parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                 parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         2 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         3 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         4 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i+1]-xpos[mapPT[i].i]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:=FloatToStr(UDS4[mapPT[i].i+1+(mapPT[i].j-1)*inx]); // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:=FloatToStr(UDS4[mapPT[i].i+2+(mapPT[i].j-1)*inx]); // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                       end;

                                    end;
                                'W' : begin
                                       // правая стенка.
                                        case imaxUDS of
                                         1 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:='0.0'; // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:='0.0'; // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:='0.0'; // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         2 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:='0.0'; // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:='0.0'; // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:='0.0'; // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         3 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:='0.0'; // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:='0.0'; // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:='0.0'; // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                         4 : begin
                                                parametric[2].sval:=FloatToStr(xpos[mapPT[i].i]-xpos[mapPT[i].i-1]); // расстояние между внутренним и граничным узлами.
                                                parametric[3].sval:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS1 на стенке.
                                                parametric[4].sval:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS2 на стенке.
                                                parametric[5].sval:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS3 на стенке.
                                                parametric[6].sval:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1)*inx]); // значение UDS4 на стенке.
                                                parametric[7].sval:=FloatToStr(UDS1[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS1 в ближайшем внутреннем узле.
                                                parametric[8].sval:=FloatToStr(UDS2[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS2 в ближайшем внутреннем узле.
                                                parametric[9].sval:=FloatToStr(UDS3[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS3 в ближайшем внутреннем узле.
                                                parametric[10].sval:=FloatToStr(UDS4[mapPT[i].i-1+(mapPT[i].j-1)*inx]); // значение UDS4 в ближайшем внутреннем узле.
                                                parametric[11].sval:=FloatToStr(UDS1[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS1 во 2  ближайшем внутреннем узле.
                                                parametric[12].sval:=FloatToStr(UDS2[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS2 во 2  ближайшем внутреннем узле.
                                                parametric[13].sval:=FloatToStr(UDS3[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS3 во 2 ближайшем внутреннем узле.
                                                parametric[14].sval:=FloatToStr(UDS4[mapPT[i].i-2+(mapPT[i].j-1)*inx]); // значение UDS4 во 2 ближайшем внутреннем узле.
                                             end;
                                        end;

                                     end;

                           end;


                  case icurentUDS of
                    1 : begin

                            bOk:=True;
                            UDS1[mapPT[i].i + (mapPT[i].j-1)*inx]:=my_real_convert(Trim(GridGenForm.edgelist[j].uds1condition),bOk);

                      end;
                    2 : begin

                            bOk:=True;
                            UDS2[mapPT[i].i + (mapPT[i].j-1)*inx]:=my_real_convert(Trim(GridGenForm.edgelist[j].uds2condition),bOk);
                      end;
                    3 : begin

                            bOk:=True;
                            UDS3[mapPT[i].i + (mapPT[i].j-1)*inx]:=my_real_convert(Trim(GridGenForm.edgelist[j].uds3condition),bOk);

                      end;
                    4 : begin

                            bOk:=True;
                            UDS4[mapPT[i].i + (mapPT[i].j-1)*inx]:=my_real_convert(Trim(GridGenForm.edgelist[j].uds4condition),bOk);

                      end;
                  end;
                 end;
                end;
             end;
          end;
       end;
    end;

end; // initBoundaryConditionUDS

// задание граничных условий
// первого рода
// для функции тока
procedure TForm1.initBoundaryConditionStreamFunction;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный номер границы

begin
    // проход по всем узлам
    for i:=1 to imaxnumbernode do
    begin
       // если узел является граничным
       if (mapPT[i].itype = 2) then
       begin
          // уникальный номер границы
          iunicalnumber:=mapPT[i].iboundary;
          // поиск границы с уникальным номером.
          for j:=1 to GridGenForm.inumboundary do
          begin
             if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
             begin
                case GridGenForm.edgelist[j].chSFval of
                  'c' : // const
                      begin
                         SF[mapPT[i].i + (mapPT[i].j-1)*inx]:=GridGenForm.edgelist[j].rSFval;
                      end;
                  'x' : // значения абсциссы
                      begin
                         SF[mapPT[i].i + (mapPT[i].j-1)*inx]:=xpos[mapPT[i].i];
                      end;
                  'y' : // значение ординаты
                      begin
                         SF[mapPT[i].i + (mapPT[i].j-1)*inx]:=ypos[mapPT[i].j];
                      end;
                end;
             end;
          end;
       end;
    end;

end; // initBoundaryConditionStreamFunction


// задание граничных условий
// первого рода
// для горизонтальной компоненты скорости Vx
procedure TForm1.initBoundaryConditionVx;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный идентификатор границы к которой принадлежит граничная точка

begin

   for i:=1 to imaxnumbernodeVx do
   begin
      if (mapVx[i].itype = 2) then
      begin
         // граничный узел
         // условия первого рода
         // уникальный номер границы
         iunicalnumber:=mapVx[i].iboundary;
         // поиск границы с уникальным номером.
         for j:=1 to GridGenForm.inumboundary do
         begin
            if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
            begin
               Vx[mapVx[i].i + (mapVx[i].j-1)*(inx-1)]:=GridGenForm.edgelist[j].Vx;
            end;
         end;
      end;
   end;
end; // initBoundaryConditionVx


// задание граничных условий
// первого рода
// для вертикальной компоненты скорости Vy
procedure TForm1.initBoundaryConditionVy;
var
  i,j : Integer; // счётчики
  iunicalnumber : Integer; // уникальный идентификатор границы к которой принадлежит граничная точка

begin
   (*
   for j:=1 to GridGenForm.inumboundary do
         begin
           mainMemo.Lines.Add(IntToStr(GridGenForm.edgelist[j].idescriptor));
           end;
         *)

   for i:=1 to imaxnumbernodeVy do
   begin
      if (mapVy[i].itype = 2) then
      begin
        //Vy[mapVy[i].i + (mapVy[i].j-1)*inx]:=mapVy[i].iboundary;


         // граничный узел
         // условия первого рода
         // уникальный номер границы
         iunicalnumber:=mapVy[i].iboundary;
         // поиск границы с уникальным номером.
         for j:=1 to GridGenForm.inumboundary do
         begin
            if ( GridGenForm.edgelist[j].idescriptor = iunicalnumber) then
            begin
               Vy[mapVy[i].i + (mapVy[i].j-1)*inx]:=GridGenForm.edgelist[j].Vy;
            end;
         end;

      end;
   end;

end; // initBoundaryConditionVy

// задание граничных условий
// первого рода
// для Давления
procedure TForm1.initBoundaryConditionPressure;
var
  k,j1 : Integer; // счётчики
  iunicalnumber : Integer; // уникальный идентификатор границы к которой принадлежит граничная точка

begin

   for k:=1 to imaxnumbernode do
   begin
   with mapPT[k] do
   begin
      if (itype = 2) then
      begin
         // граничный узел
         // условия первого рода
         // уникальный номер границы
         iunicalnumber:=iboundary;
         // поиск границы с уникальным номером.
         for j1:=1 to GridGenForm.inumboundary do
         begin
            if ( GridGenForm.edgelist[j1].idescriptor = iunicalnumber) then
            begin
               if (GridGenForm.edgelist[j1].bpressure) then
               begin
                  // Давление в граничных точках не оказывает влияния.
                  P[i + (j-1)*inx]:=GridGenForm.edgelist[j1].rpressure;
                  case mapPT[i + (j-1)*inx].chnormal of
                  'N' : begin
                           // внутренняя нормаль
                           P[i + (j)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  'S' : begin
                           // внутренняя нормаль
                           P[i + (j-2)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  'W' : begin
                           // внутренняя нормаль
                           P[(i-1) + (j-1)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  'E' : begin
                           // внутренняя нормаль
                           P[(i+1) + (j-1)*inx]:=GridGenForm.edgelist[j1].rpressure;
                        end;
                  end; // case
               end;
            end;
         end;
      end;
      end;
   end;

end; // initBoundaryConditionPressure


// Делает одну иерацию методом Гаусса - Зейделя
// для универсальной искомой функции U.
procedure TForm1.GZUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         var map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         var db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         var QneiC : TQneiC);

// если передавать без var то происходит копирование массива и работа с этой копией.
// если передавать с var то копирования не происходит и работа происходит с оригиналом.

const
      epsilon = 1.0e-30;
      relaxfactorboncon = 0.01; // параметр релаксации для граничного условия на выходной границе
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблон
    iwwi, ieei, inni, issi : Integer; // для мягких граничных условий
    bnei, bsim, boutflow, bfirstpointmetall, bMarangoni : Boolean; // для условия Неймана
    k,ip,jp : Integer; // Счётчики
    ilengthmap : Integer;
    relaxfac : Float; // параметр релаксации
    ptilda : Float;
    rbuf1 : Float; // временный буфер.
    DirichVal : Float; // значение Дирихле на границе.
    dyl, dxl, mstress, tgrad_tau, muw : Float; // Для Marangoni Convection
    iniTM, ipiTM, ieiTM : Integer; // Для условий Марангони индексирование границ на шахматной сетке.


{
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;
}

begin

    ilengthmap:=imaxnumbernode; // инициализация
    relaxfac:=1.0; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
             relaxfac:=myrelaxfactors.pSORTempreture;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
             // Обязательно нужна нижняя релаксация.
             relaxfac:=1.0;
             //relaxfac:=myrelaxfactors.Momentum;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
              // Обязательно нужна нижняя релаксация.
              relaxfac:=1.0;
              //relaxfac:=myrelaxfactors.Momentum;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0;//myrelaxfactors.pSORPressure;
          end;
    'S' : begin
             // функция тока
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0; // нет релаксации
          end;
     'F' : begin
              // функция цвета
              ilengthmap:=imaxnumbernode;
              relaxfac:=1.0; // нет релаксации
           end;
     'C' : begin
              // User-Defined Scalar
              ilengthmap:=imaxnumbernode;
              relaxfac:=1.0; // нет релаксации
              case icurentuds of
                1 : begin
                       relaxfac:=myrelaxfactors.uds1;
                    end;
                2 : begin
                       relaxfac:=myrelaxfactors.uds2;
                    end;
                3 : begin
                       relaxfac:=myrelaxfactors.uds3;
                    end;
                4 : begin
                       relaxfac:=myrelaxfactors.uds4;
                    end;
              end;
           end;
    end;

    if (bIlyin) then
    begin
        if ((chvariable='T')(*or (chvariable='C')*)) then
        begin
           relaxfac:=relaxIlyin;
        end;
    end;


    if (bIlyinvel) then
    begin
       if ((chvariable='U') or (chvariable='V')) then
       begin
          relaxfac:=relaxIlyin;
       end;
    end;

    //try

    bfirstpointmetall:=True;

   // цикл по всем узлам расчётной области
   for k:=1 to ilengthmap do
   begin
      //with map[k] do
      begin
         if (map[k].itype = 1) then
         begin
            { достаточно медленный код, ниже заменён более быстрым.
            // внутренний узел
            ini:=map[k].i + map[k].j*icolx; // север
            isi:=map[k].i + (map[k].j-2)*icolx; // юг
            iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
            iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
            ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
            if (fabs(m[ipi].dap) < epsilon ) then
            begin
               m[ipi].dap:=1.0;
            end;
            ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
            U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
            }
             // внутренний узел
             // ускоренное вычисление индексов.
            //ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
            ipi:=k;
            //ini:=map[k].i + map[k].j*icolx; // север
            ini:=k+icolx;
            //isi:=map[k].i + (map[k].j-2)*icolx; // юг
            isi:=k-icolx;
            //iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
            iwi:=k-1;
            //iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
            iei:=k+1;

            { // уберём проверку так как она очень медленная и ненужна.
            // её наверно надо выполнять до цикла сразу после сборки матрицы СЛАУ,
            // так сказать проверка на правильность сборки матрицы.
            if (fabs(m[ipi].dap) < epsilon ) then
            begin
               m[ipi].dap:=1.0;
            end;
            }
            ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
            //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
            U[ipi]:=ptilda;
         end // внутренняя точка
         else if (map[k].itype = 0) then
         begin
             // hollow point
             if (chvariable='U') then
             begin
                // горизонтальная скорость.
                ip:=map[k].i;
                jp:=map[k].j;
                if (ip=1) then
                begin
                    ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+(inx-1);
                    //isi:=k-icolx;
                    isi:=k-(inx-1);
                    iwi:=k-1;
                    iei:=k+1;

                    U[ipi]:=0.33333*(U[iei]+U[ini]+U[isi]);

                end
                else if (ip=inx-1) then
                begin
                   ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+(inx-1);
                    //isi:=k-icolx;
                    isi:=k-(inx-1);
                    iwi:=k-1;
                    iei:=k+1;

                    U[ipi]:=0.33333*(U[iwi]+U[ini]+U[isi]);
                end
                else
                begin
                   ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+(inx-1);
                    //isi:=k-icolx;
                    isi:=k-(inx-1);
                    iwi:=k-1;
                    iei:=k+1;

                    if (jp=1) then
                    begin
                       U[ipi]:=0.33333*(U[iwi]+U[ini]+U[iei]);
                    end
                    else if (jp=iny) then
                    begin
                        U[ipi]:=0.33333*(U[iwi]+U[iei]+U[isi]);
                    end
                    else
                    begin
                        U[ipi]:=0.25*(U[iei]+U[iwi]+U[ini]+U[isi]);
                    end;
                end;
             end
             else
              if (chvariable='V') then
             begin
                // вертикальная скорость.
                ip:=map[k].i;
                jp:=map[k].j;
                if (ip=1) then
                begin
                    ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+inx;
                    //isi:=k-icolx;
                    isi:=k-inx;
                    iwi:=k-1;
                    iei:=k+1;

                    U[ipi]:=0.33333*(U[iei]+U[ini]+U[isi]);

                end
                else if (ip=inx) then
                begin
                   ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+inx;
                    //isi:=k-icolx;
                    isi:=k-inx;
                    iwi:=k-1;
                    iei:=k+1;

                    U[ipi]:=0.33333*(U[iwi]+U[ini]+U[isi]);
                end
                else
                begin
                   ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+inx;
                    //isi:=k-icolx;
                    isi:=k-inx;
                    iwi:=k-1;
                    iei:=k+1;

                    if (jp=1) then
                    begin
                       U[ipi]:=0.33333*(U[iwi]+U[ini]+U[iei]);
                    end
                    else if (jp=iny-1) then
                    begin
                        U[ipi]:=0.33333*(U[iwi]+U[iei]+U[isi]);
                    end
                    else
                    begin
                        U[ipi]:=0.25*(U[iei]+U[iwi]+U[ini]+U[isi]);
                    end;
                end;
             end
              else
             begin
                // Остальные переменные.

                ip:=map[k].i;
                jp:=map[k].j;
                if (ip=1) then
                begin
                    ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+inx;
                    //isi:=k-icolx;
                    isi:=k-inx;
                    iwi:=k-1;
                    iei:=k+1;

                    U[ipi]:=0.33333*(U[iei]+U[ini]+U[isi]);

                end
                else if (ip=inx) then
                begin
                   ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+inx;
                    //isi:=k-icolx;
                    isi:=k-inx;
                    iwi:=k-1;
                    iei:=k+1;

                    U[ipi]:=0.33333*(U[iwi]+U[ini]+U[isi]);
                end
                else
                begin
                    ipi:=k;
                    //ini:=k+icolx;
                    ini:=k+inx;
                    //isi:=k-icolx;
                    isi:=k-inx;
                    iwi:=k-1;
                    iei:=k+1;

                    if (jp=1) then
                    begin
                       U[ipi]:=0.33333*(U[iwi]+U[ini]+U[iei]);
                    end
                    else if (jp=iny) then
                    begin
                        U[ipi]:=0.33333*(U[iwi]+U[iei]+U[isi]);
                    end
                    else
                    begin
                        U[ipi]:=0.25*(U[iei]+U[iwi]+U[ini]+U[isi]);
                    end;
                end;
             end

         end

          else
         begin
            // граничный узел с условием Неймана
            // задан тепловой поток
            if (map[k].itype = 2) then
            begin

               // такая граница найдена
               // и на ней поставлено условие Неймана.

               // на границе поставлено условие Неймана
               if (map[k].iugol=0) then
               begin
                  // граничная точка не является угловой


                  case chvariable of
                   'T' : begin
                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           bnei:= GridGenForm.isneiman(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                              end; // case  нормаль
                           end; // условие Неймана
                           boutflow:= GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                           if (boutflow) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        ini:=map[k].i+map[k].j*icolx; // север
                                        inni:=map[k].i+(map[k].j+1)*icolx; // удвоеннный север
                                        ptilda:=(2*U[ini]-U[inni]);
                                        //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                        U[ipi]:=ptilda;
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                        issi:= map[k].i+(map[k].j-3)*icolx; // удвоенный юг
                                        ptilda:=(2*U[isi]-U[issi]);
                                        //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                        U[ipi]:=ptilda;
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                        iwwi:=(map[k].i-2)+(map[k].j-1)*icolx; // удвоенный запад
                                        ptilda:=(2*U[iwi]-U[iwwi]);
                                        //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                        U[ipi]:=ptilda;
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                        ieei:= (map[k].i+2)+(map[k].j-1)*icolx; // удвоенный восток
                                        ptilda:=(2*U[iei]-U[ieei]);
                                        //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                        U[ipi]:=ptilda;
                                     end;
                              end; // case
                           end;
                           bsim:=GridGenForm.issimm(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bsim) then
                           begin
                              case map[k].chnormal of
                              'N' : // нижняя стенка
                                  // внутренняя нормаль
                                  begin
                                     ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                     ini:=map[k].i+map[k].j*icolx; // север
                                     ptilda:=U[ini];
                                     //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     U[ipi]:=ptilda;
                                  end;
                               'S' : // верхняя стенка
                                  // внутренняя нормаль
                                  begin
                                     ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                     isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                     ptilda:=U[isi];
                                     //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                     U[ipi]:=ptilda;
                                  end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                        ptilda:=U[iwi];
                                       // U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                       U[ipi]:=ptilda;
                                     end;
                               'E' : // восток (левая стенка)
                                   // внутренняя нормаль
                                   begin
                                      ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                      iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                      ptilda:=U[iei];
                                      //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      U[ipi]:=ptilda;
                                   end;
                               end; //case
                           end; // граница симметрии
                  end; // T
                  'C' : begin
                           // User-Defined Scalar

                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           //bnei:= GridGenForm.isneiman(map[k].iboundary,chvariable,map[k].chnormal);
                           // предположительно ускоряющий фрагмент кода
                           // результат вычислений был запомнен!!!
                           bnei:=QneiC[map[k].iboundary][icurentuds];
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;

                                   { // проверка очень сильно замедляет вычисления избавимся от неё.
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                  // U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                              end; // case  нормаль
                           end; // условие Неймана

                           // полный нормальный ток равен нулю или диффузионная нормальная составляющая тока равна нулю.
                           bnei:= (GridGenForm.isCzerocurent(map[k].iboundary) or (GridGenForm.isCzeroDiff(map[k].iboundary)));
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }

                                   //ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   ptilda:=(m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }

                                   //ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   ptilda:=(m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }

                                   //ptilda:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   ptilda:=(m[ipi].daw*U[iwi]+db[ipi])/m[ipi].dap;
                                   U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   //ptilda:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   ptilda:=(m[ipi].dae*U[iei]+db[ipi])/m[ipi].dap;
                                   U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                end;
                              end; // case  нормаль
                           end; // условие ток равен нулю.

                           // свободный металл.
                           bnei:=GridGenForm.isFreeMetall(map[k].iboundary);
                           //обход против часовой стрелки
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iei:=k+1;
                                      ini:=k+icolx;
                                      ptilda:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei])/m[ipi].dap;
                                      U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                      //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                      ipi:=k;
                                      //ini:=map[k].i+map[k].j*icolx; // север
                                      //ini:=k+icolx;
                                      //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                      //iwi:=k-1;
                                      //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                      iei:=k+1;

                                      { // проверка очень сильно замедляет вычисления избавимся от неё.
                                      if (fabs(m[ipi].dap) < epsilon ) then
                                      begin
                                         m[ipi].dap:=1.0;
                                      end;
                                      }
                                      ptilda:=(m[ipi].dae*U[iei])/m[ipi].dap;
                                      U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   end;

                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iwi:=k-1;
                                      isi:=k-icolx;
                                      ptilda:=(m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].daw*U[iwi])/m[ipi].dap;
                                   U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   end;
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iwi:=k-1;
                                      ini:=k+icolx;
                                      ptilda:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   //iwi:=k-1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dan*U[ini])/m[ipi].dap;
                                   U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   end;
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iei:=k+1;
                                      isi:=k-icolx;
                                      ptilda:=(m[ipi].das*U[isi]+m[ipi].dae*U[iei])/m[ipi].dap;
                                      U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   //ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].das*U[isi])/m[ipi].dap;
                                   U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   end;
                                end;
                              end; // case  нормаль
                           end; // условие металлической пластины с нефиксированным потенциалом.

                        end;
                  'F' : begin       // Функция цвета.
                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           bnei:= GridGenForm.isneimanVof(map[k].iboundary,rbuf1, map[k].chnormal);
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   ptilda:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   U[ipi]:=ptilda;
                                end;
                              end; // case  нормаль
                           end; // условие Неймана
                  end;
                  'U' : begin
                           // горизонтальная скорость.
                           boutflow:= GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                           if (boutflow) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i+map[k].j*icolx; // север
                                                 inni:=map[k].i+(map[k].j+1)*icolx; // удвоеннный север
                                                 ptilda:=(2*U[ini]-U[inni]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 //U[ipi]:=U[ini]; // равенство нормальной производной нулю.
                                                 //U[ipi]:=U[ipi]+relaxfac*(U[ini]-U[ipi]);
                                                 ptilda:=U[ini];
                                                 U[ipi]:=ptilda;
                                              end;
                                        end; // case
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                                 issi:= map[k].i+(map[k].j-3)*icolx; // удвоенный юг
                                                 ptilda:=(2*U[isi]-U[issi]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                  ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                  isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                  //U[ipi]:=U[isi]; // равенство нормальной производной нулю.
                                                  //U[ipi]:=U[ipi]+relaxfac*(U[isi]-U[ipi]);
                                                  ptilda:=U[isi];
                                                  U[ipi]:=ptilda;
                                              end;
                                          end; // case
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                         case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 (*if (j = (iny div 2)) then
                                                 begin
                                                    U[ipi]:=1; // скорости на входе в расчётную область
                                                 end
                                                  else
                                                 begin*)
                                                    //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                    U[ipi]:=ptilda;
                                                 //end;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                                 iwwi:=(map[k].i-2)+(map[k].j-1)*icolx; // удвоенный запад
                                                 ptilda:=(2*U[iwi]-U[iwwi]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 //U[ipi]:=U[iwi]; // равенство нормальной производной нулю.
                                                 //U[ipi]:=U[ipi]+relaxfac*(U[iwi]-U[ipi]);
                                                 ptilda:=U[iwi];
                                                 U[ipi]:=ptilda;
                                              end;
                                          end;
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                               end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                                 ieei:= (map[k].i+2)+(map[k].j-1)*icolx; // удвоенный восток
                                                 ptilda:=(2*U[iei]-U[ieei]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                           2 : // из статьи в интернете
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // запад
                                                 //U[ipi]:=U[iei]; // равенство нормальной производной нулю.
                                                 //U[ipi]:=U[ipi]+relaxfac*(U[iei]-U[ipi]);
                                                 ptilda:=U[iei];
                                                 U[ipi]:=ptilda;
                                              end;
                                          end;
                                     end;
                              end; // case
                           end;
                           bsim:= GridGenForm.issimm(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bsim) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                begin
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   //U[ipi]:= U[ini];// + relaxfac*(U[ini]-U[ipi]);
                                   //U[ipi]:=U[ipi]+relaxfac*(U[ini]-U[ipi]);
                                   ptilda:=U[ini];
                                   U[ipi]:=ptilda;
                                end;
                               'S' : // верхняя стенка
                               begin
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг j
                                   //U[ipi]:= U[isi];// + relaxfac*(U[isi]-U[ipi]);
                                   //U[ipi]:=U[ipi]+relaxfac*(U[isi]-U[ipi]);
                                   ptilda:=U[isi];
                                   U[ipi]:=ptilda;
                                end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    U[ipi]:= 0.0;
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    U[ipi]:= 0.0;
                                 end;
                              end; // case нормаль
                           end;// bsimm

                           // Marangoni Stress
                           bMarangoni:= GridGenForm.isMarangoni(map[k].iboundary, mstress, map[k].chnormal);
                           if (bMarangoni) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                begin
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   ipiTM:=map[k].i+(map[k].j-1)*(icolx+1);
                                   ieiTM:=map[k].i+1+(map[k].j-1)*(icolx+1);


                                   dyl:=(ypos[map[k].j+1]-ypos[map[k].j]);
                                   tgrad_tau:=(T[ieiTM]-T[ipiTM])/(xpos[map[k].i+1]-xpos[map[k].i]);
                                   muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                   ptilda:=U[ini]+dyl*mstress*tgrad_tau/muw;


                                   U[ipi]:=ptilda;

                                   m[ipi].dap:=viscosity(ipi)*0.5*(xpos[map[k].i+1]-xpos[map[k].i-1])/dyl;
                                   m[ipi].dan:=m[ipi].dap;
                                   m[ipi].dae:=0.0;
                                   m[ipi].daw:=0.0;
                                   m[ipi].das:=0.0;
                                end;
                               'S' : // верхняя стенка
                               begin
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг j
                                   ipiTM:=map[k].i+(map[k].j-1)*(icolx+1);
                                   ieiTM:=map[k].i+1+(map[k].j-1)*(icolx+1);

                                   dyl:=(ypos[map[k].j]-ypos[map[k].j-1]);
                                   tgrad_tau:=(T[ieiTM]-T[ipiTM])/(xpos[map[k].i+1]-xpos[map[k].i]);
                                   muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                   ptilda:=U[isi]+dyl*mstress*tgrad_tau/muw;
                                   U[ipi]:=ptilda;


                                   m[ipi].dap:=viscosity(ipi)*0.5*(xpos[map[k].i+1]-xpos[map[k].i-1])/dyl;
                                   m[ipi].das:=m[ipi].dap;
                                   m[ipi].dae:=0.0;
                                   m[ipi].daw:=0.0;
                                   m[ipi].dan:=0.0;
                                end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    U[ipi]:= 0.0;
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    U[ipi]:= 0.0;
                                 end;
                              end; // case нормаль
                           end;// Marangoni Stress
                        end; // U - горизонтальная скорость
                  'V' : // вертикальная скорость
                        begin
                           boutflow:= GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                           if (boutflow) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                                // U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                U[ipi]:=ptilda;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i+map[k].j*icolx; // север
                                                 inni:=map[k].i+(map[k].j+1)*icolx; // удвоеннный север
                                                 ptilda:=(2*U[ini]-U[inni]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 //U[ipi]:=U[ini];
                                                 //U[ipi]:=U[ipi]+relaxfac*(U[ini]-U[ipi]);
                                                 ptilda:=U[ini];
                                                 U[ipi]:=ptilda;
                                              end;
                                          end; // case
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                                // U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                U[ipi]:=ptilda;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                                 issi:= map[k].i+(map[k].j-3)*icolx; // удвоенный юг
                                                 ptilda:=(2*U[isi]-U[issi]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                                 //U[ipi]:=U[isi];
                                                 //U[ipi]:=U[ipi]+relaxfac*(U[isi]-U[ipi]);
                                                 ptilda:=U[isi];
                                                 U[ipi]:=ptilda;
                                              end;
                                        end; // case
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                                 iwwi:=(map[k].i-2)+(map[k].j-1)*icolx; // удвоенный запад
                                                 ptilda:=(2*U[iwi]-U[iwwi]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                                 //U[ipi]:=U[iwi];
                                                // U[ipi]:=U[ipi]+relaxfac*(U[iwi]-U[ipi]);
                                                 ptilda:=U[iwi];
                                                 U[ipi]:=ptilda;
                                              end;
                                        end; // case
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ptilda:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei]+m[isi].dan*U[isi]+db[ipi])/m[ipi].dap;
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                                 ieei:= (map[k].i+2)+(map[k].j-1)*icolx; // удвоенный восток
                                                 ptilda:=(2*U[iei]-U[ieei]);
                                                 //U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 U[ipi]:=ptilda;
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                                 //U[ipi]:=U[iei];
                                                 //U[ipi]:=U[ipi]+relaxfac*(U[iei]-U[ipi]);
                                                 ptilda:=U[iei];
                                                 U[ipi]:=ptilda;
                                              end;
                                        end; // case
                                     end;
                              end; // case
                           end; // outflow
                           bsim:= GridGenForm.issimm(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bsim) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                   begin
                                      ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                      U[ipi]:=0.0; // нет протекания через границу симметрии
                                   end;
                                'S' : // верхняя стенка
                                    begin
                                       ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                       U[ipi]:=0.0; // нет протекания через границу симметрии
                                    end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                    //U[ipi]:= U[iwi];// + relaxfac*(U[iwi]-U[ipi]);
                                    //U[ipi]:=U[ipi]+relaxfac*(U[iwi]-U[ipi]);
                                    ptilda:=U[iwi];
                                    U[ipi]:=ptilda;
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                    //U[ipi]:= U[iei];// + relaxfac*(U[iei]-U[ipi]);
                                   // U[ipi]:=U[ipi]+relaxfac*(U[iei]-U[ipi]);
                                    ptilda:=U[iei];
                                    U[ipi]:=ptilda;
                                 end;
                              end; // case нормаль
                           end;// bsimm

                           bMarangoni:= GridGenForm.isMarangoni(map[k].iboundary, mstress, map[k].chnormal);
                           if (bMarangoni) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                    begin
                                       ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                       U[ipi]:=0.0; // нет протекания через свободную поверхность
                                    end;
                                'S' : // верхняя стенка
                                    begin
                                       ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                       U[ipi]:=0.0; // нет протекания через свободную поверхность
                                    end;
                                'W' : // правая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                    ipiTM:=map[k].i+(map[k].j-1)*icolx;
                                    iniTM:=map[k].i+(map[k].j)*icolx;


                                    dxl:=(xpos[map[k].i]-xpos[map[k].i-1]);
                                    tgrad_tau:=(T[iniTM]-T[ipiTM])/(ypos[map[k].j+1]-ypos[map[k].j]);
                                    muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                    ptilda:=U[iwi]+dxl*mstress*tgrad_tau/muw;
                                    U[ipi]:=ptilda;

                                     m[ipi].dap:=viscosity(ipi)*0.5*(ypos[map[k].j+1]-ypos[map[k].j-1])/dxl;
                                     m[ipi].daw:=m[ipi].dap;
                                     m[ipi].dae:=0.0;
                                     m[ipi].dan:=0.0;
                                     m[ipi].das:=0.0;
                                 end;
                                'E' : // левая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                    ipiTM:=map[k].i+(map[k].j-1)*icolx;
                                    iniTM:=map[k].i+(map[k].j)*icolx;


                                    dxl:=(xpos[map[k].i+1]-xpos[map[k].i]);
                                    tgrad_tau:=(T[iniTM]-T[ipiTM])/(ypos[map[k].j+1]-ypos[map[k].j]);
                                    // на шахматной сетке лучше использовать простую формулу а не эту.
                                    //tgrad_tau:=(((T[iniTM]-T[ipiTM])*(ypos[map[k].j]-ypos[map[k].j-1])*(ypos[map[k].j]-ypos[map[k].j-1]))-((T[ipiTM]-T[isiTM])*(ypos[map[k].j+1]-ypos[map[k].j])*(ypos[map[k].j+1]-ypos[map[k].j])))/((ypos[map[k].j+1]-ypos[map[k].j])*(ypos[map[k].j]-ypos[map[k].j-1])*(ypos[map[k].j+1]-ypos[map[k].j-1]));
                                    muw:=viscosity(ipi); // динамическая вязкость в граничном узле.


                                    ptilda:=U[iei]+dxl*mstress*tgrad_tau/muw;
                                    U[ipi]:=ptilda;

                                     m[ipi].dap:=viscosity(ipi)*0.5*(ypos[map[k].j+1]-ypos[map[k].j-1])/dxl;
                                     m[ipi].dae:=m[ipi].dap;
                                     m[ipi].daw:=0.0;
                                     m[ipi].dan:=0.0;
                                     m[ipi].das:=0.0;
                                 end;
                              end; // case нормаль
                           end;// bMarangoni
                        end;
                        // Давления здесь нет, т.к. для него краевые точки не играют роли
                        // (не учитываются при расчёте).
                  end; // case chvariable
               end // граничная точка
                else
               begin  // угловая точка
                  //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                  ipi:=k;

                  if (chvariable='T') then
                  begin
                     case map[k].iugol of
                      1 : // левый нижний угол
                        begin
                            //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                             begin
                                T[iei]:=DirichVal;
                                T[ipi]:=T[iei];
                             end
                              else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                             begin
                                T[ini]:=DirichVal;
                                T[ipi]:=T[ini];
                             end
                              else
                             begin
                               //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                               U[ipi]:=0.5*(U[iei]+U[ini]);
                             end;

                        end; // 1
                      2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                           if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                           begin
                              T[iwi]:=DirichVal;
                              T[ipi]:=T[iwi];
                           end
                            else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                           begin
                              T[ini]:=DirichVal;
                              T[ipi]:=T[ini];
                           end
                            else
                           begin
                              //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                              U[ipi]:=0.5*(U[iwi]+U[ini]);
                           end;
                        end;
                      3 : // верхний левый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[isi]);
                        end;
                        end;
                      4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;


                             if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iwi]+U[isi]);
                        end;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                    if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then

                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                        end;
                        end; //5
                        end; // case
                    end
                   else if (chvariable='C') then
                  begin
                     case icurentuds of
                1 : begin
                       case map[k].iugol of
                      1 : // левый нижний угол
                        begin
                            //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iei]:=DirichVal;
                           UDS1[ipi]:=UDS1[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[ini]:=DirichVal;
                           UDS1[ipi]:=UDS1[ini];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[ini]);
                        end;

                        end; // 1
                      2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                           if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                           begin
                              UDS1[iwi]:=DirichVal;
                              UDS1[ipi]:=UDS1[iwi];
                           end
                            else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                           begin
                              UDS1[ini]:=DirichVal;
                              UDS1[ipi]:=UDS1[ini];
                           end
                            else
                           begin
                              //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                              U[ipi]:=0.5*(U[iwi]+U[ini]);
                           end;
                        end;
                      3 : // верхний левый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iei]:=DirichVal;
                           UDS1[ipi]:=UDS1[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[isi]:=DirichVal;
                           UDS1[ipi]:=UDS1[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[isi]);
                        end;
                        end;
                      4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;


                             if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iwi]:=DirichVal;
                           UDS1[ipi]:=UDS1[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[isi]:=DirichVal;
                           UDS1[ipi]:=UDS1[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iwi]+U[isi]);
                        end;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                    if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then

                        begin
                           UDS1[iei]:=DirichVal;
                           UDS1[ipi]:=UDS1[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[ini]:=DirichVal;
                           UDS1[ipi]:=UDS1[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iwi]:=DirichVal;
                           UDS1[ipi]:=UDS1[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[isi]:=DirichVal;
                           UDS1[ipi]:=UDS1[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                        end;
                        end; //5
                        end; // case
                    end;  // UDS1
                2 : begin
                        case map[k].iugol of
                      1 : // левый нижний угол
                        begin
                            //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iei]:=DirichVal;
                           UDS2[ipi]:=UDS2[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[ini]:=DirichVal;
                           UDS2[ipi]:=UDS2[ini];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[ini]);
                        end;

                        end; // 1
                      2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                           if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                           begin
                              UDS2[iwi]:=DirichVal;
                              UDS2[ipi]:=UDS2[iwi];
                           end
                            else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                           begin
                              UDS2[ini]:=DirichVal;
                              UDS2[ipi]:=UDS2[ini];
                           end
                            else
                           begin
                              //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                              U[ipi]:=0.5*(U[iwi]+U[ini]);
                           end;
                        end;
                      3 : // верхний левый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iei]:=DirichVal;
                           UDS2[ipi]:=UDS2[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[isi]:=DirichVal;
                           UDS2[ipi]:=UDS2[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[isi]);
                        end;
                        end;
                      4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;


                             if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iwi]:=DirichVal;
                           UDS2[ipi]:=UDS2[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[isi]:=DirichVal;
                           UDS2[ipi]:=UDS2[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iwi]+U[isi]);
                        end;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                    if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then

                        begin
                           UDS2[iei]:=DirichVal;
                           UDS2[ipi]:=UDS2[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[ini]:=DirichVal;
                           UDS2[ipi]:=UDS2[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iwi]:=DirichVal;
                           UDS2[ipi]:=UDS2[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[isi]:=DirichVal;
                           UDS2[ipi]:=UDS2[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                        end;
                        end; //5
                        end; // case
                    end;   // UDS2
                3 : begin
                        case map[k].iugol of
                      1 : // левый нижний угол
                        begin
                            //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iei]:=DirichVal;
                           UDS3[ipi]:=UDS3[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[ini]:=DirichVal;
                           UDS3[ipi]:=UDS3[ini];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[ini]);
                        end;

                        end; // 1
                      2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                           if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                           begin
                              UDS3[iwi]:=DirichVal;
                              UDS3[ipi]:=UDS3[iwi];
                           end
                            else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                           begin
                              UDS3[ini]:=DirichVal;
                              UDS3[ipi]:=UDS3[ini];
                           end
                            else
                           begin
                              //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                              U[ipi]:=0.5*(U[iwi]+U[ini]);
                           end;
                        end;
                      3 : // верхний левый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iei]:=DirichVal;
                           UDS3[ipi]:=UDS3[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[isi]:=DirichVal;
                           UDS3[ipi]:=UDS3[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[isi]);
                        end;
                        end;
                      4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;


                             if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iwi]:=DirichVal;
                           UDS3[ipi]:=UDS3[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[isi]:=DirichVal;
                           UDS3[ipi]:=UDS3[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iwi]+U[isi]);
                        end;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                    if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then

                        begin
                           UDS3[iei]:=DirichVal;
                           UDS3[ipi]:=UDS3[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[ini]:=DirichVal;
                           UDS3[ipi]:=UDS3[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iwi]:=DirichVal;
                           UDS3[ipi]:=UDS3[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[isi]:=DirichVal;
                           UDS3[ipi]:=UDS3[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                        end;
                        end; //5
                        end; // case
                    end;   // UDS3
                4 : begin
                        case map[k].iugol of
                      1 : // левый нижний угол
                        begin
                            //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iei]:=DirichVal;
                           UDS4[ipi]:=UDS4[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[ini]:=DirichVal;
                           UDS4[ipi]:=UDS4[ini];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[ini]);
                        end;

                        end; // 1
                      2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                           if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                           begin
                              UDS4[iwi]:=DirichVal;
                              UDS4[ipi]:=UDS4[iwi];
                           end
                            else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                           begin
                              UDS4[ini]:=DirichVal;
                              UDS4[ipi]:=UDS4[ini];
                           end
                            else
                           begin
                              //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                              U[ipi]:=0.5*(U[iwi]+U[ini]);
                           end;
                        end;
                      3 : // верхний левый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                             if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iei]:=DirichVal;
                           UDS4[ipi]:=UDS4[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[isi]:=DirichVal;
                           UDS4[ipi]:=UDS4[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[isi]);
                        end;
                        end;   // UDS3
                      4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;


                             if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iwi]:=DirichVal;
                           UDS4[ipi]:=UDS4[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[isi]:=DirichVal;
                           UDS4[ipi]:=UDS4[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iwi]+U[isi]);
                        end;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;


                    if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then

                        begin
                           UDS4[iei]:=DirichVal;
                           UDS4[ipi]:=UDS4[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[ini]:=DirichVal;
                           UDS4[ipi]:=UDS4[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iwi]:=DirichVal;
                           UDS4[ipi]:=UDS4[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[isi]:=DirichVal;
                           UDS4[ipi]:=UDS4[isi];
                        end
                         else
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                        end;
                        end; //5
                        end; // case
                    end;  // UDS4
              end; // case icurent uds


                    end
                     else   // Обычная обработка для всех остальных переменных.
                    begin

                  // среднее арефметическое на значащих узлах
                  case map[k].iugol of
                     1 :  // левый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[ini]);
                        end;
                     2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;
                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iwi]+U[ini]);
                        end;
                     3 : // верхний левый угол
                        begin
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           U[ipi]:=0.5*(U[iei]+U[isi]);
                        end;
                     4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;
                            {
                            if (fabs(m[ipi].dap) < epsilon ) then
                            begin
                                m[ipi].dap:=1.0;
                            end;
                            }
                             //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                             U[ipi]:=0.5*(U[iwi]+U[isi]);
                        end;
                     5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;
                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                        end;
                  end; // case  map[k].iugol
                  end;  // no T and no C
               end; // угловая точка


            end;
         end;
      end;
   end;

   //except
     // MainMemo.Lines.Add('exception GZ : division by zero');
   //end;

end; // GZUniversal

// решение СЛАУ с трёхдиагональной матрицей
// при вертикальной прошивке расчётной области
procedure TForm1.TDMAGibridGZUniversalVertical(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           boncond : Integer; // тип граничных условий снизу
                           bonconup : Integer; // тип граничных условий сверху
                           jstart, jend : Integer; // маркеры на чала и конца прогонки
                           i : Integer; // номер вертикальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
var
    j : Integer; // горизонтальный счётчик
    iei,iwi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    tom : array of TOMASelem; // коэффициенты СЛАУ с Трёхдиагональной матрицей
    rdivision : Float; // для ускорения времени счёта
    i1, ilength : Integer; // счётчик в алгоритме Томаса

begin
    ilength:=jend-jstart+1;
   // для фиксированного i меняем j от 1 до icoly
   // имеем уравнение
   // m[ipi].dap*U[ipi]=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+d[ipi];
   // где d[ipi]:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
   SetLength(tom,ilength+1); // нумерация начинается с единицы
   case boncond of
   0 :
      begin
         // Граничные условия I рода.
         // значение первой точки при j=1 на границе задано
         tom[1].a:=1;
         tom[1].b:=0;
         tom[1].c:=0; // c1
         tom[1].d:=U[i+(jstart-1)*icolx]; // U1 = U[i+(j-1)*icolx], но j=1.
      end;
   1 :
      begin
         // Граничные условия II рода.
         j:=jstart;
         //ini:=i+j*icolx;  // север              j+1
         //isi:=i+(j-2)*icolx; // юг              j-1
         ipi:=i+(j-1)*icolx; // текущая точка   j
         // это для коэффициента tom[1].d
         iwi:=(i-1)+(j-1)*icolx; // запад
         iei:=(i+1)+(j-1)*icolx; // восток

         tom[1].a:=m[ipi].dap;
         tom[1].b:=m[ipi].dan;
         tom[1].c:=0; // c1
         tom[1].d:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
      end;
   end; // case
   case bonconup of
   0 :
       begin
          // Граничные условия I рода
          // значение последней точки при j=icoly на границе задано
          tom[ilength].a:=1;
          tom[ilength].b:=0; // bN
          tom[ilength].c:=0;
          tom[ilength].d:=U[i+(jend-1)*icolx]; // UN
       end;
   1 :
       begin
          // Граничные условия II рода
          j:=jend;

          //ini:=i+j*icolx;  // север              j+1
          //isi:=i+(j-2)*icolx; // юг              j-1
          ipi:=i+(j-1)*icolx; // текущая точка   j
          // это для коэффициента tom[icoly].d
          iwi:=(i-1)+(j-1)*icolx; // запад
          iei:=(i+1)+(j-1)*icolx; // восток

          tom[ilength].a:=m[ipi].dap;
          tom[ilength].b:=0;
          tom[ilength].c:=m[ipi].das; // c1
          tom[ilength].d:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
       end;
   end; // case
   for j:=(jstart+1) to (jend-1) do
   begin  // здесь для какого-либо фиксированного i.

      //ini:=i+j*icolx;  // север              j+1
      //isi:=i+(j-2)*icolx; // юг              j-1
      ipi:=i+(j-1)*icolx; // текущая точка   j
      // это для коэффициента tom[j].d
      iwi:=(i-1)+(j-1)*icolx; // запад
      iei:=(i+1)+(j-1)*icolx; // восток

      tom[j-jstart+1].a:=m[ipi].dap;
      tom[j-jstart+1].b:=m[ipi].dan; // северный коэффициент при j+1
      tom[j-jstart+1].c:=m[ipi].das;  // южный коэффициент при j-1
      tom[j-jstart+1].d:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+db[ipi];
   end;
   // теперь все коэффициенты  от 1 до N=icoly
   // трёхдиагональной СЛАУ определены
   rdivision:=1/tom[1].a;
   tom[1].P:=tom[1].b*rdivision; // P1=b1/a1
   tom[1].Q:=tom[1].d*rdivision; // Q1=d1/a1
   for i1:=(jstart+1) to jend do
   begin  // вычисление прогоночных коэффициентов Pi1, Qi1
     // Деление более ресурсоёмкая операция чем умножение.
     rdivision:=1/(tom[i1-jstart+1].a-tom[i1-jstart+1].c*tom[i1-jstart+1-1].P);
     // P[i1]=b[i1]/(a[i1]-c[i1]*P[i1-1]);
     tom[i1-jstart+1].P:=tom[i1-jstart+1].b*rdivision;
     // Q[i1]=(d[i1]+c[i1]*Q[i1-1])/(a[i1]-c[i1]*P[i1-1]);
     tom[i1-jstart+1].Q:=(tom[i1-jstart+1].d+tom[i1-jstart+1].c*tom[i1-jstart+1-1].Q)*rdivision;
   end; // i1
   // теперь можно узнать значения искомой величины U
   // UN=QN в случае граничных условий I рода эта информация не нужна,
   // так как граничная точка при условиях I рода и так известна.
   if (bonconup=1) then
   begin
      // Определение граничной точки в случае условий Неймана.
      j:=jend;
      U[i+(j-1)*icolx]:=tom[ilength].Q;
   end;
   for j:=(jend-1) downto (jstart+1) do
   begin
     // при j=1 снова имеем граничную точку U1 = U[i].
     // Её значение и так известно в случае граничных условий I рода.
     // обратный ход метода прогонки
     // U[j]:=tom[j].P*U[j+1]+tom[j].Q;
     U[i+(j-1)*icolx]:=tom[j-jstart+1].P*U[i+j*icolx]+tom[j-jstart+1].Q;
   end; // теперь все температуры найдены.
   if (boncond=1) then
   begin
      // Определение граничной точки в случае условий Неймана.
      j:=jstart;
      U[i+(j-1)*icolx]:=tom[1].P*U[i+j*icolx]+tom[1].Q;
   end;
end; // TDMAGibridGZUniversalVertical

// решение СЛАУ с трёхдиагональной матрицей
// при горизонтальной прошивке расчётной области
procedure TForm1.TDMAGibridGZUniversalGorizontal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           bonconl : Integer; // тип граничных условий слева
                           bonconr : Integer; // тип граничных условий справа
                           istart, iend : Integer; // маркеры на чала и конца прогонки
                           j : Integer; // номер горизонтальной линии
                           const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           const db : array of Float); // коэффициенты правой части, содержащие источниковый член
var
    i : Integer; // Счётчики
    ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    tom : array of TOMASelem; // коэффициенты СЛАУ с Трёхдиагональной матрицей
    rdivision : Float; // для ускорения времени счёта
    i1 : Integer; // счётчик в алгоритме Томаса
    ilength : Integer;

begin
   ilength:=iend-istart+1;
   SetLength(tom,ilength+1); // нумерация начинается с единицы
   case bonconl of
   0 : begin
          // Граничные условия I рода.
          // значение первой точки при i=1 на границе задано
          tom[1].a:=1;
          tom[1].b:=0;
          tom[1].c:=0; // c1
          tom[1].d:=U[istart+(j-1)*icolx]; // U1 = U[1+(j-1)*icolx], при i=1.
       end;
   1 : begin
          // Граничные условия II рода.
          i:=istart;
          //iei:=(i+1)+(j-1)*icolx; // восток    i+1
          //iwi:=(i-1)+(j-1)*icolx; // запад     i-1
          ipi:=i+(j-1)*icolx; // текущая точка       i
          // это для коэффициента tom[j].d
          ini:=i+j*icolx;  // север
          isi:=i+(j-2)*icolx; // юг

          tom[1].a:=m[ipi].dap;
          tom[1].b:=m[ipi].dae; // северный коэффициент при i+1
          tom[1].c:=0.0;  // южный коэффициент при i-1
          tom[1].d:=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi];
       end;
   end; // case
   case bonconr of
   0 : begin
          // Граничные условия I рода.
          // значение последней точки при i=icolx на границе задано
          tom[ilength].a:=1;
          tom[ilength].b:=0; // bN
          tom[ilength].c:=0;
          tom[ilength].d:=U[iend+(j-1)*icolx]; // UN
       end;
   1 : begin
         // Граничные условия II рода.
         i:=iend;

         //iei:=(i+1)+(j-1)*icolx; // восток     i+1
         //iwi:=(i-1)+(j-1)*icolx; // запад      i-1
         ipi:=i+(j-1)*icolx; // текущая точка       i
         // это для коэффициента tom[j].d
         ini:=i+j*icolx;  // север
         isi:=i+(j-2)*icolx; // юг

         tom[ilength].a:=m[ipi].dap;
         tom[ilength].b:=0.0; // северный коэффициент при i+1
         tom[ilength].c:=m[ipi].daw;  // южный коэффициент при i-1
         tom[ilength].d:=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi];
       end;
   end;

   for i:=(istart+1) to (iend-1) do
   begin  // здесь для какого-либо фиксированного j.

      //iei:=(i+1)+(j-1)*icolx; // восток            i+1
      //iwi:=(i-1)+(j-1)*icolx; // запад             i-1
      ipi:=i+(j-1)*icolx; // текущая точка       i
      // это для коэффициента tom[j].d
      ini:=i+j*icolx;  // север
      isi:=i+(j-2)*icolx; // юг

      tom[i-istart+1].a:=m[ipi].dap;
      tom[i-istart+1].b:=m[ipi].dae; // северный коэффициент при i+1
      tom[i-istart+1].c:=m[ipi].daw;  // южный коэффициент при i-1
      tom[i-istart+1].d:=m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi];
   end;
   // теперь все коэффициенты  от 1 до N=icolx
   // трёхдиагональной СЛАУ определены
   rdivision:=1/tom[1].a;
   tom[1].P:=tom[1].b*rdivision; // P1=b1/a1
   tom[1].Q:=tom[1].d*rdivision; // Q1=d1/a1
   for i1:=(istart+1) to iend do
   begin  // вычисление прогоночных коэффициентов Pi1, Qi1
      // Для ускорения счёта: операция деления более ресурсоёмкое чем
      // умножение. Множитель rdivision вычисляется один раз а потом используется.
      rdivision:=1/(tom[i1-istart+1].a-tom[i1-istart+1].c*tom[i1-istart+1-1].P);
      // P[i1]=b[i1]/(a[i1]-c[i1]*P[i1-1]);
      tom[i1-istart+1].P:=tom[i1-istart+1].b*rdivision;
      // Q[i1]=(d[i1]+c[i1]*Q[i1-1])/(a[i1]-c[i1]*P[i1-1]);
      tom[i1-istart+1].Q:=(tom[i1-istart+1].d+tom[i1-istart+1].c*tom[i1-istart+1-1].Q)*rdivision;
   end; // i1

   // теперь можно узнать значения температур
   // UN=QN в случае граничных условий первого рода эта информация ненужна,
   // т.к. значение на границе и так известно. Но в случае условий Неймана вычислять надо.
   if ((bonconr=1))  then
   begin
     // Определение граничной точки в случае условий Неймана.
     i:=iend;
     U[i+(j-1)*icolx]:=tom[ilength].Q;
   end;
   for i:=(iend-1) downto (istart+1) do
   begin
     // при i=1 снова имеем граничную точку U1 = U[1+(j-1)*icolx]
     // Её значение и так известно в случае граничных условий I рода.
     // обратный ход метода прогонки
     // U[i]:=tom[i].P*U[i+1]+tom[i].Q;
     U[i+(j-1)*icolx]:=tom[i-istart+1].P*U[i+1+(j-1)*icolx]+tom[i-istart+1].Q;
   end; // теперь все значения искомой величины найдены.
   if ((bonconl=1)) then
   begin
      // Определение значения на границе в случае условий Неймана.
      i:=istart;
      U[i+(j-1)*icolx]:=tom[1].P*U[(i+1)+(j-1)*icolx]+tom[1].Q;
   end;

end; // TDMAGibridGZUniversalGorizontal


// делает одну итерацию методом переменных направлений
// Этот метод также можно назвать методом продольно - поперечной прогонки.
// для любой искомой величины, для граничных условий I & II рода.
// этому методу передаются на вход коэффициенты дискретного аналога
// и карта расположения узлов.
procedure TForm1.TDMAGibridGZUniversal(
                           var U : array of Float; // универсальная искомая величина
                           icolx : Integer; // количество узлов по горизонтали
                           icoly : Integer; // количество узлов по вертикали
                           const map : array of TmyNode; // карта
                           chvariable : Char; // какая переменная рассматривается
                           var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                           var db : array of Float;  // коэффициенты правой части, содержащие источниковый член
                           var Aseqx : TPeacemanRachford;
                           var Aseqy : TPeacemanRachford;
                           bpreprocessing : Boolean);


const
     epsilon = 1e-30;
var
    i, j,k : Integer; // Счётчики
    // два двумерных динамических массива.
    //Aseqx, Aseqy : array of array of Tprogonka; // прогоночные интервалы
    bflag1, bflag2, bflag3  : Boolean; // для создания прогоночных интервалов
    ipi,imarker : Integer; // текущая точка и кол-ва прогоночных интервалов
    ini, iei,isi, iwi : Integer;
    ilengthmap : Integer;
    ir, ic : Integer;

begin
   // Мы запомним пределы прогоночных отрезков один раз перед началом итерирования это должно ускорить вычисления.
   // Без такого запоминания время вычисления по сравнению с методом Гаусса - Зейделя возрастает на 23%.


   //  bpreprocessing - булев флаг отвечающий за то нужно ли заполнять  Aseqx and Aseqy.

   // идея алгоритма следующая
   // 1. выбрать направление прошивки, например вертикальное.
   // 2. для каждой вертикальной направляющей требуется найти
   // интервалы для вертикальной прошивки - это расстояние
   // от границы до границы через внутренние точки расчётной области.

   // Мы будем чередовать случайным образом направления проходов :
   // горизонтальные с вертикальными.
   ir:=Random(2); // случайное значение 0 или 1.

   for ic:=0 to 1 do
   begin

   if (ic=1) then
   begin
      if (ir=0) then ir:=1
      else ir:=0;
   end;

   case ir of
   0 : // вертикальная прошивка.
       begin

          if (bpreprocessing) then
          begin

             SetLength(Aseqx,icolx+1);
          end;


   // фиксируем i
   for i:=2 to icolx-1 do
   begin
      // проход слева направо
      // скорость передачи информации о граничных условиях
      // вглубь расчётной области: в горизонтальном направлении оси x
      // медленная (как у Гаусса-Зейеля), зато в вертикальном направлении
      // мгновенная.

      if (bpreprocessing) then
      begin

         imarker:=1; // инициализация
         SetLength(Aseqx[i], 1); // пока ни одного интервала
         bflag1:=false; // граница не найдена
         bflag2:=false;
         for j:=1 to icoly do
         begin
            ipi:=i+(j-1)*icolx; // текущая точка
            ini:=i+(j+1-1)*icolx; // верхняя точка
            if (map[ipi].itype=2) then
            begin // граничная точка
               // bflag1=false граница не найдена // true граница найдена
               // bflag3=true мы внутри границы искомой нами границы.

               bflag3:=false;
               if (j<icoly) then
               begin
                  if (map[ini].itype=1) then bflag3:=true; // начинается сеточный отрезок
               end;
               if ((not(bflag1)) and (bflag3)) then
               begin
                  // граница начала а за ней сразу внутренняя точка
                  // редактирует длину массива границ
                  inc(imarker);
                  SetLength(Aseqx[i],imarker); // выделение памяти под новый интервал
                  // точка на нижней стенке
                  Aseqx[i][imarker-1].istart:=j; // индекс начальной точки.
                  case chvariable of
                    'C' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary,chvariable,'N')or GridGenForm.isCzerocurent(map[ipi].iboundary) or (GridGenForm.isCzeroDiff(map[ipi].iboundary)) ) then
                             begin
                                Aseqx[i][imarker-1].boncond:=1  // II - рода
                             end
                             else
                             begin
                                Aseqx[i][imarker-1].boncond:=0; // I - рода
                             end;
                          end;
                    'T' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'N')) then
                                Aseqx[i][imarker-1].boncond:=1  // II - рода
                             else if (GridGenForm.isoutflow(map[ipi].iboundary, chvariable,'N') or GridGenForm.issimm(map[ipi].iboundary, chvariable,'N')) then
                                Aseqx[i][imarker-1].boncond:=1  // II - рода
                             else
                                Aseqx[i][imarker-1].boncond:=0; // I - рода
                          end;
                    'P'  : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'N')) then
                                 Aseqx[i][imarker-1].boncond:=1  // II - рода
                             else
                                 Aseqx[i][imarker-1].boncond:=0; // I - рода
                           end;
                     'U' : begin
                             if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'N')) then
                                 Aseqx[i][imarker-1].boncond:=1  // условия симметрии  II рода
                             else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'N')) then
                                 Aseqx[i][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                             else
                                 Aseqx[i][imarker-1].boncond:=0; // I - рода
                           end;
                     'V' : begin
                              if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'N')) then
                                  Aseqx[i][imarker-1].boncond:=0  // условия симметрии  I - рода
                              else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'N')) then
                                  Aseqx[i][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                              else
                                  Aseqx[i][imarker-1].boncond:=0; // I - рода
                           end;
                  end;

                  bflag1:=true; // начальная граница найдена
                  bflag2:=true; // не сразу граница конца
               end;
               if ((bflag1) and (not(bflag2))) then
               begin
                  // граница конца
                  // точка на верхней стенке
                  Aseqx[i][imarker-1].iend:=j; // индекс конечной точки
                  case chvariable of
                    'C' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary,chvariable,'S')or GridGenForm.isCzerocurent(map[ipi].iboundary) or (GridGenForm.isCzeroDiff(map[ipi].iboundary)) ) then
                             begin
                                Aseqx[i][imarker-1].bonconup:=1  // II - рода
                             end
                             else
                             begin
                                Aseqx[i][imarker-1].bonconup:=0; // I - рода
                             end;
                          end;
                    'T' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'S')) then
                                Aseqx[i][imarker-1].bonconup:=1  // II - рода
                             else if (GridGenForm.isoutflow(map[ipi].iboundary, chvariable,'S') or GridGenForm.issimm(map[ipi].iboundary, chvariable,'S')) then
                                 Aseqx[i][imarker-1].bonconup:=1  // II - рода
                             else
                                Aseqx[i][imarker-1].bonconup:=0; // I - рода
                          end;
                    'P' :  begin
                             if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'S')) then
                                Aseqx[i][imarker-1].bonconup:=1  // II - рода
                             else
                                Aseqx[i][imarker-1].bonconup:=0; // I - рода
                            end;
                    'U' : begin
                             if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'S')) then
                                 Aseqx[i][imarker-1].bonconup:=1  // II рода условия симметрии
                             else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'S')) then
                                 Aseqx[i][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                             else
                                 Aseqx[i][imarker-1].bonconup:=0; // I - рода
                          end;
                    'V' : begin
                             if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'S')) then
                                 Aseqx[i][imarker-1].bonconup:=0  // I - рода условия симметрии
                             else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'S')) then
                                 Aseqx[i][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                             else
                                 Aseqx[i][imarker-1].bonconup:=0; // I - рода
                          end;
                  end;
                  bflag1:=false;
               end;
               bflag2:=false;
            end;
         end;

      end;

      for j:=1 to High(Aseqx[i]) do
      begin
         if (chvariable<>'P') then
         begin
            // Не давление и не поправка давления.

            // прошивка в вертикальном направлении при фиксированном i
            TDMAGibridGZUniversalVertical(U, icolx, icoly, Aseqx[i][j].boncond, Aseqx[i][j].bonconup, Aseqx[i][j].istart, Aseqx[i][j].iend, i, m, db);
         end
          else
         begin
            // Давление или поправка давления.
            // Так как для давления и поправки давления мы имеем лишь строго внутренние узлы,
            // то istart должно быть увеличено на единицу, а iend должно быть уменьшено на единицу.
            // После завершения процедуры решения граничные узлы должны быть заполнены по непрерывности.

            // прошивка в вертикальном направлении при фиксированном i
            TDMAGibridGZUniversalVertical(U, icolx, icoly, Aseqx[i][j].boncond, Aseqx[i][j].bonconup, Aseqx[i][j].istart+1, Aseqx[i][j].iend-1, i, m, db);
         end;
      end;
   end; // i
   // конец первого прохода слева направо
   end;

   1 : // Горизонтальная прошивка.
   begin

       if (bpreprocessing) then
       begin
          SetLength(Aseqy,icoly+1);
       end;


   // проход снизу вверх
   // фиксируем j
   for j:=2 to icoly-1 do
   begin
      if (bpreprocessing) then
      begin


         imarker:=1; // инициализация
         SetLength(Aseqy[j], 1); // пока ни одного интервала
         bflag1:=false; // граница не найдена
         bflag2:=false;
         for i:=1 to icolx do
         begin
            ipi:=i+(j-1)*icolx; // текущая точка
            iei:=(i+1)+(j-1)*icolx; // следующая точка
            if (map[ipi].itype=2)  then
            begin  // граничная точка
               bflag3:=false;
               if (i<icolx) then
               begin
                  if (map[iei].itype=1) then bflag3:=true;
               end;
               if ((not(bflag1)) and (bflag3)) then
               begin
                  // граница сначала,  а за ней сразу внутренняя точка расчётной области
                  // редактирует длину массива границ
                  inc(imarker);
                  SetLength(Aseqy[j],imarker); // выделение памяти под новый интервал
                  // точка на левой стенке
                  Aseqy[j][imarker-1].istart:=i; // индекс начала интервала
                  case chvariable of
                   'C' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary,chvariable,'E')or GridGenForm.isCzerocurent(map[ipi].iboundary) or (GridGenForm.isCzeroDiff(map[ipi].iboundary)) ) then
                             begin
                                Aseqy[j][imarker-1].boncond:=1  // II - рода
                             end
                             else
                             begin
                                Aseqy[j][imarker-1].boncond:=0; // I - рода
                             end;
                          end;
                   'T': begin
                           if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'E')) then
                                Aseqy[j][imarker-1].boncond:=1  // II - рода
                           else if (GridGenForm.isoutflow(map[ipi].iboundary, chvariable,'E') or GridGenForm.issimm(map[ipi].iboundary, chvariable,'E')) then
                                Aseqy[j][imarker-1].boncond:=1  // II - рода
                           else
                                Aseqy[j][imarker-1].boncond:=0; // I - рода
                        end;
                   'P' : begin
                           if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'E')) then
                                Aseqy[j][imarker-1].boncond:=1  // II - рода
                            else
                                Aseqy[j][imarker-1].boncond:=0; // I - рода
                       end;
                   'U' : begin
                            if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'E')) then
                               Aseqy[j][imarker-1].boncond:=0  // I - рода условия симметрии
                            else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'E')) then
                               Aseqy[j][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                            else
                               Aseqy[j][imarker-1].boncond:=0; // I - рода
                         end;
                   'V' :   begin
                            if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'E')) then
                                 Aseqy[j][imarker-1].boncond:=1  // II рода условия симметрии
                            else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'E')) then
                                Aseqy[j][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                            else
                               Aseqy[j][imarker-1].boncond:=0; // I - рода
                           end;
                  end;
                  bflag1:=true; // начальная граница найдена
                  bflag2:=true; // не сразу граница конца
               end;
               if ((bflag1) and (not(bflag2))) then
               begin
                  // граница конца
                  // точка на правой стенке
                  Aseqy[j][imarker-1].iend:=i; // индекс конца интервала
                  case chvariable of
                     'C' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary,chvariable,'W')or GridGenForm.isCzerocurent(map[ipi].iboundary) or (GridGenForm.isCzeroDiff(map[ipi].iboundary)) ) then
                             begin
                                Aseqy[j][imarker-1].bonconup:=1  // II - рода
                             end
                             else
                             begin
                                Aseqy[j][imarker-1].bonconup:=0; // I - рода
                             end;
                          end;
                    'T' : begin
                             if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'W')) then
                                 Aseqy[j][imarker-1].bonconup:=1  // II - рода
                             else if (GridGenForm.isoutflow(map[ipi].iboundary, chvariable,'W') or GridGenForm.issimm(map[ipi].iboundary, chvariable,'W')) then
                                 Aseqy[j][imarker-1].bonconup:=1  // II - рода
                             else
                                 Aseqy[j][imarker-1].bonconup:=0; // I - рода
                          end;
                    'P' :  begin
                             if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'W')) then
                                 Aseqy[j][imarker-1].bonconup:=1  // II - рода
                             else
                                 Aseqy[j][imarker-1].bonconup:=0; // I - рода
                           end;
                    'U' : begin
                             if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'W')) then
                                 Aseqy[j][imarker-1].bonconup:=0  // I - рода условия симметрии
                             else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'W')) then
                                 Aseqy[j][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                             else
                                 Aseqy[j][imarker-1].bonconup:=0; // I - рода
                          end;
                    'V' : begin
                             if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'W')) then
                                 Aseqy[j][imarker-1].bonconup:=1  // II рода условия симметрии
                             else if (GridGenForm.isoutflow(map[ipi].iboundary,chvariable,'W')) then
                                 Aseqy[j][imarker-1].boncond:=1 // II рода выходная граница однородные условия Неймана.
                             else
                                 Aseqy[j][imarker-1].bonconup:=0; // I - рода
                          end;

                  end;
                  bflag1:=false;
               end;
               bflag2:=false;
            end;
         end;

      end;

      for i:=1 to High(Aseqy[j]) do
      begin
         if (chvariable<>'P') then
         begin
            // Не давление и не поправка давления.

            // Прошивка в горизонтальном направлении при фиксированном j.
            TDMAGibridGZUniversalGorizontal(U, icolx, icoly, Aseqy[j][i].boncond, Aseqy[j][i].bonconup, Aseqy[j][i].istart, Aseqy[j][i].iend, j, m, db);
         end
          else
         begin
            // Давление или поправка давления.

            // Прошивка в горизонтальном направлении при фиксированном j.
            TDMAGibridGZUniversalGorizontal(U, icolx, icoly, Aseqy[j][i].boncond, Aseqy[j][i].bonconup, Aseqy[j][i].istart+1, Aseqy[j][i].iend-1, j, m, db);
         end;
      end;
   end;  // j
   // конец прохода снизу вверх

   end;

   end; // case

   end;

   (*
   // проход справа налево
   // фиксируем i
   for i:=icolx-1 downto 2 do
   begin
      // проход справа налево
      // скорость передачи информации о граничных условиях
      // вглубь расчётной области: в горизонтальном направлении оси x
      // медленная (как у Гаусса-Зейеля), зато в вертикальном направлении
      // мгновенная.
      imarker:=1; // инициализация
      SetLength(Aseq, 1); // пока ни одного интервала
      bflag1:=false; // граница не найдена
      bflag2:=false;
      for j:=1 to icoly do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         ini:=i+(j+1-1)*icolx; // верхняя точка
         if (map[ipi].itype=2) then
         begin // граничная точка
             bflag3:=false;
            if (j<icoly) then
            begin
               if (map[ini].itype=1) then bflag3:=true;
            end;
            if ((not(bflag1)) and (bflag3)) then
            begin
                // граница начала а за ней сразу внутренняя точка
                // редактирует длину массива границ
                inc(imarker);
                SetLength(Aseq,imarker); // выделение памяти под новый интервал
                // точка на нижней стенке
                Aseq[imarker-1].istart:=j; // индекс начальной точки.
                case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'N')) then
                              Aseq[imarker-1].boncond:=1  // II - рода
                            else
                             Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'N')) then
                               Aseq[imarker-1].boncond:=2  // условия симметрии
                            else
                               Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 end;
                bflag1:=true; // начальная граница найдена
                bflag2:=true; // не сразу граница конца
            end;
            if ((bflag1) and (not(bflag2))) then
            begin
               // граница конца
               // точка на верхней стенке
               Aseq[imarker-1].iend:=j; // индекс конечной точки
               case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'S')) then
                              Aseq[imarker-1].bonconup:=1  // II - рода
                            else
                             Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'S')) then
                               Aseq[imarker-1].bonconup:=2  // условия симметрии
                            else
                               Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 end;
               bflag1:=false;
            end;
            bflag2:=false;
         end;
      end;


      for j:=1 to (imarker-1) do
      begin
         // прошивка в вертикальном направлении при фиксированном i
         TDMAGibridGZUniversalVertical(U, icolx, icoly,  Aseq[j].boncond, Aseq[j].bonconup, Aseq[j].istart, Aseq[j].iend, i, m, db);
      end;
   end; // i
   // конец третьего прохода справа налево


   // проход сверху вниз
   // фиксируем j
   for j:=icoly-1 downto 2 do
   begin

      imarker:=1; // инициализация
      SetLength(Aseq, 1); // пока ни одного интервала
      bflag1:=false; // граница не найдена
      bflag2:=false;
      for i:=1 to icolx do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         iei:=(i+1)+(j-1)*icolx; // следующая точка
         if (map[ipi].itype=2)  then
         begin  // граничная точка
            bflag3:=false;
            if (i<icolx) then
            begin
               if (map[iei].itype=1) then bflag3:=true;
            end;
            if ((not(bflag1)) and (bflag3)) then
            begin
                // граница сначала,  а за ней сразу внутренняя точка расчётной области
                // редактирует длину массива границ
                inc(imarker);
                SetLength(Aseq,imarker); // выделение памяти под новый интервал
                // точка на левой стенке
                Aseq[imarker-1].istart:=i; // индекс начала интервала
                case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'E')) then
                              Aseq[imarker-1].boncond:=1  // II - рода
                            else
                             Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'E')) then
                               Aseq[imarker-1].boncond:=2  // условия симметрии
                            else
                               Aseq[imarker-1].boncond:=0; // I - рода
                       end;
                 end;
                bflag1:=true; // начальная граница найдена
                bflag2:=true; // не сразу граница конца
            end;
            if ((bflag1) and (not(bflag2))) then
            begin
               // граница конца
               // точка на правой стенке
               Aseq[imarker-1].iend:=i; // индекс конца интервала
               case chvariable of
                 'T','P' : begin
                          if (GridGenForm.isneiman(map[ipi].iboundary, chvariable,'W')) then
                              Aseq[imarker-1].bonconup:=1  // II - рода
                            else
                             Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 'U','V' : begin
                          if ( GridGenForm.issimm(map[ipi].iboundary,chvariable,'W')) then
                               Aseq[imarker-1].bonconup:=2  // условия симметрии
                            else
                               Aseq[imarker-1].bonconup:=0; // I - рода
                       end;
                 end;
               bflag1:=false;
            end;
            bflag2:=false;
         end;
      end;

      for i:=1 to (imarker-1) do
      begin
         // Прошивка в горизонтальном направлении при фиксированном j.
         TDMAGibridGZUniversalGorizontal(U, icolx, icoly, Aseq[i].boncond, Aseq[i].bonconup, Aseq[i].istart, Aseq[i].iend, j, m, db);
      end;
   end; // j
   // конец проходу сверху вниз
   *)

   ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
          end;
    end;

   // обработка всех угловых точек
   for k:=1 to ilengthmap do
   begin
      with (map[k]) do
      begin
         ipi:=i+(j-1)*icolx; // текущая точка
         ini:=i+j*icolx; // север
         isi:=i+(j-2)*icolx; // юг
         iei:=(i+1)+(j-1)*icolx; // восток
         iwi:=(i-1)+(j-1)*icolx; // запад
         if (itype = 2) then
         begin
            // только если граничный узел

            // среднее арефметическое на значащих узлах
            case iugol of
              1 :  // левый нижний угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iei]+U[ini]);
                end;
              2 : // правый нижний угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iwi]+U[ini]);
                end;
              3 : // верхний левый угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iei]+U[isi]);
                end;
              4 : // верхний правый угол
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                   U[ipi]:=0.5*(U[iwi]+U[isi]);
                end;
              5 : // пятиточечная звезда
                begin
                   (*
                   if (abs(m[ipi].dap) < epsilon ) then
                   begin
                      m[ipi].dap:=1.0;
                   end; *)
                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                   U[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi]);
                end;
            end; // case
         end;
      end;// with
   end;

end; // TDMAGibridGZUniversal


// Решает задачу прямым методом исключения Гаусса
// для универсальной искомой функции U.
procedure TForm1.GaussUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсированные индексы
    i,j,k,i1,j1 : Integer; // Счётчики
    dA  : array of TmyDynArray; // матрица СЛАУ (хранится только лента).
    move : array of Integer; // для хранения ленточной матрицы
    dV  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    ilengthmap, ilengthA : Integer; // длина карты
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    bnei,bsymm : Boolean; // поставлено ли граничное условие Неймана, условие симметрии
    // проверяющий участок кода для отладки.
   //f : TStrings; // для отладки заполнения формируемых матриц
   //str : String; // для формирования отладочной информации

begin


   SetLength(pointerlistrevers,icolx*icoly);

    ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    'C' : begin
             // User-Defined Scalar
             // предположительно электрический потенциал.
             ilengthmap:=imaxnumbernode;
           end;
    end;

    // определим
    ilengthA:=0; // число уравнений которые потребуется решить
    for i:=1 to icolx do
    begin
       for j:=1 to icoly do
       begin
          if (map[i+(j-1)*icolx].itype<>0) then
          begin
             inc(ilengthA);
             // в число решаемых уравнений обязательно входят
             // все не пустые узлы (не hollow point) карты map
          end;
       end;
    end;

    // прямое преобразование
    SetLength(pointerlist,ilengthA);
     // инициализация
     // будет вылетать по обращению на несуществующий адрес
    for i:=0 to (icolx*icoly-1) do pointerlistrevers[i]:=-1;
    j:=0;
    for i1:=1 to icolx do
    begin
       for j1:=1 to icoly do
       begin
       if (map[i1+(j1-1)*icolx].itype<>0) then
       begin
          // список номеров уравнений
          // обязательно должна быть -1
          pointerlist[j]:=(i1-1) + (j1-1)*icolx; // номер для U
          pointerlistrevers[(i1-1) + (j1-1)*icolx]:=j;
          inc(j); // переход к следующей не пустой точке.
       end;
    end;
    end;

     (*
     // Так делать нельзя, этото цикл будет выполняться вечно.


    // обратное преобразование
    for i:=0 to (icolx*icoly-1) do
    begin
       // нужно найти в pointerlist[j] уникальный номер i
       for j:=0 to (ilengthA-1) do
       begin  // нахождение соответствия
          if (pointerlist[j]=i) then
          begin
             // по номеру для дает номер для x
             // для некоторых соответствующих несуществует
             // и тогда номер заменяется условным значением -1
             pointerlistrevers[i]:=j;
          end;
       end;
    end;
    *)

   if (bmessage) then MainMemo.Lines.Add('начало выделения оперативной памяти ');

   // выделение памяти под матрицу СЛАУ
   SetLength(move,ilengthA);
   for i:=0 to (ilengthA-1) do move[i]:=icolx-i; // массив сдвигов
   SetLength(dA,ilengthA);
   for i:=0 to (ilengthA-1) do SetLength(dA[i],2*icolx+1); // храним только ленту
   // выделение памяти под вектор правой части
   SetLength(dV,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);

   if (bmessage) then MainMemo.Lines.Add('окончание выделения оперативной памяти ');

   // обнуление матрицы dА
   for i:=0 to (ilengthA-1) do  for j:=0 to (2*icolx+1-1) do  dA[i][j]:=0.0; // обнуляем только ленту
   // инициализация вектора правой части
   for i:=0 to (ilengthA-1) do dV[i]:=0.0;
   // инициализация вектора
   k:=0;
   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin
          // нужно ли уравнение для данной точки ?
          j1:=i+(j-1)*icolx;
          // принадлежит ли эта точка к списку зачисленных ?
          for i1:=0 to (ilengthA-1) do
          begin
             if (j1 = (pointerlist[i1]+1)) then
             begin
                // в U нумерация начинается с 1.
                dx[k]:= U[j1];
                inc(k);
             end;
          end;
      end;
   end;
   if (bmessage) then MainMemo.Lines.Add('прошла инициализация ');


   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin

      // внутренний узел
      ini:=i+j*icolx; // север
      isi:=i+(j-2)*icolx; // юг
      iwi:=(i-1)+(j-1)*icolx; // запад
      iei:=(i+1)+(j-1)*icolx; // восток
      ipi:=i+(j-1)*icolx; // текущая точка
      rini:=0;
      risi:=0;
      riwi:=0;
      riei:=0;
      ripi:=0;
      // реверсированные точки:
      if ((ini>=1) and (ini<=icolx*icoly)) then
      begin
         rini:=pointerlistrevers[ini-1];
      end
       else
      begin
        // Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((isi>=1) and (isi<=icolx*icoly)) then
      begin
         risi:=pointerlistrevers[isi-1];
      end
       else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((iwi>=1) and (iwi<=icolx*icoly)) then
      begin
         riwi:=pointerlistrevers[iwi-1];
      end
      else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((iei>=1) and (iei<=icolx*icoly)) then
      begin
         riei:=pointerlistrevers[iei-1];
      end
      else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((ipi>=1) and (ipi<=icolx*icoly)) then
      begin
         ripi:=pointerlistrevers[ipi-1];
      end
      else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if (map[i+(j-1)*icolx].itype = 1) then
      begin
         //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
         dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
         dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
         dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
         dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
         dA[ripi][risi+move[ripi]]:= - m[ipi].das;
         dV[ripi]:= db[ipi];
      end
       else
      begin
         // граничный узел
         if (map[i+(j-1)*icolx].itype = 2) then
         begin
            case chvariable of
             'T','P' : begin
                          // ищем границу по уникальному номеру
                          // на которой поставлено условие Неймана
                          bnei:=GridGenForm.isneiman(map[i+(j-1)*icolx].iboundary,chvariable,map[i+(j-1)*icolx].chnormal);
                          if (bnei) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие Неймана

                             // на границе поставлено условие Неймана
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                              0 : // граничное условие первого рода
                                begin
                                  dA[ripi][ripi+move[ripi]]:=1.0;
                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][rini+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   dA[ripi][rini+move[ripi]]:= - 0.5;
                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riei+move[ripi]]:= - 0.25;
                                   dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   dA[ripi][rini+move[ripi]]:= - 0.25;
                                   dA[ripi][risi+move[ripi]]:= - 0.25;
                                   dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                    end;
             'C' : begin
                          // ищем границу по уникальному номеру
                          // на которой поставлено условие Неймана
                          bnei:=GridGenForm.isneiman(map[i+(j-1)*icolx].iboundary,chvariable,map[i+(j-1)*icolx].chnormal);
                          if (bnei) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие Неймана

                             // на границе поставлено условие Неймана
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else if (GridGenForm.isCzerocurent(map[i+(j-1)*icolx].iboundary) or (GridGenForm.isCzeroDiff(map[i+(j-1)*icolx].iboundary))) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие полный нормальный ток равен нулю !!!
                             // или условие диффузионный нормальный ток равен нулю.

                             // на границе поставлено условие ток равен нулю!!!
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+db[ipi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                              0 : // граничное условие первого рода
                                begin
                                  dA[ripi][ripi+move[ripi]]:=1.0;
                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][rini+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   dA[ripi][rini+move[ripi]]:= - 0.5;
                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riei+move[ripi]]:= - 0.25;
                                   dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   dA[ripi][rini+move[ripi]]:= - 0.25;
                                   dA[ripi][risi+move[ripi]]:= - 0.25;
                                   dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                    end;
             'U','V' : begin
                          bsymm:=GridGenForm.issimm(map[i+(j-1)*icolx].iboundary,chvariable,map[i+(j-1)*icolx].chnormal);
                          if (bsymm) then
                          begin
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=U[ini];
                                    dA[ripi][ripi+move[ripi]]:= 1;
                                    dA[ripi][rini+move[ripi]]:= - 1;
                                    dV[ripi]:= 0;
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=U[isi];
                                     dA[ripi][ripi+move[ripi]]:= 1;
                                     dA[ripi][risi+move[ripi]]:= - 1;
                                     dV[ripi]:= 0;
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=U[iwi];
                                      dA[ripi][ripi+move[ripi]]:= 1;
                                      dA[ripi][riwi+move[ripi]]:= - 1;
                                      dV[ripi]:= 0;
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=U[iei];
                                      dA[ripi][ripi+move[ripi]]:= 1;
                                      dA[ripi][riei+move[ripi]]:= - 1;
                                      dV[ripi]:= 0;
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      dA[ripi][risi+move[ripi]]:= - m[ipi].das;
                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                              0 : // граничное условие первого рода
                                begin
                                  dA[ripi][ripi+move[ripi]]:=1.0;
                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][rini+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   dA[ripi][rini+move[ripi]]:= - 0.5;
                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riei+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  dA[ripi][ripi+move[ripi]]:= 1.0;
                                  dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  dA[ripi][risi+move[ripi]]:= - 0.5;
                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   dA[ripi][ripi+move[ripi]]:= 1.0;
                                   dA[ripi][riei+move[ripi]]:= - 0.25;
                                   dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   dA[ripi][rini+move[ripi]]:= - 0.25;
                                   dA[ripi][risi+move[ripi]]:= - 0.25;
                                   dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                       end;
             end; // case
         end;
      end;
   end;
   end;


   (* // проверяющий участок кода.
   f:=TStringList.Create();
   for k:=0 to (2*icolx) do
   begin
      str:='';
      for i:=0 to (ilengthA-1) do
      begin
         str:=str+FloatToStr(dA[i][k]) + ' ';
      end;
      f.Add(str);
   end;
   f.SaveToFile('debug.txt');
   f.Free;
   *)


   if (bmessage) then
   begin
      MainMemo.Lines.Add('матрица СЛАУ сформирована ');
   end;

   // Решение СЛАУ
   // прямым методом исключения Гаусса
   GaussAlgorithm(ilengthA, dA, icolx, icoly, move, dV, dx, bmessage);
   //LUdecomposition(ilengthA, dA, icolx, icoly, move, dV, dx, bmessage);
   // копирование полученного решения обратно в U
   for i:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i] + 1] := dx[i]; // вектор с решением задачи;
   end;
   // освобождение памяти
   Finalize(dA); // эта матрица на больших сетках будет действительно очень много памяти съедать.
   Finalize(move); // для вычисления сдвига при обращении к ленте
   Finalize(dV); // вектор правой части
   Finalize(dx); // вектор решения


end; // GaussUniversal

// Решает задачу самобытным классическим алгебраическим многосеточным методом
// для универсальной искомой функции U.
procedure TForm1.classical_aglomeration_amg(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль



var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсированные индексы
    i,j,k,i1,j1 : Integer; // Счётчики
    isize_export : Integer;
    Aexport : array of TnodeAMG;
    //dA  : array of TmyDynArray; // матрица СЛАУ (хранится только лента).
    move : array of Integer; // для хранения ленточной матрицы
    dV  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    ilengthmap, ilengthA : Integer; // длина карты
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    bnei,bsymm,boutflow, bMarangoni : Boolean; // поставлено ли граничное условие Неймана, условие симметрии
    // для Марангони конвекции.
    ipiTM, ieiTM, iniTM : Integer;
    dxl, dyl, tgrad_tau, muw, mstress : Float;
    // проверяющий участок кода для отладки.
    f : TStrings; // для передачи параметров алгебраическому многосеточному методу.
    str : String; // для передачи параметров алгебраическому многосеточному методу.
    bamgdivergencedetected : Boolean;

begin

   isize_export:=0;

   SetLength(pointerlistrevers,icolx*icoly);

    ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    'C' : begin
             // User-Defined Scalar
             // предположительно электрический потенциал.
             ilengthmap:=imaxnumbernode;
           end;
    end;

    // определим
    ilengthA:=0; // число уравнений которые потребуется решить
    for i:=1 to icolx do
    begin
       for j:=1 to icoly do
       begin
          if (map[i+(j-1)*icolx].itype<>0) then
          begin
             inc(ilengthA);
             // в число решаемых уравнений обязательно входят
             // все не пустые узлы (не hollow point) карты map
          end;
       end;
    end;

    // прямое преобразование
    SetLength(pointerlist,ilengthA);
     // инициализация
     // будет вылетать по обращению на несуществующий адрес
    for i:=0 to (icolx*icoly-1) do pointerlistrevers[i]:=-1;
    j:=0;
    for i1:=1 to icolx do
    begin
       for j1:=1 to icoly do
       begin
       if (map[i1+(j1-1)*icolx].itype<>0) then
       begin
          // список номеров уравнений
          // обязательно должна быть -1
          pointerlist[j]:=(i1-1) + (j1-1)*icolx; // номер для U
          pointerlistrevers[(i1-1) + (j1-1)*icolx]:=j;
          inc(j); // переход к следующей не пустой точке.
       end;
    end;
    end;

     (*
     // Так делать нельзя, этото цикл будет выполняться вечно.


    // обратное преобразование
    for i:=0 to (icolx*icoly-1) do
    begin
       // нужно найти в pointerlist[j] уникальный номер i
       for j:=0 to (ilengthA-1) do
       begin  // нахождение соответствия
          if (pointerlist[j]=i) then
          begin
             // по номеру для дает номер для x
             // для некоторых соответствующих несуществует
             // и тогда номер заменяется условным значением -1
             pointerlistrevers[i]:=j;
          end;
       end;
    end;
    *)

   if (bmessage) then MainMemo.Lines.Add('начало выделения оперативной памяти ');

   // выделение памяти под матрицу СЛАУ
   SetLength(move,ilengthA);
   for i:=0 to (ilengthA-1) do move[i]:=icolx-i; // массив сдвигов
   //SetLength(dA,ilengthA);
   //for i:=0 to (ilengthA-1) do SetLength(dA[i],2*icolx+1); // храним только ленту
   // выделение памяти под вектор правой части
   SetLength(dV,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);

   if (bmessage) then MainMemo.Lines.Add('окончание выделения оперативной памяти ');

   // обнуление матрицы dА
   //for i:=0 to (ilengthA-1) do  for j:=0 to (2*icolx+1-1) do  dA[i][j]:=0.0; // обнуляем только ленту
   // инициализация вектора правой части
   for i:=0 to (ilengthA-1) do dV[i]:=0.0;
   // инициализация вектора
   k:=0;
   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin
          // нужно ли уравнение для данной точки ?
          j1:=i+(j-1)*icolx;
          // принадлежит ли эта точка к списку зачисленных ?
          for i1:=0 to (ilengthA-1) do
          begin
             if (j1 = (pointerlist[i1]+1)) then
             begin
                // в U нумерация начинается с 1.
                dx[k]:= U[j1];
                inc(k);
             end;
          end;
      end;
   end;
   if (bmessage) then MainMemo.Lines.Add('прошла инициализация ');


   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin

      // внутренний узел
      ini:=i+j*icolx; // север
      isi:=i+(j-2)*icolx; // юг
      iwi:=(i-1)+(j-1)*icolx; // запад
      iei:=(i+1)+(j-1)*icolx; // восток
      ipi:=i+(j-1)*icolx; // текущая точка
      rini:=0;
      risi:=0;
      riwi:=0;
      riei:=0;
      ripi:=0;
      // реверсированные точки:
      if ((ini>=1) and (ini<=icolx*icoly)) then
      begin
         rini:=pointerlistrevers[ini-1];
      end
       else
      begin
        // Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((isi>=1) and (isi<=icolx*icoly)) then
      begin
         risi:=pointerlistrevers[isi-1];
      end
       else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((iwi>=1) and (iwi<=icolx*icoly)) then
      begin
         riwi:=pointerlistrevers[iwi-1];
      end
      else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((iei>=1) and (iei<=icolx*icoly)) then
      begin
         riei:=pointerlistrevers[iei-1];
      end
      else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if ((ipi>=1) and (ipi<=icolx*icoly)) then
      begin
         ripi:=pointerlistrevers[ipi-1];
      end
      else
      begin
         //Application.MessageBox('метод Гаусса вышел за границы','fatal error',MB_OK);
      end;
      if (map[i+(j-1)*icolx].itype = 1) then
      begin
         //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
        // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
         //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
         //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
        // dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
        // dA[ripi][risi+move[ripi]]:= - m[ipi].das;
         inc(isize_export);
         SetLength(Aexport,isize_export);
         Aexport[isize_export-1].val:=m[ipi].dap;
         Aexport[isize_export-1].i:=ripi+1;
         Aexport[isize_export-1].j:=ripi+1;
         inc(isize_export);
          SetLength(Aexport,isize_export);
         Aexport[isize_export-1].val:=- m[ipi].dae;
         Aexport[isize_export-1].i:=ripi+1;
         Aexport[isize_export-1].j:=riei+1;
         inc(isize_export);
          SetLength(Aexport,isize_export);
         Aexport[isize_export-1].val:=- m[ipi].daw;
         Aexport[isize_export-1].i:=ripi+1;
         Aexport[isize_export-1].j:=riwi+1;
          inc(isize_export);
           SetLength(Aexport,isize_export);
         Aexport[isize_export-1].val:=- m[ipi].dan;
         Aexport[isize_export-1].i:=ripi+1;
         Aexport[isize_export-1].j:=rini+1;
           inc(isize_export);
            SetLength(Aexport,isize_export);
         Aexport[isize_export-1].val:=- m[ipi].das;
         Aexport[isize_export-1].i:=ripi+1;
         Aexport[isize_export-1].j:=risi+1;




         dV[ripi]:= db[ipi];
      end
       else
      begin
         // граничный узел
         if (map[i+(j-1)*icolx].itype = 2) then
         begin
            case chvariable of
                'T' : begin
                          // ищем границу по уникальному номеру
                          // на которой поставлено условие Неймана
                          k:=i+(j-1)*icolx;


                             // на границе поставлено условие Неймана
                          if (map[k].iugol=0) then
                          begin
                                 //  граничная точка не являющаяся угловой
                             bsymm:=GridGenForm.issimm(map[k].iboundary,chvariable, map[k].chnormal);
                             boutflow:=GridGenForm.isoutflow(map[k].iboundary,chvariable, map[k].chnormal);

                             bnei:=GridGenForm.isneiman(map[k].iboundary,chvariable,map[k].chnormal);
                             if (bnei) then
                             begin
                             // такая граница найдена
                             // и на ней поставлено условие Неймана

                                case map[k].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                   // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=  m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].dae;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=riei+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].daw;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                    // На случай если HeatFlux отличен от нуля.
                                    // db[ipi]
                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //  dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                      inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].dae;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=riei+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].daw;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].das;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;

                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     // dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                     // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                         inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].daw;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].dan;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=rini+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].das;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dae;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    //inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].dan;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=rini+1;
                                    ///inc(isize_export);
                                    //SetLength(Aexport,isize_export);
                                    //Aexport[isize_export-1].val:= -m[ipi].das;
                                    //Aexport[isize_export-1].i:=ripi+1;
                                    //Aexport[isize_export-1].j:=risi+1;



                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                            end
                             else if (bsymm or boutflow) then
                            begin
                               // В данном коде условие boutflow эквивалентно условию
                               // однородное условие Неймана на выходной границе.

                               // такая граница найдена
                               // и на ней поставлено условие симметрии
                               // эквивалентное условию симметричности поля температур.

                                case map[k].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;
                                    dV[ripi]:= 0.0;
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                    //  dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;

                                     dV[ripi]:= 0.0;
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;


                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;


                                       dV[ripi]:= 0.0;
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= 1.0;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -1.0;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;

                                       dV[ripi]:= 0.0;
                                   end;
                                end; // case

                            end
                             else
                            begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть

                              //dA[ripi][ripi+move[ripi]]:=1.0;

                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:=1.0;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=ripi+1;

                                  dV[ripi]:=U[ipi];


                                  (*
                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                              0 : // граничное условие первого рода
                                begin

                                end;
                              1 :  // левый нижний угол
                                begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                    //dA[ripi][ripi+move[ripi]]:= 1.0;
                                    //dA[ripi][riei+move[ripi]]:= - 0.5;
                                    //dA[ripi][rini+move[ripi]]:= - 0.5;


                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                    dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  // dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   //dA[ripi][rini+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;


                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riei+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                    dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                    dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   // dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riei+move[ripi]]:= - 0.25;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   //dA[ripi][rini+move[ripi]]:= - 0.25;
                                   //dA[ripi][risi+move[ripi]]:= - 0.25;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                   dV[ripi]:= 0.0;
                                end;
                             end; // case
                             *)
                             end;


                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;

                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;


                                       dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                       dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                       dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                       //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                       // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                       // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                       // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end;
                    'P' : begin
                          // ищем границу по уникальному номеру
                          // на которой поставлено условие Неймана
                          bnei:=GridGenForm.isneiman(map[i+(j-1)*icolx].iboundary,chvariable,map[i+(j-1)*icolx].chnormal);
                          if (bnei) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие Неймана

                             // на границе поставлено условие Неймана
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                   // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dae;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].daw;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;


                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   //  dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                      inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dae;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].daw;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].das;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;

                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     // dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                     // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                         inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].daw;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].das;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dae;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].das;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;



                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;

                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;


                                       dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                       dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                       dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                       //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                       // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                       // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                       // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:=- m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                              0 : // граничное условие первого рода
                                begin
                                  //dA[ripi][ripi+move[ripi]]:=1.0;

                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:=1.0;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=ripi+1;

                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                    //dA[ripi][ripi+move[ripi]]:= 1.0;
                                    //dA[ripi][riei+move[ripi]]:= - 0.5;
                                    //dA[ripi][rini+move[ripi]]:= - 0.5;


                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                    dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  // dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   //dA[ripi][rini+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;


                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riei+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                    dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                    dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   // dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riei+move[ripi]]:= - 0.25;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   //dA[ripi][rini+move[ripi]]:= - 0.25;
                                   //dA[ripi][risi+move[ripi]]:= - 0.25;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=- 0.25;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                   dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                    end;
             'C' : begin
                          // ищем границу по уникальному номеру
                          // на которой поставлено условие Неймана
                          bnei:=GridGenForm.isneiman(map[i+(j-1)*icolx].iboundary,chvariable,map[i+(j-1)*icolx].chnormal);
                          if (bnei) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие Неймана

                             // на границе поставлено условие Неймана
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;


                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dae;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].daw;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                    // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    // dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;


                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                     // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= m[ipi].dap;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= -m[ipi].daw;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=riwi+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= -m[ipi].dan;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=rini+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= -m[ipi].das;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                     // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     // dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     // dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dae;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -m[ipi].das;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;




                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= -m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= -m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;

                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                     // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dan;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=rini+1;

                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                    // dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].dae;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riei+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                       dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                       //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                       //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                       //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                       //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= m[ipi].dap;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=ripi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].daw;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=riwi+1;
                                       inc(isize_export);
                                       SetLength(Aexport,isize_export);
                                       Aexport[isize_export-1].val:= -m[ipi].das;
                                       Aexport[isize_export-1].i:=ripi+1;
                                       Aexport[isize_export-1].j:=risi+1;

                                       dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin



                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;



                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else if (GridGenForm.isCzerocurent(map[i+(j-1)*icolx].iboundary) or (GridGenForm.isCzeroDiff(map[i+(j-1)*icolx].iboundary))) then
                          begin
                             // такая граница найдена
                             // и на ней поставлено условие полный нормальный ток равен нулю !!!
                             // или условие диффузионный нормальный ток равен нулю.

                             // на границе поставлено условие ток равен нулю!!!
                             if (map[i+(j-1)*icolx].iugol=0) then
                             begin
                                 //  граничная точка не являющаяся угловой

                                case map[i+(j-1)*icolx].chnormal of
                                  'N' : //север (верх)
                                  begin
                                    //U[ipi]:=(m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                    //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                    //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:=m[ipi].dap;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= - m[ipi].dan;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;


                                    dV[ripi]:= db[ipi];
                                  end;
                                  'S' : // юг (низ)
                                  begin
                                     //U[ipi]:=(m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                     inc(isize_export);
                                     SetLength(Aexport,isize_export);
                                     Aexport[isize_export-1].val:=m[ipi].dap;
                                     Aexport[isize_export-1].i:=ripi+1;
                                     Aexport[isize_export-1].j:=ripi+1;
                                     inc(isize_export);
                                     SetLength(Aexport,isize_export);
                                     Aexport[isize_export-1].val:= - m[ipi].das;
                                     Aexport[isize_export-1].i:=ripi+1;
                                     Aexport[isize_export-1].j:=risi+1;


                                     dV[ripi]:= db[ipi];
                                  end;
                                  'W' : // запад (лево)
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;


                                      dV[ripi]:= db[ipi];
                                   end;
                                   'E' : // восток (право)
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+db[ipi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;


                                      dV[ripi]:= db[ipi];
                                   end;
                                end; // case

                             end
                              else
                             begin
                                // угловые точки

                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;

                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;

                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     //dA[ripi][risi+move[ripi]]:= - m[ipi].das;


                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;

                                      dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                     //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                     //dA[ripi][risi+move[ripi]]:= - m[ipi].das;


                                     inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;

                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;



                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case

                             end;
                          end
                           else
                          begin
                             // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                              0 : // граничное условие первого рода
                                begin
                                   //dA[ripi][ripi+move[ripi]]:=1.0;

                                   inc(isize_export);
                                   SetLength(Aexport,isize_export);
                                   Aexport[isize_export-1].val:=1.0;
                                   Aexport[isize_export-1].i:=ripi+1;
                                   Aexport[isize_export-1].j:=ripi+1;

                                  dV[ripi]:=U[ipi];
                                end;
                              1 :  // левый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   //dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riei+move[ripi]]:= - 0.5;
                                   //dA[ripi][rini+move[ripi]]:= - 0.5;


                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                    dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   //dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   //dA[ripi][rini+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;



                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riei+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:= 1.0;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=ripi+1;
                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:= -0.5;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=riei+1;
                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:= -0.5;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=risi+1;



                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:= 1.0;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=ripi+1;
                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:= -0.5;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=riwi+1;
                                  inc(isize_export);
                                  SetLength(Aexport,isize_export);
                                  Aexport[isize_export-1].val:= -0.5;
                                  Aexport[isize_export-1].i:=ripi+1;
                                  Aexport[isize_export-1].j:=risi+1;


                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   //dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riei+move[ripi]]:= - 0.25;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   //dA[ripi][rini+move[ripi]]:= - 0.25;
                                   //dA[ripi][risi+move[ripi]]:= - 0.25;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= 1.0;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;



                                      dV[ripi]:= 0.0;
                                end;
                             end; // case

                          end;
                    end;
             'U','V' : begin
                          k:=i+(j-1)*icolx;
                          if (map[i+(j-1)*icolx].iugol=0) then
                          begin
                             bsymm:=GridGenForm.issimm(map[i+(j-1)*icolx].iboundary,chvariable,map[i+(j-1)*icolx].chnormal);
                             if (bsymm) then
                             begin

                                 //  граничная точка не являющаяся угловой

                                 if chvariable='U' then
                                 begin

                                    case map[i+(j-1)*icolx].chnormal of
                                     'N' : //север (верх)
                                     begin
                                        //U[ipi]:=U[ini];
                                        //dA[ripi][ripi+move[ripi]]:= 1;
                                        //dA[ripi][rini+move[ripi]]:= - 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= - 1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=rini+1;

                                        dV[ripi]:= 0;
                                     end;
                                     'S' : // юг (низ)
                                     begin
                                        //U[ipi]:=U[isi];
                                        // dA[ripi][ripi+move[ripi]]:= 1;
                                        // dA[ripi][risi+move[ripi]]:= - 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= - 1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=risi+1;


                                        dV[ripi]:= 0;
                                     end;
                                     'W' : // запад (лево)
                                     begin
                                        //U[ipi]:=U[iwi];
                                        //dA[ripi][ripi+move[ripi]]:= 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;


                                        dV[ripi]:= 0;
                                     end;
                                     'E' : // восток (право)
                                     begin
                                        //U[ipi]:=U[iei];
                                        //dA[ripi][ripi+move[ripi]]:= 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;



                                        dV[ripi]:= 0;
                                     end;
                                   end; // case

                                 end;

                                 if chvariable='V' then
                                 begin

                                    case map[i+(j-1)*icolx].chnormal of
                                     'N' : //север (верх)
                                     begin
                                        //U[ipi]:=U[ini];
                                        //dA[ripi][ripi+move[ripi]]:= 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;


                                        dV[ripi]:= 0;
                                     end;
                                     'S' : // юг (низ)
                                     begin
                                        //U[ipi]:=U[isi];
                                        // dA[ripi][ripi+move[ripi]]:= 1;


                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;


                                        dV[ripi]:= 0;
                                     end;
                                     'W' : // запад (лево)
                                     begin
                                        //U[ipi]:=U[iwi];
                                        //dA[ripi][ripi+move[ripi]]:= 1;
                                        //dA[ripi][riwi+move[ripi]]:= - 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= - 1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=riwi+1;

                                        dV[ripi]:= 0;
                                     end;
                                     'E' : // восток (право)
                                     begin
                                        //U[ipi]:=U[iei];
                                        //dA[ripi][ripi+move[ripi]]:= 1;
                                        //dA[ripi][riei+move[ripi]]:= - 1;

                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:=1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=ripi+1;
                                        inc(isize_export);
                                        SetLength(Aexport,isize_export);
                                        Aexport[isize_export-1].val:= - 1.0;
                                        Aexport[isize_export-1].i:=ripi+1;
                                        Aexport[isize_export-1].j:=riei+1;


                                        dV[ripi]:= 0;
                                     end;
                                   end; // case

                                 end;


                             end // symm
                             else
                             begin
                               boutflow:=GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                               if (boutflow) then
                               begin
                                  if ((chvariable='U') or (chvariable='V')) then
                                  begin
                                     case map[k].chnormal of
                                       'N' : // нижняя стенка
                                       // Внутренняя нормаль
                                       begin
                                         case ioutflow of
                                           0: // Условиия Патанкара
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=m[ipi].dap;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].dae;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riei+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].daw;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riwi+1;
                                                inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].dan;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=rini+1;
                                              dV[ripi]:=db[ipi];
                                           end;
                                           2 : // из статьи в интернете
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=1.0;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-1;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=rini+1;
                                              dV[ripi]:=0.0;
                                           end;
                                         end;
                                       end;
                                       'S' : // верхняя стенка
                                       // внутренняя нормаль
                                       begin
                                          case ioutflow of
                                           0: // Условиия Патанкара
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=m[ipi].dap;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].dae;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riei+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].daw;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riwi+1;
                                                inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].das;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=risi+1;
                                              dV[ripi]:=db[ipi];
                                           end;
                                            2 : // из статьи в интернете
                                           begin


                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=1.0;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-1;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=risi+1;
                                              dV[ripi]:=0.0;
                                           end;
                                         end;
                                       end;
                                       'W' : // нижняя стенка
                                       // Внутренняя нормаль
                                       begin
                                         case ioutflow of
                                           0: // Условиия Патанкара
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=m[ipi].dap;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].das;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=risi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].daw;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riwi+1;
                                                inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].dan;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=rini+1;
                                              dV[ripi]:=db[ipi];
                                           end;
                                           2 : // из статьи в интернете
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=1.0;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-1;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riwi+1;
                                              dV[ripi]:=0.0;
                                           end;
                                         end;
                                       end;
                                       'E' : // нижняя стенка
                                       // Внутренняя нормаль
                                       begin
                                         case ioutflow of
                                           0: // Условиия Патанкара
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=m[ipi].dap;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].dae;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riei+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].das;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=risi+1;
                                                inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-m[ipi].dan;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=rini+1;
                                              dV[ripi]:=db[ipi];
                                           end;
                                           2 : // из статьи в интернете
                                           begin
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=1.0;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=ripi+1;
                                              inc(isize_export);
                                              SetLength(Aexport,isize_export);
                                              Aexport[isize_export-1].val:=-1;
                                              Aexport[isize_export-1].i:=ripi+1;
                                              Aexport[isize_export-1].j:=riei+1;
                                              dV[ripi]:=0.0;
                                           end;
                                         end;
                                       end;
                                     end;
                                  end;
                               end
                                else
                               begin
                                   // 29 ноября 2015.
                                   bMarangoni:=GridGenForm.isMarangoni(map[k].iboundary,mstress,map[k].chnormal);
                                   if (bMarangoni) then
                                   begin
                                      // Marangony Stress
                                      case map[k].chnormal of
                                       'N' : // нижняя стенка
                                       begin
                                          if (chvariable='V') then
                                          begin
                                             // Dirichlet
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;

                                             dV[ripi]:=0.0;
                                          end;
                                          if (chvariable='U') then
                                          begin
                                             ipi:=i+(j-1)*icolx;
                                             ini:=i+j*icolx;
                                             ipiTM:=i+(j-1)*(icolx+1);
                                             ieiTM:=i+1+(j-1)*(icolx+1);
                                             dyl:=(ypos[j+1]-ypos[j]);
                                             tgrad_tau:=(T[ieiTM]-T[ipiTM])/(xpos[i+1]-xpos[i]);
                                             muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=-1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=rini+1;

                                             dV[ripi]:=dyl*mstress*tgrad_tau/muw;
                                          end;
                                       end;
                                       'S' : // верхняя стенка
                                       begin
                                           if (chvariable='V') then
                                          begin
                                             // Dirichlet
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;

                                             dV[ripi]:=0.0;
                                          end;

                                          if (chvariable='U') then
                                          begin
                                             ipi:=i+(j-1)*icolx;
                                             isi:=i+(j-2)*icolx;
                                             ipiTM:=i+(j-1)*(icolx+1);
                                             ieiTM:=i+1+(j-1)*(icolx+1);
                                             dyl:=(ypos[j]-ypos[j-1]);
                                             tgrad_tau:=(T[ieiTM]-T[ipiTM])/(xpos[i+1]-xpos[i]);
                                             muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=-1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=risi+1;

                                             dV[ripi]:=dyl*mstress*tgrad_tau/muw;
                                          end;
                                       end;
                                       'E' : // левая стенка
                                       begin
                                           if (chvariable='U') then
                                          begin
                                             // Dirichlet
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;

                                             dV[ripi]:=0.0;
                                          end;
                                          if (chvariable='V') then
                                          begin
                                             ipi:=i+(j-1)*icolx;
                                             iei:=i+1+(j-1)*icolx;
                                             ipiTM:=i+(j-1)*(icolx);
                                             iniTM:=i+(j)*(icolx);
                                             dxl:=(xpos[i+1]-xpos[i]);
                                             tgrad_tau:=(T[iniTM]-T[ipiTM])/(ypos[j+1]-ypos[j]);
                                             muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=-1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=riei+1;

                                             dV[ripi]:=dxl*mstress*tgrad_tau/muw;
                                          end;
                                       end;
                                        'W' : // правая стенка
                                       begin
                                           if (chvariable='U') then
                                          begin
                                             // Dirichlet
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;

                                             dV[ripi]:=0.0;
                                          end;
                                          if (chvariable='V') then
                                          begin
                                             ipi:=i+(j-1)*icolx;
                                             iwi:=i-1+(j-1)*icolx;
                                             ipiTM:=i+(j-1)*(icolx);
                                             iniTM:=i+(j)*(icolx);
                                             dxl:=(xpos[i]-xpos[i-1]);
                                             tgrad_tau:=(T[iniTM]-T[ipiTM])/(ypos[j+1]-ypos[j]);
                                             muw:=viscosity(ipi); // динамическая вязкость в граничном узле.
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=ripi+1;
                                             inc(isize_export);
                                             SetLength(Aexport,isize_export);
                                             Aexport[isize_export-1].val:=-1.0;
                                             Aexport[isize_export-1].i:=ripi+1;
                                             Aexport[isize_export-1].j:=riwi+1;

                                             dV[ripi]:=dxl*mstress*tgrad_tau/muw;
                                          end;
                                       end;
                                      end;

                                   end
                                   else
                                   begin
                                      // Dirichlet
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=1.0;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;

                                      dV[ripi]:=U[ipi];
                                   end;
                               end;
                             end;


                             end
                              else
                             begin
                                // угловые точки

                                (*
                                // среднее арефметическое на значащих узлах
                                case map[i+(j-1)*icolx].iugol of
                                 1 :  // левый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      // dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;


                                      dV[ripi]:= 0.0;
                                   end;
                                 2 : // правый нижний угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;


                                      dV[ripi]:= 0.0;
                                   end;
                                 3 : // верхний левый угол
                                   begin
                                     //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                     //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                     //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                     //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;


                                     dV[ripi]:=0.0;
                                   end;
                                 4 : // верхний правый угол
                                   begin
                                      //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;




                                     dV[ripi]:= 0.0;
                                   end;
                                 5 : // пятиточечная звезда
                                   begin
                                      //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      //dA[ripi][ripi+move[ripi]]:= m[ipi].dap;
                                      //dA[ripi][riei+move[ripi]]:= - m[ipi].dae;
                                      //dA[ripi][riwi+move[ripi]]:= - m[ipi].daw;
                                      //dA[ripi][rini+move[ripi]]:= - m[ipi].dan;
                                      //dA[ripi][risi+move[ripi]]:= - m[ipi].das;


                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=m[ipi].dap;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].dae;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].daw;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].dan;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:=- m[ipi].das;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= 0.0;
                                   end;
                                end; // case
                                *)

                                 // Обычные краевые условия первого рода которые
                             // в данном случае также необходимо учесть


                             // среднее арефметическое на значащих узлах
                             case map[i+(j-1)*icolx].iugol of
                             (* 0 : // граничное условие первого рода
                                begin
                                  //dA[ripi][ripi+move[ripi]]:=1.0;

                                   inc(isize_export);
                                   SetLength(Aexport,isize_export);
                                   Aexport[isize_export-1].val:=1.0;
                                   Aexport[isize_export-1].i:=ripi+1;
                                   Aexport[isize_export-1].j:=ripi+1;

                                   dV[ripi]:=U[ipi];
                                end;
                                *)
                              1 :  // левый нижний угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                                  //dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riei+move[ripi]]:= - 0.5;
                                  //dA[ripi][rini+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                  dV[ripi]:= 0.0;
                                end;
                              2 : // правый нижний угол
                                begin
                                   //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                                   //dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                   //dA[ripi][rini+move[ripi]]:= - 0.5;

                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=rini+1;

                                   dV[ripi]:= 0.0;
                                end;
                              3 : // верхний левый угол
                                begin
                                  //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                                 // dA[ripi][ripi+move[ripi]]:= 1.0;
                                 // dA[ripi][riei+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                   inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riei+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;


                                  dV[ripi]:=0.0;
                                end;
                              4 : // верхний правый угол
                                begin
                                  //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                                  // dA[ripi][ripi+move[ripi]]:= 1.0;
                                  //dA[ripi][riwi+move[ripi]]:= - 0.5;
                                  //dA[ripi][risi+move[ripi]]:= - 0.5;

                                   inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= 1.0;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=ripi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=riwi+1;
                                    inc(isize_export);
                                    SetLength(Aexport,isize_export);
                                    Aexport[isize_export-1].val:= -0.5;
                                    Aexport[isize_export-1].i:=ripi+1;
                                    Aexport[isize_export-1].j:=risi+1;



                                  dV[ripi]:= 0.0;
                                end;
                              5 : // пятиточечная звезда
                                begin
                                   //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                   // dA[ripi][ripi+move[ripi]]:= 1.0;
                                   //dA[ripi][riei+move[ripi]]:= - 0.25;
                                   //dA[ripi][riwi+move[ripi]]:= - 0.25;
                                   //dA[ripi][rini+move[ripi]]:= - 0.25;
                                   //dA[ripi][risi+move[ripi]]:= - 0.25;

                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= 1.0;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=ripi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riei+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=riwi+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=rini+1;
                                      inc(isize_export);
                                      SetLength(Aexport,isize_export);
                                      Aexport[isize_export-1].val:= - 0.25;
                                      Aexport[isize_export-1].i:=ripi+1;
                                      Aexport[isize_export-1].j:=risi+1;


                                      dV[ripi]:= 0.0;
                                end;
                             end; // case


                             end;




                       end;
             end; // case
         end;
      end;
   end;
   end;


   (* // проверяющий участок кода.
   f:=TStringList.Create();
   for k:=0 to (2*icolx) do
   begin
      str:='';
      for i:=0 to (ilengthA-1) do
      begin
         str:=str+FloatToStr(dA[i][k]) + ' ';
      end;
      f.Add(str);
   end;
   f.SaveToFile('debug.txt');
   f.Free;
   *)


   if (bmessage) then
   begin
      MainMemo.Lines.Add('матрица СЛАУ сформирована ');
   end;

   // Решение СЛАУ
   // прямым методом исключения Гаусса
   //GaussAlgorithm(ilengthA, dA, icolx, icoly, move, dV, dx, bmessage);
   //LUdecomposition(ilengthA, dA, icolx, icoly, move, dV, dx, bmessage);



    // Вызов dll на языке С.
    my_aglomerative_external_amg(ilengthA,isize_export,@dV,@dx,@Aexport,bamgdivergencedetected);

    if (bamgdivergencedetected) then
    begin
       // Вызов алгебраического многосеточного метода.
       // TODO 18 11 2015

       f:=TStringList.Create();
       str:=IntToStr(ilengthA);
       f.Add(str);
       for i := 0 to (ilengthA-1) do
       begin
          // Правая часть.
          str:=FloatToStr(dV[i]);
          f.Add(str);
       end;
       str:=IntToStr(isize_export);
       f.Add(str);
       for i := 0 to (isize_export-1) do
       begin
          str:=FloatToStr(Aexport[i].val)+' '+IntToStr(Aexport[i].i)+' '+IntToStr(Aexport[i].j);
          f.Add(str);
       end;


       for i:=0 to f.Count-1 do
       begin
          str:=f.Strings[i];
          f.Strings[i]:=StringReplace(str,',','.',[rfReplaceAll, rfIgnoreCase]);
       end;

       f.SaveToFile('amg_input.txt');
       f.Free();
       ShowMessage('AMG divergence detected');
    end;


   // копирование полученного решения обратно в U
   for i:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i] + 1] := dx[i]; // вектор с решением задачи;
   end;
   // освобождение памяти
  // Finalize(dA); // эта матрица на больших сетках будет действительно очень много памяти съедать.
   Finalize(Aexport);
   Finalize(move); // для вычисления сдвига при обращении к ленте
   Finalize(dV); // вектор правой части
   Finalize(dx); // вектор решения
   Finalize(pointerlist); // Свзь между представлениями.
   Finalize(pointerlistrevers);


end; // classical_aglomeration_amg




// трансформация Гаусса.
// выполняется и над матрицей СЛАУ dA и над вектором правой части dV.
procedure TForm1.GaussTransform(isize : Integer;
                                 var dA : array of TmyDynArray;
                                 var dV : array of Float);
var
    dB : array of TmyDynArray; // транспонированнпая матрица dA
    dC : array of TmyDynArray; // самосопряжённое положительно определённое произведение dB*dA
    i,j,k : Integer; // счётчик цикла for
    dsum : Float; // некая формируемая сумма
    dx : array of Float;

begin
   // преобразует матрицу СЛАУ путём
   // домножения её на саму себя транспонированную.
   // Результирующая матрица, являющая собой произведение двух,
   // будет уже самосопряжённой положительно определённой.
   // такому же преобразованию (домножению на транспонированную) должен
   // подвергаться и вектор правой части СЛАУ.

   // выделение памяти
   SetLength(dB, isize);
   for i:=0 to (isize-1) do SetLength(dB[i], isize);
   SetLength(dC, isize);
   for i:=0 to (isize-1) do SetLength(dC[i], isize);
   SetLength(dx, isize);

   // инициализация
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         dB[i][j]:=dA[j][i];
         dC[i][j]:=0.0;
      end;
      dx[i]:=0.0;
   end;

   // умножение транспонированной матрицы dA раной dB
   // на вектор dV. Результат сохраняется в dx.
   MatrixByVector(isize, dB, dV, dx);
   // запись результата обратно в dV
   for i:=0 to (isize-1) do dV[i]:=dx[i];

   // вычисление произведения
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         // нахождение элемента dC[i][j]
         dsum:=0.0; // обнуление сумматора
         for k:=0 to (isize-1) do
         begin
            dsum:= dsum + dB[i][k]*dA[k][j];
         end;
         dC[i][j]:=dsum;
      end;
   end;

   // формирование результата
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         dA[i][j]:=dC[i][j];
      end;
   end;

   // освобождение
   // оперативной памяти
   Finalize(dB);
   Finalize(dC);
   Finalize(dx);

end; // GaussTransform

// Решает задачу методом сопряжённых градиентов
// Хестенса и Штифеля
// для универсальной искомой функции U.
// данный метод имеет итерационный характер с хорошей скоростью сходимости,
// т.к. он строит базис и поэтому сходится за количество итераций
// равных размерности вектора правой части СЛАУ.
// Ещё одним достоинством данного метода является то, что он
// стартуя с некоторого начального приближения уточняет решение.
procedure TForm1.SoprGradUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         const db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         bmessage : Boolean); // печать диагностических сообщений на консоль
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсированные  индексы узлов на пятиточечном шаблоне
    i,j,k,i1,j1 : Integer; // Счётчики
    dA  : array of TmyDynArray; // матрица СЛАУ
    dV  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    ilengthmap, ilengthA : Integer; // длина пути по карте
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    bnei : Boolean; // поставлено ли граничное условие Неймана
    rbuf : Float;

begin
    ilengthmap:=imaxnumbernode; // инициализация
   case chvariable of
   'T' : begin
            // температура
            ilengthmap:=imaxnumbernode;
         end;
   'U' : begin
            // горизонтальная скорость
            ilengthmap:=imaxnumbernodeVx;
         end;
   'V' : begin
            // вертикальная скорость
            ilengthmap:=imaxnumbernodeVy;
         end;
   'O' : begin
            // others все другие переменные
            ilengthmap:=imaxnumbernode;
         end;
   end; // case

   // определим
    ilengthA:=0; // число уравнений которые потребуется решить
    for i:=1 to ilengthmap do
    begin
       if (map[i].itype<>0) then
       begin
          inc(ilengthA);
          // в число решаемых уравнений обязательно входят
          // все не пустые узлы (не hollow point) карты map
       end;
    end;

    // прямое преобразование
    SetLength(pointerlist,ilengthA);
    j:=0;
     for i:=1 to ilengthmap do
    begin
       if (map[i].itype<>0) then
       begin
          // список номеров уравнений
          // обязательно должна быть -1
          pointerlist[j]:=(map[i].i-1) + (map[i].j-1)*icolx; // номер для U
          inc(j); // переход к следующей не пустой точке.
       end;
    end;

    SetLength(pointerlistrevers,icolx*icoly); // выделение памяти
    // инициализация
     for i:=0 to (icolx*icoly-1) do pointerlistrevers[i]:=-1; // будет вылетать по обращению на несуществующий адрес
    // обратное преобразование
    for i:=0 to (icolx*icoly-1) do
    begin
       // нужно найти в pointerlist[j] уникальный номер i
       for j:=0 to (ilengthA-1) do
       begin  // нахождение соответствия
          if (pointerlist[j]=i) then
          begin
             // по номеру для дает номер для x
             // для некоторых соответствующих несуществует
             // и тогда номер заменяется условным значением -1
             pointerlistrevers[i]:=j;
          end;
       end;
    end;

   if (bmessage) then MainMemo.Lines.Add('начало выделения оперативной памяти ');

   // выделение памяти под матрицу СЛАУ
   SetLength(dA,ilengthA);
   for i:=0 to (ilengthA-1) do SetLength(dA[i],ilengthA);
   // выделение памяти под вектор правой части
   SetLength(dV,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);

   if (bmessage) then MainMemo.Lines.Add('окончание выделения оперативной памяти ');

   // обнуление матрицы dА
   for i:=0 to (ilengthA-1) do for j:=0 to (ilengthA-1) do  dA[i][j]:=0.0;
   // инициализация вектора правой части
   for i:=0 to (ilengthA-1) do dV[i]:=0.0;
   // инициализация вектора
   k:=0;
   for i:=1 to icolx do
   begin
      for j:=1 to icoly do
      begin
          // нужно ли уравнение для данной точки ?
          j1:=i+(j-1)*inx;
          // принадлежит ли эта точка к списку зачисленных ?
          for i1:=0 to (ilengthA-1) do
          begin
             if (j1 = (pointerlist[i1]+1)) then
             begin
                // в U нумерация начинается с 1.
                dx[k]:= U[j1];
                inc(k);
             end;
          end;
      end;
   end;
   if (bmessage) then MainMemo.Lines.Add('прошла инициализация ');

   for i:=1 to ilengthmap do
   begin
      ini:=map[i].i+map[i].j*icolx; // север
      isi:=map[i].i+(map[i].j-2)*icolx; // юг
      iwi:=(map[i].i-1)+(map[i].j-1)*icolx; // запад
      iei:=(map[i].i+1)+(map[i].j-1)*icolx; // восток
      ipi:=map[i].i+(map[i].j-1)*icolx; // текущая точка

      ripi:=pointerlistrevers[ipi-1];
      riei:=pointerlistrevers[iei-1];
      riwi:=pointerlistrevers[iwi-1];
      rini:=pointerlistrevers[ini-1];
      risi:=pointerlistrevers[isi-1];

      if (map[i].itype = 1) then
      begin
          // внутренний узел

         //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
         rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
         dA[ripi][ripi]:= 1.0;
         dA[ripi][riei]:= - rbuf*m[ipi].dae;
         dA[ripi][riwi]:= - rbuf*m[ipi].daw;
         dA[ripi][rini]:= - rbuf*m[ipi].dan;
         dA[ripi][risi]:= - rbuf*m[ipi].das;
         dV[ripi]:= rbuf*db[ipi];
      end
       else
      begin
         // граничный узел
         if (map[i].itype = 2) then
         begin
            // ищем границу по уникальному номеру
            // на которой поставлено условие Неймана
            bnei:=GridGenForm.isneiman(map[i].iboundary,chvariable,map[i].chnormal);
            if (bnei) then
            begin
               // такая граница найдена
               // и на ней поставлено условие Неймана

               // на границе поставлено условие Неймана
               if (map[i].iugol=0) then
               begin
                  //  граничная точка не являющаяся угловой

                  case map[i].chnormal of
                     'N' : //север (верх)
                      begin
                        //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                        rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                        dA[ripi][ripi]:= 1.0;
                        dA[ripi][riei]:= - rbuf*m[ipi].dae;
                        dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                        dA[ripi][rini]:= - rbuf*m[ipi].dan;
                        dV[ripi]:= rbuf*db[ipi];
                      end;
                   'S' : // юг (низ)
                    begin
                       //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                       rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                       dA[ripi][ripi]:= 1.0;
                       dA[ripi][riei]:= - rbuf*m[ipi].dae;
                       dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                       dA[ripi][risi]:= - rbuf*m[ipi].das;
                       dV[ripi]:= rbuf*db[ipi];
                    end;
                   'W' : // запад (лево)
                    begin
                       //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                       rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                       dA[ripi][ripi]:= 1.0;
                       dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                       dA[ripi][rini]:= - rbuf*m[ipi].dan;
                       dA[ripi][risi]:= - rbuf*m[ipi].das;
                       dV[ripi]:= rbuf*db[ipi];
                    end;
                   'E' : // восток (право)
                    begin
                       //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                        rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                        dA[ripi][ripi]:= 1.0;
                        dA[ripi][riei]:= - rbuf*m[ipi].dae;
                        dA[ripi][rini]:= - rbuf*m[ipi].dan;
                        dA[ripi][risi]:= - rbuf*m[ipi].das;
                        dV[ripi]:= rbuf*db[ipi];
                    end;
                  end; // case

                end
                 else
                begin
                  // среднее арефметическое на значащих узлах
                  case map[i].iugol of
                     1 :  // левый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riei]:= - rbuf*m[ipi].dae;
                           dA[ripi][rini]:= - rbuf*m[ipi].dan;
                           dV[ripi]:= 0.0;
                        end;
                     2 : // правый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                           dA[ripi][rini]:= - rbuf*m[ipi].dan;
                           dV[ripi]:= 0.0;
                        end;
                     3 : // верхний левый угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                            rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riei]:= - rbuf*m[ipi].dae;
                            dA[ripi][risi]:= - rbuf*m[ipi].das;
                            dV[ripi]:=0.0;
                        end;
                     4 : // верхний правый угол
                        begin
                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                            dA[ripi][risi]:= - rbuf*m[ipi].das;
                            dV[ripi]:= 0.0;
                        end;
                     5 : // пятиточечная звезда
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                            rbuf:=1/m[ipi].dap; // диагональное предъобуславливание
                            dA[ripi][ripi]:=1.0;
                            dA[ripi][riei]:= - rbuf*m[ipi].dae;
                            dA[ripi][riwi]:= - rbuf*m[ipi].daw;
                            dA[ripi][rini]:= - rbuf*m[ipi].dan;
                            dA[ripi][risi]:= - rbuf*m[ipi].das;
                            dV[ripi]:= 0.0;
                        end;
                  end; // case

                end;
             end
               else
             begin
                // Обычные краевые условия первого рода которые
                // в данном случае также необходимо учесть

                  // среднее арефметическое на значащих узлах
                  case map[i].iugol of
                     0 : // граничное условие первого рода
                        begin
                           dA[ripi][ripi]:=1.0;
                           dV[ripi]:=U[ipi];
                        end;
                     1 :  // левый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riei]:= - 0.5;
                           dA[ripi][rini]:= - 0.5;
                           dV[ripi]:= 0.0;
                        end;
                     2 : // правый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           dA[ripi][ripi]:= 1.0;
                           dA[ripi][riwi]:= - 0.5;
                           dA[ripi][rini]:= - 0.5;
                           dV[ripi]:= 0.0;
                        end;
                     3 : // верхний левый угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riei]:= - 0.5;
                            dA[ripi][risi]:= - 0.5;
                            dV[ripi]:=0.0;
                        end;
                     4 : // верхний правый угол
                        begin
                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riwi]:= - 0.5;
                            dA[ripi][risi]:= - 0.5;
                            dV[ripi]:= 0.0;
                        end;
                     5 : // пятиточечная звезда
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                            dA[ripi][ripi]:= 1.0;
                            dA[ripi][riei]:= - 0.25;
                            dA[ripi][riwi]:= - 0.25;
                            dA[ripi][rini]:= - 0.25;
                            dA[ripi][risi]:= - 0.25;
                            dV[ripi]:= 0.0;
                        end;
                  end;

            end;
         end;
      end;
   end;


   // Всё нижеперечисленное справедливо только для
   // граничных условий первого рода на всём периметре


   // Диагональное предъобуславливание:
   // домножение СЛАУ слева на обратную матрицу
   // к главной диагонали матрицы А.
   (*  сейчас диагональное преъдобуславливание
       встроено в формирование матрицы СЛАУ
   for i:=0 to ilengthA-1 do
   begin
      rbuf:=1/dA[i][i];
      dV[i]:=rbuf*dV[i];
      for j:=1 to ilengthA-1 do
      begin
         if (dA[i][j]<>0.0) then dA[i][j]:=rbuf*dA[i][j];
      end;
   end;
   *)


   MainMemo.Lines.Add('матрица СЛАУ сформирована ');

   if (bgt) then
   begin
      // трансформация Гаусса
      GaussTransform(ilengthA, dA, dV);
   end;

   // Решение СЛАУ
   // методом Сопряжённых Градиентов
   // Хестенса и Штифеля
   SoprGrad(ilengthA, dA, dV, U, dx, true, kend, epsilon); // точность вычисления epsilon
   // копирование полученного решения обратно в U
   for i:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i] + 1] := dx[i]; // вектор с решением задачи;
   end;

   // освобождение памяти
   Finalize(dA); Finalize(dV); Finalize(dx);

end; // SoprGradUniversal

// Решает задачу методом сопряжённых градиентов
// Хестенса и Штифеля
// для универсальной искомой функции U.
// данный метод имеет итерационный характер с хорошей скоростью сходимости,
// т.к. он строит базис и поэтому сходится за количество итераций
// равных размерности вектора правой части СЛАУ.
// Ещё одним достоинством данного метода является то, что он
// стартуя с некоторого начального приближения уточняет решение.
// Данная версия реализована с использованием технологии CRS хранения
// и обработки разреженных матриц. Учёт разреженности матрицы позволяет
// более эффективно использовать оперативную память компьютера и повысить
// скорость операций по решению большой СЛАУ. После того как данный метод
// пройдёт тестирование он может быть рекомендован к использованию.
procedure TForm1.SoprGradCRSUniversal(
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         const map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         const m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         bgt : Boolean; // нужно ли применять трансформация Гаусса (если true то Да, false = НЕТ)
                         bmessage : Boolean; // выводить ли значение невязки на консоль: true - ДА, false - НЕТ.
                         kend : Integer; // ограничение сверху на количество итераций
                         epsilon : Float; // точность вычисления
                         itypealg : Integer; // тип алгоритма: 0 - Сопряжённые градиенты, 1 - Ю.Г. Соловейчика.
                         const db : array of Float); // коэффициенты правой части, содержащие источниковый член
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблоне
    rini, risi, riwi, riei, ripi : Integer; // реверсивные индексы узлов на пятиточечном шаблоне
    i1,j1,i2,j2 : Integer; // Счётчики
    iNelem : Integer; // число ненулевых элементов матрицы СЛАУ
    k,k1 : Integer; // счётчик количества ненулевых элементов + проход по карте
    ilengthmap : Integer; // длина пути по карте
    nze : array of TmyNonZeroElemMatrix; // ненулевые элементы матрицы СЛАУ
    val  : array of Float; // ненулевые элементы матрицы СЛАУ
    col_ind : array of Integer; // соответствующие номера столбцов
    row_ptr : array of Integer; // для определения начала следующей строки.
    dV1  : array of Float; // вектор правой части
    dx : array of Float; // вектор с решением
    bnei : Boolean; // Условие Неймана для температуры
    ilengthA : Integer; // число уравнений которое требуется решить
    pointerlist : array of Integer; // номера для связи x и U
    pointerlistrevers : array of Integer; // для обратной связи между U и x
    dmul : Float; // для диагонального предъобуславливателя
    bwesholdcontloc : Boolean; // нужно ли продолжать.

begin
   bwesholdcontloc:=True;

   ilengthmap:=imaxnumbernode; // инициализация
   case chvariable of
   'T' : begin
            // температура
            ilengthmap:=imaxnumbernode;
         end;
   'U' : begin
            // горизонтальная скорость
            ilengthmap:=imaxnumbernodeVx;
         end;
   'V' : begin
            // вертикальная скорость
            ilengthmap:=imaxnumbernodeVy;
         end;
   'O' : begin
            // others все другие переменные
            ilengthmap:=imaxnumbernode;
         end;
   end; // case

   // Это верно только для температуры
   k:=0;
   for k1:=1 to ilengthmap do
   begin
      if (map[k1].itype=1) then
      begin
         // внутренний узел
         k:=k+5;
      end
       else
      begin
         if (map[k1].itype=2) then
         begin
            // граничный узел


               case map[k1].iugol of
                 0: begin
                       case chvariable of
                        'T' : begin
                                 bnei:=GridGenForm.isneiman(map[k1].iboundary,chvariable,map[k1].chnormal);
                                 if (bnei) then
                                 begin
                                    // условие Неймана
                                    k:=k+4; // условие 2 рода
                                 end
                                 else if (GridGenForm.isoutflow(map[k1].iboundary,chvariable,map[k1].chnormal)) then
                                 begin
                                    // Трёхточечное условие оно точно не реализовано в
                                    // преобразовании матрицы к CRS формату (на данный момент).
                                    k:=k+3;

                                    bwesholdcontloc:=False;
                                 end
                                 else if (GridGenForm.issimm(map[k1].iboundary,chvariable,map[k1].chnormal)) then
                                 begin
                                    // Условие симметрии (двухточечное).
                                    // тоже скорей всего на данный момент не реализовано.
                                    k:=k+2;

                                    bwesholdcontloc:=False;
                                 end
                                  else
                                 begin
                                    // условие Дирихле
                                    k:=k+1; // условие 1 рода
                                 end;
                              end;

                        // Внимание : код для случаев 'U', 'V', 'O' недоделан.
                        // вставлена заглушка 13.12.2013 года.
                        'U' : begin
                                 bnei:=GridGenForm.isneiman(map[k1].iboundary,chvariable,map[k1].chnormal);
                                 if (bnei) then
                                 begin
                                    // условие Неймана
                                    k:=k+4; // условие 2 рода
                                 end
                                  else
                                 begin
                                    // условие Дирихле
                                    k:=k+1; // условие 1 рода
                                 end;
                              end;
                        'V' : begin
                                 bnei:=GridGenForm.isneiman(map[k1].iboundary,chvariable,map[k1].chnormal);
                                 if (bnei) then
                                 begin
                                    // условие Неймана
                                    k:=k+4; // условие 2 рода
                                 end
                                  else
                                 begin
                                    // условие Дирихле
                                    k:=k+1; // условие 1 рода
                                 end;
                              end;
                        'O' : begin
                                 bnei:=GridGenForm.isneiman(map[k1].iboundary,chvariable,map[k1].chnormal);
                                 if (bnei) then
                                 begin
                                    // условие Неймана
                                    k:=k+4; // условие 2 рода
                                 end
                                  else
                                 begin
                                    // условие Дирихле
                                    k:=k+1; // условие 1 рода
                                 end;
                              end;
                       end;


                    end;
                 1 : begin
                       k:=k+3;
                     end;
                 2 :  begin
                       k:=k+3;
                     end;
                 3 : begin
                       k:=k+3;
                     end;
                 4: begin
                       k:=k+3;
                     end;
                 5 : begin
                        // пятиузловой крест
                        // образуется на стыке двух
                        // четырёхугольников при их
                        // касании лишь в одной общей вершине.

                        k:=k+5;
                     end;
                 end; // case
         end;
      end;
   end;

   if (bwesholdcontloc) then
   begin

   // определим число уравнений которое требуется решить
   ilengthA:=0;
   for k1:=1 to ilengthmap do
   begin
      if (map[k1].itype<>0) then
      begin
         inc(ilengthA);
         // число решаемых уравнений равно числу
         // непустых узлов (не Hollow point) карты map.
      end;
   end;

   iNelem:=k; // число ненулевых элементов матрицы СЛАУ
   // выделение памяти под ненулевые эементы матрицы СЛАУ.
   // Этот массив будет использоваться для сортировки
   // сортировка выполняется с целью упорядочить строки матицы и ключом
   // служит номер строки. При этом среди множества ключей есть ключи равные друг другу,
   // однако это не мешает выполнить сортировку.
   SetLength(nze,iNelem+1); // ненулевые элементы которые потом придётся сортировать по строкам
   SetLength(val,iNelem); // ненулевые элементы матрицы СЛАУ
   SetLength(col_ind,iNelem); // соответствующие ненулевым элементам номера столбцов
   SetLength(row_ptr,ilengthA+1); // информация о том где начинается следующая строка
   // выделение памяти под вектор правой части
   SetLength(dV1,ilengthA);
   // выделение памяти под результат вычисления
   SetLength(dx,ilengthA);


   // обнуление матрицы dА
   // здесь было от 1 до iNelem
   for k1:=0 to (iNelem) do
   begin
      // инициализация
      // массива для хранения
      // ненулевых элементов
      nze[k1].i:=0;
      nze[k1].j:=0;
      nze[k1].aij:=0.0;
      nze[k1].key:=0;
   end;

   // обнуление матрицы dА
   for k1:=0 to (iNelem-1) do
   begin
      // инициализация
      val[k1]:=0.0;
      col_ind[k1]:=0;
   end;

   // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
   // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
   for k1:=0 to (ilengthA) do row_ptr[k1]:=iNelem; // инициализация указателей на следующую строку

   for k1:=0 to (ilengthA-1) do
   begin
      dV1[k1]:=0.0;  // инициализация вектора правой части
   end;

   // прямое преобразование
   SetLength(pointerlist,ilengthA);
   // обратное преобразование
   SetLength(pointerlistrevers,icolx*icoly); // выделение памяти
   // инициализация
   // номер -1 соответствует hollow point
   for i1:=0 to (icolx*icoly-1) do pointerlistrevers[i1]:=-1;
   j1:=0;
   for i1:=1 to ilengthmap do
   begin
      if (map[i1].itype<>0) then
      begin
         // список номеров уравнений
         with map[i1] do
         begin
            pointerlist[j1]:=(i-1)+(j-1)*icolx; // номер для U
            pointerlistrevers[(i-1)+(j-1)*icolx]:=j1;
         end; // with
         inc(j1); // переход к следующей непустой точке
      end;
   end;


   (*
   // Так делать нельзя этот двойной цикл будет выполняться вечно.

   for i1:=0 to (icolx*icoly-1) do
   begin
      // нужно найти в pointerlist[j1] уникальный номер i1
      for j1:=0 to (ilengthA-1) do
      begin
         // нахождение соответствия
         if (pointerlist[j1]=i1) then
         begin
            // по номеру для U даёт номер для x
            // для некоторых соответствующих несуществует
            // и тогда номер заменяется условным значением -1
            pointerlistrevers[i1]:=j1;
         end;
      end;
   end;
   *)

   (*
   // Этот двойной цикл будет выполняться вечно !!!

   // инициализация вектора
   k1:=0;
   for i1:=1 to icolx do
   begin
      for j1:=1 to icoly do
      begin
         // нужно ли уравнение для этой точки ?
         j2:=i1+(j1-1)*inx; // нумерация начинается с 1
         // принадлежит ли эта точка к списку зачисленных ?
         for i2:=0 to (ilengthA-1) do
         begin
            if (j2 = (pointerlist[i2]+1)) then
            begin
               // в U нумерация начинается с 1
               dx[k1]:=U[j2]; // инициализация вектора решения
               inc(k1);
            end;
         end;
      end;
   end;
   //*)

   //(*
   for k1:=1 to ilengthmap do
   begin
			if (map[k1].itype<>0) then
      begin
				// внутренний узел
				//dx[pointerlistrevers[map[k1].ipi-1]]:=U[map[k1].ipi];
        dx[pointerlistrevers[k1-1]]:=U[k1];
			end;
   end;
   //*)

   k:=0; // счётчик ненулевых элементов
   // k - это просто индекс, нумерация начиная с 1 нужна для пирамидальной сортировки

   // здесь происходит обращение к элементам nze от 0 до iNelem-1

   // Заполнение матрицы dА с учётом её разреженности и
   // вектора правой части dV
   for k1:=1 to ilengthmap do
   begin
      with map[k1] do
      begin
         ini:=i+j*icolx; // север
         isi:=i+(j-2)*icolx; // юг
         iwi:=(i-1)+(j-1)*icolx; // запад
         iei:=(i+1)+(j-1)*icolx; // восток
         ipi:=i+(j-1)*icolx; // текущая точка

         //if ((ini>=1) and (ini<=ilengthmap)) then
         //begin
            rini:=pointerlistrevers[ini-1];
         //end;
         //if ((isi>=1) and (isi<=ilengthmap)) then
         //begin
            risi:=pointerlistrevers[isi-1];
         //end;
         //if ((iwi>=1) and (iwi<=ilengthmap)) then
         //begin
            riwi:=pointerlistrevers[iwi-1];
         //end;
         //if ((iei>=1) and (iei<=ilengthmap)) then
         //begin
            riei:=pointerlistrevers[iei-1];
         //end;
         //if ((ipi>=1) and (ipi<=ilengthmap)) then
         //begin
            ripi:=pointerlistrevers[ipi-1];
         //end;


         if (itype = 1) then
         begin
            // внутренний узел

            // первый шаблон заполнения
            // U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
            // второй шаблон заполнения
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
            // dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
            dmul:=1/m[ipi].dap; // диагональное предъобуславливание
            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
            nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i; k:=k+1;
            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i; k:=k+1;
            nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i; k:=k+1;
            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i; k:=k+1;
            dV1[ripi]:= dmul*db[ipi];
         end
          else
         begin
            // граничный узел
            if (itype = 2) then
            begin

               bnei:=GridGenForm.isneiman(iboundary,chvariable,chnormal);
               if (bnei) then
               begin
                  // такая граница найдена
                  // и на ней поставлено условие Неймана

                  if (iugol=0) then
                  begin
                     // граничная точка не являющаяся угловой

                     // Внимание ! это нормали внутрь области.
                     case chnormal of
                       'N' : // север (верх)
                       begin
                          //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                       'S' : // юг (низ)
                       begin
                          //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                      'W' : // запад (лево)
                       begin
                          //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                      'E' : // восток (право)
                       begin
                          //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                          //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                          dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                          nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                          nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                          dV1[ripi]:= dmul*db[ipi];
                       end;
                     end; // case
                  end
                   else
                  begin
                     // угловые точки при условии Неймана
                     // угловые точки

                     // среднее арефметическое на значащих узлах
                     case iugol of
                       1 :  // левый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                           dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                       2 : // правый нижний угол
                        begin
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                           dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                       3 : // верхний левый угол
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                            dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:=0.0;
                        end;
                       4 : // верхний правый угол
                        begin
                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                            dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:= 0.0;
                        end;
                       5 : // пятиточечная звезда
                        begin
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - m[ipi].dae;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - m[ipi].daw;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - m[ipi].dan;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - m[ipi].das;
                           dmul:=1/m[ipi].dap; // диагональное предъобуславливание
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:= - dmul*m[ipi].dae; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:= - dmul*m[ipi].daw; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:= - dmul*m[ipi].dan; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:= - dmul*m[ipi].das; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                    end; // case iugol

                  end; // if iugol1 else ...

               end // Условие Неймана
                else
               begin
                  // Обычные краевые условия первого
                  // рода которые тоже необходимо учесть

                  // среднее арефметическое на значащих узлах
                  case iugol of
                     0 : // граничное условие первого рода
                        begin
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:=1.0;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:=U[ipi];
                        end;
                     1 :  // левый нижний угол
                        begin

                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - 0.5;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - 0.5;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                     2 : // правый нижний угол
                        begin

                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - 0.5;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - 0.5;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           dV1[ripi]:= 0.0;
                        end;
                     3 : // верхний левый угол
                        begin

                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - 0.5;
                           //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - 0.5;
                           nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                           nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:=0.0;
                        end;
                     4 : // верхний правый угол
                        begin

                            //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - 0.5;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - 0.5;
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:= 0.0;
                        end;
                     5 : // пятиточечная звезда
                        begin

                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ipi-1]]:= 1.0;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iei-1]]:= - 0.25;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[iwi-1]]:= - 0.25;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[ini-1]]:= - 0.25;
                            //dA[pointerlistrevers[ipi-1]][pointerlistrevers[isi-1]]:= - 0.25;
                            nze[k].i:=ripi; nze[k].j:=ripi; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riei; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=riwi; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=rini; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            nze[k].i:=ripi; nze[k].j:=risi; nze[k].aij:=-0.25; nze[k].key:=nze[k].i;  k:=k+1;
                            dV1[ripi]:= 0.0;
                        end;
                  end; // case


               end;
            end;
         end;
      end; // with
   end;

   // debug
   //MainMemo.Lines.Add('k='+IntToStr(k)+' iNelem='+IntToStr(iNelem)); // верно

   for k:=iNelem downto 1  do nze[k]:=nze[k-1]; // сдвиг вправо на 1.
   // нумерация начинается с 1, а при заполнении nze нумерация начиналась с нуля
   if (itypesorter = 1) then
   begin
      QuickSort(nze,1,iNelem); // быстрая сортировка Хоара
   end
    else
   begin
      // itypesorter = 2
      HeapSort(nze,iNelem); // пирамидальная сортировка
   end;


   // формирование матрицы разреженной матрицы СЛАУ
   //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
   for k:=0 to iNelem-1 do
   begin
      // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
      // это требование алгоритма пирамидальной сортировки.
      val[k]:=nze[k+1].aij;
      col_ind[k]:=nze[k+1].j;
      row_ptr[nze[k+1].i]:=min(k, row_ptr[nze[k+1].i]);
   end;

   Finalize(nze); // освобождение памяти под массив nze
   if (bmessage) then MainMemo.Lines.Add('матрица СЛАУ сформирована ');


   case itypealg of
   0 : // Сопряжённые градиенты Хестенса и Штифеля
       begin
          // Решение СЛАУ
          // методом Сопряжённых Градиентов
          // Хестенса и Штифеля
          // на основе технологии хранения и обработки разреженных матриц CRS
          // В зависимости от значения параметра bgt применяется или не применяется трансформация Гаусса.
          SoprGradCRS(ilengthA, val, col_ind, row_ptr, dV1, U, dx, bmessage, kend, bgt, epsilon);
       end;
   1 : // алгоритм Ю.Г. Соловейчика [1993]
       begin
          SoloveichikAlg(ilengthA, val, col_ind, row_ptr, dV1, U, dx, bmessage, kend, epsilon);
       end;
   end;

   // копирование полученного решения обратно в U
   for i1:=0 to (ilengthA-1) do
   begin
      U[pointerlist[i1]+1] := dx[i1]; // вектор с решением задачи;
   end;

   // Освобождение памяти из под
   // матрицы А
   SetLength(val,0);
   SetLength(col_ind,0);
   SetLength(row_ptr,0);
   // и вектора правой части.
   SetLength(dV1,0);
   SetLength(dx,0);
   SetLength(pointerlist,0);
   SetLength(pointerlistrevers,0);

   end
   else
   begin
      MainMemo.Lines.Add('не предусмотренные для CRS формата граничные условия. Они ещё не реализованы в программном коде для методов Крыловского типа. Смените решатель на метод Гаусса-Зейделя. ');
   end;

end; // SoprGradCRSUniversal

// Граничное условие II рода на левой стенке
                                      // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefLeft(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                         qbleft : Float; // заданный тепловой поток на границе
                                      place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dke, dkn, dks : Float; // теплопроводность на грани контрольного объёма
    //iei, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне

begin
   with place do
   begin
      //ini:=i+j*inx;  // север
      //isi:=i+(j-2)*inx; // юг
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iei:=(i+1)+(j-1)*inx; // восток
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      //dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      //dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      m[ipi].dae:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp); // коэффициенты
      m[ipi].daw:=0.0; // дискретного
      //m[ipi].dan:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp); // аналога
      //m[ipi].das:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
      m[ipi].dan:=0.0;
      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
           else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].dae + m[ipi].dan + m[ipi].das;
      m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV/(densuty_in_surface(ipi,iei)*dcp);
      db[ipi]:=(dSc[ipi]*dV + dy*qbleft)/(densuty_in_surface(ipi,iei)*dcp);
      if (btimedepend) then
      begin
         // учёт поля температуры с последней итерации
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
          else
         begin
            db[ipi]:=db[ipi] + dap0*ToldTimeStep[ipi];
         end;
      end;
   end; // with
end; // TempBoundaryCoefLeft

// Граничное условие II рода на правой стенке
                                      // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                         qbright : Float; // заданный тепловой поток на границе
                                       place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dkw, dkn, dks : Float; // теплопроводность на грани контрольного объёма
    //iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iwi:=(i-1)+(j-1)*inx; // запад
      //ini:=i+j*inx; // север
      //isi:=i+(j-2)*inx; // юг
      // теплопроводность на грани контрольного объёма
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      //dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      //dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      m[ipi].daw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp); // коэффициенты
      m[ipi].dae:=0.0; // дискретного
      //m[ipi].dan:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp); // аналога
      //m[ipi].das:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
      m[ipi].dan:=0.0;
      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестационарный вклад
         end
           else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].daw + m[ipi].dan + m[ipi].das;
      m[ipi].dap:= m[ipi].dap + dap0 - dSp*dV/(densuty_in_surface(ipi,iwi)*dcp);
      db[ipi]:=(dSc[ipi]*dV + dy*qbright)/(densuty_in_surface(ipi,iwi)*dcp);
      if (btimedepend) then
      begin
         // учёт поля температуры с предедущей итерации
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
          else
         begin
            db[ipi]:=db[ipi] + dap0*ToldTimeStep[ipi];
         end;
      end;
   end; // with
end; // TempBoundaryCoefRight

// Граничное условие II рода на нижней стенке
                                      // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefBottom(var m : array of MatrixCoef;
                                        var db : array of Float; // правая часть
                        qbbottom : Float; // заданный тепловой поток на границе
                                        place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dkw, dkn, dke : Float; // теплопроводность на грани контрольного объёма
    //iwi, ini, iei, ipi : Integer; // номера узлов на пятиточечном шаблоне

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      //iwi:=(i-1)+(j-1)*inx; // запад
      //iei:=(i+1)+(j-1)*inx; // восток
      // теплопроводность на грани контрольного объёма
      //dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      //dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      //m[ipi].dae:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp); // коэффициенты
      //m[ipi].daw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp); // дискретного
       m[ipi].dae:=0.0;
       m[ipi].daw:=0.0;
      m[ipi].dan:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp); // аналога
      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
           else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
           dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].dan + m[ipi].dae + m[ipi].daw;
      m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV/densuty_in_surface(ipi,ini)*dcp;
      db[ipi]:=(dSc[ipi]*dV + dx*qbbottom)/(densuty_in_surface(ipi,ini)*dcp);
      if (btimedepend) then
      begin
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
          else
         begin
            db[ipi]:=db[ipi]+dap0*ToldTimeStep[ipi]; // учёт поля температуры с предедущей итерации
         end;
      end;
   end; // with
end; // TempBoundaryCoefBottom

// Граничное условие II рода на верхней стенке
                                   // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefTop(var m : array of MatrixCoef;
                                     var db : array of Float; // правая часть
                         qbtop : Float; // заданный тепловой поток на границе
                                     place : TmyNode); // место на карте
var
    dap0 : Float;  // нестационарный коэффициент
    dkw, dks, dke : Float; // теплопроводность на грани контрольного объёма
    //iwi, isi, iei, ipi : Integer; // номера узлов на пятиточечном шаблоне


begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      isi:=i+(j-2)*inx; // юг
      //iwi:=(i-1)+(j-1)*inx; // запад
      //iei:=(i+1)+(j-1)*inx; // восток
      // теплопроводность на грани контрольного объёма
      //dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      //dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      //m[ipi].daw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp);  // коэффициенты
      //m[ipi].dae:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp);  // дискретного
      m[ipi].daw:=0.0;
      m[ipi].dae:=0.0;
      m[ipi].dan:=0.0; // аналога
      m[ipi].das:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
      if (btimedepend) then
      begin
         // нестационарная теплопроводность
         if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
           else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарная теплопроводность
         dap0:=0.0; // стационарный вклад
      end;
      m[ipi].dap:=m[ipi].das + m[ipi].daw + m[ipi].dae;
      m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV/(densuty_in_surface(ipi,isi)*dcp);
      db[ipi]:=(dSc[ipi]*dV + dx*qbtop)/(densuty_in_surface(ipi,isi)*dcp);
      if (btimedepend) then
      begin
         // учёт поля температуры с предедущей итерации
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
          else
         begin
            db[ipi]:=db[ipi]+dap0*ToldTimeStep[ipi];
         end;
      end;
   end; // with
end; // TempBoundaryCoefTop


// вычисление коэффициентов дискретного аналога для уравнения
// теплопроводности.
// коэффициенты дискретного аналога.
// Поузловая сборка матрицы:
// Чистая диффузионная составляющая.
procedure TForm1.TempCoef(var m : array of MatrixCoef;
                          var db : array of Float); // правая часть
var
    dap0 : Float;  // нестационарный коэффициент
    dke, dkw, dkn, dks : Float; // теплопроводность на грани контрольного объёма
    //iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    k : Integer; // счётчики для вычисления коэффициентов дискретного аналога
    qb : Float; // тепловой поток через границу
    bneiman : Boolean; // поставлено ли условие неймана
    DirichVal : Float; // значение Дирихле.

begin

   // проход по всем внутренним точкам
   // для определения матриц коэффициентов m и db

   for k:=1 to imaxnumbernode do
   begin
   
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // теплопроводность на грани контрольного объёма
            dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
            dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
            dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
            dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
            // Диффузия.
            m[ipi].dae:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp);  // коэффициенты
            m[ipi].daw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp); // дискретного
            m[ipi].dan:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp);  // аналога
            m[ipi].das:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
            if (btimedepend) then
            begin
               // нестационарная теплопроводность
               if (bsecondordertemp) then
               begin
                  // Схема Пейре.
                  dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
               end
                else
               begin
                  //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
                  dap0:=dV/dTimeStep; // нестаионарный вклад
               end;
            end
             else
            begin
               // стационарная теплопроводность
               dap0:=0.0; // стационарный вклад
            end;

            db[ipi]:=dSc[ipi]*dV;// неизменная составляющая источникового члена
            if (btimedepend) then
            begin
               if (bsecondordertemp) then
               begin
                  // Схема Пейре второго порядка по времени !!!
                  db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
               end
                else
               begin
                  // учёт поля температуры с предедущей итерации
                  db[ipi]:=db[ipi]+dap0*ToldTimeStep[ipi];
               end;
            end;
            m[ipi].dap:=m[ipi].dae + m[ipi].daw + m[ipi].dan + m[ipi].das;
            m[ipi].dap:=m[ipi].dap + dap0 - dSp*dV;
         end;

         if (itype = 2 ) then
         begin

            // граничный узел
            // возможны условия Неймана
            // словесно порядок действий следующий:
            // каждая граничная точка принадлежит
            // какойлибо определенной границе с уникальным номером
            // по этому уникальному номеру (идентификатору) граница
            // должна быть найдена  и для неё должно быть проверено
            // поставлено ли на ней условие Неймана.
            // iboundary - уникальный номер границы

            // на границе поставлено условие Неймана
            if (iugol=0) then
            begin
               bneiman:=GridGenForm.isneimanqb(iboundary, 'T', qb);
               (*if (not(bneiman)) then
               begin
                 if (GridGenForm.isoutflow(iboundary, 'T', chnormal)) then
                 begin
                    // Выходная граница, но у нас теплопередача в твёрдом теле, поэтому ставим однородное условие Неймана.
                    bneiman:=True;
                 end;
               end;
               *)
               if (bneiman) then
               begin
                  // точка не является угловой
                  case chnormal of
                   'N' : begin
                            // На нижней границе.
                            TempBoundaryCoefBottom(m, db, qb, mapPT[k]);
                         end;
                   'S' : begin
                            // На верхней границе.
                            TempBoundaryCoefTop(m, db, qb, mapPT[k]);
                         end;
                   'W' : begin
                            // Правая стенка
                            TempBoundaryCoefRight(m, db, qb, mapPT[k]);
                         end;
                   'E' : begin
                            // Левая стенка
                            TempBoundaryCoefLeft(m, db, qb, mapPT[k]);
                         end;
                  end; // case
               end // Нейман
               else if (GridGenForm.isoutflow(iboundary, 'T', chnormal)) then
               begin
                  // Особое условие на выходной границе.
                  ipi:=i+(j-1)*inx; // текущая точка
                  //ini:=i+j*inx;  // север
                  //isi:=i+(j-2)*inx; // юг
                  //iwi:=(i-1)+(j-1)*inx; // запад
                  //iei:=(i+1)+(j-1)*inx; // восток
                  case chnormal of
                      'N' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=2.0;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=0.0;
                               db[ipi]:=-T[i+(j+1)*inx];
                            end;
                      'S' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=2.0;
                               db[ipi]:=-T[i+(j-3)*inx];
                            end;
                      'W' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=2.0;
                               m[ipi].das:=0.0;
                               db[ipi]:=-T[i-2+(j-1)*inx];
                            end;
                      'E' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dae:=2.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=0.0;
                               db[ipi]:=-T[i+2+(j-1)*inx];
                            end;
                  end;
               end;
            end
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               ini:=i+j*inx;  // север
               isi:=i+(j-2)*inx; // юг
               iwi:=(i-1)+(j-1)*inx; // запад
               iei:=(i+1)+(j-1)*inx; // восток
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
               // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    3 : // верхний левый угол
                     begin
                          m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    4 : // верхний правый угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    5 : // пятиточечная звезда
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;

                          if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[isi]:=T[ini];
                        end
                         else
                        begin

                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;
                        end;
                     end;
                  end; // case
               end; // угловая точка
         end; // принадлежит границе расчётной области
      end; // with
   end;

end; // TempCoef

// Поячеечная сборка матрицы:
// TODO 8 августа 2013.
// Идея использования данного собирающего алгоритма.
// Только для граничных условий Неймана однородных и дирихле.
// Взять обычную сетку. Построить по ней nvtx. Собрать матрицу слау особого вида на основе nvtx.
// Проитерировать зейделем. На основе решения Зейделя вычлить модуль градиента и в местах большого
// модуля градиента произвести адаптацию nvtx, но так чтобы положения и привязки исходных узлов для
// связи с обычной сеткой полностью сохранились. Это нужно для отката на стандартную сетку.
// Далее для адаптированного nvtx снова произвести сборку матрицы и поэтерировать по зейделю.!!!
// Данная сборка матрицы хороша тем что позволяет строить локально измельчённые сетки.
procedure TForm1.TempCoefCell(var m : array of MatrixCoef;
                          var db : array of Float); // правая часть
var
    i,j : Integer; // счётчик
    k1,k2,k3,k4 : Integer; // вешины ячейки
    hx, hy : Float; // размеры ячейки дискретизации
    A : array [1..4] of array [1..4] of Float;
    lam12, lam13, lam24, lam34 : Float; // средняя теплопроводность внутри ячейки
    G : array [1..4] of Float;// вектор правой части
    C : array [1..4] of Float; // нестационарный вклад
    i1 : Integer;
    qb : Float; // значение теплового потока через границу
begin
   //  вся информация и о самом уравнении и о граничных условиях
   //  должна содержаться в матрице (m & db). В методе Гаусса - Зейделя
   // или методе Ричардсона -Либмана должно быть обращение только к
   // (m & db) и ни к чему другому.

   // После такой сборки на всех границах по умолчанию будут стоять однородные условия Неймана.

   //нужно осуществить прозход по всем ячейкам дискретизации
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         k1:=i+(j-1)*inx;
         k2:=(i+1)+(j-1)*inx;
         k3:=i+(j)*inx;
         k4:=(i+1)+(j)*inx;
         if ((mapPT[k1].itype<>0) and
             (mapPT[k2].itype<>0) and
             (mapPT[k3].itype<>0) and
             (mapPT[k4].itype<>0)) then
             begin
                // размеры ячейки
                hx:=xpos[i+1]-xpos[i];
                hy:=ypos[j+1]-ypos[j];
                // теплопроводность на гранях контрольного объёма
                lam12:=2*lambda[k1]*lambda[k2]/((lambda[k1]+lambda[k2]));
                lam13:=2*lambda[k1]*lambda[k3]/((lambda[k1]+lambda[k3]));
                lam24:=2*lambda[k2]*lambda[k4]/((lambda[k2]+lambda[k4]));
                lam34:=2*lambda[k3]*lambda[k4]/((lambda[k3]+lambda[k4]));
                for i1:=1 to 4 do C[i1]:=0.0; // обнуление
                if (btimedepend) then
                begin
                   // к контрольному объему
                   C[1]:=density(k1)*dcp*hx*hy/4; // k1  можно drho[k1], dcp[k1]
                   C[2]:=density(k2)*dcp*hx*hy/4; // k2  drho[k2], dcp[k2]
                   C[3]:=density(k3)*dcp*hx*hy/4; // k3  drho[k3], dcp[k3]
                   C[4]:=density(k4)*dcp*hx*hy/4; // k4  drho[k4], dcp[k4]
                end;
                // использование средней теплопроводности плохая идея,
                // лучше аппроксимировать теплопроводность для каждой грани отдельно.
                // аналогично и с источниковым членом.
                // формирование матрицы жёсткости А:
                // левая нижняя четвертинка контрольного объёма:
                A[1][1]:=lam12*hy/(2*hx)+lam13*hx/(2*hy); A[1][2]:=-lam12*hy/(2*hx);
                A[1][3]:=-lam13*hx/(2*hy); A[1][4]:=0.0;
                m[k1].dap:=m[k1].dap+A[1][1]+C[1]/dTimeStep;;
                m[k1].dae:=m[k1].dae-A[1][2]; // здесь вычитание, но
                m[k1].dan:=m[k1].dan-A[1][3]; // в матрице было бы сложение
                // правая нижняя четвертинка контрольного объёма:
                A[2][1]:=-lam12*hy/(2*hx); A[2][2]:=lam12*hy/(2*hx)+lam24*hx/(2*hy);
                A[2][3]:=0.0; A[2][4]:=-lam24*hx/(2*hy);
                m[k2].daw:=m[k2].daw-A[2][1]; // здесь вычитание, но
                m[k2].dap:=m[k2].dap+A[2][2]+C[2]/dTimeStep;;
                m[k2].dan:=m[k2].dan-A[2][4]; // в матрице было бы сложение
                // левая верхняя четвертинка контрольного объёма
                A[3][1]:=-lam13*hx/(2*hy); A[3][2]:=0.0;
                A[3][3]:=lam34*hy/(2*hx)+lam13*hx/(2*hy); A[3][4]:=-lam34*hy/(2*hx);
                m[k3].das:=m[k3].das-A[3][1]; // здесь вычитание, но
                m[k3].dap:=m[k3].dap+A[3][3]+C[3]/dTimeStep;;
                m[k3].dae:=m[k3].dae-A[3][4]; // в матрице было бы сложение
                // правая верхняя четвертинка контрольного объёма
                A[4][1]:=0.0; A[4][2]:=-lam24*hx/(2*hy);
                A[4][3]:=-lam34*hy/(2*hx); A[4][4]:=lam34*hy/(2*hx)+lam24*hx/(2*hy);
                m[k4].das:=m[k4].das-A[4][2]; // здесь вычитание, но
                m[k4].daw:=m[k4].daw-A[4][3]; // в матрице было бы сложение
                m[k4].dap:=m[k4].dap+A[4][4]+C[4]/dTimeStep;
                // вектор правой части:
                G[1]:=dSc[k1]*hx*hy/4;  // левый нижний
                db[k1]:=db[k1]+G[1]+C[1]*ToldTimeStep[k1]/dTimeStep;
                G[2]:=dSc[k2]*hx*hy/4;  // правый нижний
                db[k2]:=db[k2]+G[2]+C[2]*ToldTimeStep[k2]/dTimeStep;
                G[3]:=dSc[k3]*hx*hy/4;  // левый верхний
                db[k3]:=db[k3]+G[3]+C[3]*ToldTimeStep[k3]/dTimeStep;
                G[4]:=dSc[k4]*hx*hy/4;  // правый верхний
                db[k4]:=db[k4]+G[4]+C[4]*ToldTimeStep[k4]/dTimeStep;
             end;
      end;
   end;

   // В общем нужно учесть условия Дирихле.

   // алгоритм учёта краевых условий 2 и 3 рода
   // сначала проход по всем вертикальным рёбрам на границах,
   // потом проход по всем горизонтальным рёбрам на границах.
   // проход по всем вертикальным рёбрам на которых
   // поставлено краевое условие 2 или 3 рода
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         // введём локальную нумерацию точек
         k1:=i+(j-1)*inx;
         k2:=i+(j)*inx;
         if ((mapPT[k1].itype=2) and
             (mapPT[k2].itype=2)) then // вертикальная граница
             begin
                // нужно проверить поставлены ли
                // на данном ребре краевые условия
                // второго или третьего рода:
                if (GridGenForm.isneimanqb(mapPT[k1].iboundary, 'T', qb) and
                    GridGenForm.isneimanqb(mapPT[k2].iboundary, 'T', qb)) then
                    begin
                       // на ребре соединяющем точки k1 и k2
                       // поставлено краевое условие 2 или 3 рода
                       // TODO
                    end;
             end;
      end;
   end;

end; // TempCoefCell



// закрывает главное приложение
procedure TForm1.Close1Click(Sender: TObject);
begin
   OpenGLUnit.Timer1.Interval:=100000;
   OpenGLUnit.Close;

   // нужно освободить выделенную память перед
   // закрытием
   // освобождаем память выделенную под карты
   if (High(mapPT)>1) then SetLength(mapPT,1);
   if (High(mapVx)>1) then SetLength(mapVx,1);
   if (High(mapVy)>1) then SetLength(mapVy,1);
   // освобождаем память выделенную под функции
   if (High(T)>1) then SetLength(T,1);
   if (High(TOldIteration)>1) then SetLength(TOldIteration,1);
   if (High(TOldTimeStep)>1) then SetLength(TOldTimeStep,1);
   if (High(SF)>1) then SetLength(SF,1);
   if (High(Omega)>1) then SetLength(Omega,1);
   if (High(Vx)>1) then SetLength(Vx,1);
   if (High(Vy)>1) then SetLength(Vy,1);
   if (High(VxOld)>1) then SetLength(VxOld,1);
   if (High(VyOld)>1) then SetLength(VyOld,1);
   if (High(VxActing)>1) then SetLength(VxActing,1);
   if (High(VyActing)>1) then SetLength(VyActing,1);
   if (High(VxOldTimeStep)>1) then SetLength(VxOldTimeStep,1);
   if (High(VyOldTimeStep)>1) then SetLength(VyOldTimeStep,1);
   if (High(P)>1) then SetLength(P,1);
   if (High(Pamendment)>1) then SetLength(Pamendment,1);
   // для осреднённого вибрационного течения
   // функция тока
   if (High(meanSF)>1) then SetLength(meanSF,1);
   if (High(meanSF1T)>1) then SetLength(meanSF1T,1);
   if (High(meanSFGl)>1) then SetLength(meanSFGl,1);
   // вихрь
   if (High(meanOmega)>1) then SetLength(meanOmega,1);
   if (High(meanOmega1T)>1) then SetLength(meanOmega1T,1);
   if (High(meanOmegaGl)>1) then SetLength(meanOmegaGl,1);
   // температура
   if (High(meanT1T)>1) then SetLength(meanT1T,1);
   if (High(meanTGl)>1) then SetLength(meanTGl,1);
   if (High(meanT)>1) then SetLength(meanT,1);
   // горизонтальная скорость
   if (High(meanVx1T)>1) then SetLength(meanVx1T,1);
   if (High(meanVxGl)>1) then SetLength(meanVxGl,1);
   if (High(meanVx)>1) then SetLength(meanVx,1);
   // вертикальная скорость
   if (High(meanVy1T)>1) then SetLength(meanVy1T,1);
   if (High(meanVyGl)>1) then SetLength(meanVyGl,1);
   if (High(meanVy)>1) then SetLength(meanVy,1);
   // VOF метод
   if (High(VOF)>1) then SetLength(VOF,1);
   if (High(VOFOldTimeStep)>1) then SetLength(VOFOldTimeStep,1);
   if (High(DensityOldTimeStep)>1) then SetLength(DensityOldTimeStep,1);
   // освобождение сеточных мвассивов
   if (High(xpos)>1) then SetLength(xpos,1);
   if (High(ypos)>1) then SetLength(ypos,1);
   if (High(yposfix)>1) then SetLength(yposfix,1);
   inx:=0;
   iny:=0;
   fanimationtecplot.Free; // освобождение памяти.

   Application.MessageBox('память освобождена','память освобождена',MB_OK);


   Close; // закрывает главное приложение
end;

// прорисовывает расчётную сетку
procedure TForm1.Mesh2Click(Sender: TObject);
begin
    with DisplayForm do
    begin
         Show;  // отображает форму
         iwhotvisible:=1; // прорисовка сетки
         displaymesh; // вызывает метод прорисовки расчётной сетки
    end;
end;

// вызывает визуализатор для функции D
procedure TForm1.myDisp;
var
  iselect : Integer; // способ интерполяции
begin


    // эта штука определяет нужна ли интерполяция
    // и если нужна то какая именно
    iselect:=InterpolateCaseForm.RadioGroup1.ItemIndex;
    case iselect of
     0 : begin
            // без интерполяции
            with DisplayForm do
            begin
               Show;  // отображает форму
               iwhotvisible:=2;
               displayTempreture; // вызывает прорисовку поля температур
            end;
                  // Здесь также была интерполяция биоинейным и бикубическим сплайном,
                  // но только на равномерных сетках. (оставим для совместимости с предыдущим кодом).
                  (*
                    // интерполяция пока не работает на неравномерных сетках
                   1 : begin
                          b13:=false; // бикубический сплайн
                          iwhotvisible:=3;
                          displayTempreturebicubicsplane;
                       end;
                   2 : begin
                          b13:=true; // билинейный сплайн
                          iwhotvisible:=4;
                          displayTempreturebicubicsplane;
                       end;
                  *)
         end;
     1 : // OpenGL
         begin
            OpenGLUnit.Show;
         end;
    end; // case


end;  // myDisp


// загружает основной тест
// программного комплекса МАРЕНА
// загрузка должна производится только после генерации сетки
procedure TForm1.MARENAtest1Click(Sender: TObject);
begin
   MARENAload;
   // сообщает о том что загрузка тестового примера МАРЕНА
   // успешно завершена
   Application.MessageBox('тест МАРЕНА успешно загружен','',MB_OK);
end;  // загружает МАРЕНА тест


// загружает основной тест
// программного комплекса МАРЕНА
// загрузка должна производится только после генерации сетки
// эти функции можно использовать для инициализации
// всех обрабатываемых матриц.
procedure TForm1.MARENAload;
const
    MPI=3.141; // число ПИ
var
   i,j : Integer;

function F1(x, y : Float) : Float; // правая часть
var
   r : Float;
begin
  r:=8*(cos(2*MPI*y)*(cos(2*MPI*x)-power(sin(MPI*x),2))-cos(2*MPI*x)*power(sin(MPI*y),2));
  r:=r-power(sin(MPI*x)*sin(2*MPI*x),2)*sin(4*MPI*y);
  r:=r+power(sin(MPI*y)*sin(2*MPI*y),2)*sin(4*MPI*x);
  r:=r*power(MPI,4);
  Result:=r;
end; // F1

function F2(x, y : Float) : Float; // функция тока
var
   r : Float;
begin
  r:=power(sin(MPI*x)*sin(MPI*y),2);
  Result:=r;
end;  // F2

function F3(x, y : Float) : Float; // вихрь
var
   r : Float;
begin
  r:=-2*power(MPI,2)*(cos(2*MPI*x)*power(sin(MPI*y),2)+cos(2*MPI*y)*power(sin(MPI*x),2));
  Result:=r;
end;  // F3

function F4(x, y : Float) : Float; // горизонтальная компонента скорости
var
   r : Float;
begin
  r:=2*MPI*power(sin(MPI*x),2)*sin(MPI*y)*cos(MPI*y);
  Result:=r;
end; // F4

function F5(x, y : Float) : Float; // вертикальная компонента скорости
var
   r : Float;
begin
  r:=-2*MPI*power(sin(MPI*y),2)*cos(MPI*x)*sin(MPI*x);
  Result:=r;
end; // F5

begin
   // выделение памяти под расчитываемые матрицы
   SetLength(dSc,mzapas*inx*iny+1);
   SetLength(SF,mzapas*inx*iny+1);
   SetLength(Omega,mzapas*inx*iny+1);
   SetLength(Vx,mzapas*(inx-1)*iny+1); // на смещённой по горизонтали сетке
   SetLength(Vy,mzapas*inx*(iny-1)+1); // на смещённой по горизонтали сетке
   SetLength(P,mzapas*inx*iny+1); // давление
   SetLength(Pamendment,mzapas*inx*iny+1); // поправка давления
   // Здесь нехватает давления и температуры.
   for i:=1 to inx do
   begin
     for j:=1 to iny do
     begin
        // Правая часть
        dSc[i+(j-1)*inx]:=F1(xpos[i],ypos[j]);
        // функция тока
        SF[i+(j-1)*inx]:=F2(xpos[i],ypos[j]);
        // вихрь
        Omega[i+(j-1)*inx]:=F3(xpos[i],ypos[j]);
        // давление
        P[i+(j-1)*inx]:=0.0;
        // поправка давления
        Pamendment[i+(j-1)*inx]:=0.0;
     end;
   end;
   // Загрузка горизонтальной компоненты скорости
   for i:=1 to inx-1 do
   begin
      for j:=1 to iny do
      begin
         // горизонтальная компонента скорости
         // грани контрольных объёмов находятся по середине между узлами
         // расчётной сетки
         // по оси x точек на одну меньше !
         Vx[i+(j-1)*(inx-1)]:=F4(0.5*(xpos[i]+xpos[i+1]),ypos[j]);
      end;
   end;
   // Загрузка вертикальной компоненты скорости
   for i:=1 to inx do
   begin
      for j:=1 to iny-1 do
      begin
         // горизонтальная компонента скорости
         // грани контрольных объёмов находятся по середине между узлами
         // расчётной сетки
         Vy[i+(j-1)*inx]:=F5(xpos[i],0.5*(ypos[j]+ypos[j+1]));
      end;
   end;
end; // MARENAload

// универсальная функция визуализации
// основная сетка
procedure TForm1.DisplayUniversalInternal(ival : Integer; bonlyupdateD : Boolean);
var
   i, j, k : Integer;
   dfe, ux, uy : Float; // для учёта неравномерности сетки
   ubuf1, ubuf2 : array of Float; // для градиентов температуры по х и у.
   minD, maxD, hD : Float; // минимальное и максимальное значение функции.
begin
    // Визуализируемая величина определяется
    // параметром ival:
    // 1 - поле температур,
    // 2 - горизонтальная компонента скорости,
    // 3 - вертикальная компонента скорости, 4 - вихрь,
    // 5 - функцию тока, 6 - поправка давления,
    // 7 - давление, 8 - источниковый член уравнения теплопроводности,
    // 9 - модуль скорости, 10 производная от температуры по х,
    // 11 - производная от температуры по у, 12 - модуль градиента температуры.
    // 13 - VOF, 14 - UDS1, 15 - UDS2, 16 - UDS3, 17 - UDS4, 18 - UDS1 and UDS2.
    // 19 - UDS1, UDS2, UDS3.
    if (ival<18) then
    begin
    SetLength(D,inx*iny+1);
    SetLength(D2,0); // по признаку D2=nil можно проверить что выводить нужно лишь одну функцию.
    SetLength(D3,0);
    SetLength(ubuf1,inx*iny+1);
    universalgradx_mapPT(T,ubuf1);
    SetLength(ubuf2,inx*iny+1);
    universalgrady_mapPT(T,ubuf2);

    case ival of
    1 :  OpenGLUnit.GroupBox1.Caption:='Temperature, K';
    2 :  OpenGLUnit.GroupBox1.Caption:='x-velocity, m/s';
    3 :  OpenGLUnit.GroupBox1.Caption:='y-velocity, m/s';
    4 :  OpenGLUnit.GroupBox1.Caption:='Curl, 1/s';
    5 :  OpenGLUnit.GroupBox1.Caption:='Stream Function, m!2/s';
    6 :  OpenGLUnit.GroupBox1.Caption:='Amendment Pressure, Pa';
    7 :  OpenGLUnit.GroupBox1.Caption:='Pressure, Pa';
    8 :  OpenGLUnit.GroupBox1.Caption:='Sc temperature, W/m!2';
    9 :  OpenGLUnit.GroupBox1.Caption:='velocity magnitude, m/s';
    10 : OpenGLUnit.GroupBox1.Caption:='grad x temperature, K/m';
    11 : OpenGLUnit.GroupBox1.Caption:='grad y temperature, K/m';
    12 : OpenGLUnit.GroupBox1.Caption:='magnitude grad temperature, K/m';
    13 :  OpenGLUnit.GroupBox1.Caption:='VOF';
    14 :  OpenGLUnit.GroupBox1.Caption:='UDS1';
    15 :  OpenGLUnit.GroupBox1.Caption:='UDS2';
    16 :  OpenGLUnit.GroupBox1.Caption:='UDS3';
    17 :  OpenGLUnit.GroupBox1.Caption:='UDS4';
    18 :  OpenGLUnit.GroupBox1.Caption:='';
    19 :  OpenGLUnit.GroupBox1.Caption:='';
    end;


    for i:=1 to inx do
    begin
       for j:=1 to iny do
       begin
          case ival of
            1 : // поле температур при его наличии.
                begin
                if ((imodelEquation=1) or (imodelEquation=4)) then
                begin
                   D[i+(j-1)*inx]:=T[i+(j-1)*inx];
                end
                 else
                begin
                   D[i+(j-1)*inx]:=0.0;
                end;

                end;
            2 : // горизонтальная компонента скорости
                begin

                   if (i=1) then
                   begin
                      D[i+(j-1)*inx]:=Vx[1+(j-1)*(inx-1)];
                   end
                   else
                   if (i=inx) then
                   begin
                      D[i+(j-1)*inx]:=Vx[(inx-1)+(j-1)*(inx-1)];
                   end
                   else
                   begin
                      // используется линейная интерполяция
                      // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                      // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                      dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                      if ((i<>1) and (i<>inx)) then
                      begin
                         D[i+(j-1)*inx]:=dfe*Vx[(i-1)+(j-1)*(inx-1)] + (1-dfe)*Vx[i+(j-1)*(inx-1)];
                      end;
                   end;
                end;
            3 : // вертикальная компонента скорости
                begin

                   if (j=1) then
                   begin
                      D[i+(j-1)*inx]:=Vy[i];
                   end
                   else if (j=iny) then
                   begin
                      D[i+(j-1)*inx]:=Vy[i+(iny-2)*inx];
                   end
                    else
                   begin
                      // линейная интерполяция
                      // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                      // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                      dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                      if ((j<>1) and (j<>iny)) then
                      begin
                         D[i+(j-1)*inx]:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
                      end;
                   end;
                end;
            4 : begin
                    D[i+(j-1)*inx]:=Omega[i+(j-1)*inx];  // вихрь
                end;
            5 : D[i+(j-1)*inx]:=SF[i+(j-1)*inx]; // функция тока
            6 : D[i+(j-1)*inx]:=Pamendment[i+(j-1)*inx];  // поправка давления
            7 : D[i+(j-1)*inx]:=P[i+(j-1)*inx];  // давление
            8 : D[i+(j-1)*inx]:=dSc[i+(j-1)*inx];  // источниковый член в уравнении для температуры
            9 : begin
                   //  горизонтальная компонента скорости.
                   if (i=1) then
                   begin
                      ux:=Vx[1+(j-1)*(inx-1)];
                   end
                   else
                   if (i=inx) then
                   begin
                      ux:=Vx[(inx-1)+(j-1)*(inx-1)];
                   end
                   else
                   begin
                      // используется линейная интерполяция
                      // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                      // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                      dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                      if ((i<>1) and (i<>inx)) then
                      begin
                         ux:=dfe*Vx[(i-1)+(j-1)*(inx-1)] + (1-dfe)*Vx[i+(j-1)*(inx-1)];
                      end;
                   end;
                    // Вертикальная компонента скорости.
                     if (j=1) then
                   begin
                      uy:=Vy[i];
                   end
                   else if (j=iny) then
                   begin
                      uy:=Vy[i+(iny-2)*inx];
                   end
                    else
                   begin
                      // линейная интерполяция
                      // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                      // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                      dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                      if ((j<>1) and (j<>iny)) then
                      begin
                         uy:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
                      end;
                   end;
                    D[i+(j-1)*inx]:=sqrt(ux*ux+uy*uy);
                end;
                // Мы расширяем наши представления о физике происходящего
                // имея возможность наблюдать как изменяется тепловой поток.
            10 : begin
                    // градиент температуры по х
                    D[i+(j-1)*inx]:=ubuf1[i+(j-1)*inx];
                 end;
            11 : begin
                    // градиент температуры по y
                    D[i+(j-1)*inx]:=ubuf2[i+(j-1)*inx];
                 end;
            12 : begin
                    // модуль градиента температуры.
                    D[i+(j-1)*inx]:=sqrt(sqr(ubuf1[i+(j-1)*inx])+sqr(ubuf2[i+(j-1)*inx]));
                 end;
            13 : D[i+(j-1)*inx]:=VOF[i+(j-1)*inx]; // Функция цвета.
            14 : D[i+(j-1)*inx]:=UDS1[i+(j-1)*inx];
            15 : D[i+(j-1)*inx]:=UDS2[i+(j-1)*inx];
            16 : D[i+(j-1)*inx]:=UDS3[i+(j-1)*inx];
            17 : D[i+(j-1)*inx]:=UDS4[i+(j-1)*inx];
          end;
       end;
    end;
    SetLength(ubuf1,0);
    SetLength(ubuf2,0);
    end;
    if (ival=18) then
    begin
       // прорисовка сразу двух UDS.
       SetLength(D, inx*iny+1);
       SetLength(D2,inx*iny+1);
       SetLength(D3,0);
       for i:=1 to inx do
       begin
          for j:=1 to iny do
          begin
              D[i+(j-1)*inx]:= UDS1[i+(j-1)*inx];
              D2[i+(j-1)*inx]:=UDS2[i+(j-1)*inx];
          end;
       end;
    end;
    if (ival=19) then
    begin
       // прорисовка сразу трёх UDS.
       SetLength(D, inx*iny+1);
       SetLength(D2,inx*iny+1);
       SetLength(D3,inx*iny+1);
       for i:=1 to inx do
       begin
          for j:=1 to iny do
          begin
             D[i+(j-1)*inx]:=UDS1[i+(j-1)*inx];
             D2[i+(j-1)*inx]:=UDS2[i+(j-1)*inx];
             D3[i+(j-1)*inx]:=UDS3[i+(j-1)*inx];
          end;
       end;
    end;

    maxD:=-1e+300;
    minD:=1e+300;

     for k:=1 to imaxnumbernode do
         begin
            if ((mapPT[k].i < inx) and (mapPT[k].j < iny)) then
            begin
               if ((GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[k].i+1+(mapPT[k].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[k].i+1+(mapPT[k].j)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j)*inx].itypenode > 0)) then
                 begin
                    if (D[k]>maxD) then maxD:=D[k];
                    if (D[k]<minD) then minD:=D[k];
                 end;
            end;
       end;

      hD:=(maxD-minD)/19.0;
      OpenGLUnit.Label1.Caption:=FormatFloat('#.##e-0',maxD);
      OpenGLUnit.Label2.Caption:=FormatFloat('#.##e-0',minD+18.0*hD);
      OpenGLUnit.Label3.Caption:=FormatFloat('#.##e-0',minD+17.0*hD);
      OpenGLUnit.Label4.Caption:=FormatFloat('#.##e-0',minD+16.0*hD);
      OpenGLUnit.Label5.Caption:=FormatFloat('#.##e-0',minD+15.0*hD);
      OpenGLUnit.Label6.Caption:=FormatFloat('#.##e-0',minD+14.0*hD);
      OpenGLUnit.Label7.Caption:=FormatFloat('#.##e-0',minD+13.0*hD);
      OpenGLUnit.Label8.Caption:=FormatFloat('#.##e-0',minD+12.0*hD);
      OpenGLUnit.Label9.Caption:=FormatFloat('#.##e-0',minD+11.0*hD);
      OpenGLUnit.Label10.Caption:=FormatFloat('#.##e-0',minD+10.0*hD);
      OpenGLUnit.Label11.Caption:=FormatFloat('#.##e-0',minD+9.0*hD);
      OpenGLUnit.Label12.Caption:=FormatFloat('#.##e-0',minD+8.0*hD);
      OpenGLUnit.Label13.Caption:=FormatFloat('#.##e-0',minD+7.0*hD);
      OpenGLUnit.Label14.Caption:=FormatFloat('#.##e-0',minD+6.0*hD);
      OpenGLUnit.Label15.Caption:=FormatFloat('#.##e-0',minD+5.0*hD);
      OpenGLUnit.Label16.Caption:=FormatFloat('#.##e-0',minD+4.0*hD);
      OpenGLUnit.Label17.Caption:=FormatFloat('#.##e-0',minD+3.0*hD);
      OpenGLUnit.Label18.Caption:=FormatFloat('#.##e-0',minD+2.0*hD);
      OpenGLUnit.Label19.Caption:=FormatFloat('#.##e-0',minD+hD);
      OpenGLUnit.Label20.Caption:=FormatFloat('#.##e-0',minD);

    if (not(bonlyupdateD)) then
    begin
        myDisp;
    end;
end; // DisplayUniversalInternal

// восстановление вихря с интерполяцией на основную сетку
// здесь требуется выполнить операции дифференцирования
// для компонент скорости с учётом шахматной (разнесённой) сетки.
procedure TForm1.CurlConstruct;
var
    i,j : Integer; // счётчики
    rbuf : Float; // временное хранилище
    CurlBuf : array of Float; // временное хранилище для вихря на другой сетке
begin
   // выделение оперативной памяти
   SetLength(CurlBuf, (inx-1)*(iny-1) + 1);
   // обнуление вихря
   CurlBuf[0]:=0.0;
   for i:=1 to (inx - 1) do
   begin
      for j:=1 to (iny - 1) do
      begin
         CurlBuf[i+(j-1)*(inx-1)]:=0.0;
      end;
   end;
   // CurlBuf = diff(Vy,x) - diff(Vx,y);
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         // rbuf := diff(Vy,x);
         rbuf:= (Vy[(i+1)+(j-1)*inx] - Vy[i+(j-1)*inx])/(xpos[i+1] - xpos[i]);
         // rbuf := rbuf - diff(Vx,y);
         rbuf:=rbuf - (Vx[i+(j-1+1)*(inx-1)]-Vx[i+(j-1)*(inx-1)])/(ypos[j+1]-ypos[j]);
         // CurlBuf = diff(Vy,x) - diff(Vx,y);
         CurlBuf[i+(j-1)*(inx-1)]:=rbuf;
      end;
   end;
   // восстановление на основную сетку
   // путём интерполяции

   // для внутренних точек расчётной области
   for i:=2 to (inx-1) do
   begin
      for j:=2 to (iny-1) do
      begin
         Omega[i+(j-1)*inx]:=0.25*(CurlBuf[(i-1)+(j-1-1)*(inx-1)]+CurlBuf[(i-1)+(j-1)*(inx-1)]+CurlBuf[i+(j-1-1)*(inx-1)]+CurlBuf[i+(j-1)*(inx-1)]);
      end;
   end;
   // левая и правая граница
   for j:=2 to (iny-1) do
   begin
      // левая граница
      i:=1;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[i+(j-1-1)*(inx-1)]+CurlBuf[i+(j-1)*(inx-1)]);
      // правая граница
      i:=inx;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[(i-1)+(j-1-1)*(inx-1)]+CurlBuf[(i-1)+(j-1)*(inx-1)]);
   end;
   // нижняя и верхние границы
   for i:=2 to (inx-1) do
   begin
      // нижняя граница
      j:=1;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[(i-1)+(j-1)*(inx-1)]+CurlBuf[i+(j-1)*(inx-1)]);
      // верхняя граница
      j:=iny;
      Omega[i+(j-1)*inx]:=0.5*(CurlBuf[(i-1)+(j-1-1)*(inx-1)]+CurlBuf[i+(j-1-1)*(inx-1)]);
   end;
   // угловые точки
   // левый нижний угол
   i:=1; j:=1;
   Omega[i+(j-1)*inx]:=CurlBuf[i+(j-1)*(inx-1)];
   // правый нижний угол
   i:=inx; j:=1;
   Omega[i+(j-1)*inx]:=CurlBuf[(i-1)+(j-1)*(inx-1)];
   // правый верхний угол
   i:=inx; j:=iny;
   Omega[i+(j-1)*inx]:=CurlBuf[(i-1)+(j-1-1)*(inx-1)];
   // левый верхний угол
   i:=1; j:=iny;
   Omega[i+(j-1)*inx]:=CurlBuf[i+(j-1-1)*(inx-1)];
   // освобождение оперативной памяти
   Finalize(CurlBuf);
   // домножение на минус 1: *(-1)
   for i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         Omega[i+(j-1)*inx]:= (-1)*Omega[i+(j-1)*inx];
      end;
   end;

end; // CurlConstruct

// генеральные настройки
procedure TForm1.myGeneraltune;
begin
   // инициализирует форму
   if (btimedepend) then // нестационарный
   begin
      General.RadioGroup1.ItemIndex:=1;
   end
    else // стационарный
   begin
      General.RadioGroup1.ItemIndex:=0;
   end;
   // показывает форму
   General.ShowModal; // вызывает форму где задаются параметры солвера
   myInitializationRestart; // всё придётся инициализировать заново: выделение памяти и присвоение значений.
end;

// форма параметров солвера
procedure TForm1.General1Click(Sender: TObject);
begin
   // главные параметры солвера:
   // стационарный и нестационарный
   myGeneraltune;
end;

// Щас реализуется возможность приостановки и последующего
// продолжения вычисления с остановленного места. Это приводит
// к необходимости в случае малейших изменений, например в граничных условиях, производить
// инициализацию решения заново. Иначе новые граничные условия не будут учтены.
procedure TForm1.myInitializationRestart;
var
    i : Integer; // внутренний счётчик.
begin
   // 1 - чистая теплопроводность,
   // 2 - теплопроводность с учётом конвективного члена,
   // 3 - чистый Навье-Стокс, 4 - Навье-Стокс с учётом теплопроводности.
   // 5 - VOF метод.
   // говорит о том что перед началом счёта требуется
   // инициализировать искомые величины и выделить под их хранение память.
   for i:=1 to 5 do bweShouldInitialize[i]:=true;
end;

// некоторые параметры требуется инициализировать непосредственно
// сразу после создания формы приложения
procedure TForm1.FormCreate(Sender: TObject);
var
   dx, dy : Float; // равномерные шаги сетки
   i : Integer; // Счётчики

begin
   // Такое вычисление оптимального параметра релаксации предложено в работе Ильина (книга по ЧМА 1985).
   bIlyin:=true; // false - не вычислять оптимальный параметр верхней релаксации. (true вычислять).
   bIlyinvel:=true; // для компонент скорости автоматический подбор параметра верхней релаксации.
   relaxIlyin:=1.0;

   // масштаб длины при выводе в Tecplot:
   lengthscaleplot.xscale:=1.0;
   lengthscaleplot.yscale:=1.0;


   // показ анимации прямо во время вычислений.
   // При этом мониторинг вычислений не производится.
   banimationnow:=True;

   brealisticflow:=false;
   brealistictemperature:=false;
   // При включённом ISezai во многих задачах с большим ренольдсом
   // имеем расходимость.
   bISezai:=true;//False; // увеличение реалистичности в ущерб сходимости.
   bGarberArtDiffusion:=True; // искусственная диффузия предложенная в статье Г.З. Гарбера.

   // мы будем осуществлять запись анимации в текстовый файл.
   fanimationtecplot:=TStringList.Create();
   // запись анимационных кадров каждый шаг по времени.
   ianimateeverytimestep:=1;
   // Если расчётная сетка сгенерирована и границы занесены в список то
   // bcreateboundary=True, а если генерация сетки ещё не произведена то
   // список границ не сформирован и нельзя вызывать форму задания граничных условий.
   bcreateboundary:=False;

   bNICENO:=False; // не использовать EasyMesh или использовать.

   // Дополнение для физики полупроводников и не только.
   imaxUDS:=0; // нет User-Defined Scalar`ов
   imaxUDM:=0; // нет User-Defined Memory.

   // Вещественный параметр характеризующий уникальность поллескоростной характеристики кремния.
   ruds_silicon:=0.7; // параметр очень важен и используется для ускорения вычислений.
   // Два вещественных параметра указывающие уникальность полескоростной характеристики GaAs :
   ruds_GaAs_top:=2.830713727e-8;
   ruds_GaAs_bottom:=5.785855354e-10;

   // Источниковый член в первом уравнении для диффузионно-дрейфовой модели имеет стандартную форму и это надо
   // учесть для увеличения Быстродействия. ДДМ очень важна поэтому имеет смысл прилагать все усилия чтобы она быстро считала.
   // 0 - стандартный user-defined шаблон.
   // 1 - источниковый член в диффузионно дрейфовой модели (из двух уравнений первое для электрического потенциала, для
   // этого уравнения как раз и задаётся источниковый член, а второе уравнение для переноса электронного газа (именно электронного)).
   // вида K1*(1.0-$uds2), где K1=rdsc1K1 - заданная пользователем постоянная.
   // 2 - аналогично с 1 но источник имеет вид $udm1-K1*$uds2, здесь $udm1 - неоднородное легирование,
   // $uds2 - концентрация электронов, K1=rdsc1K1 - константа определённая пользователем.
   idsc1type:=0;
   rdsc1K1:=0.0;
   // Следующая булева переменная равна True только тогда когда в момент вычисления
   // для первого уравнения имеем константу dSpравную нулю тождественно, и константный коэффициент диффузии.
   // Значение True проверяется и в случае необходимости присваивается внутри simple algorithm`a
   // в ручную значение False здесь менять ни в коем случае нельзя !!!
   buds1coefconst:=False;
   diffuds1const:=1.0; // константный коэффициент диффузии для первого уравнения во всей расчётной области,
   // используется только при buds1coefconst=true;

   // Конвективный член пока полностью выключен (отсутствует).
   itypemassFluxuds1:=0; // 0 нет конвективного члена (он тождественный ноль)
   itypemassFluxuds2:=0; // 1 - стандартный конвективный член на основе гидродинамических компонент скорости.
   itypemassFluxuds3:=0; // 2 - определённый пользователем вариант.
   itypemassFluxuds4:=0;
   // Буссинесковская сила всплытия в которой роль температуры играет соответсвующая UDS.
   // подстёгивается к гидродинамическому солверу на шахматных сетках.
   // По умолчанию все эти силы выключены!!!
   dbetaUDS1:=0.0;
   dbetaUDS2:=0.0;
   dbetaUDS3:=0.0;
   dbetaUDS4:=0.0;

   // Для конвективного члена определённого пользователем.
   // определяются на сетке для компонент скорости.
   // Можно использовать переменные :
   // $x и $y - декартовы координаты.
   // для горизонтальных скоростей можно использовать $gradxuds1, $gradxuds2, $gradxuds3.
   // для вертикальных скоростей можно использовать переменные $gradyuds1, $gradyuds2, $gradyuds3.
   Vxuds1str:='0.0';
   Vyuds1str:='0.0';
   Vxuds2str:='0.0';
   Vyuds2str:='0.0';
   Vxuds3str:='0.0';
   Vyuds3str:='0.0';
   Vxuds4str:='0.0';
   Vyuds4str:='0.0';
   // Нестационарный член :
   itypeuds1unsteadyfunction:=0; // 0 - стационарная задача.
   itypeuds2unsteadyfunction:=0; // 1 - стандартная нестационарная задача.
   itypeuds3unsteadyfunction:=0;
   itypeuds4unsteadyfunction:=0;
   // Постоянные коэффициенты диффузии :
   gamma1str:='1.0';
   gamma2str:='1.0';
   gamma3str:='1.0';
   gamma4str:='1.0';
   // тип Решающего устройства
   // 1 - поточечный метод Гаусса-Зейделя.
   itypesolver.iuds1:=1;
   itypesolver.iuds2:=1;
   itypesolver.iuds3:=1;
   itypesolver.iuds4:=1;
   // контроль сходимости
   // вычислительного процесса
   rcs.uds1:=1.0e-9;
   rcs.uds2:=1.0e-9;
   rcs.uds3:=1.0e-9;
   rcs.uds4:=1.0e-9;
   // Плотность.
   // 0 - константа равная единице (потом можно сделать константу задаваемую пользователем),
   // гидродинамическая плотность задаваемая пользователем для гидродинамики в частности и для VOF метода.
   iuds1typerho:=0;
   iuds2typerho:=0;
   iuds3typerho:=0;
   iuds4typerho:=0;
   // Записано ли уравнение для User-Defined Scalar`a на маске или нет.
   // Узлы не принадлежащие маске заморожены в момент инициализации.
   imaskuds1:=0; // рассчитывать ли uds1 используюя маску 0 - нет (вся расчётная область), 1 - использовать маску.
   imaskuds2:=0; // по умолчанию вся расчётная область.
   imaskuds3:=0;
   imaskuds4:=0;
   // параметризованная постоянная составляющая источникового члена:
   dsc1str:='0.0';
   dsc2str:='0.0';
   dsc3str:='0.0';
   dsc4str:='0.0';
   dsp1str:='0.0';
   dsp2str:='0.0';
   dsp3str:='0.0';
   dsp4str:='0.0';
   // Началные значения :
   InitVal.UDS1Init:='0.0';
   InitVal.UDS2Init:='0.0';
   InitVal.UDS3Init:='0.0';
   InitVal.UDS4Init:='0.0';
   // Схема аппроксимации для UDS.
   ishconv1:=6; // схема Булгакова.
   ishconv2:=6; // схема Булгакова.
   ishconv3:=6; // схема Булгакова.
   ishconv4:=6; // схема Булгакова.

   // Пределы изменения каждой из UDS.
   // Возможно позволит решить проблемы сходимости для систем нелинейных уравнений.
   sollimuds1min:=-1.0e30;
   sollimuds1max:=+1.0e30;
   sollimuds2min:=-1.0e30;
   sollimuds2max:=+1.0e30;
   sollimuds3min:=-1.0e30;
   sollimuds3max:=+1.0e30;
   sollimuds4min:=-1.0e30;
   sollimuds4max:=+1.0e30;

   inumCFF:=0; // количество активных пользовательских функций.
   cff1str:='0.0';     // пользовательские функции всего не более 10
   cff2str:='0.0';
   cff3str:='0.0';
   cff4str:='0.0';
   cff5str:='0.0';
   cff6str:='0.0';
   cff7str:='0.0';
   cff8str:='0.0';
   cff9str:='0.0';
   cff10str:='0.0';
   cff1name:='custom-function-1';     // имена пользовательских функций всего не более 10
   cff2name:='custom-function-2';
   cff3name:='custom-function-3';
   cff4name:='custom-function-4';
   cff5name:='custom-function-5';
   cff6name:='custom-function-6';
   cff7name:='custom-function-7';
   cff8name:='custom-function-8';
   cff9name:='custom-function-9';
   cff10name:='custom-function-10';


   // Основная программа.
   sFedor.q:=5;
   sFedor.inxc:=0;
   sFedor.inyc:=0;
   sFedor.bready:=False; // Алгоритм Федоренко не готов !!!

   TreeView1.FullExpand; // полностью раскрыть дерево
   ilanguage:=0; // 0 - Паскаль.
   ig_nNumberOfThreads:=1; // один поток.
   // для исследования сходимости
   // гидродинамических алгоритмов
   freport:=TStringList.Create();
   // сгенерируем сетку по умолчанию
   // равномерная 10 на 10
   // это нужно для того чтобы не было сбоев
   // при попытке сразу запустить расчёт на выполнение.
   dLx:=1; // ширина области
   dLy:=1; // высота области
   inx:=60; // 60 узлов по горизонтали
   iny:=60; // 60 узлов по вертикали
   dx:=dLx/(inx-1);
   dy:=dLy/(iny-1);
   SetLength(xpos,inx+1); // выделение памяти
   for i:=1 to inx do
   begin
     xpos[i]:=0+(i-1)*dx;
   end;
   SetLength(ypos,iny+1); // выделение памяти
   for i:=1 to iny do
   begin
      ypos[i]:=0+(i-1)*dy;
   end;
   // инициализация всех обрабатываемых матриц
   // включая выделение памяти
   MARENAload; // начальные значения полевых величин
   // выделение памяти и инициализация поля температур
   SetLength(T,inx*iny+1);
   for i:=0 to inx*iny do T[i]:=0.0;
   SetLength(VOF,inx*iny+1);
   for i:=0 to inx*iny do VOF[i]:=0.0; // всё занято первой жидкостью
   myInitializationRestart; // всё придётся инициализировать заново: выделение памяти и присвоение значений.
   // параметры относящиеся к управлению
   // солвером
   bsimplec:=false; // по умолчанию применяется алгоритм SIMPLE.
   bsimpler:=false; // по умолчанию применяется алгоритм SIMPLE.
   //ishconv:=4; // схема со степенным законом рекомендуемая С. Патанкаром
   ishconv:=6; // схема Булгакова.
   ishconvtemp:=6; // схема Булгакова.
   ishconvvof:=1011; // SUPERBEE
   imodelEquation:=3; // чистая гидродинамика по умолчанию.
   // выбор типа солвера для каждого из уравнений в отдельности
   itypesolver.itemperature:=1; // 1- GZ; 2 - переменных направлений; // метод Сопряжённых Градиентов
   itypesolver.ivelocity:=1; // 1 - GZ; 2 - переменных направлений;//по умолчанию метод переменных направлений
   itypesolver.ipamendment:=1; // 1 - Солвер Гаусса - Зейделя
   itypesolver.istreamfunction:=1; // по умолчанию переменных направлений
   itypesolver.ivof:=1;
   // 1,2,3,4,5,10,15,20,25,50,100,200, OFF.
   iantidiffusionBuragoevery:=High(Integer); // через сколько шагов по времени применять антидиффузионную корекцию.
   // разреженность матрицы всегда учитывается на основе CRS формата хранения.
   // алгоритм сортировки в методе сопряжённых градиентов на основе CRS.
   itypesorter:=2; // по умолчанию пирамидальная сортировка как экономичная по памяти.
   // какую норму использовать
   // 1 - евклидова, 2 - кубическая норма, 3 - октаэдрическая норма.
   ibasenorma:=1; // по умолчанию евклидова норма.
   // контроль сходимости
   // вычислительного процесса
   rcs.temp:=1e-19; // пороговое значение невязки по температуре
   rcs.Vx:=1e-15; // отклонение при преодолении нелинейности для горизонтальной скорости
   rcs.Vy:=1e-15; // отклонение при преодолении нелинейности для вертикальной скорости
   rcs.Pamendment:=1e-19; // пороговое значение невязки для поправки давления
   rcs.continity:=1e-16; // пороговое значение невязки для несбалансированных источников массы
   rcs.streamfunction:=1e-17; // пороговое значение невязки для функции тока
   rcs.Pressure:=1e-19; // пороговое значение невязки для давления
   rcs.vof:=1.0e-18; // пороговое значение невязки для функции цвета.
   // параметры релаксации
   // для алгоритма SIMPLE
   myrelaxfactors.Momentum:=0.7; // для уравнения сохранения импульса
   myrelaxfactors.PressureRelax:=0.3; // для давления
   // для SOR в уравнении для поправки давления.
   myrelaxfactors.pSORPressure:=1.0; // по умолчанию SOR (значение 1.855 подобрано для задачи течения внутри изотермической каверны).
   myrelaxfactors.pSORpresr:=1.0; // для давления в алгоритме SIMPLER
   myrelaxfactors.pSORTempreture:=1.0; // для поля температур
   myrelaxfactors.uds1:=1.0; // нижняя релаксация для user-defined scalar
   myrelaxfactors.uds2:=1.0; //
   myrelaxfactors.uds3:=1.0; //
   myrelaxfactors.uds4:=1.0; //
   myrelaxfactors.prelaxBodyForce:=1.0; // по умолчанию нижняя релаксация ( < 1) отсутствует.
   // структура одной итерации алгоритма SIMPLE
   // при перестроении сетки эти параметры подстраиваются автоматом
   iterSimple.iterVxLin:=2;//10; // здесь будет
   iterSimple.iterVyLin:=2;//10; // нижняя релаксация
   bVOFExplicit:=True;  // Явный метод.
   bVOFsecondorder:=False; // аппроксимация по времени второго порядка для постоянного шага по времени.
   bsecondorderflow:=False;  // второй порядок аппроксимации по времени для компонент скорости.
   bsecondordertemp:=False; // второй порядок аппроксимации по времени для температуры.
   iterSimple.iterVof:=2; // для функции цвета. Явный метод !!!
   iterSimple.iterPamendment:=4;//Min(inx,iny); // для поправки давления
   iterSimple.iterPressure:=4;//Min(inx,iny); // для давления в алгоритме SIMPLER
   // в случае задач с учётом естественной конвекции
   // требуется решать также уравнение теплопроводности
   // здесь даётся оценка сверху для количества итераций
   // в предположении что используется полилинейный солвер.
   iterSimple.iterTemperature:=2;//Min(inx,iny);
   // нахождение функции тока происходит после окончания
   // работы алгоритма SIMPLE
   // максимальное число итераций оценивается равным 9*inx*iny, где 9 = ln(1e4).
   iterSimple.iterStreamFunction:=Min(inx,iny); // для нахождения функции тока
   // Количество итераций User-Define Scalar:
   iterSimple.iteruds1:=Min(inx,iny);
   iterSimple.iteruds2:=Min(inx,iny);
   iterSimple.iteruds3:=Min(inx,iny);
   iterSimple.iteruds4:=Min(inx,iny);
   // нужно ли продолжить вычисления
   bweShouldContinue:=true; // для прерывания вычисления в случае false
   // временная зависимость
   btimedepend:=false; // по умолчанию стационарный решатель
   // количество итераций зависит от качества итерационной процедуры
   // решения задачи и размерности вектора переменных.
   // в данный момент реализован однослойный метод Гаусса-Зейделя
   // оценка числа итераций составляет для него порядка 2*N^2, где
   // N = inx*iny - размерность вектора нейзвестных.
   itercount:=20; // количество итераций для сетки 10 на 10.
   iglobalnumberiteration:=1; // глобальный номер итераций присваивается при инициализации
   // параметры овечающие за начальную
   // инициализацию полевых величин
   InitVal.TempInit:=0.0; // начальное значение поля температур
   InitVal.XvelInit:=0.0; // начальное значение Vx
   InitVal.YvelInit:=0.0; // начальное значение Vy
   CourantNumber:=0.25; // Число Куранта в явной сземе VOF метода
   bCSF:=false; // использовать ли continuum surface force.
   rsigma:=0.0; // коэффициент поверхностного натяжения.
   bWallAdhesion:=false; // краевые углы смачивания.
   InitVal.VofInit:=0.0; // начальное значение для функции цвета.
   // задание начального времени
   realFlowTime:=0.0;
   // параметры материалов
   // air
   matprop[0].drho:=1.0; // плотность
   matprop[0].dlambda:=1.0; // теплопроводность
   matprop[0].dcp:=1.0; // теплоёмкость
   matprop[0].dmu:=1.0; // динамическая вязкость
   matprop[0].beta:=1.0; // коэффициент линейного температурного расширения
   // water
   matprop[1].drho:=1.0; // плотность
   matprop[1].dlambda:=1.0; // теплопроводность
   matprop[1].dcp:=1.0; // теплоёмкость
   matprop[1].dmu:=1.0; // динамическая вязкость
   matprop[1].beta:=1.0; // коэффициент линейного температурного расширения

   // приближение Буссинеска
   bBussinesk:=false; // по умолчанию выключено
   OperatingPressure:=0.0;
   // ускорение свободного падения
   dgx:=0.0;
   dgy:=0.0;
   // для силы тяжести изменяющейся по гармоническому закону от времени
   rgravVib.bOn:=false; // по умолчанию вибрации выключены.
   rgravVib.Amplitude:=0.01; // Амплитуда
   rgravVib.Frequency:=20.0; // Частота 20 Гц
   rgravVib.chDirect:='y'; // вертикальные вибрации
   // граничные условия
   // информация отсутствует так как модуль переделывается

   // линеаризованные источниковые члены
   // всех уравнений
   // уравнение теплопроводности
   defmysource.Temperature.dSc:=0.0; // постоянная составляющая
   defmysource.Temperature.dSp:=0.0; // линеаризованная составляющая
   // уравнение для горизонтальной скорости
   defmysource.Vxvelocity.dSc:=0.0; // постоянная составляющая
   defmysource.Vxvelocity.dSp:=0.0; // линеаризованная составляющая
   // уравнение для вертикальной скорости
   defmysource.Vyvelocity.dSc:=0.0; // постоянная составляющая
   defmysource.Vyvelocity.dSp:=0.0; // линеаризованная составляющая
   // для вихря
   defmysource.Omega.dSc:=0.0; // постоянная составляющая
   defmysource.Omega.dSp:=0.0; // линеаризованная составляющая
   imarker:=0; // для графической визуализации невязок.
   // Граничные условия в уравнении для поправки давления:
   // если = true значит нет влияния от точки на границе как у Патанкара в книжке,
   // а если = false значит условие Неймана равенство нулю нормальной производной.
   bPatankarPressure:=true; // по умолчанию условия Патанкара.
   bipifixpamendment:=false; // по умолчанию уровень поправки давления фиксировать не надо
   // выбор граничного условия на выходной границе потока
   // 0 - условия Патанкара, 1 - F[i]=2*F[i-1]-F[i-2];
   // 2 - однородные условия Неймана.
   // 3 - игнорируется.
   ioutflow:=2;//3;

   // нет parametric trial.
   ivar_trial:=0; // количество переменных  для parametric trial
   SetLength(base_value_trial,0);
   SetLength(series_value_of_the_variable,0);

   // сообщение о том что запуск программы
   // произошёл успешно.
   MainMemo.Lines.Add('Данная программа поставляется в исходных кодах');
   MainMemo.Lines.Add('на условиях FreeBSD подобной лицензии.');
   MainMemo.Lines.Add('Системные требования:');
   MainMemo.Lines.Add('1. Windows XP Professional x64 или Windows 7 x64');
   MainMemo.Lines.Add('2. Tecplot 360 для видео анимации и красивых картинок');
   MainMemo.Lines.Add('3. a) Delphi 6.0 Build 6.163 2001 года. Поддерживаются также');
   MainMemo.Lines.Add('следующие компиляторы: b) Delphi 7.0 Lite (7.3.4.2 Build 8.1) 2002 года');
   MainMemo.Lines.Add('c) Delphi 10 Lite v3.0 (Build 10.0.2.166.28377) 2005 года');
   MainMemo.Lines.Add('4. Для коректной работы dll необходима Visual Studio 2012');
   MainMemo.Lines.Add('5. Для программистов настоятельно рекомендуется все изменения кода');
   MainMemo.Lines.Add('данной программы немедленно проверять по критерию быстродействия с');
   MainMemo.Lines.Add('помощью замечательного компактного профайлера с открытым  исходным');
   MainMemo.Lines.Add('кодом GpProfile 2011. Профилирование должно проводится на копии программы');
   MainMemo.Lines.Add('так как оно изменяет исходный код.');
   MainMemo.Lines.Add('Авторы среды программирования Delphi:');
   MainMemo.Lines.Add('проф. Никлаус Вирт, Филипп Канн (Kahn), Андерс Хейлсберг (Hejlsberg) и др.');
   MainMemo.Lines.Add('Авторы CFD алгоритмов: С. Патанкар и проф. Сполдинг и др. ');
   MainMemo.Lines.Add('Для работы на других платформах в другом окружении');
   MainMemo.Lines.Add('можно использовать, например, WINE ');
   MainMemo.Lines.Add('или переписать программу для компилятора gcc.');
   MainMemo.Lines.Add('Возможной альтернативой является обращение, например, к проекту lazarus.');
   MainMemo.Lines.Add('7 деабря 2014 года к программе подключено дочернее приложение ');
   MainMemo.Lines.Add('на треугольных элементах построенных для предопределённых геометрий ');
   MainMemo.Lines.Add('на основе генератора Бояно Никено EasyMesh.  ');
   MainMemo.Lines.Add('Дочернее приложение называется BenarFlow v 0.02. ');
   MainMemo.Lines.Add('Патрик Роуч является автором алгоритма заложенного в BenarFlow. ');
   MainMemo.Lines.Add('приложение доступно по ссылке Interpritator->BenarFlow.');
   if (bIlyin) then
   begin
      MainMemo.Lines.Add('Поддерживается ускоряющая методика Ильин 1985. ');
   end;
   if (bNICENO) then
   begin
      // Переход на треугольную сетку потребует переделки всего кода и это будет уже совсем другая программа,
      //  кроме того исходная программа может сильно потерять в быстродействии поэтому переход
      // на треугольные сетки отложен на неопределённое время.
      MainMemo.Lines.Add('21 июня 2013 начато интегрирование кода сеточного генератора Easy Mesh в данный код.');
      mainMemo.Lines.Add('Author Easy mesh : Bojan NICENO. niceno@univ.trieste.it')
   end;
   MainMemo.Lines.Add('Done.');
end; // FormCreate

// возвращает наибольшую из величин da, db.
function TForm1.maxoper(da,db : Float) : Float;
var
   r : Float;
begin
   r:=da;
   if (db>r) then r:=db;
   Result:=r;
end;

// функция A(|P|) для различных схем
// ishconvection - номер схемы
function TForm1.ApproxConvective(fp : Float; ishconvection : Integer) : Float;
// Наименование схем для аппроксимации конвекции.
const
   CR = 1;     // Центрально - разностная.
   UDS = 2;    // Противопоточная первого поряда.
   COMB = 3;   // Комбинированная.
   POLY = 4;   // Полиномиальная С. Патанкара (схема со степенным законом)
   EXPONENTIAL = 5;    // Экспоненциальная схема.
   BULG = 6;   // схема В.К. Булгакова (23) из статьи
   POW = 7;    // показательная.
   STUB = 8; // UDS залушка.

var
   r : Float;
   ishloc  : Integer;
begin

   ishloc:=ishconvection;
   if ((ishloc<1) or (ishloc>7)) then
   begin
      ishloc:=8; // вариант по умолчанию.
   end;

   r:=1.0; // по умолчанию с разностями против потока
   // fp - имеет смысл сеточного числа Пекле
   // внутрь данной функции передаётся модуль числа fp и
   // здесь мы имеем дело только с fp>=0.
   case ishloc of
      CR : // Центрально-разностная
      begin
         // Центрально-разностная схема
         // пригодна только для небольших
         // чисел fp (Пекле) (по модулю меньших 1)
         // поэтому здесь при fp>1 осуществляется автоматический переход
         //  на рекомендуемую схему со степенным законом
         if (fp<1.0) then
         begin
            r:=1.0-0.5*fp;
            // В единице схема притерпевает разрыв!!!
         end;
         // если p>=1 то автоматический переход на схему со степенным законом
         if ((fp>=1.0) and (fp<3.8)) then
         begin
            // во избежании переполнения данная аппроксимация
            // используется только для сеточных чисел Пекле меньших 10
            r:=(1.0-0.1*fp)*(1.0-0.1*fp)*(1.0-0.1*fp)*(1.0-0.1*fp)*(1.0-0.1*fp);
         end
          else if (fp>=3.8) then
         begin
            // при сеточном числе Пекле большем 10 искомая величина
            // прекрасно аппроксимируется нулём
            // r:=0.0;
            // Ноль не так хорош он может привести ко всем коэффициентам равным нулю,
            // поэтому мы не допускаем ноль применяя формулу В.К. Булгакова [23].
            // Точка 3.8 выбрана из расчёта совпадения полиномиальной схемы патанкара и схемы булгакова.

            // При числе Рейнольдса 1000 было установлено что этого недостаточно и мы имеем
            // переполнение нулевые диагональные элементы матрицы. Повидимому коэффициент диффузии недостаточно
            // велик. Здесь интересно добавить применение методики I. Sezai которая увеличивает диагональный элемент.
            r:=1.0/(1.0+0.6712*fp*fp);
         end;
         // Мы применяем метод отложенной коррекции для центрально разностной
         // схемы, так что неявно учитывается лишь противопоточная часть.
         // Если применять вышенаписанный код при очень больших сеточных числах Пекле,
         // то все коэффициенты СЛАУ могут быть тождественно равны нулю что недопустимо.
         // При числах Пекле больших 10 применим схему В.К. Булгакова которая точно не даёт ноль !!!
         // из-за обязательного неотрицательного коэффициента диффузии.
      end;
      UDS : // с разностями против потока
      begin
         // здесь разумно ступеньку сделать
         (*
         if (fp<10.0) then
         begin
            r:=1.0;
         end
         else
         begin
            // здесь fp>=10
            r:=0.0;
         end;
         *)
         r:=1.0; // см. I. Sezai.
      end;
      COMB : // Комбинированная
      begin
         r:=maxoper(0.0,1.0-0.5*fp);
      end;
      POLY : // со степенным законом
      begin
          // по условию сюда подаётся fp>=0.

         // здесь может быть переполнение,
         // если написать так:
         // r:=maxoper(0,power(1-0.1*fp,5)); // уже пи вычислении степени возникнет переполнение при p чуть большем 10
         // r:=maxoper(0,r); - здесь и кроется переполнение, на данном этапе r уже очень велико и предыдущая операция даст сбой
         // здесь сделано так чтобы его корректно исключить:

         if (fp<10.0) then
         begin
            // по своему смыслу r лежит в интервале от нуля до единицы
            r:=(1.0-0.1*fp)*(1.0-0.1*fp)*(1.0-0.1*fp)*(1.0-0.1*fp)*(1.0-0.1*fp);
         end
          else // fp>=10
         begin
            // если p>10 то мы уходим в область отрицательных
            // значений и к тому-же там может быть очень большое
            // по абсолютной величине значение так что может быть и переполнение.
            // В связи с этим разумно ограничится предложенной реализацией.
            r:=0.0;
         end;

      end;
      EXPONENTIAL : // экспоненциальная (точная )
      begin
         if (fp<10.0) then
         begin
            // этим можно пользоваться только
            // при fp<10, при больших p значение
            // данной функции будет хорошо аппроксимироваться 0
            // иными словами 0 её асимптотика при больших fp, но
            // прямая подстановка слишком больших fp приводит
            // к переполнению т.к. exp(fp) становится слишком большим.
            if (fp<1.0e-2) then
            begin
              r:=1.0-0.5*fp; // центрально-разностная
            end
             else
            begin
               r:=fp/(exp(fp)-1.0);
            end;
         end
          else
         begin
            // при fp>=10 данная функция
            // достаточно хорошо аппроксимируется нулём.
            r:=0.0;
         end;
      end;
      BULG : // В.К. Булгаков, Н.В. Булгаков
          // Хабаровский государственный технический университет
          // зависимость 23 из статьи
      begin
         if (fp<10000.0) then
         begin
            // при fp = 10.0 r=0.01468;
            r:=1.0/(1.0+0.6712*fp*fp);
         end
          else
         begin
            r:=0.0;
         end;
      end;
      POW : // показательная зависимость
      begin
         if (fp<10.0) then
         begin
            r:=power(0.553,fp);
         end
          else
         begin
            r:=0.0;
         end;
      end;
      STUB : // противопоточная схема, вариант по умолчанию.
      begin
         r:=1.0;
      end;
   end;
   //Result:=r;
   ApproxConvective:=r;
end; // ApproxConvective

// минимум из двух чисел.
function TForm1.fmin(fA : Float; fB : Float) : Float;
var
   r : Float;
begin
   r:=fA;
   if (fB<fA) then
   begin
      r:=fB;
   end;
   fmin:=r;
end; // fmin

// максимум из двух чисел.
function TForm1.fmax(fA : Float; fB : Float) : Float;
var
   r : Float;
begin
   r:=fA;
   if (fB>fA) then
   begin
      r:=fB;
   end;
   fmax:=r;
end; // fmax


// Схемы Высокой разрешающей способности.
// В надежде получить гораздо более реалистичное решение.

// Возвращает минимум из трёх чисел.
function TForm1.fmin3(fA : Float; fB : Float; fC : Float) : Float;
begin
   fmin3:=fmin(fmin(fA,fB),fC);
end; // fmin3

// Возвращает минимум из четырёх чисел.
function TForm1.fmin4(fA : Float; fB : Float; fC : Float; fD : Float) : Float;
begin
   fmin4:=fmin(fmin3(fA,fB,fC),fD);
end; // fmin4

// Возвращает максимум из трёх чисел.
function TForm1.fmax3(fA : Float; fB : Float; fC : Float) : Float;
begin
   fmax3:=maxoper(maxoper(fA,fB),fC);
end; // fmax3

// см. дискретизация конвективных потоков в уравнениях Навье-Стокса
// на основе разностных схем высокой разрешающей способности.
// К.Н. Волков. стр. 135.
// Вычислительные методы и программирование. 2004. Т. 5.
function TForm1.linear_flux_limiter(kappa : Float; r : Float) : Float;
begin
   linear_flux_limiter:=0.5*((1.0+kappa)*r+(1.0-kappa));
end; // linear_flux_limiter

// по мотивам программы проф. Сполдинга PHOENICS
// К сожалению это многообразие пригодно лишь для равномерной сетки.
function TForm1.limiter_function(ishconvection : Integer; r : Float) : Float;

const
   QUICK = 1000;
   LUS = 1001;
   CUS = 1002;
   SMART = 1003;
   H_QUICK = 1004;
   UMIST = 1005;
   CHARM = 1006;
   MUSCL = 1007;
   VAN_LEER_HARMONIC = 1008;
   OSPRE = 1009;
   VAN_ALBADA = 1010;
   SUPERBEE = 1011;
   MINMOD = 1012;
   H_CUS = 1013;
   KOREN = 1014;
   FROMM = 1015;
   STUB = 1016; // заглушка.

var
   Br : Float;
   Konst : Float;
   ishloc  : Integer;

// модуль вещественного числа.
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin
   // Дискретизация конвективных потоков в уравнениях Навье-Стокса
   // на основе разностных схем высокой разрешающей способности К.Н.Волков.
   // Вычислительные методы и программирование. 2004. Т. 5.

   Br:=fmax3(0.0,fmin(2.0*r,1.0),fmin(r,2.0)); // SUPERBEE - схема по дефолту
   //Konst:=0.0;

   ishloc:=ishconvection;
   if ((ishloc<QUICK) or (ishloc>FROMM)) then
   begin
      // В качестве заглушки используется схема Леонарда QUICK.
      ishloc:=STUB;   // заглушка.
   end;

   case  ishloc of
    QUICK : begin
               Konst:=0.5;
               Br:=linear_flux_limiter(Konst, r);
            end;
    LUS :   begin
               Konst:=-1.0;
               Br:=linear_flux_limiter(Konst, r);
            end;
    CUS :   begin
               Konst:=1.0/3.0;
               Br:=linear_flux_limiter(Konst, r);
            end;
    SMART : begin
               // ограниченная на основе QUICK
               Br:=maxoper(0.0,fmin3(2.0*r,0.75*r+0.25,4.0));
            end;
    H_QUICK : begin
                 // гладкая на основе QUICK
                 if (r<=0.0) then Br:=0.0 else Br:=2.0*(r+fabs(r))/(r+3.0);
              end;
    UMIST : begin
               // TVD на основе QUICK
               Br:=maxoper(0.0,fmin4(2.0*r,0.25+0.75*r,0.75+0.25*r,2.0));
            end;
    CHARM : begin
               // ограниченная на основе QUICK
               if (r<=0.0) then Br:=0.0 else Br:=r*(3.0*r+1.0)/((r+1)*(r+1));
            end;
    MUSCL : begin
               // TVD на базе Fromm
               Br:=maxoper(0.0, fmin3(2.0*r,0.5+0.5*r,2));
            end;
    VAN_LEER_HARMONIC : begin
                           // TVD на базе Fromm
                           if (r<0.0) then
                           begin
                              Br:=0.0;
                           end
                            else
                           begin
                              Br:=(r+fabs(r))/(r+1.0);
                           end;
                        end;
    OSPRE : begin
               // гладкая на основе Fromm
               Br:=3.0*(r*r+r)/(2.0*(r*r+r+1.0));
            end;
    VAN_ALBADA : begin
                    // TVD на основе Fromm
                    Br:=(r*r+r)/(r*r+1.0);
                 end;
    SUPERBEE : begin
                   // TVD
                   Br:=fmax3(0.0,fmin(2.0*r,1.0),fmin(r,2.0));
               end;
    MINMOD : begin
                // (SOUCUP) TVD
                Br:=maxoper(0.0,fmin(r,1.0));
             end;
    H_CUS : begin
               // (HCUDS) гладкая на основе CUDS
               if (r<=0.0) then Br:=0.0 else Br:=1.5*(r+fabs(r))/(r+2.0);
            end;
    KOREN : begin
               // TVD на основе CUDS
               Br:=maxoper(0.0,fmin3(2.0*r,2.0*r/3.0+1.0/3.0,2.0));
            end;
    FROMM : begin
               Konst:=0.0; Br:=0.5*((1.0+Konst)*r+(1.0-Konst));
            end;
    STUB : begin
              // В качестве заглушки использутся схема Леонарда QUICK.
              Konst:=0.5;
              Br:=linear_flux_limiter(Konst, r);
           end;
   end; // case
   limiter_function:=Br;
end; // limiter_function

// по мотивам программы проф. Сполдинга PHOENICS
// Возвращает значение искомой величины на грани контрольного объёма.
function TForm1.cell_face_value_local(ishconvection : Integer; Fc : Float; Fd : Float; Fu :  Float) : Float ;
const
    UDS = 8; // противопоточная заглушка.

var
   Ff : Float; // значение функции на грани.
   bcontinue : Boolean;
   r : Float;

   // модуль вещественного числа.
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin
   Ff:=Fc;  // UDS Br==0 // противопоточная схема.
   bcontinue:=True;

   if (fabs(Fc-Fu)<1.0e-30) then
   begin
      bcontinue:=False;
   end;

   if (bcontinue) then
   begin

      r:=(Fd-Fc)/(Fc-Fu);

      if (ishconvection=UDS) then
      begin
         Ff:=Fc; // UDS
      end
       else
      begin
         Ff:=Fc+0.5*limiter_function(ishconvection,r)*(Fc-Fu); // Higher-Order Scheme
      end;

   end;

   cell_face_value_local:=Ff;

end;  // cell_face_value_local

// по мотивам программы проф. Сполдинга PHOENICS
// Возвращает значение искомой величины на грани контрольного объёма.
function TForm1.cell_face_value_global(ischeme : Integer; uf : Float; fa : Float;
fb : Float; fc : Float; fd : Float) : Float;
var
   // ff : Float;
    Fcloc, Fdloc, Fuloc : Float;
begin
  // uf - скорость на грани контрольного объёма.
  // fa, fb, fc, fd - значение искомой величины (с предыдущей итерации алгоритма SIMPLE)
	// в центрах контрольного объёма.

 (*  sign(uf)	 U	C	f	D
	*		+	    	WW	W	f	P
  *
	*	sign(uf)	D	f	C	U
	*		-		    W	f	P	E
	*
	*   f - face - поверхность на которой нужно получить искомую функцию (грань контрольного объёма).
	*)

	//Fcloc:=0.0;
  //Fdloc:=0.0;
  //Fuloc:=0.0;

	if (uf >= 0.0) then
  begin
		Fcloc:=fb;
		Fdloc:=fc;
		Fuloc:=fa;
	end
   else
  begin
		Fcloc:=fc;
		Fdloc:=fb;
		Fuloc:=fd;
	end;

	Result:=cell_face_value_local(ischeme, Fcloc, Fdloc, Fuloc);
end;

// Решает задачу теплопроводности с учётом конвекции или
// без конвекции если требуется. За это отвечает передаваемый
// параметр bconv если он равен true то значит с конвекцией,
// а если false - то без конвективного члена.
// Операции по вычислению коэффициентов
// дискретного аналога вынесены за пределы цикла.
// Это можно сделать потому, что значения этих
// коэффициентов зависят только от координат x и y
// а сетка неизменна, зависимости коэффициентов
// дискретного аналога от искомой функции тоже нет,
// так что задача линейна.
// недостатком является использование несколько большего
// количества оперативной памяти для хранения коэффициентов.
// Содержит в себе четыре решателя:
// 1). Гаусса-Зейделя (ГЗ), 2).  гибридный ГЗ-Томас он же метод
//  продольно поперечной прогонки или метод переменных направлений.
// 3). прямой метод исключения Гаусса, 4). метод сопряжённых градиентов Хестенса и Штифеля.
// 5) алгоритм Ю.Г. Соловейчика [1993]
// ГЗ - это поточечный последовательный
// метод Гауса-Зейделя.
// Главный недостаток метода Гаусса-Зейделя это медленная сходимость.
// гибридный ГЗ-Томас:  используется гибридный алгоритм:
// итерационный в сочетании с прямым.
// При расчёте используется алгоритм Томаса (
// трёхдиагональной матрицы или алгоритм прогонки).
//
// Прямой метод исключения Гаусса реализован с учётом ленточной структуры матрицы СЛАУ.
// Сходимость методов гарантируется критерием Скарбороу.
procedure TForm1.SolveTempSteady(bmessage : Boolean; kfinish : Integer; bconv : Boolean);
const
   kgold = 3;   // оптимальное значение для чисто эллиптической задачи 3.

var
   k,k1,k2 : Integer; // номер итерации
   m : array of MatrixCoef; // матрица коэффициетов
   db, myrU : array of Float;  // коэффициенты и невязка
   residualtemp : Float; // текущее значение невязки
   bflagconstruct : Boolean;
   Aseqx, Aseqy : TPeacemanRachford;
   QneiC : TQneiC;
   u1,u2,u3 : array of Float; // для вычисления оптимального параметра релаксации.
   dsum1, dsum2 : Float;

begin
   for k:=1 to 20 do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false;
      end;
   end;

   // показываем ход выполнения
   if ((not(btimedepend)) and (bmessage) and (itypesolver.itemperature < 3)) then myProgressBarForm.Show;

   // коэффициенты дискретного аналога не зависят от
   // температуры и этим можно воспользоваться, т.е.
   // их можно вычислить только один раз и дальше только использовать при вычислении.
   SetLength(m,inx*iny+1); // выделение памяти под коэффициенты
   SetLength(db,inx*iny+1); // выделение памяти под коэффициент
   SetLength(myrU,inx*iny+1); // невязка.

   if (bIlyin) then
   begin
      SetLength(u1,inx*iny+1);
      SetLength(u2,inx*iny+1);
      SetLength(u3,inx*iny+1);
   end;

   // коэффициенты дискретного аналога вычисляются
   // только один раз путём прохода по всем внутренним точкам
   // а затем только используются.
   if (bconv) then TempConvCoef(m, db) // с конвективным членом
   else TempCoef(m,db); // чистая теплопроводность

   // коэффициенты дискретного аналога уже вычислены
   // и теперь будут только использоваться.
   if (itypesolver.itemperature < 3) then
   begin
      k:=0;
      residualtemp:=1e0; // очень большое число
      bflagconstruct:=True;
      // матрицы коэффициентов m и db сформированы
      // и теперь просто будут только использоваться.
      while ((bweShouldContinue) and (residualtemp > rcs.temp) and (k < kfinish)) do
      begin
         // Реализовано только для граничных условий первого рода.
         if (imodelEquation=1) then
         begin
            DisplayUniversalInternal(1,true);
         end;

         case itypesolver.itemperature of
           1 : // итерационный последовательный поточечный метод
               // Гаусса-Зейделя
             begin
               if (bIlyin) then
               begin
                  if (k<3) then
                  begin
                     relaxIlyin:=1.0;
                  end;
               end;
                // одна итерация методом Гаусса-Зейделя
                GZUniversal(T,inx,iny,mapPT, 'T', m,db,QneiC);
                if (bIlyin) then
               begin
                  if (k mod kgold =0) then
                  begin
                     for k2:=0 to inx*iny do
                     begin
                        u1[k2]:=T[k2];
                     end;
                  end;
                  if ((k-1)mod kgold=0) then
                  begin
                     for k2:=0 to inx*iny do
                     begin
                        u2[k2]:=T[k2];
                     end;
                  end;
                  if ((k-2) mod kgold =0) then
                  begin
                     for k2:=0 to inx*iny do
                     begin
                        u3[k2]:=T[k2];
                     end;
                     dsum1:=0.0;
                     dsum2:=0.0;
                     for k2:=1 to inx*iny do
                     begin
                         if ((mapPT[k2].itype=1) or (mapPT[k2].itype=2)) then
                         begin
                            dsum1:=dsum1+(u3[k2]-u2[k2])*(u3[k2]-u2[k2]);
                            dsum2:=dsum2+(u2[k2]-u1[k2])*(u2[k2]-u1[k2]);
                         end;
                     end;
                     if (abs(dsum2)>1.0e-30) then
                     begin
                        dsum1:=sqrt(dsum1/dsum2);
                        relaxIlyin:=2.0/(1.0+sqrt(fmax(1.0-dsum1,0.002))); // оптимальный параметр релаксации.
                     end;
                  end;
               end;
             end;
           2 : // метод переменных направлений
             begin
                // одна итерация методом переменных направлений
                // для поля температур и граничных условий первого рода
                TDMAGibridGZUniversal(T,inx,iny, mapPT, 'T',m, db,Aseqx,Aseqy,bflagconstruct);
                bflagconstruct:=False;
             end;
         end; // case

         // текущее значение невязки
         //residualtemp:=myResidual(T,myrU,inx,iny,mapPT,'T',m,db);
         // невязка с учётом граничных условий :
         myResidual_all(myrU,residualtemp,T,inx,iny,mapPT,'T',m,db,QneiC);
         if (imodelEquation = 1) then
         begin
            inc(imarker);
            SetLength(myresplot,imarker);
            myresplot[imarker-1].temperature:=residualtemp; // нумерация начинается от нуля
            if (imarker>1) then updatemainpaintbox; // графики невязок
         end;

         if (bmessage) then
         begin
            if (k mod 10 = 0) then  MainMemo.Lines.Add('iter   temperature');
            MainMemo.Lines.Add(IntToStr(k+1) + '    ' + FormatFloat('#.####e-0',residualtemp));
         end;

         // индикатор хода выполнения
         if ((not(btimedepend)) and (bmessage)) then
         begin
             // стационарное моделирование.
             myProgressBarForm.ProgressBar1.Position:=round((k+1)/itercount*100);
         end
         else
         begin
            // нестационарное моделирование
            if (bmessage) then
            begin
               myProgressBarUnsteadyForm.ProgressBar2.Position:=round((k+1)/itercount*100);
            end;
         end;
         k:=k+1; // переходим к следующей итерации
         Application.ProcessMessages;
      end; // k while
      // Если решалось только уравнение теплопроводности,
      // то восстанавливаем готовность к решению.
      if (imodelEquation = 1) then bweShouldContinue:=true;
      if ((not(btimedepend)) and (bmessage)) then
      begin
         myProgressBarForm.ProgressBar1.Position:=0;
         myProgressBarForm.Close; // закрываем индикатор хода выполнения
      end;
   end
   else
   begin

      case itypesolver.itemperature of
        3 :  // решение задачи прямым методом Гаусса
           begin
              // эсли этот код используется в нестационарном решателе
              // и граничное условие является функцией времени, то
              // это приводит к необходимости обращать матрицу СЛАУ
              // на каждом временном слое.
              GaussUniversal(T,inx,iny, mapPT, 'T', m,db,bmessage);
              // текущее значение невязки
              //residualtemp:=myResidual(T,myrU,inx,iny,mapPT,'T',m,db);
              // невязка с учётом граничных условий :
              myResidual_all(myrU,residualtemp,T,inx,iny,mapPT,'T',m,db,QneiC);
              if (bmessage) then
              begin
                 MainMemo.Lines.Add('residual tempreture ='+ FloatToStr(residualtemp));
              end;
           end;
        4 : // метод Сопряжённых Градиентов
           begin
              // передаваемое значение bconv=true означает
              // что будет выполнена трансформация Гаусса
              // необходимая для того чтобы матрица СЛАУ была
              // самосопряжённой положительно определённой
              // метод сопряжённых градиентов Хестенса и Штифеля.
              // debug без учёта разреженности.
              //SoprGradUniversal(T,inx,iny, mapPT,  'T', m, true, kfinish, rcs.temp, db,bmessage);

              SoprGradCRSUniversal( T, inx, iny, mapPT, 'T', m, bconv, bmessage, kfinish, rcs.temp, 0,db); // хранение разреженной матрицы в формате CRS
           end;
        5 : // алгоритм Ю.Г. Соловейчика
           begin
              // Локально оптимальная схема.
              // алгоритм Ю.Г. Соловейчика [1993]
              // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
              SoprGradCRSUniversal( T, inx, iny, mapPT, 'T', m, bconv, bmessage, kfinish, rcs.temp*rcs.temp, 1,db); // используется формат хранения разреженной матрицы CRS
           end;
        6 :  // решение задачи алгебраическим многосеточным методом.
           begin
              // Реализовано только для граничных условий первого рода.
              if (imodelEquation=1) then
              begin
                 DisplayUniversalInternal(1,true);
              end;
              // эсли этот код используется в нестационарном решателе
              // и граничное условие является функцией времени, то
              // это приводит к необходимости обращать матрицу СЛАУ
              // на каждом временном слое.
              //GaussUniversal(T,inx,iny, mapPT, 'T', m,db,bmessage);
              classical_aglomeration_amg(T,inx,iny,mapPT,'T',m,db,bmessage);
              if (bmessage) then
              begin
                 // текущее значение невязки
                 //residualtemp:=myResidual(T,myrU,inx,iny,mapPT,'T',m,db);
                 // невязка с учётом граничных условий :
                 myResidual_all(myrU,residualtemp,T,inx,iny,mapPT,'T',m,db,QneiC);
                 MainMemo.Lines.Add('residual tempreture ='+ FloatToStr(residualtemp));
              end;
           end;
        end; // case

   end;

   SetLength(m,0); // выделение памяти под коэффициенты
   SetLength(db,0); // выделение памяти под коэффициент
   SetLength(myrU,0); // невязка.

   if (bIlyin) then
   begin
      SetLength(u1,0);
      SetLength(u2,0);
      SetLength(u3,0);
   end;

   if ((not(btimedepend)) and (bmessage) and (itypesolver.itemperature = 1)) then
   begin
      myProgressBarForm.ProgressBar1.Position:=0; // в исходное положение
      myProgressBarForm.Close;
   end;
end; // SolveTempSteady

// препроцессор для quickcalc
procedure TForm1.preprocessing_quick_calc(var bquickcalc :  TmyDynArrayb;
                                          var bquickcalcVx :  TmyDynArrayb;
                                          var bquickcalcVy :  TmyDynArrayb);

const
   variablenameuds : array[0..36] of string =
                     ('$x','$y','$udm1','$udm2','$udm3','$uds1','$uds2','$uds3','$uds4',
                      '$diff1','$diff2','$diff3','$diff4','$laplas1','$laplas2','$laplas3','$laplas4',
                      '$laplasx1','$laplasx2','$laplasx3','$laplasx4','$laplasy1','$laplasy2','$laplasy3',
                      '$laplasy4','$gradxuds1','$gradxuds2','$gradxuds3','$gradxuds4',
                      '$gradyuds1','$gradyuds2','$gradyuds3','$gradyuds4',
                      '$gradxyuds1','$gradxyuds2','$gradxyuds3','$gradxyuds4');
   variablenamevel : array[0..9] of string =
                     ('$x','$y','$gradxuds1','$gradxuds2','$gradxuds3','$gradxuds4',
                      '$gradyuds1','$gradyuds2','$gradyuds3','$gradyuds4');

var
    k : Integer;

procedure isvariablefind(pattern : String; inum : Integer);
var
   posloc : Integer;
begin
  case icurentuds of
     1 : begin
            posloc:=Pos(pattern,dsc1str);
            if (posloc=0) then
            begin
               posloc:=Pos(pattern,dsp1str);
               if (posloc=0) then
               begin
                  posloc:=Pos(pattern,gamma1str);
               end;
            end;
         end;
     2 : begin
            posloc:=Pos(pattern,dsc2str);
            if (posloc=0) then
            begin
               posloc:=Pos(pattern,dsp2str);
               if (posloc=0) then
               begin
                  posloc:=Pos(pattern,gamma2str);
               end;
            end;
         end;
     3 : begin
            posloc:=Pos(pattern,dsc3str);
            if (posloc=0) then
            begin
               posloc:=Pos(pattern,dsp3str);
               if (posloc=0) then
               begin
                  posloc:=Pos(pattern,gamma3str);
               end;
            end;
         end;
     4 : begin
            posloc:=Pos(pattern,dsc4str);
            if (posloc=0) then
            begin
               posloc:=Pos(pattern,dsp4str);
               if (posloc=0) then
               begin
                  posloc:=Pos(pattern,gamma4str);
               end;
            end;
         end;
   end;
   if (posloc<>0) then
   begin
      bquickcalc[inum]:=True; // данная переменная (pattern) присутствует и имеет номер inum.
   end;
end;

procedure isvariablefindVx(pattern : String; inum : Integer);
var
   posloc : Integer;
begin
   case icurentuds of
    1 : begin
           posloc:=Pos(pattern,Vxuds1str);
        end;
    2 : begin
           posloc:=Pos(pattern,Vxuds2str);
        end;
    3 : begin
           posloc:=Pos(pattern,Vxuds3str);
        end;
    4 : begin
           posloc:=Pos(pattern,Vxuds4str);
        end;
   end;
   if (posloc<>0) then
   begin
      bquickcalcVx[inum]:=True; // данная переменная присутствует.
   end;
end;

procedure isvariablefindVy(pattern : String; inum : Integer);
var
   posloc : Integer;
begin
   case icurentuds of
    1 : begin
           posloc:=Pos(pattern,Vyuds1str);
        end;
    2 : begin
           posloc:=Pos(pattern,Vyuds2str);
        end;
    3 : begin
           posloc:=Pos(pattern,Vyuds3str);
        end;
    4 : begin
           posloc:=Pos(pattern,Vyuds4str);
        end;
   end;
   if (posloc<>0) then
   begin
      bquickcalcVy[inum]:=True; // данная переменная присутствует.
   end;
end;

begin
   SetLength(bquickcalc,37);
   for k:=0 to 36 do
   begin
      // переменных нет вообще.
      bquickcalc[k]:=False;
   end;

   for k:=0 to 36 do
   begin
      // номер текущей uds уже учтён внутри isvariablefind.
      isvariablefind(variablenameuds[k], k);
   end;


   SetLength(bquickcalcVx,10);

   SetLength(bquickcalcVy,10);

   for k:=0 to 9 do
   begin
      bquickcalcVx[k]:=false;
      bquickcalcVy[k]:=false;
   end;

   for k:=0 to 9 do
   begin
      // номер текущей uds уже учтён внутри isvariablefindV* - x или y.
      isvariablefindVx(variablenamevel[k],k);
      isvariablefindVy(variablenamevel[k],k);
   end;

end;

// 1 ноября 2013 года.

// Метод Ньютона для ДДМ на GaAs.
// В методе Ньютона присутствует неявность по полескоростной характеристике
// и эта неявность учитывается путём линеаризации.
function fgaas1(A : Float; B : Float; C : Float; x : Float) : Float;
begin
   Result:=Sqrt(A+Sqr((x-C)/B));
end;

function fgaas2(A : Float; B : Float; C : Float; x : Float) : Float;
begin
   Result:=Sqr(A+Sqr((x-C)/B));
end;

function fgaas3(A : Float; B : Float; C : Float; x : Float) : Float;
begin
   Result:=(A+Sqr((x-C)/B));
end;

// Вычисляет производную от функции (полескоростной характеристики GaAs)
// f(x)=((x-C)/B)*((fgaas1(A, B, C, x)+Form1.ruds_GaAs_top*fgaas2(A, B, C, x))/
//      ((1.0+Form1.ruds_GaAs_bottom*fgaas2(A, B, C, x))*fgaas1(A, B, C, x)));
// fgaas4 = diff(f(x),x);
function fgaas4(A : Float; B : Float; C : Float; x : Float) : Float;
var
    r, r1, r2, r3 : Float;
begin
   r1:=fgaas1(A, B, C, x); // sqrt
   r2:=fgaas2(A, B, C, x); // sqr
   r3:=fgaas3(A, B, C, x);
   r:=(r1+Form1.ruds_GaAs_top*r2)/(B*(1.0+Form1.ruds_GaAs_bottom*r2)*r1);
   r:=r+(x-C)*((x-C)/(B*B*r1)+(4.0*Form1.ruds_GaAs_top*(x-C)*r3)/(B*B))/(B*(1.0+Form1.ruds_GaAs_bottom*r2)*r1);
   r:=r-(4.0*Sqr(x-C)*Form1.ruds_GaAs_bottom*r1*(r1+Form1.ruds_GaAs_top*r2))/(B*B*B*Sqr(1.0+Form1.ruds_GaAs_bottom*r2));
   r:=r-(Sqr(x-C)*(r1+Form1.ruds_GaAs_top*r2))/(B*B*B*(1.0+Form1.ruds_GaAs_bottom*r2)*r1*r3);
   Result:=r;
end;


// Метод Ньютона-Канторовича в GaAs,
// решение с помощью метода последовательной
// верхней релаксации.
// Внимание метод настроен только на GaAs.
procedure TForm1.solvegaas();
var
   m : array of MatrixCoefNewton; // матрица блочно пятидиагональной СЛАУ.
   b1, b2 : array of Float; // правые части.
   dphi, dn : array of Float; // приращения искомых переменных в методе Ньютона.
   k1, iloc, igl, k : Integer;
   r1, r2, b1loc, b2loc : Float;
   inslau, inglobal : Integer;
   gradxuds1x, gradyuds1x : array of Float; // градиенты потенциала для горизонтальной скорости.
   gradxuds1y, gradyuds1y : array of Float; // градиенты потенциала для вертикальной скорости.

begin
   // Настройки алгоритма :
   // Количество итераций метода Гаусса-Зейделя для
   // решения СЛАУ.
   inslau:=120;
   // глобальные итерации для
   // сходимости в статике или
   // на временном слое.
   inglobal:=20;



   // Выделение памяти :
   SetLength(m,mzapas*inx*iny+1);
   SetLength(b1,mzapas*inx*iny+1);
   SetLength(b2,mzapas*inx*iny+1);
   SetLength(dphi,mzapas*inx*iny+1);
   SetLength(dn,mzapas*inx*iny+1);

   // препроцессинг.
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         // внутренний узел

         // координаты узлов для поправки давления
         // используется обыкновенная сетка
         ini:=i+j*inx; // север
         isi:=i+(j-2)*inx; // юг
         iwi:=(i-1)+(j-1)*inx; // запад
         iei:=(i+1)+(j-1)*inx; // восток
         ipi:=i+(j-1)*inx;  // текущая точка
      end;
   end;

   SetLength(gradxuds1x, mzapas*(inx-1)*iny+1);
   SetLength(gradyuds1x, mzapas*(inx-1)*iny+1);
   SetLength(gradxuds1y, mzapas*inx*(iny-1)+1);
   SetLength(gradyuds1y, mzapas*inx*(iny-1)+1);

   // Получение решения в статике или
   // на временном шаге.
   for igl:=0 to inglobal do
   begin




      // Заполнение данных :
      // Обязательно нужна сборка матрицы, т.к.
      // задача нелинейна и коэффициенты слау зависят
      // от значений с прошлой итерации.

      // Иксовая компонента скорости :
      // Особый случай : задана полескоростная характеристика GaAs.
      universalgradx(UDS1 , gradxuds1x);
      universalgrady_mapx(UDS1 , gradyuds1x);
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               if (sqrt(sqr(gradxuds1x[ipi])+sqr(gradyuds1x[ipi]))>1.0e-30) then
               begin
                  Vxuds[ipi]:=(gradxuds1x[ipi])*(Sqrt(sqr(gradxuds1x[ipi])+sqr(gradyuds1x[ipi]))+ruds_GaAs_top*sqr(sqr(gradxuds1x[ipi])+sqr(gradyuds1x[ipi])))/(1.0+ruds_GaAs_bottom*sqr(sqr(gradxuds1x[ipi])+sqr(gradyuds1x[ipi])))/(sqrt(sqr(gradxuds1x[ipi])+sqr(gradyuds1x[ipi])));
               end
                else
               begin
                  Vxuds[ipi]:=0.0;
               end;
            end;
         end;
      end;

      //вертикальная скорость.
      // Особый случай : задана полескоростная характеристика GaAs.
      universalgradx_mapy(UDS1 , gradxuds1y);
      universalgrady(UDS1 , gradyuds1y);
      for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*inx;
               if (sqrt(sqr(gradxuds1y[ipi])+sqr(gradyuds1y[ipi]))>1.0e-30) then
               begin
                  Vyuds[ipi]:=(gradyuds1y[ipi])*(Sqrt(sqr(gradxuds1y[ipi])+sqr(gradyuds1y[ipi]))+ruds_GaAs_top*sqr(sqr(gradxuds1y[ipi])+sqr(gradyuds1y[ipi])))/(1.0+ruds_GaAs_bottom*sqr(sqr(gradxuds1y[ipi])+sqr(gradyuds1y[ipi])))/(sqrt(sqr(gradxuds1y[ipi])+sqr(gradyuds1y[ipi])));
               end
               else
               begin
                  Vyuds[ipi]:=0.0;
               end;

            end;
         end;
      end;

      // TODO
      // Итерационный процесс :

      // Цикл решения СЛАУ.
      // Это обычный последовательный поточечный
      // метод Гаусса-Зейделя.
      for iloc:=0 to inslau do
      begin


         // Внутренность РО :
         for k1:=1 to imaxnumbernode do
         begin
            with mapPT[k1] do
            begin
               if (mapPT[k1].itype=1) then
               begin
                  // UDS1 - phi, UDS2 - n;
                  // внутренний узел :
                  b1loc:=m[ipi].aer1phi*UDS1[iei]+m[ipi].awr1phi*UDS1[iwi];
                  b1loc:=b1loc+m[ipi].anr1phi*UDS1[ini]+m[ipi].asr1phi*UDS1[isi];
                  b1loc:=b1loc+m[ipi].aer1n*UDS2[iei]+m[ipi].awr1n*UDS2[iwi];
                  b1loc:=b1loc+m[ipi].anr1n*UDS2[ini]+m[ipi].asr1n*UDS2[isi];
                  b1loc:=b1loc-m[ipi].apr1phi*UDS1[ipi]-m[ipi].apr1n*UDS2[ipi]+m[ipi].b1;
                  b1[ipi]:=b1loc;

                  r1:=(m[ipi].aw1phi*dphi[iwi]+m[ipi].ae1phi*dphi[iei]+m[ipi].as1phi*dphi[isi]+m[ipi].an1phi*dphi[ini])/m[ipi].ap1phi;
                  r1:=r1+(m[ipi].aw1n*dn[iwi]+m[ipi].ae1n*dn[iei]+m[ipi].as1n*dn[isi]+m[ipi].an1n*dn[ini]-m[ipi].ap1n*dn[ipi]+b1[ipi])/m[ipi].ap1phi;
                  dphi[ipi]:=r1;


                  b2loc:=m[ipi].aer2n*UDS2[iei]+m[ipi].awr2n*UDS2[iwi];
                  b2loc:=b2loc+m[ipi].anr2n*UDS2[ini]+m[ipi].asr2n*UDS2[isi];
                  b2loc:=b2loc-m[ipi].apr2n*UDS2[ipi]+m[ipi].b2;
                  b2[ipi]:=b2loc;

                  r2:=(m[ipi].aw2phi*dphi[iwi]+m[ipi].ae2phi*dphi[iei])/m[ipi].ap2n;
                  r2:=r2+(m[ipi].as2phi*dphi[isi]+m[ipi].an2phi*dphi[ini])/m[ipi].ap2n;
                  r2:=r2+(-m[ipi].ap2phi*dphi[ipi])/m[ipi].ap2n;
                  r2:=r2+(m[ipi].aw2n*dn[iwi]+m[ipi].ae2n*dn[iei])/m[ipi].ap2n;
                  r2:=r2+(m[ipi].as2n*dn[isi]+m[ipi].an2n*dn[ini])/m[ipi].ap2n;
                  r2:=r2+(b2[ipi])/m[ipi].ap2n;
                  dn[ipi]:=r2;
               end;
            end;
         end;
         // Граничные точки РО:



      end;
   end;

   // Освобождение оперативной памяти :
   SetLength(m,0);
   SetLength(b1,0);
   SetLength(b2,0);
   SetLength(dphi,0);
   SetLength(dn,0);
   SetLength(gradxuds1x,0);
   SetLength(gradyuds1x,0);
   SetLength(gradxuds1y,0);
   SetLength(gradyuds1y,0);
end;


// Находит решение уравнения для пользовательского скаляра.
// bmessage - сообщения на консоль,
// kfinish - заданное количество итераций.
// value_of_equation нужно для метода Ньютона, оно возвращает
// значение дискретного аналога при текущих UDS1 и UDS2.
// Возвращение value_of_equation происходит при выбранном itypesolverloc=6.
procedure TForm1.SolveUDS(bmessage : Boolean; kfinish : Integer;
                          var res : Float; bquickcalc : array of Boolean;
                          var bquickcalcVx : array of Boolean;
                          var bquickcalcVy : array of Boolean;
                          var value_of_equation : array of Float);
const
   kgold = 3;   // оптимальное значение для чисто эллиптической задачи 3.

var
   k,k1,k2 : Integer; // номер итерации
   m : array of MatrixCoef; // матрица коэффициетов
   db : array of Float;  // коэффициенты
   myrU : array of Float; // невязка
   residualuds : Float; // текущее значение невязки
   epsilon_loc : Float; // точность с которой решается СЛАУ.
   itypesolver_loc : Integer;// алгоритм решателя.
   bOk : Boolean;
   gradxuds1, gradxuds2, gradxuds3, gradxuds4 : array of Float;
   gradyuds1, gradyuds2, gradyuds3, gradyuds4 : array of Float;
   laplasxuds1, laplasxuds2, laplasxuds3, laplasxuds4 : array of Float;
   laplasyuds1, laplasyuds2, laplasyuds3, laplasyuds4 : array of Float;
   laplasuds1, laplasuds2, laplasuds3, laplasuds4 : array of Float;
   gradxmapptuds1, gradxmapptuds2, gradxmapptuds3, gradxmapptuds4 : array of Float;
   gradymapptuds1, gradymapptuds2, gradymapptuds3, gradymapptuds4 : array of Float;
   gradxymapptuds1, gradxymapptuds2, gradxymapptuds3, gradxymapptuds4 : array of Float;
   c, cdsc, cdsp, cdiff : Float; // для ускоренного вычисления коэффициентов !!!
   code : Integer;
   bcontquick : Boolean;
   bflagconstruct : Boolean;
   Aseqx, Aseqy : TPeacemanRachford;
   // Не более 20 границ не более 4 UDS.
   // Проверка стоит ли на границе условие Неймана.
   QneiC : TQneiC; // ускорение проверки граничных условий.
   QneiCdll : TmyDynArrayb; // одномерное представление QneiC для передачи внутрь dll.
   bzerocurrenrorzerodiffdll : TmyDynArrayb; //одномерное представление отвечающее за условие
   // нормальная компонента полного тока равна нулю и номальная составляющая диффузионного тока равна нулю.
   // 1..20, 1..20, 1..20, 1..20. - схема линейного хранения.
   resloc : Float;
   u1,u2,u3 : array of Float; // для вычисления оптимального параметра релаксации.
   dsum1, dsum2 : Float;
   mapPTold : TdynArraymyNodeold;

begin

   SetLength(bzerocurrenrorzerodiffdll,80);
   for k:=1 to GridGenForm.inumboundary do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false; // нет условий Неймана !!!
         bzerocurrenrorzerodiffdll[k+(k1-1)*20-1]:=False;
      end;
   end;
    for k:=1 to GridGenForm.inumboundary do
   begin
     case icurentuds of
      1 : begin
             if (GridGenForm.edgelist[k].uds1clan=2) then
             begin
                QneiC[GridGenForm.edgelist[k].idescriptor][1]:=true;
             end;
             if ((GridGenForm.edgelist[k].uds1clan=3)or(GridGenForm.edgelist[k].uds1clan=4)) then
             begin
                 bzerocurrenrorzerodiffdll[GridGenForm.edgelist[k].idescriptor+(1-1)*20-1]:=true;
             end;
          end;
      2 : begin
             if (GridGenForm.edgelist[k].uds2clan=2) then
             begin
                QneiC[GridGenForm.edgelist[k].idescriptor][2]:=true;
             end;
             if ((GridGenForm.edgelist[k].uds2clan=3)or(GridGenForm.edgelist[k].uds2clan=4)) then
             begin
                 bzerocurrenrorzerodiffdll[GridGenForm.edgelist[k].idescriptor+(2-1)*20-1]:=true;
             end;
          end;
      3 : begin
             if (GridGenForm.edgelist[k].uds3clan=2) then
             begin
                QneiC[GridGenForm.edgelist[k].idescriptor][3]:=true;
             end;
             if ((GridGenForm.edgelist[k].uds3clan=3)or(GridGenForm.edgelist[k].uds3clan=4)) then
             begin
                 bzerocurrenrorzerodiffdll[GridGenForm.edgelist[k].idescriptor+(3-1)*20-1]:=true;
             end;
          end;
      4 : begin
             if (GridGenForm.edgelist[k].uds4clan=2) then
             begin
                QneiC[GridGenForm.edgelist[k].idescriptor][4]:=true;
             end;
              if ((GridGenForm.edgelist[k].uds4clan=3)or(GridGenForm.edgelist[k].uds4clan=4)) then
             begin
                 bzerocurrenrorzerodiffdll[GridGenForm.edgelist[k].idescriptor+(4-1)*20-1]:=true;
             end;
          end;
     end;

   end;

   // представление из двумерного представления в одномерное.
   SetLength(QneiCdll, 80);
   for k:=1 to 4 do
   begin
      for k1:=1 to 20 do
      begin
         QneiCdll[k1+(k-1)*20-1]:=QneiC[k1][k];
      end;
   end;

   // res - начальная невязка.

   epsilon_loc:=1.0e-10;

   // ход выполнения показывается внутри SIMPLE алгоритма.
   // icurentuds - текущий номер 1, 2 или  3 пользовательского скаляра.
   case icurentuds of
     1 : begin
            epsilon_loc:=rcs.uds1;
            itypesolver_loc:=itypesolver.iuds1;
         end;
     2 : begin
            epsilon_loc:=rcs.uds2;
            itypesolver_loc:=itypesolver.iuds2;
         end;
     3 : begin
            epsilon_loc:=rcs.uds3;
            itypesolver_loc:=itypesolver.iuds3;
         end;
     4 : begin
            epsilon_loc:=rcs.uds4;
            itypesolver_loc:=itypesolver.iuds4;
         end;
   end;


   case imaxUDS of
      1 : begin
             SetLength(gradxuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds2,0);
             SetLength(gradxuds3,0);
             SetLength(gradxuds4,0);
             // Производная по y  на сетке для горизонтальной скорости.
             SetLength(gradyuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds2,0);
             SetLength(gradyuds3,0);
             SetLength(gradyuds4,0);
          end;
      2 : begin
             SetLength(gradxuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds2,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds3,0);
             SetLength(gradxuds4,0);
             // Производная по y  на сетке для горизонтальной скорости.
             SetLength(gradyuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds2,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds3,0);
             SetLength(gradyuds4,0);
          end;
      3 : begin
             SetLength(gradxuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds2,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds3,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds4,0);
             // Производная по y  на сетке для горизонтальной скорости.
             SetLength(gradyuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds2,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds3,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds4,0);
          end;
      4 : begin
             SetLength(gradxuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds2,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds3,mzapas*(inx-1)*iny+1);
             SetLength(gradxuds4,mzapas*(inx-1)*iny+1);
             // Производная по y  на сетке для горизонтальной скорости.
             SetLength(gradyuds1,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds2,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds3,mzapas*(inx-1)*iny+1);
             SetLength(gradyuds4,mzapas*(inx-1)*iny+1);
          end;
   end;

   case imaxUDS of
   1 : begin
           if (((icurentuds=1)and(itypemassFluxuds1=2))) then
           begin
              // Вычисляет производную по x.
              // U - задано на сетке mapPT, gradxU - задано на сетке для горизонтальной скорости.
              universalgradx(UDS1 , gradxuds1);
              // Вычисляет производную по y.
              // U - задано на сетке mapPT, gradyU - задано на сетке для горизонтальной скорости.
              universalgrady_mapx(UDS1 , gradyuds1);
          end;
       end;
   2 : begin
          if (((icurentuds=1)and(itypemassFluxuds1=2)) or ((icurentuds=2)and(itypemassFluxuds2=2))) then
          begin
             // Вычисляет производную по x.
             // U - задано на сетке mapPT, gradxU - задано на сетке для горизонтальной скорости.
             universalgradx(UDS1 , gradxuds1);
             universalgradx(UDS2 , gradxuds2);
             // Вычисляет производную по y.
             // U - задано на сетке mapPT, gradyU - задано на сетке для горизонтальной скорости.
             universalgrady_mapx(UDS1 , gradyuds1);
             universalgrady_mapx(UDS2 , gradyuds2);
          end;
       end;
   3 : begin
          if (((icurentuds=1)and(itypemassFluxuds1=2)) or ((icurentuds=2)and(itypemassFluxuds2=2)) or ((icurentuds=3)and(itypemassFluxuds3=2))) then
          begin
             // Вычисляет производную по x.
             // U - задано на сетке mapPT, gradxU - задано на сетке для горизонтальной скорости.
             universalgradx(UDS1 , gradxuds1);
             universalgradx(UDS2 , gradxuds2);
             universalgradx(UDS3 , gradxuds3);
             // Вычисляет производную по y.
             // U - задано на сетке mapPT, gradyU - задано на сетке для горизонтальной скорости.
             universalgrady_mapx(UDS1 , gradyuds1);
             universalgrady_mapx(UDS2 , gradyuds2);
             universalgrady_mapx(UDS3 , gradyuds3);
          end;
       end;
   4 : begin
          if (((icurentuds=1)and(itypemassFluxuds1=2)) or ((icurentuds=2)and(itypemassFluxuds2=2)) or ((icurentuds=3)and(itypemassFluxuds3=2)) or ((icurentuds=4)and(itypemassFluxuds4=2))) then
          begin
             // Вычисляет производную по x.
             // U - задано на сетке mapPT, gradxU - задано на сетке для горизонтальной скорости.
             universalgradx(UDS1 , gradxuds1);
             universalgradx(UDS2 , gradxuds2);
             universalgradx(UDS3 , gradxuds3);
             universalgradx(UDS4 , gradxuds4);
             // Вычисляет производную по y.
             // U - задано на сетке mapPT, gradyU - задано на сетке для горизонтальной скорости.
             universalgrady_mapx(UDS1 , gradyuds1);
             universalgrady_mapx(UDS2 , gradyuds2);
             universalgrady_mapx(UDS3 , gradyuds3);
             universalgrady_mapx(UDS4 , gradyuds4);
          end;
       end;
   end;



   ivar:=10; // 2 переменные x и y
   SetLength(parametric,ivar);
   parametric[0].svar:='$x';
   parametric[1].svar:='$y';
   parametric[2].svar:='$gradxuds1';
   parametric[3].svar:='$gradxuds2';
   parametric[4].svar:='$gradxuds3';
   parametric[5].svar:='$gradxuds4';
   parametric[6].svar:='$gradyuds1';
   parametric[7].svar:='$gradyuds2';
   parametric[8].svar:='$gradyuds3';
   parametric[9].svar:='$gradyuds4';

   if ((icurentuds=2)and(itypemassFluxuds2=3)) then
   begin
      // В случае если
      // edtVx.Text = $gradxuds1, а
      // edtVy.Text = $gradyuds1 то
      // это случай ДДМ модели для электронного газа (обезразмеренный).
      // Его нужно очень быстро вычислять потому что эта модель очень важна для Пульсара.
      // При распознании данной ситуации вынесем этот случай в особый вариант itypemassFluxuds2=3.
      universalgradx(UDS1 , Vxuds);
   end;

   if ((icurentuds=2)and(itypemassFluxuds2=4)) then
   begin
      // Особый случай : задана полескоростная характеристика кремния.
      universalgradx(UDS1 , gradxuds1);
      universalgrady_mapx(UDS1 , gradyuds1);
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               c:=Sqrt(Sqr(gradxuds1[ipi])+Sqr(gradyuds1[ipi]));
               Vxuds[ipi]:=gradxuds1[ipi]/(1.0+ruds_silicon*c);
            end;
         end;
      end;
   end;

   if ((icurentuds=2)and(itypemassFluxuds2=8)) then
   begin
      // Особый случай : задана полескоростная характеристика GaAs.
      universalgradx(UDS1 , gradxuds1);
      universalgrady_mapx(UDS1 , gradyuds1);
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               if (sqrt(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi]))>1.0e-30) then
               begin
                  Vxuds[ipi]:=(gradxuds1[ipi])*(Sqrt(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi]))+ruds_GaAs_top*sqr(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi])))/(1.0+ruds_GaAs_bottom*sqr(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi])))/(sqrt(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi])));
               end
                else
               begin
                  Vxuds[ipi]:=0.0;
               end;
            end;
         end;
      end;
   end;

   if ((icurentuds=1)and(itypemassFluxuds1=6)) then
   begin
      // Особый случай : задана аналитическая скорость в виде водоворота.
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               //  6.282*sin(3.141*$x)*sin(3.141*$x)*sin(3.141*$y)*cos(3.141*$y)
               Vxuds[ipi]:=6.282*sin(3.141*0.5*(xpos[i]+xpos[i+1]))*sin(3.141*0.5*(xpos[i]+xpos[i+1]))*sin(3.141*ypos[j])*cos(3.141*ypos[j]);
            end;
         end;
      end;
   end;

    if ((icurentuds=1)and(itypemassFluxuds1=7)) then
   begin
      // Особый случай : задана аналитическая скорость направленная
      // к верхнему левому углу и правому нижнему углу.
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               //  6.282*sin(3.141*$x)*sin(3.141*$x)*sin(3.141*$y)*cos(3.141*$y)
               Vxuds[ipi]:=6.282*sin(3.141*0.5*(xpos[i]+xpos[i+1]))*sin(3.141*0.5*(xpos[i]+xpos[i+1]))*sin(3.141*ypos[j])*cos(3.141*ypos[j]);
            end;
         end;
      end;
   end;


   if ((icurentuds=2)and(itypemassFluxuds2=5)) then
   begin
      // В случае если
      // edtVx.Text = -$gradyuds1, а
      // edtVy.Text = $gradxuds1 то
      // это случай уравнений Навье-Стокса в переменных вихрь-функция тока.
      // Его нужно очень быстро вычислять потому что эта модель относительно часто используется.
      // При распознании данной ситуации вынесем этот случай в особый вариант itypemassFluxuds2=5.
      universalgrady_mapx(UDS1 , Vxuds);
      // меняем знак.
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               Vxuds[ipi]:=-Vxuds[ipi];
            end;
         end;
      end;
   end;

   if ((icurentuds=3)and(itypemassFluxuds3=5)) then
   begin
      // В случае если
      // edtVx.Text = -$gradyuds1, а
      // edtVy.Text = $gradxuds1 то
       // это случай уравнений Навье-Стокса в приближении Обербека-Буссинеска в переменных вихрь-функция тока.
      // Его нужно очень быстро вычислять потому что эта модель относительно часто используется.
      // При распознании данной ситуации вынесем этот случай в особый вариант itypemassFluxuds3=5.
      // Третье уравнение предполагается уравнением теплопередачи.
      universalgrady_mapx(UDS1 , Vxuds);
      // меняем знак.
      for k:=1 to imaxnumbernodeVx do
      begin
         with mapVx[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*(inx-1);
               Vxuds[ipi]:=-Vxuds[ipi];
            end;
         end;
      end;
   end;

   // Горизонтальная скорость
   for k:=1 to imaxnumbernodeVx do
   begin
      with mapVx[k] do
      begin
         if (itype<>0) then
         begin
            ipi:=i+(j-1)*(inx-1);

            case icurentuds of
              1 : begin
                      case itypemassFluxuds1 of
                         0 : begin
                                // нулевые скорости
                                Vxuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vxuds[ipi]:=Vx[ipi];
                             end;
                         2 : begin
                                val(Vxuds1str,c,code);
                                if (code=0) then
                                begin
                                   Vxuds[ipi]:=c;
                                end
                                 else
                                begin

                                   if (bquickcalcVx[0]) then
                                   begin
                                      parametric[0].sval:=FloatToStr(0.5*(xpos[i]+xpos[i+1]));
                                   end
                                    else
                                   begin
                                      parametric[0].sval:='0.0';
                                   end;
                                   if (bquickcalcVx[1]) then
                                   begin
                                      parametric[1].sval:=FloatToStr(ypos[j]);
                                   end
                                    else
                                   begin
                                      parametric[1].sval:='0.0';
                                   end;
                                   if (bquickcalcVx[2]) then
                                   begin
                                      parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[2].sval:='0.0';
                                   end;
                                   if (bquickcalcVx[3]) then
                                   begin
                                      parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[3].sval:='0.0';
                                   end;
                                   if (bquickcalcVx[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;
                                 bOk:=true;
                                 Vxuds[ipi]:=my_real_convert(Vxuds1str,bOk);
                                 end;
                             end;
                      end;
                  end;
              2 : begin
                     case itypemassFluxuds2 of
                         0 : begin
                                // нулевые скорости
                                 Vxuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vxuds[ipi]:=Vx[ipi];
                             end;
                         2 : begin
                                val(Vxuds2str,c,code);
                                if (code=0) then
                                begin
                                   Vxuds[ipi]:=c;
                                end
                                else
                                begin

                                 if (bquickcalcVx[0]) then
                                 begin
                                    parametric[0].sval:=FloatToStr(0.5*(xpos[i]+xpos[i+1]));
                                 end
                                 else
                                 begin
                                    parametric[0].sval:='0.0';
                                 end;
                                  if (bquickcalcVx[1]) then
                                 begin
                                    parametric[1].sval:=FloatToStr(ypos[j]);
                                 end
                                 else
                                 begin
                                    parametric[1].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[2]) then
                                 begin
                                    parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[2].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[3]) then
                                 begin
                                    parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[3].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;
                                 bOk:=true;
                                 Vxuds[ipi]:=my_real_convert(Vxuds2str,bOk);
                                 end;
                             end;

                     end;
                  end;
              3 : begin
                     case itypemassFluxuds3 of
                         0 : begin
                                // нулевые скорости
                                Vxuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vxuds[ipi]:=Vx[ipi];
                             end;
                         2 : begin
                                val(Vxuds3str,c,code);
                                if (code=0) then
                                begin
                                   Vxuds[ipi]:=c;
                                end
                                else
                                begin

                                if (bquickcalcVx[0]) then
                                 begin
                                    parametric[0].sval:=FloatToStr(0.5*(xpos[i]+xpos[i+1]));
                                 end
                                 else
                                 begin
                                    parametric[0].sval:='0.0';
                                 end;
                                  if (bquickcalcVx[1]) then
                                 begin
                                    parametric[1].sval:=FloatToStr(ypos[j]);
                                 end
                                 else
                                 begin
                                    parametric[1].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[2]) then
                                 begin
                                    parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[2].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[3]) then
                                 begin
                                    parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[3].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;
                                bOk:=true;
                                Vxuds[ipi]:=my_real_convert(Vxuds3str,bOk);
                                end;
                             end;
                     end;
                  end;
              4 : begin
                     case itypemassFluxuds4 of
                         0 : begin
                                // нулевые скорости
                                Vxuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vxuds[ipi]:=Vx[ipi];
                             end;
                         2 : begin
                                val(Vxuds4str,c,code);
                                if (code=0) then
                                begin
                                   Vxuds[ipi]:=c;
                                end
                                 else
                                begin

                                 if (bquickcalcVx[0]) then
                                 begin
                                    parametric[0].sval:=FloatToStr(0.5*(xpos[i]+xpos[i+1]));
                                 end
                                 else
                                 begin
                                    parametric[0].sval:='0.0';
                                 end;
                                  if (bquickcalcVx[1]) then
                                 begin
                                    parametric[1].sval:=FloatToStr(ypos[j]);
                                 end
                                 else
                                 begin
                                    parametric[1].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[2]) then
                                 begin
                                    parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[2].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[3]) then
                                 begin
                                    parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[3].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVx[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;
                                 bOk:=true;
                                 Vxuds[ipi]:=my_real_convert(Vxuds4str,bOk);
                                 end;
                             end;
                     end;
                  end;
            end;
         end;
      end;
   end;



   case imaxUDS  of
     1 : begin
            SetLength(gradyuds1,inx*(iny-1)+1);
            SetLength(gradyuds2,0);
            SetLength(gradyuds3,0);
            SetLength(gradyuds4,0);

            SetLength(gradxuds1,inx*(iny-1)+1);
            SetLength(gradxuds2,0);
            SetLength(gradxuds3,0);
            SetLength(gradxuds4,0);
            if (((icurentuds=1)and(itypemassFluxuds1=2))) then
            begin
               // Вычисляет производную по y.
               // U - задано на сетке mapPT, gradyU - задано на сетке для вертикальной скорости.
               universalgrady(UDS1 , gradyuds1);
               // Вычисляет производную по x.
               // U - задано на сетке mapPT, gradxU - задано на сетке для вертикальной скорости.
               universalgradx_mapy(UDS1 , gradxuds1);
            end;
         end;
     2 : begin
            SetLength(gradyuds1,inx*(iny-1)+1);
            SetLength(gradyuds2,inx*(iny-1)+1);
            SetLength(gradyuds3,0);
            SetLength(gradyuds4,0);

            SetLength(gradxuds1,inx*(iny-1)+1);
            SetLength(gradxuds2,inx*(iny-1)+1);
            SetLength(gradxuds3,0);
            SetLength(gradxuds4,0);
             if (((icurentuds=1)and(itypemassFluxuds1=2))or ((icurentuds=2)and(itypemassFluxuds2=2))) then
            begin
               // Вычисляет производную по y.
               // U - задано на сетке mapPT, gradyU - задано на сетке для вертикальной скорости.
               universalgrady(UDS1 , gradyuds1);
               universalgrady(UDS2 , gradyuds2);
               // Вычисляет производную по x.
               // U - задано на сетке mapPT, gradxU - задано на сетке для вертикальной скорости.
               universalgradx_mapy(UDS1 , gradxuds1);
               universalgradx_mapy(UDS2 , gradxuds2);
            end;
         end;
     3 : begin
            SetLength(gradyuds1,inx*(iny-1)+1);
            SetLength(gradyuds2,inx*(iny-1)+1);
            SetLength(gradyuds3,inx*(iny-1)+1);
            SetLength(gradyuds4,0);

            SetLength(gradxuds1,inx*(iny-1)+1);
            SetLength(gradxuds2,inx*(iny-1)+1);
            SetLength(gradxuds3,inx*(iny-1)+1);
            SetLength(gradxuds4,0);

            if (((icurentuds=1)and(itypemassFluxuds1=2))or ((icurentuds=2)and(itypemassFluxuds2=2))or ((icurentuds=3)and(itypemassFluxuds3=2))) then
            begin
               // Вычисляет производную по y.
               // U - задано на сетке mapPT, gradyU - задано на сетке для вертикальной скорости.
               universalgrady(UDS1 , gradyuds1);
               universalgrady(UDS2 , gradyuds2);
               universalgrady(UDS3 , gradyuds3);
               // Вычисляет производную по x.
               // U - задано на сетке mapPT, gradxU - задано на сетке для вертикальной скорости.
               universalgradx_mapy(UDS1 , gradxuds1);
               universalgradx_mapy(UDS2 , gradxuds2);
               universalgradx_mapy(UDS3 , gradxuds3);
            end;
         end;
      4 : begin
            SetLength(gradyuds1,inx*(iny-1)+1);
            SetLength(gradyuds2,inx*(iny-1)+1);
            SetLength(gradyuds3,inx*(iny-1)+1);
            SetLength(gradyuds4,inx*(iny-1)+1);

            SetLength(gradxuds1,inx*(iny-1)+1);
            SetLength(gradxuds2,inx*(iny-1)+1);
            SetLength(gradxuds3,inx*(iny-1)+1);
            SetLength(gradxuds4,inx*(iny-1)+1);

            if (((icurentuds=1)and(itypemassFluxuds1=2))or ((icurentuds=2)and(itypemassFluxuds2=2))or ((icurentuds=3)and(itypemassFluxuds3=2))or ((icurentuds=4)and(itypemassFluxuds4=2))) then
            begin
               // Вычисляет производную по y.
               // U - задано на сетке mapPT, gradyU - задано на сетке для вертикальной скорости.
               universalgrady(UDS1 , gradyuds1);
               universalgrady(UDS2 , gradyuds2);
               universalgrady(UDS3 , gradyuds3);
               universalgrady(UDS4 , gradyuds4);
               // Вычисляет производную по x.
               // U - задано на сетке mapPT, gradxU - задано на сетке для вертикальной скорости.
               universalgradx_mapy(UDS1 , gradxuds1);
               universalgradx_mapy(UDS2 , gradxuds2);
               universalgradx_mapy(UDS3 , gradxuds3);
               universalgradx_mapy(UDS4 , gradxuds4);
            end;
         end;
   end;

   ivar:=10; // 2 переменные x и y
   SetLength(parametric,ivar);
   parametric[0].svar:='$x';
   parametric[1].svar:='$y';
   parametric[2].svar:='$gradxuds1';
   parametric[3].svar:='$gradxuds2';
   parametric[4].svar:='$gradxuds3';
   parametric[5].svar:='$gradxuds4';
   parametric[6].svar:='$gradyuds1';
   parametric[7].svar:='$gradyuds2';
   parametric[8].svar:='$gradyuds3';
   parametric[9].svar:='$gradyuds4';

   if ((icurentuds=2)and(itypemassFluxuds2=3)) then
   begin
      // В случае если
      // edtVx.Text = $gradxuds1, а
      // edtVy.Text = $gradyuds1 то
      // это случай ДДМ модели для электронного газа (обезразмеренный).
      // Его нужно очень быстро вычислять потомучто эта модель очень важна для Пульсара.
      // При распознании данной ситуации вынесем этот случай в особый вариант itypemassFluxuds2=3.
      universalgrady(UDS1 , Vyuds);
   end;

   if ((icurentuds=2)and(itypemassFluxuds2=4)) then
   begin
      // Особый случай : задана полескоростная характеристика кремния.
      universalgradx_mapy(UDS1 , gradxuds1);
      universalgrady(UDS1 , gradyuds1);
      for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*inx;
               c:=Sqrt(Sqr(gradxuds1[ipi])+Sqr(gradyuds1[ipi]));
               Vyuds[ipi]:=gradyuds1[ipi]/(1.0+ruds_silicon*c);
            end;
         end;
      end;
   end;

   if ((icurentuds=2)and(itypemassFluxuds2=8)) then
   begin
      // Особый случай : задана полескоростная характеристика GaAs.
      universalgradx_mapy(UDS1 , gradxuds1);
      universalgrady(UDS1 , gradyuds1);
      for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*inx;
               if (sqrt(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi]))>1.0e-30) then
               begin
                  Vyuds[ipi]:=(gradyuds1[ipi])*(Sqrt(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi]))+ruds_GaAs_top*sqr(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi])))/(1.0+ruds_GaAs_bottom*sqr(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi])))/(sqrt(sqr(gradxuds1[ipi])+sqr(gradyuds1[ipi])));
               end
               else
               begin
                  Vyuds[ipi]:=0.0;
               end;

            end;
         end;
      end;
   end;

   if ((icurentuds=2)and(itypemassFluxuds2=5)) then
   begin
      // В случае если
      // edtVx.Text = -$gradyuds1, а
      // edtVy.Text = $gradxuds1 то
      // это случай уравнений Навье-Стокса в переменных вихрь-функция тока.
      // Его нужно очень быстро вычислять потому что эта модель относительно часто используется.
      // При распознании данной ситуации вынесем этот случай в особый вариант itypemassFluxuds2=5.
      universalgradx_mapy(UDS1 , Vyuds);
   end;

   if ((icurentuds=1)and(itypemassFluxuds1=6)) then
   begin
      // Особый случай : задана аналитическая скорость в виде водоворота.
      for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*inx;
               //  -6.282*sin(3.141*$y)*sin(3.141*$y)*sin(3.141*$x)*cos(3.141*$x)
               Vyuds[ipi]:=-6.282*sin(3.141*0.5*(ypos[j]+ypos[j+1]))*sin(3.141*0.5*(ypos[j]+ypos[j+1]))*sin(3.141*xpos[i])*cos(3.141*xpos[i]);
            end;
         end;
      end;
   end;

   if ((icurentuds=1)and(itypemassFluxuds1=7)) then
   begin
      // Особый случай : задана аналитическая скорость в виде .
      // движений среды направленных левому верхнему узлу и правому нижнему.
      for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype<>0) then
            begin
               ipi:=i+(j-1)*inx;
               //  6.282*sin(3.141*$y)*sin(3.141*$y)*sin(3.141*$x)*cos(3.141*$x)
               Vyuds[ipi]:=6.282*sin(3.141*0.5*(ypos[j]+ypos[j+1]))*sin(3.141*0.5*(ypos[j]+ypos[j+1]))*sin(3.141*xpos[i])*cos(3.141*xpos[i]);
            end;
         end;
      end;
   end;


   if ((icurentuds=3)and(itypemassFluxuds3=5)) then
   begin
      // В случае если
      // edtVx.Text = -$gradyuds1, а
      // edtVy.Text = $gradxuds1 то
       // это случай уравнений Навье-Стокса в приближении Обербека-Буссинеска в переменных вихрь-функция тока.
      // Его нужно очень быстро вычислять потому что эта модель относительно часто используется.
      // При распознании данной ситуации вынесем этот случай в особый вариант itypemassFluxuds3=5.
      // Третье уравнение предполагается уравнением теплопередачи.
      universalgradx_mapy(UDS1 , Vyuds);
   end;

   // Вертикальная скорость
   for k:=1 to Form1.imaxnumbernodeVy do
   begin
      with Form1.mapVy[k] do
      begin
         if (itype<>0) then
         begin
            ipi:=i+(j-1)*inx;


            case icurentuds of
              1 : begin
                     case itypemassFluxuds1 of
                         0 : begin
                                // нулевые скорости
                                Vyuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vyuds[ipi]:=Vy[ipi];
                             end;
                         2 : begin
                                val(Vyuds1str,c,code);
                                if (code=0) then
                                begin
                                   Vyuds[ipi]:=c;
                                end
                                 else
                                begin

                                   if (bquickcalcVy[0]) then
                                   begin
                                      parametric[0].sval:=FloatToStr(xpos[i]);
                                   end
                                    else
                                   begin
                                      parametric[0].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[1]) then
                                   begin
                                      parametric[1].sval:=FloatToStr(0.5*(ypos[j]+ypos[j+1]));
                                   end
                                    else
                                   begin
                                      parametric[1].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[2]) then
                                   begin
                                      parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[2].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[3]) then
                                   begin
                                      parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[3].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[4]) then
                                   begin
                                      parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[4].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[5]) then
                                   begin
                                      parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[5].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[6]) then
                                   begin
                                      parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[6].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[7]) then
                                   begin
                                      parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[7].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[8]) then
                                   begin
                                      parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[8].sval:='0.0';
                                   end;
                                   if (bquickcalcVy[9]) then
                                   begin
                                      parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                   end
                                    else
                                   begin
                                      parametric[9].sval:='0.0';
                                   end;
                                   bOk:=true;
                                   Vyuds[ipi]:=my_real_convert(Vyuds1str,bOk);
                                end;
                             end;
                     end;

                  end;
              2 : begin
                     case itypemassFluxuds2 of
                         0 : begin
                                // нулевые скорости
                                 Vyuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vyuds[ipi]:=Vy[ipi];
                             end;
                          2 : begin
                                 val(Vyuds2str,c,code);
                                 if (code=0) then
                                 begin
                                     Vyuds[ipi]:=c;
                                 end
                                  else
                                 begin

                                 if (bquickcalcVy[0]) then
                                 begin
                                    parametric[0].sval:=FloatToStr(xpos[i]);
                                 end
                                 else
                                 begin
                                    parametric[0].sval:='0.0';
                                 end;
                                  if (bquickcalcVy[1]) then
                                 begin
                                    parametric[1].sval:=FloatToStr(0.5*(ypos[j]+ypos[j+1]));
                                 end
                                 else
                                 begin
                                    parametric[1].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[2]) then
                                 begin
                                    parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[2].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[3]) then
                                 begin
                                    parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[3].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;
                                bOk:=true;
                                Vyuds[ipi]:=my_real_convert(Vyuds2str,bOk);
                                end;
                             end;
                     end;
                  end;
              3 : begin
                     case itypemassFluxuds3 of
                         0 : begin
                                // нулевые скорости
                                 Vyuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vyuds[ipi]:=Vy[ipi];
                             end;
                         2 : begin
                                val(Vyuds3str,c,code);
                                if (code=0) then
                                begin
                                   Vyuds[ipi]:=c;
                                end
                                else
                                begin

                                if (bquickcalcVy[0]) then
                                 begin
                                    parametric[0].sval:=FloatToStr(xpos[i]);
                                 end
                                 else
                                 begin
                                    parametric[0].sval:='0.0';
                                 end;
                                  if (bquickcalcVy[1]) then
                                 begin
                                    parametric[1].sval:=FloatToStr(0.5*(ypos[j]+ypos[j+1]));
                                 end
                                 else
                                 begin
                                    parametric[1].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[2]) then
                                 begin
                                    parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[2].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[3]) then
                                 begin
                                    parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[3].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;
                                bOk:=true;
                                Vyuds[ipi]:=my_real_convert(Vyuds3str,bOk);
                                end;
                             end;
                     end;

                  end;
              4 : begin
                     case itypemassFluxuds4 of
                         0 : begin
                                // нулевые скорости
                                 Vyuds[ipi]:=0.0;
                             end;
                         1 : begin
                                // гидродинамические скорости.
                                Vyuds[ipi]:=Vy[ipi];
                             end;
                         2 : begin
                                val(Vyuds4str,c,code);
                                if (code=0) then
                                begin
                                    Vyuds[ipi]:=c;
                                end
                                else
                                begin

                                 if (bquickcalcVy[0]) then
                                 begin
                                    parametric[0].sval:=FloatToStr(xpos[i]);
                                 end
                                 else
                                 begin
                                    parametric[0].sval:='0.0';
                                 end;
                                  if (bquickcalcVy[1]) then
                                 begin
                                    parametric[1].sval:=FloatToStr(0.5*(ypos[j]+ypos[j+1]));
                                 end
                                 else
                                 begin
                                    parametric[1].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[2]) then
                                 begin
                                    parametric[2].sval:=FloatToStr(gradxuds1[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[2].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[3]) then
                                 begin
                                    parametric[3].sval:=FloatToStr(gradxuds2[ipi]);
                                    end
                                 else
                                 begin
                                    parametric[3].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[4]) then
                                 begin
                                    parametric[4].sval:=FloatToStr(gradxuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[4].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[5]) then
                                 begin
                                    parametric[5].sval:=FloatToStr(gradxuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[5].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[6]) then
                                 begin
                                    parametric[6].sval:=FloatToStr(gradyuds1[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[6].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[7]) then
                                 begin
                                    parametric[7].sval:=FloatToStr(gradyuds2[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[7].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[8]) then
                                 begin
                                 parametric[8].sval:=FloatToStr(gradyuds3[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[8].sval:='0.0';
                                 end;
                                   if (bquickcalcVy[9]) then
                                 begin
                                    parametric[9].sval:=FloatToStr(gradyuds4[ipi]);
                                 end
                                 else
                                 begin
                                    parametric[9].sval:='0.0';
                                 end;

                                 bOk:=true;
                                 Vyuds[ipi]:=my_real_convert(Vyuds4str,bOk);
                                 end;
                             end;
                     end;

                  end;
            end;
         end;
      end;
   end;

   // Источниковый член в первом уравнении для диффузионно-дрейфовой модели имеет стандартную форму и это надо
    // учесть для увеличения Быстродействия. ДДМ очень важна поэтому имеет смысл прилагать все усилия чтобы она быстро считала.
    // 0 - стандартный user-defined шаблон.
    // 1 - источниковый член в диффузионно дрейфовой модели (из двух уравнений первое для электрического потенциала, для
    // этого уравнения как раз и задаётся источниковый член, а второе уравнение для переноса электронного газа (именно электронного).
    //)вида K1*(1.0-$uds2), где K1=rdsc1K1 - заданная пользователем постоянная.
    // 2 - аналогично с 1 но источник имеет вид $udm1-K1*$uds2, здесь $udm1 - неоднородное легирование,
    // $uds2 - концентрация электронов, K1=rdsc1K1 - константа определённая пользователем.
    //idsc1type : Integer;
    //rdsc1K1 : Float;
    // Следующая булева переменная равна True только тогда когда в момент вычисления
    // для первого уравнения имеем константу dSpравную нулю тождественно, и константный коэффициент диффузии.
    // а dsc определяется по быстрму встроенному шаблону!!!.
    // Значение True проверяется и в случае необходимости присваивается внутри simple algorithm`a
    // в ручную значение False здесь менять ни в коем случае нельзя !!!
    //buds1coefconst : Boolean;
    //diffuds1const : Float; // константный коэффициент диффузии для первого уравнения во всей расчётной области,
    // используется только при buds1coefconst=true;
    if ((icurentuds=1) and (buds1coefconst)) then
    begin
       if (idsc1type=1) then
       begin
          // случай однородного легирования.
          for k:=1 to Form1.imaxnumbernode do
          begin
             with Form1.mapPT[k] do
             begin
                if (itype<>0) then
                begin
                   ipi:=i+(j-1)*inx;
                   dsp1[ipi]:=0.0;
                   uds1diffusivity[ipi]:=diffuds1const;
                   dsc1[ipi]:=rdsc1K1*(1.0-UDS2[ipi]);
                end;
             end;
          end;
       end
       else if (idsc1type=2) then
       begin
          // случай неоднородного легирования.
          // Неоднородность задаётся в первой user-defined memory.
          for k:=1 to Form1.imaxnumbernode do
          begin
             with Form1.mapPT[k] do
             begin
                if (itype<>0) then
                begin
                   //ipi:=i+(j-1)*inx;
                   ipi:=k;
                   dsp1[ipi]:=0.0;
                   uds1diffusivity[ipi]:=diffuds1const;
                   dsc1[ipi]:=UDM1[ipi]-rdsc1K1*UDS2[ipi];
                end;
             end;
          end;
       end;
    end
     else
    begin

       bcontquick:=true;
       // Если все коэффициенты константы то нам незачем городить огород
       // и можно сразу выполнить присвоение.
       case icurentuds of
          1 : begin
                 // Источниковый член.
                 val(dsc1str,c,code);
                 if (code=0) then
                 begin
                    cdsc:=c;
                    val(dsp1str,c,code);
                    if (code=0) then
                    begin
                       cdsp:=c;
                       val(gamma1str,c,code);
                       if (code=0) then
                       begin
                          cdiff:=c;
                          bcontquick:=false;
                          for k:=1 to Form1.imaxnumbernode do
                          begin
                             if (mapPT[k].itype<>0) then
                             begin
                                dsc1[k]:=cdsc;
                                dsp1[k]:=cdsp;
                                uds1diffusivity[k]:=cdiff;
                             end;
                          end;
                       end;
                    end;
                 end;
              end;
          2 : begin
                  // Источниковый член.
                 val(dsc2str,c,code);
                 if (code=0) then
                 begin
                    cdsc:=c;
                    val(dsp2str,c,code);
                    if (code=0) then
                    begin
                       cdsp:=c;
                       val(gamma2str,c,code);
                       if (code=0) then
                       begin
                          cdiff:=c;
                          bcontquick:=false;
                          for k:=1 to imaxnumbernode do
                          begin
                             if (mapPT[k].itype<>0) then
                             begin
                                dsc2[k]:=cdsc;
                                dsp2[k]:=cdsp;
                                uds2diffusivity[k]:=cdiff;
                             end;
                          end;
                       end;
                    end;
                 end;
              end;
          3 : begin
                  // Источниковый член.
                 val(dsc3str,c,code);
                 if (code=0) then
                 begin
                    cdsc:=c;
                    val(dsp3str,c,code);
                    if (code=0) then
                    begin
                       cdsp:=c;
                       val(gamma3str,c,code);
                       if (code=0) then
                       begin
                          cdiff:=c;
                          bcontquick:=false;
                          for k:=1 to imaxnumbernode do
                          begin
                               if (mapPT[k].itype<>0) then
                                begin
                                   dsc3[k]:=cdsc;
                                   dsp3[k]:=cdsp;
                                   uds3diffusivity[k]:=cdiff;
                                end;
                          end;
                       end;
                    end;
                 end;
              end;
          4 : begin
                  // Источниковый член.
                 val(dsc4str,c,code);
                 if (code=0) then
                 begin
                    cdsc:=c;
                    val(dsp4str,c,code);
                    if (code=0) then
                    begin
                       cdsp:=c;
                       val(gamma4str,c,code);
                       if (code=0) then
                       begin
                          cdiff:=c;
                          bcontquick:=false;
                          for k:=1 to imaxnumbernode do
                          begin
                             if (mapPT[k].itype<>0) then
                             begin
                                dsc4[k]:=cdsc;
                                dsp4[k]:=cdsp;
                                uds4diffusivity[k]:=cdiff;
                             end;
                          end;
                       end;
                    end;
                 end;
              end;
       end;

       if (bcontquick) then
       begin

   case imaxUDS of
      1 : begin
             // Выделение памяти.
             if (bquickcalc[17]) then
             begin
                SetLength(laplasxuds1,inx*iny+1);
             end;
             SetLength(laplasxuds2,0);
             SetLength(laplasxuds3,0);
             SetLength(laplasxuds4,0);
             if (bquickcalc[21]) then
             begin
                SetLength(laplasyuds1,inx*iny+1);
             end;
             SetLength(laplasyuds2,0);
             SetLength(laplasyuds3,0);
             SetLength(laplasyuds4,0);
             if (bquickcalc[13]) then
             begin
                SetLength(laplasuds1,inx*iny+1);
             end;
             SetLength(laplasuds2,0);
             SetLength(laplasuds3,0);
             SetLength(laplasuds4,0);
             if (bquickcalc[25]) then
             begin
                SetLength(gradxmapptuds1,inx*iny+1);
             end;
             SetLength(gradxmapptuds2,0);
             SetLength(gradxmapptuds3,0);
             SetLength(gradxmapptuds4,0);
             if (bquickcalc[29]) then
             begin
                SetLength(gradymapptuds1,inx*iny+1);
             end;
             SetLength(gradymapptuds2,0);
             SetLength(gradymapptuds3,0);
             SetLength(gradymapptuds4,0);
             // Вычисление.
             if (bquickcalc[17]) then
             begin
                universallaplasx(UDS1,laplasxuds1);
             end;
             if (bquickcalc[21]) then
             begin
                universallaplasy(UDS1,laplasyuds1);
             end;
             if (bquickcalc[13]) then
             begin
                universallaplas(UDS1,laplasuds1);
             end;
             if (bquickcalc[25]) then
             begin
                universalgradx_mapPT(UDS1,gradxmapptuds1);
             end;
             if (bquickcalc[29]) then
             begin
                universalgrady_mapPT(UDS1,gradymapptuds1);
             end;
             if (bquickcalc[33]) then
             begin
                SetLength(gradxymapptuds1,inx*iny+1);
                universalgradxy_mapPT(UDS1,gradxymapptuds1);
             end;
             SetLength(gradxymapptuds2,0);
             SetLength(gradxymapptuds3,0);
             SetLength(gradxymapptuds4,0);
          end;
      2 : begin
             // Выделение памяти.
             SetLength(laplasxuds3,0);
             SetLength(laplasyuds3,0);
             SetLength(laplasuds3,0);
             SetLength(gradxmapptuds3,0);
             SetLength(gradymapptuds3,0);
             SetLength(laplasxuds4,0);
             SetLength(laplasyuds4,0);
             SetLength(laplasuds4,0);
             SetLength(gradxmapptuds4,0);
             SetLength(gradymapptuds4,0);
             // Вычисление.
             if (bquickcalc[17]) then
             begin
                universallaplasx(UDS1,laplasxuds1);
                SetLength(laplasxuds1,inx*iny+1);
             end;
             if (bquickcalc[18]) then
             begin
             universallaplasx(UDS2,laplasxuds2);
             SetLength(laplasxuds2,inx*iny+1);
             end;
             if (bquickcalc[21]) then
             begin
             universallaplasy(UDS1,laplasyuds1);
             SetLength(laplasyuds1,inx*iny+1);
             end;
             if (bquickcalc[22]) then
             begin
             universallaplasy(UDS2,laplasyuds2);
             SetLength(laplasyuds2,inx*iny+1);
             end;
             if (bquickcalc[13]) then
             begin
             universallaplas(UDS1,laplasuds1);
             SetLength(laplasuds1,inx*iny+1);
             end;
             if (bquickcalc[14]) then
             begin
             universallaplas(UDS2,laplasuds2);
             SetLength(laplasuds2,inx*iny+1);
             end;
             if (bquickcalc[25]) then
             begin
             universalgradx_mapPT(UDS1,gradxmapptuds1);
             SetLength(gradxmapptuds1,inx*iny+1);
             end;
             if (bquickcalc[26]) then
             begin
             universalgradx_mapPT(UDS2,gradxmapptuds2);
             SetLength(gradxmapptuds2,inx*iny+1);
             end;
             if (bquickcalc[29]) then
             begin
             universalgrady_mapPT(UDS1,gradymapptuds1);
             SetLength(gradymapptuds1,inx*iny+1);
             end;
             if (bquickcalc[30]) then
             begin
             universalgrady_mapPT(UDS2,gradymapptuds2);
             SetLength(gradymapptuds2,inx*iny+1);
             end;
             if (bquickcalc[33]) then
             begin
                SetLength(gradxymapptuds1,inx*iny+1);
                universalgradxy_mapPT(UDS1,gradxymapptuds1);
             end;
              if (bquickcalc[34]) then
             begin
                SetLength(gradxymapptuds2,inx*iny+1);
                universalgradxy_mapPT(UDS2,gradxymapptuds2);
             end;
             SetLength(gradxymapptuds3,0);
             SetLength(gradxymapptuds4,0);
          end;
      3 : begin
             // Выделение памяти.
             SetLength(laplasxuds4,0);
             SetLength(laplasyuds4,0);
             SetLength(laplasuds4,0);
             SetLength(gradxmapptuds4,0);
             SetLength(gradymapptuds4,0);
             // и Вычисление.
             if (bquickcalc[17]) then
             begin
                SetLength(laplasxuds1,inx*iny+1);
                universallaplasx(UDS1,laplasxuds1);
             end;
             if (bquickcalc[18]) then
             begin
                SetLength(laplasxuds2,inx*iny+1);
                universallaplasx(UDS2,laplasxuds2);
             end;
             if (bquickcalc[19]) then
             begin
                SetLength(laplasxuds3,inx*iny+1);
                universallaplasx(UDS3,laplasxuds3);
             end;
             if (bquickcalc[21]) then
             begin
                SetLength(laplasyuds1,inx*iny+1);
                universallaplasy(UDS1,laplasyuds1);
             end;
             if (bquickcalc[22]) then
             begin
                SetLength(laplasyuds2,inx*iny+1);
                universallaplasy(UDS2,laplasyuds2);
             end;
             if (bquickcalc[23]) then
             begin
                SetLength(laplasyuds3,inx*iny+1);
                universallaplasy(UDS3,laplasyuds3);
             end;
             if (bquickcalc[13]) then
             begin
                SetLength(laplasuds1,inx*iny+1);
                universallaplas(UDS1,laplasuds1);
             end;
             if (bquickcalc[14]) then
             begin
                SetLength(laplasuds2,inx*iny+1);
                universallaplas(UDS2,laplasuds2);
             end;
             if (bquickcalc[15]) then
             begin
                SetLength(laplasuds3,inx*iny+1);
                universallaplas(UDS3,laplasuds3);
             end;
             if (bquickcalc[25]) then
             begin
                SetLength(gradxmapptuds1,inx*iny+1);
                universalgradx_mapPT(UDS1,gradxmapptuds1);
             end;
             if (bquickcalc[26]) then
             begin
                SetLength(gradxmapptuds2,inx*iny+1);
                universalgradx_mapPT(UDS2,gradxmapptuds2);
             end;
             if (bquickcalc[27]) then
             begin
                SetLength(gradxmapptuds3,inx*iny+1);
                universalgradx_mapPT(UDS3,gradxmapptuds3);
             end;
             if (bquickcalc[29]) then
             begin
                SetLength(gradymapptuds1,inx*iny+1);
                universalgrady_mapPT(UDS1,gradymapptuds1);
             end;
             if (bquickcalc[30]) then
             begin
                SetLength(gradymapptuds2,inx*iny+1);
                universalgrady_mapPT(UDS2,gradymapptuds2);
             end;
             if (bquickcalc[31]) then
             begin
                SetLength(gradymapptuds3,inx*iny+1);
                universalgrady_mapPT(UDS3,gradymapptuds3);
             end;
             if (bquickcalc[33]) then
             begin
                SetLength(gradxymapptuds1,inx*iny+1);
                universalgradxy_mapPT(UDS1,gradxymapptuds1);
             end;
              if (bquickcalc[34]) then
             begin
                SetLength(gradxymapptuds2,inx*iny+1);
                universalgradxy_mapPT(UDS2,gradxymapptuds2);
             end;
             if (bquickcalc[35]) then
             begin
                SetLength(gradxymapptuds3,inx*iny+1);
                universalgradxy_mapPT(UDS3,gradxymapptuds3);
             end;
             SetLength(gradxymapptuds4,0);
          end;
      4 : begin
             // Выделение памяти.
             // и Вычисление.
             if (bquickcalc[17]) then
             begin
                SetLength(laplasxuds1,inx*iny+1);
                universallaplasx(UDS1,laplasxuds1);
             end;
             if (bquickcalc[18]) then
             begin
                SetLength(laplasxuds2,inx*iny+1);
                universallaplasx(UDS2,laplasxuds2);
             end;
             if (bquickcalc[19]) then
             begin
                SetLength(laplasxuds3,inx*iny+1);
                universallaplasx(UDS3,laplasxuds3);
             end;
             if (bquickcalc[20]) then
             begin
                SetLength(laplasxuds4,inx*iny+1);
                universallaplasx(UDS4,laplasxuds4);
             end;
             if (bquickcalc[21]) then
             begin
                SetLength(laplasyuds1,inx*iny+1);
                universallaplasy(UDS1,laplasyuds1);
             end;
             if (bquickcalc[22]) then
             begin
                SetLength(laplasyuds2,inx*iny+1);
                universallaplasy(UDS2,laplasyuds2);
             end;
             if (bquickcalc[23]) then
             begin
                SetLength(laplasyuds3,inx*iny+1);
                universallaplasy(UDS3,laplasyuds3);
             end;
             if (bquickcalc[24]) then
             begin
                SetLength(laplasyuds4,inx*iny+1);
                universallaplasy(UDS4,laplasyuds4);
             end;
             if (bquickcalc[13]) then
             begin
                SetLength(laplasuds1,inx*iny+1);
                universallaplas(UDS1,laplasuds1);
             end;
             if (bquickcalc[14]) then
             begin
                SetLength(laplasuds2,inx*iny+1);
                universallaplas(UDS2,laplasuds2);
             end;
             if (bquickcalc[15]) then
             begin
                SetLength(laplasuds3,inx*iny+1);
                universallaplas(UDS3,laplasuds3);
             end;
             if (bquickcalc[16]) then
             begin
                SetLength(laplasuds4,inx*iny+1);
                universallaplas(UDS4,laplasuds4);
             end;
             if (bquickcalc[25]) then
             begin
                SetLength(gradxmapptuds1,inx*iny+1);
                universalgradx_mapPT(UDS1,gradxmapptuds1);
             end;
             if (bquickcalc[26]) then
             begin
                SetLength(gradxmapptuds2,inx*iny+1);
                universalgradx_mapPT(UDS2,gradxmapptuds2);
             end;
             if (bquickcalc[27]) then
             begin
                SetLength(gradxmapptuds3,inx*iny+1);
                universalgradx_mapPT(UDS3,gradxmapptuds3);
             end;
             if (bquickcalc[28]) then
             begin
                SetLength(gradxmapptuds4,inx*iny+1);
                universalgradx_mapPT(UDS4,gradxmapptuds4);
             end;
             if (bquickcalc[29]) then
             begin
                SetLength(gradymapptuds1,inx*iny+1);
                universalgrady_mapPT(UDS1,gradymapptuds1);
             end;
             if (bquickcalc[30]) then
             begin
                SetLength(gradymapptuds2,inx*iny+1);
                universalgrady_mapPT(UDS2,gradymapptuds2);
             end;
             if (bquickcalc[31]) then
             begin
                SetLength(gradymapptuds3,inx*iny+1);
                universalgrady_mapPT(UDS3,gradymapptuds3);
             end;
             if (bquickcalc[32]) then
             begin
                SetLength(gradymapptuds4,inx*iny+1);
                universalgrady_mapPT(UDS4,gradymapptuds4);
             end;
              if (bquickcalc[33]) then
             begin
                SetLength(gradxymapptuds1,inx*iny+1);
                universalgradxy_mapPT(UDS1,gradxymapptuds1);
             end;
              if (bquickcalc[34]) then
             begin
                SetLength(gradxymapptuds2,inx*iny+1);
                universalgradxy_mapPT(UDS2,gradxymapptuds2);
             end;
             if (bquickcalc[35]) then
             begin
                SetLength(gradxymapptuds3,inx*iny+1);
                universalgradxy_mapPT(UDS3,gradxymapptuds3);
             end;
              if (bquickcalc[36]) then
             begin
                SetLength(gradxymapptuds4,inx*iny+1);
                universalgradxy_mapPT(UDS4,gradxymapptuds4);
             end;
          end;
   end;




   // список поддерживаемых переменных
   // $x, $y - декартовы координаты.
   // $udm1, $udm2, $udm3 - если есть.  Пользовательская память.
   // $uds1, $uds2, $uds3 - если есть.  Пользовательские скаляры.
   // $diff1, $diff2, $diff3 - коэффициенты диффузии для пользовательских скаляров.
   // Если нет то тождественный ноль.
   ivar:=37; // 2 переменные x и y
   SetLength(parametric,ivar);
   parametric[0].svar:='$x';
   parametric[1].svar:='$y';
   // Пользовательская память.
   parametric[2].svar:='$udm1';
   parametric[3].svar:='$udm2';
   parametric[4].svar:='$udm3';
   // Пользовательский скаляр.
   parametric[5].svar:='$uds1';
   parametric[6].svar:='$uds2';
   parametric[7].svar:='$uds3';
   parametric[8].svar:='$uds4';
   // Коэффициенты диффузии для пользовательских скаляров с предыдущей итерации.
   parametric[9].svar:='$diff1';
   parametric[10].svar:='$diff2';
   parametric[11].svar:='$diff3';
   parametric[12].svar:='$diff4';
   // производные
   parametric[13].svar:='$laplas1';
   parametric[14].svar:='$laplas2';
   parametric[15].svar:='$laplas3';
   parametric[16].svar:='$laplas4';
   parametric[17].svar:='$laplasx1';
   parametric[18].svar:='$laplasx2';
   parametric[19].svar:='$laplasx3';
   parametric[20].svar:='$laplasx4';
   parametric[21].svar:='$laplasy1';
   parametric[22].svar:='$laplasy2';
   parametric[23].svar:='$laplasy3';
   parametric[24].svar:='$laplasy4';
   parametric[25].svar:='$gradxuds1';
   parametric[26].svar:='$gradxuds2';
   parametric[27].svar:='$gradxuds3';
   parametric[28].svar:='$gradxuds4';
   parametric[29].svar:='$gradyuds1';
   parametric[30].svar:='$gradyuds2';
   parametric[31].svar:='$gradyuds3';
   parametric[32].svar:='$gradyuds4';
   parametric[33].svar:='$gradxyuds1';
   parametric[34].svar:='$gradxyuds2';
   parametric[35].svar:='$gradxyuds3';
   parametric[36].svar:='$gradxyuds4';



   for k:=1 to Form1.imaxnumbernode do
   begin
      with Form1.mapPT[k] do
      begin
         if (itype<>0) then
         begin
            ipi:=i+(j-1)*inx;

             if (bquickcalc[0]) then
             begin
                parametric[0].sval:=FloatToStr(Form1.xpos[i]);
             end
              else
             begin
                parametric[0].sval:='0.0'
             end;
             if (bquickcalc[1]) then
             begin
                 parametric[1].sval:=FloatToStr(Form1.ypos[j]);
             end
              else
             begin
                 parametric[1].sval:='0.0'
             end;

            case imaxUDM of
              0 : begin
                     parametric[2].sval:='0.0';
                     parametric[3].sval:='0.0';
                     parametric[4].sval:='0.0';
                  end;
              1 : begin
                     if (bquickcalc[2]) then
                     begin
                        parametric[2].sval:=FloatToStr(UDM1[ipi]);
                     end
                      else
                     begin
                        parametric[2].sval:='0.0'
                     end;
                     Form1.parametric[3].sval:='0.0';
                     Form1.parametric[4].sval:='0.0';
                  end;
              2 : begin
                     if (bquickcalc[2]) then
                     begin
                        parametric[2].sval:=FloatToStr(UDM1[ipi]);
                     end
                      else
                     begin
                        parametric[2].sval:='0.0'
                     end;
                     if (bquickcalc[3]) then
                     begin
                        parametric[3].sval:=FloatToStr(UDM2[ipi]);
                     end
                       else
                     begin
                         parametric[3].sval:='0.0'
                     end;
                     parametric[4].sval:='0.0';
                  end;
              3 : begin
                      if (bquickcalc[2]) then
                     begin
                        parametric[2].sval:=FloatToStr(UDM1[ipi]);
                     end
                      else
                     begin
                        parametric[2].sval:='0.0'
                     end;
                      if (bquickcalc[3]) then
                     begin
                        parametric[3].sval:=FloatToStr(UDM2[ipi]);
                     end
                      else
                     begin
                        parametric[3].sval:='0.0'
                     end;
                      if (bquickcalc[4]) then
                     begin
                        parametric[4].sval:=FloatToStr(UDM3[ipi]);
                     end
                      else
                     begin
                        parametric[4].sval:='0.0'
                     end;
                  end;
            end;
            case imaxUDS of
              0 : begin
                     Form1.parametric[5].sval:='0.0';
                     Form1.parametric[6].sval:='0.0';
                     Form1.parametric[7].sval:='0.0';
                     Form1.parametric[8].sval:='0.0';
                     Form1.parametric[9].sval:='1.0';
                     Form1.parametric[10].sval:='1.0';
                     Form1.parametric[11].sval:='1.0';
                     Form1.parametric[12].sval:='1.0';
                     Form1.parametric[13].sval:='0.0';
                     Form1.parametric[14].sval:='0.0';
                     Form1.parametric[15].sval:='0.0';
                     Form1.parametric[16].sval:='0.0';
                     Form1.parametric[17].sval:='0.0';
                     Form1.parametric[18].sval:='0.0';
                     Form1.parametric[19].sval:='0.0';
                     Form1.parametric[20].sval:='0.0';
                     Form1.parametric[21].sval:='0.0';
                     Form1.parametric[22].sval:='0.0';
                     Form1.parametric[23].sval:='0.0';
                     Form1.parametric[24].sval:='0.0';
                     Form1.parametric[25].sval:='0.0';
                     Form1.parametric[26].sval:='0.0';
                     Form1.parametric[27].sval:='0.0';
                     Form1.parametric[28].sval:='0.0';
                     Form1.parametric[29].sval:='0.0';
                     Form1.parametric[30].sval:='0.0';
                     Form1.parametric[31].sval:='0.0';
                     Form1.parametric[32].sval:='0.0';
                     Form1.parametric[33].sval:='0.0';
                     Form1.parametric[34].sval:='0.0';
                     Form1.parametric[35].sval:='0.0';
                     Form1.parametric[36].sval:='0.0';
                  end;
              1 : begin
                     if (bquickcalc[5]) then
                     begin
                         parametric[5].sval:=FloatToStr(UDS1[ipi]);
                     end
                     else
                     begin
                        parametric[5].sval:='0.0'
                     end;
                     parametric[6].sval:='0.0';
                     parametric[7].sval:='0.0';
                     parametric[8].sval:='0.0';
                      if (bquickcalc[9]) then
                     begin
                        parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                     end
                     else
                     begin
                        parametric[9].sval:='0.0'
                     end;
                     parametric[10].sval:='1.0';
                     parametric[11].sval:='1.0';
                     parametric[12].sval:='1.0';

                     if (bquickcalc[13]) then
                     begin
                        parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                     end
                     else
                     begin
                        parametric[13].sval:='0.0'
                     end;
                     parametric[14].sval:='0.0';
                     parametric[15].sval:='0.0';
                     parametric[16].sval:='0.0';
                     if (bquickcalc[17]) then
                     begin
                        parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                     end
                     else
                     begin
                        parametric[17].sval:='0.0'
                     end;
                     parametric[18].sval:='0.0';
                     parametric[19].sval:='0.0';
                     parametric[20].sval:='0.0';
                     if (bquickcalc[21]) then
                     begin
                        parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                     end
                     else
                     begin
                        parametric[21].sval:='0.0'
                     end;
                     parametric[22].sval:='0.0';
                     parametric[23].sval:='0.0';
                     parametric[24].sval:='0.0';
                     if (bquickcalc[25]) then
                     begin
                        parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[25].sval:='0.0';
                     end;
                     parametric[26].sval:='0.0';
                     parametric[27].sval:='0.0';
                     parametric[28].sval:='0.0';
                     if (bquickcalc[29]) then
                     begin
                        parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[29].sval:='0.0';
                     end;
                     parametric[30].sval:='0.0';
                     parametric[31].sval:='0.0';
                     parametric[32].sval:='0.0';

                     if (bquickcalc[33]) then
                     begin
                        parametric[33].sval:=FloatToStr(gradxymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[33].sval:='0.0';
                     end;
                     parametric[34].sval:='0.0';
                     parametric[35].sval:='0.0';
                     parametric[36].sval:='0.0';
                  end;
              2 : begin
                     if (bquickcalc[5]) then
                     begin
                        parametric[5].sval:=FloatToStr(UDS1[ipi]);
                     end
                     else
                     begin
                        parametric[5].sval:='0.0';
                     end;
                     if (bquickcalc[6]) then
                     begin
                        parametric[6].sval:=FloatToStr(UDS2[ipi]);
                      end
                     else
                     begin
                        parametric[6].sval:='0.0';
                     end;
                     parametric[7].sval:='0.0';
                     parametric[8].sval:='0.0';
                     if (bquickcalc[9]) then
                     begin
                         parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                     end
                     else
                     begin
                        parametric[9].sval:='0.0';
                     end;
                     if (bquickcalc[10]) then
                     begin
                        parametric[10].sval:=FloatToStr(uds2diffusivity[ipi]);
                     end
                     else
                     begin
                        parametric[10].sval:='0.0';
                     end;
                     Form1.parametric[11].sval:='1.0';
                     Form1.parametric[12].sval:='1.0';

                     if (bquickcalc[13]) then
                     begin
                        parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                     end
                     else
                     begin
                        parametric[13].sval:='0.0';
                     end;
                     if (bquickcalc[14]) then
                     begin
                        parametric[14].sval:=FloatToStr(laplasuds2[ipi]);
                     end
                     else
                     begin
                        parametric[14].sval:='0.0';
                     end;
                     parametric[15].sval:='0.0';
                     parametric[16].sval:='0.0';
                     if (bquickcalc[17]) then
                     begin
                        parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                     end
                     else
                     begin
                        parametric[17].sval:='0.0';
                     end;
                     if (bquickcalc[18]) then
                     begin
                        parametric[18].sval:=FloatToStr(laplasxuds2[ipi]);
                     end
                     else
                     begin
                        parametric[18].sval:='0.0';
                     end;
                     parametric[19].sval:='0.0';
                     parametric[20].sval:='0.0';
                     if (bquickcalc[21]) then
                     begin
                        parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                     end
                     else
                     begin
                        parametric[21].sval:='0.0';
                     end;
                     if (bquickcalc[22]) then
                     begin
                        parametric[22].sval:=FloatToStr(laplasyuds2[ipi]);
                     end
                     else
                     begin
                        parametric[22].sval:='0.0';
                     end;
                     parametric[23].sval:='0.0';
                     parametric[24].sval:='0.0';
                     if (bquickcalc[25]) then
                     begin
                        parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[25].sval:='0.0';
                     end;
                     if (bquickcalc[26]) then
                     begin
                        parametric[26].sval:=FloatToStr(gradxmapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[26].sval:='0.0';
                     end;
                     parametric[27].sval:='0.0';
                     parametric[28].sval:='0.0';
                     if (bquickcalc[29]) then
                     begin
                        parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[29].sval:='0.0';
                     end;
                     if (bquickcalc[30]) then
                     begin
                        parametric[30].sval:=FloatToStr(gradymapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[30].sval:='0.0';
                     end;
                     parametric[31].sval:='0.0';
                     parametric[32].sval:='0.0';

                      if (bquickcalc[33]) then
                     begin
                     parametric[33].sval:=FloatToStr(gradxymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[33].sval:='0.0';
                     end;
                      if (bquickcalc[34]) then
                     begin
                        parametric[34].sval:=FloatToStr(gradxymapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[34].sval:='0.0';
                     end;
                     parametric[35].sval:='0.0';
                     parametric[36].sval:='0.0';
                  end;
              3 : begin
                     if (bquickcalc[5]) then
                     begin
                        parametric[5].sval:=FloatToStr(UDS1[ipi]);
                     end
                     else
                     begin
                        parametric[5].sval:='0.0';
                     end;
                      if (bquickcalc[6]) then
                     begin
                        parametric[6].sval:=FloatToStr(UDS2[ipi]);
                     end
                     else
                     begin
                        parametric[6].sval:='0.0';
                     end;
                       if (bquickcalc[7]) then
                     begin
                        parametric[7].sval:=FloatToStr(UDS3[ipi]);
                      end
                     else
                     begin
                        parametric[7].sval:='0.0';
                     end;
                       parametric[8].sval:='0.0';
                     if (bquickcalc[9]) then
                     begin
                        parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                      end
                     else
                     begin
                        parametric[9].sval:='0.0';
                     end;
                     if (bquickcalc[10]) then
                     begin
                        parametric[10].sval:=FloatToStr(uds2diffusivity[ipi]);
                      end
                     else
                     begin
                        parametric[10].sval:='0.0';
                     end;
                     if (bquickcalc[11]) then
                     begin
                        parametric[11].sval:=FloatToStr(uds3diffusivity[ipi]);
                      end
                     else
                     begin
                        parametric[11].sval:='0.0';
                     end;
                     parametric[12].sval:='0.0';

                     if (bquickcalc[13]) then
                     begin
                        parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                     end
                     else
                     begin
                        parametric[13].sval:='0.0';
                     end;
                     if (bquickcalc[14]) then
                     begin
                        parametric[14].sval:=FloatToStr(laplasuds2[ipi]);
                     end
                     else
                     begin
                        parametric[14].sval:='0.0';
                     end;
                     if (bquickcalc[15]) then
                     begin
                        parametric[15].sval:=FloatToStr(laplasuds3[ipi]);
                     end
                      else
                     begin
                        parametric[15].sval:='0.0';
                     end;
                     parametric[16].sval:='0.0';
                     if (bquickcalc[17]) then
                     begin
                        parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                     end
                      else
                     begin
                        parametric[17].sval:='0.0';
                     end;
                     if (bquickcalc[18]) then
                     begin
                        parametric[18].sval:=FloatToStr(laplasxuds2[ipi]);
                     end
                     else
                     begin
                        parametric[18].sval:='0.0';
                     end;
                     if (bquickcalc[19]) then
                     begin
                        parametric[19].sval:=FloatToStr(laplasxuds3[ipi]);
                     end
                     else
                     begin
                        parametric[19].sval:='0.0';
                     end;
                     parametric[20].sval:='0.0';
                     if (bquickcalc[21]) then
                     begin
                        parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                     end
                     else
                     begin
                        parametric[21].sval:='0.0';
                     end;
                     if (bquickcalc[22]) then
                     begin
                        parametric[22].sval:=FloatToStr(laplasyuds2[ipi]);
                     end
                     else
                     begin
                        parametric[22].sval:='0.0';
                     end;
                     if (bquickcalc[23]) then
                     begin
                        parametric[23].sval:=FloatToStr(laplasyuds3[ipi]);
                     end
                     else
                     begin
                        parametric[23].sval:='0.0';
                     end;
                     parametric[24].sval:='0.0';
                     if (bquickcalc[25]) then
                     begin
                        parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[25].sval:='0.0';
                     end;
                     if (bquickcalc[26]) then
                     begin
                        parametric[26].sval:=FloatToStr(gradxmapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[26].sval:='0.0';
                     end;
                     if (bquickcalc[27]) then
                     begin
                        parametric[27].sval:=FloatToStr(gradxmapptuds3[ipi]);
                     end
                     else
                     begin
                        parametric[27].sval:='0.0';
                     end;
                     parametric[28].sval:='0.0';
                     if (bquickcalc[29]) then
                     begin
                        parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[29].sval:='0.0';
                     end;
                     if (bquickcalc[30]) then
                     begin
                        parametric[30].sval:=FloatToStr(gradymapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[30].sval:='0.0';
                     end;
                     if (bquickcalc[31]) then
                     begin
                        parametric[31].sval:=FloatToStr(gradymapptuds3[ipi]);
                     end
                     else
                     begin
                        parametric[31].sval:='0.0';
                     end;
                     parametric[32].sval:='0.0';

                       if (bquickcalc[33]) then
                     begin
                     parametric[33].sval:=FloatToStr(gradxymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[33].sval:='0.0';
                     end;
                      if (bquickcalc[34]) then
                     begin
                        parametric[34].sval:=FloatToStr(gradxymapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[34].sval:='0.0';
                     end;
                      if (bquickcalc[35]) then
                     begin
                        parametric[35].sval:=FloatToStr(gradxymapptuds3[ipi]);
                     end
                     else
                     begin
                         parametric[35].sval:='0.0';
                     end;
                       parametric[36].sval:='0.0';
                  end;
              4 : begin
                      if (bquickcalc[5]) then
                     begin
                        parametric[5].sval:=FloatToStr(UDS1[ipi]);
                     end
                      else
                     begin
                         parametric[5].sval:='0.0';
                     end;
                      if (bquickcalc[6]) then
                     begin
                         parametric[6].sval:=FloatToStr(UDS2[ipi]);
                      end
                     else
                     begin
                         parametric[6].sval:='0.0';
                     end;
                      if (bquickcalc[7]) then
                     begin
                        parametric[7].sval:=FloatToStr(UDS3[ipi]);
                      end
                     else
                     begin
                         parametric[7].sval:='0.0';
                     end;
                      if (bquickcalc[8]) then
                     begin
                        parametric[8].sval:=FloatToStr(UDS4[ipi]);
                      end
                     else
                     begin
                         parametric[8].sval:='0.0';
                     end;
                      if (bquickcalc[9]) then
                     begin
                        parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                      end
                     else
                     begin
                         parametric[9].sval:='0.0';
                     end;
                      if (bquickcalc[10]) then
                     begin
                        parametric[10].sval:=FloatToStr(uds2diffusivity[ipi]);
                      end
                     else
                     begin
                         parametric[10].sval:='0.0';
                     end;
                      if (bquickcalc[11]) then
                     begin
                        parametric[11].sval:=FloatToStr(uds3diffusivity[ipi]);
                      end
                     else
                     begin
                         parametric[11].sval:='0.0';
                     end;
                      if (bquickcalc[12]) then
                     begin
                        parametric[12].sval:=FloatToStr(uds4diffusivity[ipi]);
                      end
                     else
                     begin
                         parametric[12].sval:='0.0';
                     end;

                     if (bquickcalc[13]) then
                     begin
                         parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                     end
                     else
                     begin
                        parametric[13].sval:='0.0';
                     end;
                     if (bquickcalc[14]) then
                     begin
                        parametric[14].sval:=FloatToStr(laplasuds2[ipi]);
                     end
                     else
                     begin
                        parametric[14].sval:='0.0';
                     end;
                     if (bquickcalc[15]) then
                     begin
                        parametric[15].sval:=FloatToStr(laplasuds3[ipi]);
                     end
                      else
                     begin
                        parametric[15].sval:='0.0';
                     end;
                     if (bquickcalc[16]) then
                     begin
                        parametric[16].sval:=FloatToStr(laplasuds4[ipi]);
                     end
                      else
                     begin
                        parametric[16].sval:='0.0';
                     end;
                     if (bquickcalc[17]) then
                     begin
                        parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                     end
                      else
                     begin
                        parametric[17].sval:='0.0';
                     end;
                     if (bquickcalc[18]) then
                     begin
                        parametric[18].sval:=FloatToStr(laplasxuds2[ipi]);
                     end
                     else
                     begin
                        parametric[18].sval:='0.0';
                     end;
                     if (bquickcalc[19]) then
                     begin
                        parametric[19].sval:=FloatToStr(laplasxuds3[ipi]);
                     end

                     else
                     begin
                        parametric[19].sval:='0.0';
                     end;
                     if (bquickcalc[20]) then
                     begin
                        parametric[20].sval:=FloatToStr(laplasxuds4[ipi]);
                     end
                     else
                     begin
                        parametric[20].sval:='0.0';
                     end;
                     if (bquickcalc[21]) then
                     begin
                        parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                     end
                     else
                     begin
                        parametric[21].sval:='0.0';
                     end;
                     if (bquickcalc[22]) then
                     begin
                        parametric[22].sval:=FloatToStr(laplasyuds2[ipi]);
                     end
                     else
                     begin
                        parametric[22].sval:='0.0';
                     end;
                     if (bquickcalc[23]) then
                     begin
                        parametric[23].sval:=FloatToStr(laplasyuds3[ipi]);
                     end
                     else
                     begin
                        parametric[23].sval:='0.0';
                     end;
                     if (bquickcalc[24]) then
                     begin
                        parametric[24].sval:=FloatToStr(laplasyuds4[ipi]);
                     end
                     else
                     begin
                        parametric[24].sval:='0.0';
                     end;

                     if (bquickcalc[25]) then
                     begin
                        parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[25].sval:='0.0';
                     end;
                     if (bquickcalc[26]) then
                     begin
                        parametric[26].sval:=FloatToStr(gradxmapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[26].sval:='0.0';
                     end;
                     if (bquickcalc[27]) then
                     begin
                        parametric[27].sval:=FloatToStr(gradxmapptuds3[ipi]);
                     end
                     else
                     begin
                        parametric[27].sval:='0.0';
                     end;
                     if (bquickcalc[28]) then
                     begin
                        parametric[28].sval:=FloatToStr(gradxmapptuds4[ipi]);
                     end
                     else
                     begin
                        parametric[28].sval:='0.0';
                     end;

                     if (bquickcalc[29]) then
                     begin
                        parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[29].sval:='0.0';
                     end;
                     if (bquickcalc[30]) then
                     begin
                        parametric[30].sval:=FloatToStr(gradymapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[30].sval:='0.0';
                     end;
                     if (bquickcalc[31]) then
                     begin
                        parametric[31].sval:=FloatToStr(gradymapptuds3[ipi]);
                     end
                     else
                     begin
                        parametric[31].sval:='0.0';
                     end;
                     if (bquickcalc[32]) then
                     begin
                        parametric[32].sval:=FloatToStr(gradymapptuds4[ipi]);
                     end
                     else
                     begin
                        parametric[32].sval:='0.0';
                     end;

                        if (bquickcalc[33]) then
                     begin
                        parametric[33].sval:=FloatToStr(gradxymapptuds1[ipi]);
                     end
                     else
                     begin
                        parametric[33].sval:='0.0';
                     end;
                      if (bquickcalc[34]) then
                     begin
                        parametric[34].sval:=FloatToStr(gradxymapptuds2[ipi]);
                     end
                     else
                     begin
                        parametric[34].sval:='0.0';
                     end;
                      if (bquickcalc[35]) then
                     begin
                        parametric[35].sval:=FloatToStr(gradxymapptuds3[ipi]);
                     end
                     else
                     begin
                        parametric[35].sval:='0.0';
                     end;
                      if (bquickcalc[36]) then
                     begin
                        parametric[36].sval:=FloatToStr(gradxymapptuds4[ipi]);
                     end
                     else
                     begin
                        parametric[36].sval:='0.0';
                     end;
                  end;
            end;

            case icurentuds of
              1 : begin
                     // Источниковый член.
                     val(dsc1str,c,code);
                     if (code=0) then
                     begin
                        dsc1[ipi]:=c;
                     end
                     else
                     begin
                        bOk:=true;
                        dsc1[ipi]:=my_real_convert(dsc1str,bOk);
                     end;
                     val(dsp1str,c,code);
                     if (code=0) then
                     begin
                        dsp1[ipi]:=c;
                     end
                      else
                     begin
                        bOk:=true;
                        dsp1[ipi]:=my_real_convert(dsp1str,bOk);
                     end;
                     val(gamma1str,c,code);
                     if (code=0) then
                     begin
                        uds1diffusivity[ipi]:=c;
                     end
                      else
                     begin
                        // коэффициент диффузии.
                        bOk:=true;
                        uds1diffusivity[ipi]:=my_real_convert(gamma1str,bOk);
                     end;
                  end;
              2 : begin
                     // Источниковый член.
                     val(dsc2str,c,code);
                     if (code=0) then
                     begin
                        dsc2[ipi]:=c;
                     end
                     else
                     begin
                        bOk:=true;
                        dsc2[ipi]:=my_real_convert(dsc2str,bOk);
                     end;
                     val(dsp2str,c,code);
                     if (code=0) then
                     begin
                        dsp2[ipi]:=c;
                     end
                     else
                     begin
                        bOk:=true;
                        dsp2[ipi]:=my_real_convert(dsp2str,bOk);
                     end;
                     // коэффициент диффузии.
                     val(gamma2str,c,code);
                     if (code=0) then
                     begin
                        uds2diffusivity[ipi]:=c;
                     end
                     else
                     begin
                        bOk:=true;
                        uds2diffusivity[ipi]:=my_real_convert(gamma2str,bOk);
                     end;
                  end;
              3 : begin
                     // источниковый член.
                     val(dsc3str,c,code);
                     if (code=0) then
                     begin
                        dsc3[ipi]:=c;
                     end
                      else
                     begin
                        bOk:=true;
                        dsc3[ipi]:=my_real_convert(dsc3str,bOk);
                     end;
                     val(dsp3str,c,code);
                     if (code=0) then
                     begin
                        dsp3[ipi]:=c;
                     end
                       else
                     begin
                        bOk:=true;
                        dsp3[ipi]:=my_real_convert(dsp3str,bOk);
                     end;
                     // коэффициент диффузии.
                     val(gamma3str,c,code);
                     if (code=0) then
                     begin
                        uds3diffusivity[ipi]:=c;
                     end
                      else
                     begin
                        bOk:=true;
                        uds3diffusivity[ipi]:=my_real_convert(gamma3str,bOk);
                     end;
                  end;
              4 : begin
                     // источниковый член.
                     val(dsc4str,c,code);
                     if (code=0) then
                     begin
                        dsc4[ipi]:=c;
                     end
                      else
                     begin
                        bOk:=true;
                        dsc4[ipi]:=my_real_convert(dsc4str,bOk);
                     end;
                     val(dsp4str,c,code);
                     if (code=0) then
                     begin
                        dsp4[ipi]:=c;
                     end
                      else
                     begin
                        bOk:=true;
                        dsp4[ipi]:=my_real_convert(dsp4str,bOk);
                     end;
                     // коэффициент диффузии.
                     val(gamma4str,c,code);
                     if (code=0) then
                     begin
                        uds4diffusivity[ipi]:=c;
                     end
                      else
                     begin
                        bOk:=true;
                        uds4diffusivity[ipi]:=my_real_convert(gamma4str,bOk);
                     end;
                  end;
            end;
       end;
     end;
   end;
   end;
   end;


   // коэффициенты дискретного аналога
   SetLength(m,inx*iny+1); // выделение памяти под коэффициенты СЛАУ
   SetLength(db,inx*iny+1); // выделение памяти под правую часть.
   SetLength(myrU,inx*iny+1); // невязка

   // коэффициенты дискретного аналога вычисляются
   // только один раз путём прохода по всем внутренним точкам
   // а затем только используются.
   UDSCoef(m,db); // сборка матрицы с учётом конвективного, нестационарного,
   // диффузионного и источникового членов если требуется.

   // текущее значение невязки
   // которое будет отображаться на мониторе.
   case icurentuds of
     1 : begin
            //res:=myResidual(UDS1,myrU,inx,iny,mapPT,'C',m,db);
            // полная невязка с учётом граничных условий.
            myResidual_all(myrU,res,UDS1,inx,iny,mapPT,'C',m,db,QneiC);
         end;
     2 : begin
            //res:=myResidual(UDS2,myrU,inx,iny,mapPT,'C',m,db);
            // полная невязка с учётом граничных условий.
            myResidual_all(myrU,res,UDS2,inx,iny,mapPT,'C',m,db,QneiC);
         end;
     3 : begin
            //res:=myResidual(UDS3,myrU,inx,iny,mapPT,'C',m,db);
            // полная невязка с учётом граничных условий.
            myResidual_all(myrU,res,UDS3,inx,iny,mapPT,'C',m,db,QneiC);
         end;
     4 : begin
            //res:=myResidual(UDS4,myrU,inx,iny,mapPT,'C',m,db);
            // полная невязка с учётом граничных условий.
            myResidual_all(myrU,res,UDS4,inx,iny,mapPT,'C',m,db,QneiC);
         end;
   end;

   // Если мы имеем itypesolver_loc = 6
   // то мы применяем метод Ньютона.

   // коэффициенты дискретного аналога уже вычислены
   // и теперь будут только использоваться.
   if ( itypesolver_loc = 1 ) then
   begin
      k:=0;
      residualuds:=1e0; // очень большое число

      if (ilanguage=0) then
      begin
         // Язык Pascal.


         if (bIlyin) then
         begin
            SetLength(u1,inx*iny+1);
            SetLength(u2,inx*iny+1);
            SetLength(u3,inx*iny+1);
         end;

      // матрицы коэффициентов m и db сформированы
      // и теперь просто будут только использоваться.
      while ((bweShouldContinue) and (residualuds > epsilon_loc) and (k < kfinish)) do
      begin
         // Реализовано только для граничных условий первого рода.

          // итерационный последовательный поточечный метод
          // Гаусса-Зейделя

          if (bIlyin) then
          begin
             if (k<3) then
             begin
                relaxIlyin:=1.0;
             end;
          end;

          // одна итерация методом Гаусса-Зейделя
          case icurentuds of
            1 : begin
                   GZUniversal(UDS1,inx,iny, mapPT, 'C', m, db, QneiC);
                end;
            2 : begin
                   GZUniversal(UDS2,inx,iny, mapPT, 'C', m, db, QneiC);
                end;
            3 : begin
                   GZUniversal(UDS3,inx,iny, mapPT, 'C', m, db, QneiC);
                end;
            4 : begin
                   GZUniversal(UDS4,inx,iny, mapPT, 'C', m, db, QneiC);
                end;
          end;

          if (bIlyin) then
               begin
                  if (k mod kgold =0) then
                  begin
                     for k2:=0 to inx*iny do
                     begin
                        case icurentuds of
                        1 : begin
                               u1[k2]:=UDS1[k2];
                            end;
                        2 : begin
                               u1[k2]:=UDS2[k2];
                            end;
                        3 : begin
                               u1[k2]:=UDS3[k2];
                            end;
                        4 : begin
                               u1[k2]:=UDS4[k2];
                            end;
                        end;
                     end;
                  end;
                  if ((k-1) mod kgold=0) then
                  begin
                     for k2:=0 to inx*iny do
                     begin
                         case icurentuds of
                        1 : begin
                               u2[k2]:=UDS1[k2];
                            end;
                        2 : begin
                               u2[k2]:=UDS2[k2];
                            end;
                        3 : begin
                               u2[k2]:=UDS3[k2];
                            end;
                        4 : begin
                               u2[k2]:=UDS4[k2];
                            end;
                        end;
                     end;
                  end;
                  if ((k-2) mod kgold=0) then
                  begin
                     for k2:=0 to inx*iny do
                     begin
                         case icurentuds of
                        1 : begin
                               u3[k2]:=UDS1[k2];
                            end;
                        2 : begin
                               u3[k2]:=UDS2[k2];
                            end;
                        3 : begin
                               u3[k2]:=UDS3[k2];
                            end;
                        4 : begin
                               u3[k2]:=UDS4[k2];
                            end;
                        end;
                     end;
                     dsum1:=0.0;
                     dsum2:=0.0;
                     for k2:=1 to inx*iny do
                     begin
                         if ((mapPT[k2].itype=1) or (mapPT[k2].itype=2)) then
                         begin
                            dsum1:=dsum1+(u3[k2]-u2[k2])*(u3[k2]-u2[k2]);
                            dsum2:=dsum2+(u2[k2]-u1[k2])*(u2[k2]-u1[k2]);
                         end;
                     end;
                     if (abs(dsum2)>1.0e-30) then
                     begin
                        dsum1:=sqrt(dsum1/dsum2);
                        relaxIlyin:=2.0/(1.0+sqrt(fmax(1.0-dsum1,0.002))); // оптимальный параметр релаксации.
                     end;
                  end;
               end;


         if (((2*k)mod(inx+iny))=0) then
         begin
            // Будем редко вычислять невязки как и раньше в естественных переменных
            // для поправки давления.

            (*
            // текущее значение невязки
            // только внутренность расчётной области.
            case icurentuds of
              1 : begin
                     residualuds:=myResidual(UDS1,myrU,inx,iny,mapPT,'C',m,db);
                  end;
              2 : begin
                     residualuds:=myResidual(UDS2,myrU,inx,iny,mapPT,'C',m,db);
                  end;
              3 : begin
                    residualuds:=myResidual(UDS3,myrU, inx,iny,mapPT,'C',m,db);
                  end;
              4 : begin
                    residualuds:=myResidual(UDS4,myrU,inx,iny,mapPT,'C',m,db);
                  end;
            end;
            *)

            // текущее значение невязки
            // которое будет отображаться на мониторе.
            case icurentuds of
              1 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS1,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
              2 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS2,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
              3 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS3,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
              4 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS4,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
            end;

         end;

         // Управление показом невязок осуществляется внутри SIMPLE алгоритма.



          k:=k+1; // переходим к следующей итерации
          Application.ProcessMessages;

      end; // k while

         if (bIlyin) then
         begin
            SetLength(u1,0);
            SetLength(u2,0);
            SetLength(u3,0);
         end;

      end;

       SetLength(mapPTold,imaxnumbernode+2);

    for k1:=1 to imaxnumbernode do
      begin
        mapPTold[k1].itype:=mapPT[k1].itype;
        mapPTold[k1].i:=mapPT[k1].i;
        mapPTold[k1].j:=mapPT[k1].j;
        mapPTold[k1].dx:=mapPT[k1].dx;
        mapPTold[k1].dy:=mapPT[k1].dy;
        mapPTold[k1].dV:=mapPT[k1].dV;
        mapPTold[k1].dxe:=mapPT[k1].dxe;
        mapPTold[k1].dxw:=mapPT[k1].dxw;
        mapPTold[k1].dyn:=mapPT[k1].dyn;
        mapPTold[k1].dys:=mapPT[k1].dys;
        mapPTold[k1].iboundary:=mapPT[k1].iboundary;
        mapPTold[k1].chnormal:=mapPT[k1].chnormal;
        mapPTold[k1].iugol:=mapPT[k1].iugol;
        mapPTold[k1].ini:=mapPT[k1].ini;
        mapPTold[k1].isi:=mapPT[k1].isi;
        mapPTold[k1].iwi:=mapPT[k1].iwi;
        mapPTold[k1].iei:=mapPT[k1].iei;
        mapPTold[k1].ipi:=mapPT[k1].ipi;
      end;

      if (ilanguage=1) then
      begin
         // Язык СИ.


         // Солвер Гаусса-Зейделя.

         case icurentuds of
           1 : begin
                   seidel_uds(rcs.uds1,
							                iterSimple.iteruds1,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS1,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              icurentuds);
               end;
           2 : begin
                  seidel_uds(rcs.uds2,
							                iterSimple.iteruds2,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS2,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              icurentuds);
               end;
           3 : begin
                  seidel_uds(rcs.uds3,
							                iterSimple.iteruds3,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS3,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              icurentuds);
               end;
           4 : begin
                  seidel_uds(rcs.uds4,
							                iterSimple.iteruds4,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS4,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              icurentuds);
               end;
         end;


      end;


      if (ilanguage=2) then
      begin
         // Язык СИ и OpenMP.


         // Солвер Гаусса-Зейделя.

         case icurentuds of
           1 : begin
                   seidel_uds_omp(rcs.uds1,
							                iterSimple.iteruds1,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS1,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              ig_nNumberOfThreads,
                              icurentuds);
               end;
           2 : begin
                  seidel_uds_omp(rcs.uds2,
							                iterSimple.iteruds2,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS2,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              ig_nNumberOfThreads,
                              icurentuds);
               end;
           3 : begin
                  seidel_uds_omp(rcs.uds3,
							                iterSimple.iteruds3,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS3,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              ig_nNumberOfThreads,
                              icurentuds);
               end;
           4 : begin
                  seidel_uds_omp(rcs.uds4,
							                iterSimple.iteruds4,
						                	imaxnumbernode,
                              inx, iny,
						                	ibasenorma,
							                @m,
						                	@mapPTold,
							                @UDS4,
						                	@db,
							                @myrU,
                              @QneiCdll,
                              @bzerocurrenrorzerodiffdll,
                              ig_nNumberOfThreads,
                              icurentuds);
               end;
         end;


      end;

     SetLength(mapPTold,0);

   end
    else if ( itypesolver_loc = 2 ) then
   begin
      k:=0;
      residualuds:=1e0; // очень большое число
      bflagconstruct:=True;
      // матрицы коэффициентов m и db сформированы
      // и теперь просто будут только использоваться.
      while ((bweShouldContinue) and (residualuds > epsilon_loc) and (k < kfinish)) do
      begin
         // Реализовано только для граничных условий первого рода.

          // метод переменных направлений

                // одна итерация методом переменных направлений
                // для user defined scalar
                case icurentuds of
                  1 : begin
                         TDMAGibridGZUniversal(UDS1,inx,iny, mapPT, 'C',m, db, Aseqx, Aseqy, bflagconstruct);
                      end;
                  2 : begin
                         TDMAGibridGZUniversal(UDS2,inx,iny, mapPT, 'C',m, db, Aseqx, Aseqy, bflagconstruct);
                      end;
                  3 : begin
                         TDMAGibridGZUniversal(UDS3,inx,iny, mapPT, 'C',m, db, Aseqx, Aseqy, bflagconstruct);
                      end;
                  4 : begin
                         TDMAGibridGZUniversal(UDS4,inx,iny, mapPT, 'C',m, db, Aseqx, Aseqy, bflagconstruct);
                      end;
                end;
                //Application.MessageBox('данная возможность пока не реализована','error',MB_Ok);




         if (((2*k)mod(inx+iny))=0) then
         begin
            // Будем редко вычислять невязки как и раньше в естественных переменных
            // для поправки давления.

            (*
            // текущее значение невязки
            case icurentuds of
              1 : begin
                     residualuds:=myResidual(UDS1,myrU,inx,iny,mapPT,'C',m,db);
                  end;
              2 : begin
                     residualuds:=myResidual(UDS2,myrU,inx,iny,mapPT,'C',m,db);
                  end;
              3 : begin
                    residualuds:=myResidual(UDS3,myrU, inx,iny,mapPT,'C',m,db);
                  end;
              4 : begin
                    residualuds:=myResidual(UDS4,myrU,inx,iny,mapPT,'C',m,db);
                  end;
            end;
            *)


            // текущее значение невязки
            // которое будет отображаться на мониторе.
            // с учётом и внутренних и граничных узлов.
            case icurentuds of
              1 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS1,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
              2 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS2,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
              3 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS3,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
              4 : begin
                     // полная невязка с учётом граничных условий.
                     myResidual_all(myrU,residualuds,UDS4,inx,iny,mapPT,'C',m,db,QneiC);
                  end;
            end;

         end;



         // Управление показом невязок осуществляется внутри SIMPLE алгоритма.



          k:=k+1; // переходим к следующей итерации
          Application.ProcessMessages;

      end; // k while

   end
    else
   begin

      case itypesolver_loc  of
        3 :  // решение задачи прямым методом Гаусса
           begin
              // эсли этот код используется в нестационарном решателе
              // и граничное условие является функцией времени, то
              // это приводит к необходимости обращать матрицу СЛАУ
              // на каждом временном слое.
              case icurentuds of
                 1 : begin
                        GaussUniversal(UDS1,inx,iny, mapPT, 'C', m,db,bmessage);
                     end;
                 2 : begin
                        GaussUniversal(UDS2,inx,iny, mapPT, 'C', m,db,bmessage);
                     end;
                 3 : begin
                        GaussUniversal(UDS3,inx,iny, mapPT, 'C', m,db,bmessage);
                     end;
                 4 : begin
                        GaussUniversal(UDS4,inx,iny, mapPT, 'C', m,db,bmessage);
                     end;
              end;
              //
              // текущее значение невязки
              // текущее значение невязки

              (*
              case icurentuds of
                1 : begin
                       residualuds:=myResidual(UDS1,myrU,inx,iny,mapPT,'C',m,db);
                    end;
                2 : begin
                      residualuds:=myResidual(UDS2,myrU,inx,iny,mapPT,'C',m,db);
                    end;
                3 : begin
                      residualuds:=myResidual(UDS3,myrU,inx,iny,mapPT,'C',m,db);
                    end;
                4 : begin
                      residualuds:=myResidual(UDS4,myrU,inx,iny,mapPT,'C',m,db);
                    end;
              end;
              *)

           end;
           4 :  // решение задачи алгебраическим многосеточным методом.
           begin
              // эсли этот код используется в нестационарном решателе
              // и граничное условие является функцией времени, то
              // это приводит к необходимости обращать матрицу СЛАУ
              // на каждом временном слое.
              case icurentuds of
                 1 : begin
                        //GaussUniversal(UDS1,inx,iny, mapPT, 'C', m,db,bmessage);
                        classical_aglomeration_amg(UDS1,inx,iny,mapPT,'C',m,db,bmessage);
                     end;
                 2 : begin
                        //GaussUniversal(UDS2,inx,iny, mapPT, 'C', m,db,bmessage);
                        classical_aglomeration_amg(UDS2,inx,iny,mapPT, 'C', m,db,bmessage);
                     end;
                 3 : begin
                        //GaussUniversal(UDS3,inx,iny, mapPT, 'C', m,db,bmessage);
                        classical_aglomeration_amg(UDS3,inx,iny,mapPT,'C',m,db,bmessage);
                     end;
                 4 : begin
                        //GaussUniversal(UDS4,inx,iny, mapPT, 'C', m,db,bmessage);
                        classical_aglomeration_amg(UDS4,inx,iny,mapPT, 'C',m,db,bmessage);
                     end;
              end;
              //
              // текущее значение невязки
              // текущее значение невязки

              (*
              case icurentuds of
                1 : begin
                       residualuds:=myResidual(UDS1,myrU,inx,iny,mapPT,'C',m,db);
                    end;
                2 : begin
                      residualuds:=myResidual(UDS2,myrU,inx,iny,mapPT,'C',m,db);
                    end;
                3 : begin
                      residualuds:=myResidual(UDS3,myrU,inx,iny,mapPT,'C',m,db);
                    end;
                4 : begin
                      residualuds:=myResidual(UDS4,myrU,inx,iny,mapPT,'C',m,db);
                    end;
              end;
              *)

           end;
        5 : // метод Сопряжённых Градиентов
           begin
              // передаваемое значение bconv=true означает
              // что будет выполнена трансформация Гаусса
              // необходимая для того чтобы матрица СЛАУ была
              // самосопряжённой положительно определённой
              // метод сопряжённых градиентов Хестенса и Штифеля.
              // debug без учёта разреженности.
              //SoprGradUniversal(T,inx,iny, mapPT,  'T', m, true, kfinish, rcs.temp, db,bmessage);

              //SoprGradCRSUniversal( T, inx, iny, mapPT, 'T', m, bconv, bmessage, kfinish, rcs.temp, 0,db); // хранение разреженной матрицы в формате CRS
              Application.MessageBox('данная возможность пока не реализована','error',MB_Ok);
           end;
        6 : // алгоритм Ю.Г. Соловейчика
           begin
              // Локально оптимальная схема.
              // алгоритм Ю.Г. Соловейчика [1993]
              // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
              //SoprGradCRSUniversal( T, inx, iny, mapPT, 'T', m, bconv, bmessage, kfinish, rcs.temp*rcs.temp, 1,db); // используется формат хранения разреженной матрицы CRS
              Application.MessageBox('данная возможность пока не реализована','error',MB_Ok);
           end;
        7 : // метод Ньютона (возвращает значение дискретного аналога).
           begin


              // Значение дискретного аналога при текущих значениях переменных :
              // UDS1 и UDS2.
              case icurentuds of
               1 : begin
                      // полная невязка с учётом граничных условий.
                      myResidual_all(value_of_equation,resloc,UDS1,inx,iny,mapPT,'C',m,db,QneiC);
                   end;
               2 : begin
                      // полная невязка с учётом граничных условий.
                      myResidual_all(value_of_equation,resloc,UDS2,inx,iny,mapPT,'C',m,db,QneiC);
                   end;
               3 : begin
                      // полная невязка с учётом граничных условий.
                      myResidual_all(value_of_equation,resloc,UDS3,inx,iny,mapPT,'C',m,db,QneiC);
                   end;
               4 : begin
                      // полная невязка с учётом граничных условий.
                      myResidual_all(value_of_equation,resloc,UDS4,inx,iny,mapPT,'C',m,db,QneiC);
                   end;
              end;
           end;
        end; // case

   end;

   SetLength(m,0); // освобождение памяти под коэффициентов СЛАУ.
   SetLength(db,0); // освобождение памяти из под правой части.
   SetLength(myrU,0); // освобождение памяти из под невязки.
   SetLength(QneiCdll, 0);  // освобождение памяти из под вспомогательной информации о граничном условии.
   SetLength(bzerocurrenrorzerodiffdll,0);// освобождение памяти из под вспомогательной информации о граничном условии.

    // Применение Solution Limits.
    for k:=1 to imaxnumbernode do
    begin
       case icurentuds of
           1 : begin
                  UDS1[k]:=fmin(sollimuds1max,fmax(UDS1[k],sollimuds1min));
               end;
           2 : begin
                  UDS2[k]:=fmin(sollimuds2max,fmax(UDS2[k],sollimuds2min));
               end;
           3 : begin
                  UDS3[k]:=fmin(sollimuds3max,fmax(UDS3[k],sollimuds3min));
               end;
           4 : begin
                  UDS4[k]:=fmin(sollimuds4max,fmax(UDS4[k],sollimuds4min));
               end;
       end;
    end;

end; // SolveUDS


// Решение уравнения для функции цвета.
// Сходимость методов гарантируется критерием Скарбороу.
procedure TForm1.SolveVOF(kfinish : Integer);
var
   k,k1 : Integer; // номер итерации
   m : array of MatrixCoef; // матрица коэффициетов
   db : array of Float;  // коэффициенты
   myrU : array of Float; // невязка.
   residualvof : Float; // текущее значение невязки
   QneiC : TQneiC;
   bOk : Boolean;

begin
   for k:=1 to 20 do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false;
      end;
   end;

   // коэффициенты дискретного аналога не зависят от
   // температуры и этим можно воспользоваться, т.е.
   // их можно вычислить только один раз и дальше только использовать при вычислении.
   SetLength(m,inx*iny+1); // выделение памяти под коэффициенты
   SetLength(db,inx*iny+1); // выделение памяти под коэффициент
   SetLength(myrU,inx*iny+1);

   // коэффициенты дискретного аналога вычисляются
   // только один раз путём прохода по всем внутренним точкам
   // а затем только используются.
   VofCoef(m, db); // с конвективным членом


   // коэффициенты дискретного аналога уже вычислены
   // и теперь будут только использоваться.
   if (itypesolver.ivof < 3) then
   begin
      k:=0;
      residualvof:=1e0; // очень большое число
      // матрицы коэффициентов m и db сформированы
      // и теперь просто будут только использоваться.
      while ((bweShouldContinue) and (residualvof > rcs.vof) and (k < kfinish)) do
      begin
         // Реализовано только для граничных условий первого рода.

         case itypesolver.ivof of
           1 : // итерационный последовательный поточечный метод
               // Гаусса-Зейделя
             begin
                // одна итерация методом Гаусса-Зейделя
                GZUniversal(VOF,inx,iny,mapPT, 'F', m,db,QneiC);
             end;
           (*
           2 : // метод переменных направлений
             begin
                // одна итерация методом переменных направлений
                // для поля температур и граничных условий первого рода
                TDMAGibridGZUniversal(T,inx,iny, mapPT, 'T',m, db);
             end;
             *)
         end; // case

         // текущее значение невязки
         residualvof:=myResidual(VOF,myrU,inx,iny,mapPT,'F',m,db);

         k:=k+1; // переходим к следующей итерации
         Application.ProcessMessages;
      end; // k while

   end;

   bOk:=True;
   for k:=1 to inx do
   begin
      for k1:=1 to iny do
      begin
         if (bOk and ((VOF[k+(k1-1)*inx]<0.0)or(VOF[k+(k1-1)*inx]>1.0))) then
         begin
            bOk:=false;
         end;
         VOF[k+(k1-1)*inx]:=maxoper(0.0,fmin(VOF[k+(k1-1)*inx],1.0));
      end;
   end;
   if (not(bOk)) then
   begin
      //Application.MessageBox('VOF вышла за границы','warning',MB_OK);
      MainMemo.Lines.Add('VOF вышла за границы в неявном методе.');
   end;

   SetLength(m,0); // уничтожение памяти под коэффициенты
   SetLength(db,0); // уничтожение памяти под коэффициент
   SetLength(myrU,0);

end;  // SolveVOFSteady.


// Возвращает значение плотности на грани контрольного объёма.
// На основе статьи Хирта и Николса.
function TForm1.densuty_in_surface(ipi1 : Integer; ipi2 : Integer) : Float;
begin
   if (imodelEquation<5) then
   begin
      Result:=2.0*density(ipi1)*density(ipi2)/(density(ipi1)+density(ipi2));
   end
    else
   begin
      // Регулируем границы, чтобы функция VOF не дай бог вышла за границы.
      VOF[ipi1]:=fmax(0.0,fmin(1.0,VOF[ipi1]));
      VOF[ipi2]:=fmax(0.0,fmin(1.0,VOF[ipi2]));
      // линейная интерполяция плотности на грань советуется в статье Hirt и Nichols.
      Result:=0.5*((matprop[0].drho+(matprop[1].drho-matprop[0].drho)*VOF[ipi1])+(matprop[0].drho+(matprop[1].drho-matprop[0].drho)*VOF[ipi2]));
   end;
end;

// Hirt-Nichols`VOF
procedure TForm1.Hirt_NicholsVOF;
// Минаков рекомендует схему SUPERBEE
// а также постоянную смену направлений прошивки.
const
   QUICK = 1000;
   LUS = 1001;
   CUS = 1002;
   SMART = 1003;
   H_QUICK = 1004;
   UMIST = 1005;
   CHARM = 1006;
   MUSCL = 1007;
   VAN_LEER_HARMONIC = 1008;
   OSPRE = 1009;
   VAN_ALBADA = 1010;
   SUPERBEE = 1011;
   MINMOD = 1012;
   H_CUS = 1013;
   KOREN = 1014;
   FROMM = 1015;
   STUB = 1016; // заглушка.

var
   k , i, j: Integer;
   dx, dy : Float;
   dxe, dxw, dys, dyn : Float;
   dS, Vol, Vol0i5 : Float;
   ini, isi, iwi, iei, ipi : Integer;
   inni, issi, iwwi, ieei : Integer;
   iecvi, iwcvi, incvi, iscvi : Integer;
   dfe, dfw, dfn, dfs : Float;
   f_forvard, f_backvard, attrs : Float;
   VOFFrozen : array of Float;
   dsp, dsc : Float; // источниковый член.
   berr  : Boolean;
   iran, icounterran : Byte;
   dtimesteploc, facemax_x, facemax_y : Float;
   inumberoftimesteploc , ic9: Integer;

// модуль вещественного числа.
function fabs(ar : Float) : Float;
begin
   if (ar<0.0) then
   begin
      Result:=-ar;
   end
    else
   begin
      Result:=ar;
   end;
end;

begin

   // VOLUME-Tracking methods for interfacial flow calculations.
   // MURRAY RUDMAN

   //CourantNumber:=0.25; // - теперь это глобальная переменная.
   facemax_x:=0.0;
   facemax_y:=0.0;
   for k:=1 to imaxnumbernode do
   begin
      if (mapPT[k].itype = 1) then
      begin
         // для шахматной сетки (для компонент скорости)
         iecvi:=mapPT[k].i+(mapPT[k].j-1)*(inx-1); // в массиве Vx
         facemax_x:=maxoper(facemax_x,fabs(Vx[iecvi])/(0.5*(xpos[mapPT[k].i+1]-xpos[mapPT[k].i])));
         iwcvi:=(mapPT[k].i-1)+(mapPT[k].j-1)*(inx-1); // горизонтальных точек на одну меньше
         facemax_x:=maxoper(facemax_x,fabs(Vx[iwcvi])/(0.5*(xpos[mapPT[k].i]-xpos[mapPT[k].i-1])));
         incvi:=mapPT[k].i+(mapPT[k].j-1)*inx; // в массиве Vy горизонтальных точек столько же,
         facemax_y:=maxoper(facemax_y,fabs(Vy[incvi])/(0.5*(ypos[mapPT[k].j+1]-ypos[mapPT[k].j])));
         iscvi:=mapPT[k].i+(mapPT[k].j-2)*inx; // а вертикальных на одну меньше
         facemax_y:=maxoper(facemax_y,fabs(Vy[iscvi])/(0.5*(ypos[mapPT[k].j]-ypos[mapPT[k].j-1])));
      end;
   end;
   dtimesteploc:=CourantNumber*1.0/(facemax_x+facemax_y);
   if (dtimesteploc>dTimeStep) then
   begin
       dtimesteploc:=dTimeStep;
       inumberoftimesteploc:=0;
   end
    else
   begin
      //inumberoftimesteploc:=0;

      inumberoftimesteploc:=round(dTimeStep/dtimesteploc);
      dtimesteploc:=dTimeStep/(inumberoftimesteploc+1);
   end;

   berr:=false;

   for ic9:=0 to inumberoftimesteploc do
   begin

   berr:=false;
   dsp:=0.0;
   dsc:=0.0;

   SetLength(VOFFrozen, mzapas*inx*iny+1);

   iran:=Random(2); // 0 или 1 случайным образом.

   for icounterran:=0 to 1 do
   begin

       for  i:=1 to inx do
       begin
          for j:=1 to iny do
          begin
             VOFFrozen[i+(j-1)*inx]:=VOF[i+(j-1)*inx];
             if ((VOFFrozen[i+(j-1)*inx]>1)or(VOFFrozen[i+(j-1)*inx]<0.0)) then
             begin
                //Application.MessageBox('error','VOF вышла заграницы',MB_OK);
                //MainMemo.Lines.Add('VOF вышла заграницы'+FloatToStr(VOFFrozen[i+(j-1)*inx]));
                if ( VOFFrozen[i+(j-1)*inx]>1.0) then
                begin
                   VOF[i+(j-1)*inx]:=1.0;
                   VOFFrozen[i+(j-1)*inx]:=1.0;
                end;
                if ( VOFFrozen[i+(j-1)*inx]<0.0) then
                begin
                   VOF[i+(j-1)*inx]:=0.0;
                   VOFFrozen[i+(j-1)*inx]:=0.0;
                end;
                berr:=true;
             end;
          end;
       end;




      case iran of
         0 : begin
               // Явная локально одномерная схема согласно статье.
               // цикл по всем узлам расчётной области
               // Горизонтальная прошивка.
               for k:=1 to imaxnumbernode do
               begin
                  if (mapPT[k].itype = 1) then
                  begin
                     // внутренний узел
                     iwi:=(mapPT[k].i-1)+(mapPT[k].j-1)*inx; // запад
                     iei:=(mapPT[k].i+1)+(mapPT[k].j-1)*inx; // восток
                     ipi:=mapPT[k].i+(mapPT[k].j-1)*inx; // текущая точка
                     // для шахматной сетки (для компонент скорости)
                     iecvi:=mapPT[k].i+(mapPT[k].j-1)*(inx-1); // в массиве Vx
                     iwcvi:=(mapPT[k].i-1)+(mapPT[k].j-1)*(inx-1); // горизонтальных точек на одну меньше
                     dS:=mapPT[k].dy;
                     dxe:=mapPT[k].dxe;
                     dxw:=mapPT[k].dxw;
                     dx:=mapPT[k].dx;
                     dy:=mapPT[k].dy;
                     // проверка прошла успешно.
                     //Application.MessageBox(PChar('Vol='+FloatToStr(mapPT[k].dV)+'dy='+FloatToStr(dy)+'dS='+FloatToStr(dS)),'error',MB_OK);

                     (*
                     // Схема Хирта и Николса похоже реализована верно !!!
                     // Схема Хирта и Николса.
                     dfe:=dS*fmin(VOFFrozen[ipi]*dx,Vx[iecvi]*VOFFrozen[iei]*0.5*dtimesteploc+fmax(0.0,Vx[iecvi]*(1.0-VOFFrozen[iei])*0.5*dtimesteploc-(1.0-VOFFrozen[ipi])*dx));
                     dfw:=dS*fmin(VOFFrozen[ipi]*dx,Vx[iwcvi]*VOFFrozen[iwi]*0.5*dtimesteploc+fmax(0.0,Vx[iwcvi]*(1.0-VOFFrozen[iwi])*0.5*dtimesteploc-(1.0-VOFFrozen[ipi])*dx));
                     VOF[ipi]:=(VOFFrozen[ipi]*mapPT[k].dV-(dfe-dfw))/(mapPT[k].dV-0.5*dtimesteploc*dS*(Vx[iecvi]-Vx[iwcvi]));
                     *)


                     attrs:=0.0;
                     dfe:=Vx[iecvi]*dy;
                     dfw:=Vx[iwcvi]*dy;

                     iwwi:=(mapPT[k].i-2)+(mapPT[k].j-1)*inx; // запад 2
                     ieei:=(mapPT[k].i+2)+(mapPT[k].j-1)*inx; // восток 2
                     if (is_internal_HO(iwi,ipi,iei,ieei)) then
                     begin
                        // можно обрабатывать грань схемой высокого порядка
                        f_forvard:=cell_face_value_global(SUPERBEE,Vx[iecvi],VOFFrozen[iwi],VOFFrozen[ipi],VOFFrozen[iei],VOFFrozen[ieei]);
                        attrs:=attrs-maxoper(dfe,0.0)*(f_forvard-VOFFrozen[ipi])+maxoper(-dfe,0.0)*(f_forvard-VOFFrozen[iei]);
                     end;
                     if (is_internal_HO(iwwi,iwi,ipi,iei)) then
                     begin
                        // можно обрабатывать грань схемой высокого порядка
                        f_backvard:=cell_face_value_global(SUPERBEE,Vx[iwcvi],VOFFrozen[iwwi],VOFFrozen[iwi],VOFFrozen[ipi],VOFFrozen[iei]);
                        attrs:=attrs-maxoper(-dfw,0.0)*(f_backvard-VOFFrozen[ipi])+maxoper(dfw,0.0)*(f_backvard-VOFFrozen[iwi]);
                     end;

                     // UDS если attrs тождественный ноль.
                     if (ApproxConvectionForm.CheckBoxKIvanovApprox.Checked) then
                     begin
                        VOF[ipi]:=(maxoper(-dfe,0.0)*VOFFrozen[iei]+
                        maxoper(dfw,0.0)*VOFFrozen[iwi]+
                        dsc*mapPT[k].dV+2.0*mapPT[k].dV*VOFFrozen[ipi]/dtimesteploc
                        +attrs)/(maxoper(dfe,0.0)+maxoper(-dfw,0.0)+
                        2.0*mapPT[k].dV/dtimesteploc - dsp*mapPT[k].dV);
                     end
                     else
                     begin
                        // Общепринятая схема.
                        VOF[ipi]:=(maxoper(-dfe,0.0)*VOFFrozen[iei]+
                        maxoper(dfw,0.0)*VOFFrozen[iwi]+
                        dsc*mapPT[k].dV+2.0*mapPT[k].dV*VOFFrozen[ipi]/dtimesteploc
                        +attrs)/(maxoper(-dfe,0.0)+maxoper(dfw,0.0)+
                        2.0*mapPT[k].dV/dtimesteploc - dsp*mapPT[k].dV);
                     end;

                  end;
               end;



               iran:=1;
             end;
         1 : begin
                 // Вертикальная прошивка.
                 for k:=1 to imaxnumbernode do
                 begin
                    if (mapPT[k].itype = 1) then
                    begin
                       ini:=mapPT[k].i+mapPT[k].j*inx;  // север
                       isi:=mapPT[k].i+(mapPT[k].j-2)*inx; // юг
                       ipi:=mapPT[k].i+(mapPT[k].j-1)*inx; // текущая точка
                       incvi:=mapPT[k].i+(mapPT[k].j-1)*inx; // в массиве Vy горизонтальных точек столько же,
                       iscvi:=mapPT[k].i+(mapPT[k].j-2)*inx; // а вертикальных на одну меньше

                       dS:=mapPT[k].dx;
                       dyn:=mapPT[k].dyn;
                       dx:=mapPT[k].dx;
                       dy:=mapPT[k].dy;
                       dys:=mapPT[k].dys;

                       (*
                       // Схема Хирта и Николса.
                       dfn:=dS*fmin(VOFFrozen[ipi]*dy,Vy[incvi]*VOFFrozen[ini]*0.5*dtimesteploc+fmax(0.0,Vy[incvi]*(1.0-VOFFrozen[ini])*0.5*dtimesteploc-(1.0-VOFFrozen[ipi])*dy));

                       dfs:=dS*fmin(VOFFrozen[ipi]*dy,Vy[iscvi]*VOFFrozen[isi]*0.5*dtimesteploc+fmax(0.0,Vy[iscvi]*(1.0-VOFFrozen[isi])*0.5*dtimesteploc-(1.0-VOFFrozen[ipi])*dy));

                       VOF[ipi]:=(VOFFrozen[ipi]*mapPT[k].dV-(dfn-dfs))/(mapPT[k].dV-0.5*dtimesteploc*dS*(Vy[incvi]-Vy[iscvi]));
                       *)


                       attrs:=0.0;
                       dfn:=Vy[incvi]*dx;
                       dfs:=Vy[iscvi]*dx;

                       issi:=(mapPT[k].i)+(mapPT[k].j-1-2)*inx; // запад 2
                       inni:=(mapPT[k].i)+(mapPT[k].j-1+2)*inx; // восток 2
                       if (is_internal_HO(isi,ipi,ini,inni)) then
                       begin
                          // можно обрабатывать грань схемой высокого порядка
                          f_forvard:=cell_face_value_global(SUPERBEE,Vy[incvi],VOFFrozen[isi],VOFFrozen[ipi],VOFFrozen[ini],VOFFrozen[inni]);
                          attrs:=attrs-maxoper(dfn,0.0)*(f_forvard-VOFFrozen[ipi])+maxoper(-dfn,0.0)*(f_forvard-VOFFrozen[ini]);
                       end;
                       if (is_internal_HO(issi,isi,ipi,ini)) then
                       begin
                          // можно обрабатывать грань схемой высокого порядка
                          f_backvard:=cell_face_value_global(SUPERBEE,Vy[iscvi],VOFFrozen[issi],VOFFrozen[isi],VOFFrozen[ipi],VOFFrozen[ini]);
                          attrs:=attrs-maxoper(-dfs,0.0)*(f_backvard-VOFFrozen[ipi])+maxoper(dfs,0.0)*(f_backvard-VOFFrozen[isi]);
                       end;

                       // UDS
                       if (ApproxConvectionForm.CheckBoxKIvanovApprox.Checked) then
                       begin
                           VOF[ipi]:=(maxoper(-dfn,0.0)*VOFFrozen[ini]
                           +maxoper(dfs,0.0)*VOFFrozen[isi]
                           +dsc*mapPT[k].dV+2.0*mapPT[k].dV*VOFFrozen[ipi]/
                           dtimesteploc+attrs)/
                           (maxoper(dfn,0.0)+maxoper(-dfs,0.0)+
                            2.0*mapPT[k].dV/dtimesteploc -
                            dsp*mapPT[k].dV);
                        end
                        else
                        begin
                           // Общепринятая схема.
                           VOF[ipi]:=(maxoper(-dfn,0.0)*VOFFrozen[ini]
                           +maxoper(dfs,0.0)*VOFFrozen[isi]
                           +dsc*mapPT[k].dV+2.0*mapPT[k].dV*VOFFrozen[ipi]/
                           dtimesteploc+attrs)/
                           (maxoper(-dfn,0.0)+maxoper(dfs,0.0)+
                            2.0*mapPT[k].dV/dtimesteploc -
                            dsp*mapPT[k].dV);
                        end;

                    end;
                 end;




                iran:=0;
             end;
      end;

      // Для сохранения массы обоих фаз сделано невтекание фазы 2 внутрь расчётной области,
      // хотя вытекать она может свободно.
      // Восстановим значения функции цвета находящиеся на границе области.
    for k:=1 to imaxnumbernode do
      begin
         if (mapPT[k].itype=2) then
            begin
               ipi:=mapPT[k].i+(mapPT[k].j-1)*inx;  // текущая точка
               iecvi:=mapPT[k].i+(mapPT[k].j-1)*(inx-1); // в массиве Vx
               iwcvi:=(mapPT[k].i-1)+(mapPT[k].j-1)*(inx-1); // горизонтальных точек на одну меньше
               incvi:=mapPT[k].i+(mapPT[k].j-1)*inx; // в массиве Vy горизонтальных точек столько же,
               iscvi:=mapPT[k].i+(mapPT[k].j-2)*inx; // а вертикальных на одну меньше

               case mapPT[k].iugol of
                 0 : begin
                        // Неугловая и нужно снести поправку на границу области.
                        // Внутренняя нормаль.
                        case mapPT[k].chnormal of
                           'N' : begin
                                    if (Vy[incvi]>0.0) then
                                    begin
                                       // втекание среды вглубь расчётной области
                                       VOF[ipi]:=0.0; // нет втекание фазы 2.
                                    end
                                    else
                                    begin
                                       VOF[ipi]:=VOF[mapPT[k].i+(mapPT[k].j-1+1)*inx];
                                    end;
                                 end;
                           'S' : begin
                                    if (Vy[iscvi]<0.0) then
                                    begin
                                       // втекание среды вглубь расчётной области
                                       VOF[ipi]:=0.0; // нет втекание фазы 2.
                                    end
                                    else
                                    begin
                                       VOF[ipi]:=VOF[mapPT[k].i+(mapPT[k].j-1-1)*inx];
                                    end;
                                 end;
                           'W' : begin
                                    if (Vx[iwcvi]<0.0) then
                                    begin
                                       // втекание среды вглубь расчётной области
                                       VOF[ipi]:=0.0; // нет втекание фазы 2.
                                    end
                                    else
                                    begin
                                       VOF[ipi]:=VOF[mapPT[k].i-1+(mapPT[k].j-1)*inx];
                                    end;
                                 end;
                           'E' : begin
                                     if (Vx[iecvi]>0.0) then
                                    begin
                                       // втекание среды вглубь расчётной области
                                       VOF[ipi]:=0.0; // нет втекания фазы 2.
                                    end
                                    else
                                    begin
                                       VOF[ipi]:=VOF[mapPT[k].i+1+(mapPT[k].j-1)*inx];
                                    end;
                                 end;
                        end;
                     end;
                 1 : begin
                        // левый нижний угол.
                        VOF[ipi]:=0.5*(VOF[mapPT[k].i+1+(mapPT[k].j-1)*inx]+VOF[mapPT[k].i+(mapPT[k].j-1+1)*inx]);
                     end;
                 2 : begin
                        // правый нижний угол.
                        VOF[ipi]:=0.5*(VOF[mapPT[k].i-1+(mapPT[k].j-1)*inx]+VOF[mapPT[k].i+(mapPT[k].j-1+1)*inx]);
                     end;
                 3 : begin
                        // левый верхний угол.
                        VOF[ipi]:=0.5*(VOF[mapPT[k].i+1+(mapPT[k].j-1)*inx]+VOF[mapPT[k].i+(mapPT[k].j-1-1)*inx]);
                     end;
                 4 : begin
                        // правый верхний угол.
                        VOF[ipi]:=0.5*(VOF[mapPT[k].i-1+(mapPT[k].j-1)*inx]+VOF[mapPT[k].i+(mapPT[k].j-1-1)*inx]);
                     end;
                 5 : begin
                        // узел пятиточечный крест.
                        VOF[ipi]:=0.25*(VOF[mapPT[k].i-1+(mapPT[k].j-1)*inx]+VOF[mapPT[k].i+(mapPT[k].j-1-1)*inx]+VOF[mapPT[k].i+1+(mapPT[k].j-1)*inx]+VOF[mapPT[k].i+(mapPT[k].j-1+1)*inx]);
                     end;
               end;

         end;
      end;


   end;


   // Update.
   for  i:=1 to inx do
   begin
      for j:=1 to iny do
      begin
         VOFFrozen[i+(j-1)*inx]:=VOF[i+(j-1)*inx];
         if ((VOFFrozen[i+(j-1)*inx]>1)or(VOFFrozen[i+(j-1)*inx]<0.0)) then
         begin
            //Application.MessageBox('error','VOF вышла заграницы',MB_OK);
            //MainMemo.Lines.Add('VOF вышла заграницы'+FloatToStr(VOFFrozen[i+(j-1)*inx]));
            if ( VOFFrozen[i+(j-1)*inx]>1) then
            begin
               VOF[i+(j-1)*inx]:=1.0;
               VOFFrozen[i+(j-1)*inx]:=1.0;
            end;
            if ( VOFFrozen[i+(j-1)*inx]<0) then
            begin
               VOF[i+(j-1)*inx]:=0.0;
               VOFFrozen[i+(j-1)*inx]:=0.0;
            end;
            berr:=true;
         end;
      end;
   end;

   end;

   if (berr) then
   begin
     // Application.MessageBox('error','VOF вышла заграницы',MB_OK);
     MainMemo.Lines.Add('VOF вышла заграницы');
   end;
   SetLength(VOFFrozen,1);
end;

// Граничное условие II рода на левой стенке
// для уравнения теплопроводности с учётом конвективного члена.
procedure TForm1.TempBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                          var db : array of Float; // правая часть
                                          qbleft : Float; // заданный тепловой поток на границе
                                          place : TmyNode); // место на карте
var
    //iei,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpn, dps : Float; // числа Пекле
    dfe, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iecvi:=i+(j-1)*(inx-1);
      //dfn:=densuty_in_surface(ipi,ini)*dcp*Vy[incvi]*dx; // интенсивность
      //dfs:=densuty_in_surface(ipi,isi)*dcp*Vy[iscvi]*dx; // конвекции
      //dfe:=densuty_in_surface(ipi,iei)*dcp*Vx[iecvi]*dy; // или течения
      dfn:=Vy[incvi]*dx; // интенсивность
      dfs:=Vy[iscvi]*dx; // конвекции
      dfe:=Vx[iecvi]*dy; // или течения
      // теплопроводность на грани контрольного объёма
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      ddn:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp);
      dds:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
      dde:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp);
      dpn:=dfn/ddn; // Значение
      dps:=dfs/dds; // чисел
      dpe:=dfe/dde; // Пекле
      // коэффициенты дискретного аналога
      if ((ishconvtemp>=0)and(ishconvtemp<=7)) then
      begin
         m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconvtemp)+maxoper(-dfe,0);
      end
      else
      begin
          m[ipi].dae:=dde+maxoper(-dfe,0);
      end;
      m[ipi].daw:=0.0;
     // m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconvtemp)+maxoper(-dfn,0);
     // m[ipi].das:=dds*ApproxConvective(abs(dps),ishconvtemp)+maxoper(dfs,0);
     m[ipi].dan:=0.0;
     m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарный солвер
         if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
          else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=(dSc[ipi]*dV + dy*qbleft)/(densuty_in_surface(ipi,iei)*dcp); // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
           else
         begin
            // нестационарный добавок к источниковому члену
            db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
         end;
      end;
      m[ipi].dap:=m[ipi].dae + m[ipi].dan + m[ipi].das + dap0 - dSp*dV/(densuty_in_surface(ipi,iei)*dcp);
      //m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconvtemp)+maxoper(dfe,0)+ddn*ApproxConvective(abs(dpn),ishconvtemp)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconvtemp)+maxoper(-dfs,0)  + dap0 - dSp*dV;


   end; // with

end; // TempBoundaryCoefConvLeft

// Граничное условие II рода на левой стенке
// для уравнения переноса User-Defined Scalar`a с учётом конвективного члена.
procedure TForm1.UDSBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                          var db : array of Float; // правая часть
                                          qbleft : Float; // заданный тепловой поток на границе
                                          place : TmyNode); // место на карте

const
   epsilonD0=1e-30;
   
var
    //iei,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpn, dps : Float; // числа Пекле
    dfe, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент

// модуль вещественного числа.    
function fabs(myf : Float) : Float;
begin
   if (myf<0.0) then
   begin
      fabs:=-myf;
   end
   else
   begin
      fabs:=myf;
   end;
end;

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iecvi:=i+(j-1)*(inx-1);

      dfn:=0.0;
      dfs:=0.0;
      dfe:=0.0;

      case icurentuds of
         1 : begin
                if (iuds1typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfe:=Vxuds[iecvi]*dy; // или течения
                end
                 else if (iuds1typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // или течения
                end;
             end;
         2 : begin
                 if (iuds2typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfe:=Vxuds[iecvi]*dy; // или течения
                end
                 else if (iuds2typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // или течения
                end;
             end;
         3 : begin
                 if (iuds3typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfe:=Vxuds[iecvi]*dy; // или течения
                end
                 else if (iuds3typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // или течения
                end;
             end;
         4 : begin
                 if (iuds4typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfe:=Vxuds[iecvi]*dy; // или течения
                end
                 else if (iuds4typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // или течения
                end;
             end;
      end;

      dkn:=1.0;
      dks:=1.0;
      dke:=1.0;

      case icurentuds of
         1 : begin
                // теплопроводность на грани контрольного объёма
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));
                end;
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));
                end;
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));
                end;
             end;
         2 : begin
                // теплопроводность на грани контрольного объёма
                 // теплопроводность на грани контрольного объёма
                if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));
                end;
                 if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));
                end;
                 if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));
                end;
             end;
         3 : begin
                // теплопроводность на грани контрольного объёма
                 if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));
                end;
                 if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));
                end;
                if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));
                end;
             end;
         4 : begin
                // теплопроводность на грани контрольного объёма
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));
                end;
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));
                end;
                  if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));
                end;
             end;
      end;




      ddn:=dkn*dx/dyn;
      dds:=dks*dx/dys;
      dde:=dke*dy/dxe;

      if (fabs(ddn)<epsilonD0) then
      begin
         dpn:=1e30;
      end
      else
      begin
         dpn:=dfn/ddn; // Значение
      end;
      if (fabs(dds)<epsilonD0) then
      begin
         dps:=1e30;
      end
       else
      begin
         dps:=dfs/dds; // чисел
      end;
      if (fabs(dde)<epsilonD0) then
      begin
         dpe:=1e30;
      end
      else
      begin
         dpe:=dfe/dde; // Пекле
      end;
      // коэффициенты дискретного аналога
      m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(-dfe,0);
      m[ipi].daw:=0.0;
      m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(-dfn,0);
      m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+maxoper(dfs,0);

      dap0:=0.0; // инициализация.

      if (btimedepend) then
      begin
         // нестационарный солвер


         case icurentuds of
           1 : begin
                  if (itypeuds1unsteadyfunction=0) then
                  begin
                     // none
                     dap0:=0.0;
                  end
                  else if (itypeuds1unsteadyfunction=1) then
                  begin
                     // стандартный
                     if (iuds1typerho=0) then
                     begin
                        // 1.0
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds1typerho=1) then
                     begin
                        // гидродинамическая плотность
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
           2 : begin
                  if (itypeuds2unsteadyfunction=0) then
                  begin
                     // none
                     dap0:=0.0;
                  end
                  else if (itypeuds2unsteadyfunction=1) then
                  begin
                     // стандартный
                     if (iuds2typerho=0) then
                     begin
                        // 1.0
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds2typerho=1) then
                     begin
                        // гидродинамическая плотность
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
           3 : begin
                  if (itypeuds3unsteadyfunction=0) then
                  begin
                     // none
                     dap0:=0.0;
                  end
                  else if (itypeuds3unsteadyfunction=1) then
                  begin
                     // стандартный
                     if (iuds3typerho=0) then
                     begin
                        // 1.0
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds3typerho=1) then
                     begin
                        // гидродинамическая плотность
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
           4 : begin
                  if (itypeuds4unsteadyfunction=0) then
                  begin
                     // none
                     dap0:=0.0;
                  end
                  else if (itypeuds4unsteadyfunction=1) then
                  begin
                     // стандартный
                     if (iuds4typerho=0) then
                     begin
                        // 1.0
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds4typerho=1) then
                     begin
                        // гидродинамическая плотность
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
         end;

      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;

      case icurentuds of
         1 : begin
                db[ipi]:=qbleft; // неизменная составляющая источникового члена
             end;
         2 : begin
                db[ipi]:=qbleft; // неизменная составляющая источникового члена
             end;
         3 : begin
                db[ipi]:=qbleft; // неизменная составляющая источникового члена
             end;
         4 : begin
                db[ipi]:=qbleft; // неизменная составляющая источникового члена
             end;
      end;

      {$IFDEF dSourceBoundary}
      // добавок к источниковому члену определён.

        case icurentuds of
           1 : begin
                 db[ipi]:=db[ipi] + dSc1[ipi]*dV; // неизменная составляющая источникового члена
               end;
           2 : begin
                  db[ipi]:=db[ipi] + dSc2[ipi]*dV; // неизменная составляющая источникового члена
               end;
           3 : begin
                  db[ipi]:=db[ipi] + dSc3[ipi]*dV; // неизменная составляющая источникового члена
               end;
           4 : begin
                  db[ipi]:=db[ipi] + dSc4[ipi]*dV; // неизменная составляющая источникового члена
               end;
         end;

      {$ENDIF}


      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену

         case icurentuds of
         1 : begin
                db[ipi]:=db[ipi]+ dap0*uds1oldTimeStep[ipi];
             end;
         2 : begin
                db[ipi]:=db[ipi]+ dap0*uds2oldTimeStep[ipi];
             end;
         3 : begin
                db[ipi]:=db[ipi]+ dap0*uds3oldTimeStep[ipi];
             end;
         4 : begin
                db[ipi]:=db[ipi]+ dap0*uds4oldTimeStep[ipi];
             end;
         end;
      end;
      //m[ipi].dap:=m[ipi].dae + m[ipi].dan + m[ipi].das;
      m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(dfe,0)+ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv)+maxoper(-dfs,0);

      case icurentuds of
         1 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
         2 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
         3 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
         4 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
      end;

      {$IFDEF dSourceBoundary}
      // добавок к диагональному члену определён.

      case icurentuds of
           1 : begin
                  m[ipi].dap:=m[ipi].dap - dSp1[ipi]*dV;
               end;
           2 : begin
                  m[ipi].dap:=m[ipi].dap - dSp2[ipi]*dV;
               end;
           3 : begin
                  m[ipi].dap:=m[ipi].dap - dSp3[ipi]*dV;
               end;
           4 : begin
                  m[ipi].dap:=m[ipi].dap - dSp4[ipi]*dV;
               end;
      end;

      {$ENDIF}

   end; // with

end; // UDSBoundaryCoefConvLeft


// Граничное условие II рода на левой стенке
// для уравнения функции цвета с учётом конвективного члена.
procedure TForm1.VofBoundaryCoefConvLeft(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                                          var db : array of Float; // правая часть
                                          qbleft : Float; // заданный тепловой поток на границе
                                          place : TmyNode; artificaldiffusion : Float); // место на карте
var
    iei,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpn, dps : Float; // числа Пекле
    dfe, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    dScVof, dSpVof : Float; // источниковый член для функции цвета.

begin
   dScVof:=0.0;
   dSpVof:=0.0;

   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iecvi:=i+(j-1)*(inx-1);
      dfn:=Vy[incvi]*dx; // интенсивность
      dfs:=Vy[iscvi]*dx; // конвекции
      dfe:=Vx[iecvi]*dy; // или течения
      // теплопроводность на грани контрольного объёма
      dkn:=artificaldiffusion;
      dks:=artificaldiffusion;
      dke:=artificaldiffusion;

      ddn:=dkn*dx/dyn;
      dds:=dks*dx/dys;
      dde:=dke*dy/dxe;

      if (artificaldiffusion<1.0e-20) then
      begin
         //dpn:=1.0e20; // Значение
         //dps:=1.0e20; // чисел
         //dpe:=1.0e20; // Пекле
         // коэффициенты дискретного аналога
         m[ipi].dae:=maxoper(-dfe,0);
         m[ipi].dan:=maxoper(-dfn,0);
         m[ipi].das:=maxoper(dfs,0);
      end
      else
      begin
         dpn:=dfn/ddn; // Значение
         dps:=dfs/dds; // чисел
         dpe:=dfe/dde; // Пекле
         // коэффициенты дискретного аналога
         m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(-dfe,0);
         m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(-dfn,0);
         m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+maxoper(dfs,0);
      end;

      m[ipi].daw:=0.0;

      if (btimedepend) then
      begin
        // нестационарный солвер
        if (bVOFsecondorder) then
        begin
           // формула Пейре второго порядка.
           dap0:=1.5*dV/dTimeStep; // неявная часть.
        end
         else
        begin
           // формула Эйлера первого порядка.
           dap0:=dV/dTimeStep; // нестаионарный вклад
        end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dScVof*dV + qbleft; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         if (bVOFsecondorder) then
         begin
            // формула Пейре второго порядка на постоянном шаге по времени.
            db[ipi]:=db[ipi]+dV*(2.0*VOFOldTimeStep[ipi]-0.5*VOFOldOldTimeStep[ipi])/dTimeStep;
         end
          else
         begin
            // Формула Эйлера.
            db[ipi]:=db[ipi]+ dap0*VOFOldTimeStep[ipi];
         end;
      end;


       if (artificaldiffusion<1.0e-20) then
      begin
         m[ipi].dap:=maxoper(dfe,0)+maxoper(dfn,0)+maxoper(-dfs,0);
      end
       else
      begin
         m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(dfe,0)+ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv)+maxoper(-dfs,0);
      end;

      m[ipi].dap:=m[ipi].dap + dap0 - dSpVof*dV;
   end; // with

end; // VofBoundaryCoefConvLeft


// Граничное условие II рода на правой стенке
// для уравнения теплопроводности с учётом конвективного члена.
                                         // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefConvRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                        qbright : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте
var
    //iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dkw, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpw, dpn,dps : Float; // числа Пекле
    dfw, dfn, dfs : Float; // интенсивность течения или конвекции
    ddw, ddn, dds : Float; // диффузионная составляющая
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iwi:=(i-1)+(j-1)*inx; // запад
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iwcvi:=(i-1)+(j-1)*(inx-1);
      //dfn:=densuty_in_surface(ipi,ini)*dcp*Vy[incvi]*dx; // интенсивность
      //dfs:=densuty_in_surface(ipi,isi)*dcp*Vy[iscvi]*dx; // конвекции
      //dfw:=densuty_in_surface(ipi,iwi)*dcp*Vx[iwcvi]*dy; // или течения
      dfn:=Vy[incvi]*dx; // интенсивность
      dfs:=Vy[iscvi]*dx; // конвекции
      dfw:=Vx[iwcvi]*dy; // или течения
      // теплопроводность на грани контрольного объёма
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      ddn:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp); // диффузионная
      dds:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp); // составляющая
      ddw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp);
      dpn:=dfn/ddn; // Значение
      dps:=dfs/dds; // числа
      dpw:=dfw/ddw; // Пекле
      m[ipi].dae:=0.0;  // коэффициенты  дискретного аналога
      if ((ishconvtemp>=0)and(ishconvtemp<=7)) then
      begin
         m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconvtemp)+ maxoper(dfw,0);
      end
      else
      begin
         m[ipi].daw:=ddw + maxoper(dfw,0);
      end;
     // m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconvtemp)+ maxoper(-dfn,0);
     // m[ipi].das:=dds*ApproxConvective(abs(dps),ishconvtemp)+ maxoper(dfs,0);
     m[ipi].dan:=0.0;
     m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарный солвер
          if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
          else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=(dSc[ipi]*dV + dy*qbright)/(densuty_in_surface(ipi,iwi)*dcp); // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
           else
         begin
            db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
         end;
      end;
      m[ipi].dap:=m[ipi].daw + m[ipi].dan + m[ipi].das + dap0 - dSp*dV/(densuty_in_surface(ipi,iwi)*dcp);
      //m[ipi].dap:=ddw*ApproxConvective(abs(dpw),ishconvtemp)+ maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconvtemp)+ maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconvtemp)+ maxoper(-dfs,0)  + dap0 - dSp*dV;



   end; // with

end; // TempBoundaryCoefConvRight


// Граничное условие II рода на правой стенке
// для уравнения переноса User-Defined Scalar`а учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.UDSBoundaryCoefConvRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                        qbright : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте

const
   epsilonD0=1e-30;
   
var
    //iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dkw, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpw, dpn,dps : Float; // числа Пекле
    dfw, dfn, dfs : Float; // интенсивность течения или конвекции
    ddw, ddn, dds : Float; // диффузионная составляющая
    dap0 : Float;  // нестационарный коэффициент

// модуль вещественного числа.    
function fabs(myf : Float) : Float;
begin
   if (myf<0.0) then
   begin
      fabs:=-myf;
   end
   else
   begin
      fabs:=myf;
   end;
end;    

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iwi:=(i-1)+(j-1)*inx; // запад
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iwcvi:=(i-1)+(j-1)*(inx-1);

      dfn:=0.0;
      dfs:=0.0;
      dfw:=0.0;

      case icurentuds of
         1 : begin
                if (iuds1typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfw:=Vxuds[iwcvi]*dy; // или течения
                end else
                if (iuds1typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // или течения
                end;
             end;
         2 : begin
                if (iuds2typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfw:=Vxuds[iwcvi]*dy; // или течения
                end else
                if (iuds2typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // или течения
                end;
             end;
         3 : begin
                if (iuds3typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfw:=Vxuds[iwcvi]*dy; // или течения
                end else
                if (iuds3typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // или течения
                end;
             end;
         4 : begin
                if (iuds4typerho=0) then
                begin
                   // 1.0
                   dfn:=Vyuds[incvi]*dx; // интенсивность
                   dfs:=Vyuds[iscvi]*dx; // конвекции
                   dfw:=Vxuds[iwcvi]*dy; // или течения
                end else
                if (iuds4typerho=1) then
                begin
                   // гидродинамическая плотность.
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // интенсивность
                   dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // конвекции
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // или течения
                end;
             end;
      end;

      dkn:=1.0;
      dks:=1.0;
      dkw:=1.0;

      case icurentuds of
         1 : begin
                // теплопроводность на грани контрольного объёма
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));
                end;
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));
                end;
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));
                end;
             end;
         2 : begin
                // теплопроводность на грани контрольного объёма
                if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));
                end;
                if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));
                end;
                if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds2diffusivity[ipi]*uds2diffusivity[iwi]/((uds2diffusivity[ipi]+uds2diffusivity[iwi]));
                end;
             end;
         3 : begin
                // теплопроводность на грани контрольного объёма
                if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));
                end;
                 if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));
                end;
                 if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));
                end;
             end;
         4 : begin
                // теплопроводность на грани контрольного объёма
                 if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[ini])<epsilonD0)) then
                begin
                   dkn:=0.0;
                end
                 else
                begin
                   dkn:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));
                end;
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));
                end;
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));
                end;
             end;
      end;



      ddn:=dkn*dx/dyn; // диффузионная
      dds:=dks*dx/dys; // составляющая
      ddw:=dkw*dy/dxw;

      if (fabs(ddn)<epsilonD0) then
      begin
         dpn:=1e30;
      end
      else
      begin
         dpn:=dfn/ddn; // Значение
      end;
      if (fabs(dds)<epsilonD0) then
      begin
         dps:=1e30;
      end
      else
      begin
         dps:=dfs/dds; // числа
      end;
      if (fabs(ddw)<epsilonD0) then
      begin
         dpw:=1e30;
      end
      else
      begin
         dpw:=dfw/ddw; // Пекле
      end;
      m[ipi].dae:=0.0;  // коэффициенты  дискретного аналога
      m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv)+ maxoper(dfw,0);
      m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+ maxoper(-dfn,0);
      m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+ maxoper(dfs,0);

      dap0:=0.0; // инициализация.

      if (btimedepend) then
      begin
         // нестационарный солвер

         case icurentuds of
         1 : begin
                if (itypeuds1unsteadyfunction=0) then
                begin
                   // none
                   dap0:=0.0;
                end
                 else if (itypeuds1unsteadyfunction=1) then
                begin
                   // standart
                   if (iuds1typerho=0) then
                   begin
                      // 1.0
                      dap0:=dV/dTimeStep; // нестаионарный вклад
                   end
                    else if (iuds1typerho=1) then
                   begin
                      // гидродинамическая плотность.
                      dap0:=density(ipi)*dV/dTimeStep; // нестационарный вклад
                   end;
                end;
             end;
         2 : begin
                if (itypeuds2unsteadyfunction=0) then
                begin
                   // none
                   dap0:=0.0;
                end
                 else if (itypeuds2unsteadyfunction=1) then
                begin
                   // standart
                   if (iuds2typerho=0) then
                   begin
                      // 1.0
                      dap0:=dV/dTimeStep; // нестаионарный вклад
                   end
                    else if (iuds2typerho=1) then
                   begin
                      // гидродинамическая плотность.
                      dap0:=density(ipi)*dV/dTimeStep; // нестационарный вклад
                   end;
                end;
             end;
         3 : begin
                if (itypeuds3unsteadyfunction=0) then
                begin
                   // none
                   dap0:=0.0;
                end
                 else if (itypeuds3unsteadyfunction=1) then
                begin
                   // standart
                   if (iuds3typerho=0) then
                   begin
                      // 1.0
                      dap0:=dV/dTimeStep; // нестаионарный вклад
                   end
                    else if (iuds3typerho=1) then
                   begin
                      // гидродинамическая плотность.
                      dap0:=density(ipi)*dV/dTimeStep; // нестационарный вклад
                   end;
                end;
             end;
          4 : begin
                if (itypeuds4unsteadyfunction=0) then
                begin
                   // none
                   dap0:=0.0;
                end
                 else if (itypeuds4unsteadyfunction=1) then
                begin
                   // standart
                   if (iuds4typerho=0) then
                   begin
                      // 1.0
                      dap0:=dV/dTimeStep; // нестаионарный вклад
                   end
                    else if (iuds4typerho=1) then
                   begin
                      // гидродинамическая плотность.
                      dap0:=density(ipi)*dV/dTimeStep; // нестационарный вклад
                   end;
                end;
             end;
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;

      case icurentuds of
         1 : begin
                db[ipi]:=qbright; // неизменная составляющая источникового члена
             end;
         2 : begin
                db[ipi]:=qbright; // неизменная составляющая источникового члена
             end;
         3 : begin
                db[ipi]:=qbright; // неизменная составляющая источникового члена
             end;
         4 : begin
                db[ipi]:=qbright; // неизменная составляющая источникового члена
             end;
      end;

      {$IFDEF dSourceBoundary}
      // добавок к источниковому члену определён.

        case icurentuds of
           1 : begin
                 db[ipi]:=db[ipi] + dSc1[ipi]*dV; // неизменная составляющая источникового члена
               end;
           2 : begin
                  db[ipi]:=db[ipi] + dSc2[ipi]*dV; // неизменная составляющая источникового члена
               end;
           3 : begin
                  db[ipi]:=db[ipi] + dSc3[ipi]*dV; // неизменная составляющая источникового члена
               end;
           4 : begin
                  db[ipi]:=db[ipi] + dSc4[ipi]*dV; // неизменная составляющая источникового члена
               end;
         end;

      {$ENDIF}

      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
        case icurentuds of
         1 : begin
                db[ipi]:=db[ipi]+ dap0*uds1oldTimeStep[ipi];
             end;
         2 : begin
                db[ipi]:=db[ipi]+ dap0*uds2oldTimeStep[ipi];
             end;
         3 : begin
                db[ipi]:=db[ipi]+ dap0*uds3oldTimeStep[ipi];
             end;
         4 : begin
                db[ipi]:=db[ipi]+ dap0*uds4oldTimeStep[ipi];
             end;
        end;
      end;
      //m[ipi].dap:=m[ipi].daw + m[ipi].dan + m[ipi].das;
      m[ipi].dap:=ddw*ApproxConvective(abs(dpw),ishconv)+ maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv)+ maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv)+ maxoper(-dfs,0);

      case icurentuds of
         1 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
         2 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
         3 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
         4 : begin
                m[ipi].dap:=m[ipi].dap + dap0;
             end;
      end;

      {$IFDEF dSourceBoundary}
      // добавок к диагональному члену определён.

      case icurentuds of
           1 : begin
                  m[ipi].dap:=m[ipi].dap - dSp1[ipi]*dV;
               end;
           2 : begin
                  m[ipi].dap:=m[ipi].dap - dSp2[ipi]*dV;
               end;
           3 : begin
                  m[ipi].dap:=m[ipi].dap - dSp3[ipi]*dV;
               end;
           4 : begin
                  m[ipi].dap:=m[ipi].dap - dSp4[ipi]*dV;
               end;
      end;

      {$ENDIF}

   end; // with

end; // UDSBoundaryCoefConvRight

// Граничное условие II рода на правой стенке
// для уравнения переноса функции цввета с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.VofBoundaryCoefConvRight(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                        qbright : Float; // заданный тепловой поток на границе
                        place : TmyNode; artificaldiffusion : Float); // место на карте
var
    iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dkw, dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpw, dpn,dps : Float; // числа Пекле
    dfw, dfn, dfs : Float; // интенсивность течения или конвекции
    ddw, ddn, dds : Float; // диффузионная составляющая
    dap0 : Float;  // нестационарный коэффициент
    dScVof, dSpVof : Float;

begin
   dScVof:=0.0;
   dSpVof:=0.0;
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      iwi:=(i-1)+(j-1)*inx; // запад
      ini:=i+j*inx;  // север
      isi:=i+(j-2)*inx; // юг
      incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
      iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
      iwcvi:=(i-1)+(j-1)*(inx-1);
      dfn:=Vy[incvi]*dx; // интенсивность
      dfs:=Vy[iscvi]*dx; // конвекции
      dfw:=Vx[iwcvi]*dy; // или течения
      // теплопроводность на грани контрольного объёма
      dkn:=artificaldiffusion;
      dks:=artificaldiffusion;
      dkw:=artificaldiffusion;

      ddn:=dkn*dx/dyn; // диффузионная
      dds:=dks*dx/dys; // составляющая
      ddw:=dkw*dy/dxw;

      if (artificaldiffusion<1.0e-20) then
      begin
         //dpn:=1.0e20; // Значение
         //dps:=1.0e20; // числа
         //dpw:=1.0e20; // Пекле
         // коэффициенты  дискретного аналога
         m[ipi].daw:=maxoper(dfw,0);
         m[ipi].dan:=maxoper(-dfn,0);
         m[ipi].das:=maxoper(dfs,0);
      end
       else
      begin
         dpn:=dfn/ddn; // Значение
         dps:=dfs/dds; // числа
         dpw:=dfw/ddw; // Пекле
         // коэффициенты  дискретного аналога
         m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv)+ maxoper(dfw,0);
         m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+ maxoper(-dfn,0);
         m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+ maxoper(dfs,0);
      end;

      m[ipi].dae:=0.0;

      if (btimedepend) then
      begin
         // нестационарный солвер
         if (bVOFsecondorder) then
         begin
            // формула Пейре второго порядка.
            dap0:=1.5*dV/dTimeStep; // неявная часть.
         end
          else
         begin
            // формула Эйлера первого порядка.
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dScVof*dV + qbright; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         if (bVOFsecondorder) then
         begin
            // формула Пейре второго порядка на постоянном шаге по времени.
            db[ipi]:=db[ipi]+dV*(2.0*VOFOldTimeStep[ipi]-0.5*VOFOldOldTimeStep[ipi])/dTimeStep;
         end
           else
         begin
            // Формула Эйлера.
            db[ipi]:=db[ipi]+ dap0*VOFOldTimeStep[ipi];
         end;
      end;

      if (artificaldiffusion<1.0e-20) then
      begin
         m[ipi].dap:=maxoper(-dfw,0)+maxoper(dfn,0)+maxoper(-dfs,0);
      end
      else
      begin
         m[ipi].dap:=ddw*ApproxConvective(abs(dpw),ishconv)+ maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv)+ maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv)+ maxoper(-dfs,0);
      end;

      m[ipi].dap:=m[ipi].dap + dap0 - dSpVof*dV;
   end; // with

end; // VofBoundaryCoefConvRight

// Граничное условие II рода на нижней стенке
// для уравнения теплопроводности с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefConvBottom(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                       qbbottom : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте
var
    //iei,iwi,ini,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi : Integer;// номера узлов для граней контрольного объёма
    dke, dkw,dkn : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn : Float; // числа Пекле
    dfe, dfw, dfn : Float;
    dde, ddw, ddn : Float;
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx;
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      //dfe:=densuty_in_surface(ipi,iei)*dcp*Vx[iecvi]*dy; // интенсивность
      //dfw:=densuty_in_surface(ipi,iwi)*dcp*Vx[iwcvi]*dy; // конвекции
      //dfn:=densuty_in_surface(ini,ipi)*dcp*Vy[incvi]*dx; // или течения
      dfe:=Vx[iecvi]*dy; // интенсивность
      dfw:=Vx[iwcvi]*dy; // конвекции
      dfn:=Vy[incvi]*dx; // или течения
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
      dde:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp);  // диффузионная
      ddw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp);  // составляющая.
      ddn:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp);
      dpn:=dfn/ddn;  // Значения
      dpe:=dfe/dde;  //  чисел Пекле.
      dpw:=dfw/ddw;
      // коэффициенты дискретного аналога
      //m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconvtemp) + maxoper(-dfe,0);
      //m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconvtemp) + maxoper(dfw,0);
      m[ipi].dae:=0.0;
      m[ipi].daw:=0.0;
      if ((ishconvtemp>=0)and(ishconvtemp<=7)) then
      begin
         m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconvtemp) + maxoper(-dfn,0);
      end
      else
      begin
          m[ipi].dan:=ddn + maxoper(-dfn,0);
      end;
      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарный солвер
         if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
          else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=(dSc[ipi]*dV + dx*qbbottom)/(densuty_in_surface(ipi,ini)*dcp); // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
           else
         begin
            // нестационарный добавок к источниковому члену
            db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
         end;
      end;
      m[ipi].dap:= m[ipi].dan + m[ipi].dae + m[ipi].daw + dap0 - dSp*dV/(densuty_in_surface(ipi,ini)*dcp);
      //m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconvtemp) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconvtemp) + maxoper(-dfw,0)+ ddn*ApproxConvective(abs(dpn),ishconvtemp) + maxoper(dfn,0)+ dap0 - dSp*dV;

   end; // with

end; // TempBoundaryCoefConvBottom

// Граничное условие II рода на нижней стенке
// для уравнения UDS с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.UDSBoundaryCoefConvBottom(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                       qbbottom : Float; // заданный тепловой поток на границе
                                           place : TmyNode); // место на карте
const
   epsilonD0=1e-30;
   
var
    //iei,iwi,ini,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi : Integer;// номера узлов для граней контрольного объёма
    dke, dkw,dkn : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn : Float; // числа Пекле
    dfe, dfw, dfn : Float;
    dde, ddw, ddn : Float;
    dap0 : Float;  // нестационарный коэффициент

// модуль вещественного числа.    
function fabs(myf : Float) : Float;
begin
   if (myf<0.0) then
   begin
      fabs:=-myf;
   end
   else
   begin
      fabs:=myf;
   end;
end;    

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx;
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше

      // инициализация.
      dfe:=0.0;
      dfw:=0.0;
      dfn:=0.0;


      case icurentuds of
         1 : begin
                if (iuds1typerho=0) then
                begin
                   dfe:=Vxuds[iecvi]*dy; // интенсивность
                   dfw:=Vxuds[iwcvi]*dy; // конвекции
                   dfn:=Vyuds[incvi]*dx; // или течения
                end
                else if (iuds1typerho=1) then
                begin
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // или течения
                end;
             end;
         2 : begin
                if (iuds2typerho=0) then
                begin
                   dfe:=Vxuds[iecvi]*dy; // интенсивность
                   dfw:=Vxuds[iwcvi]*dy; // конвекции
                   dfn:=Vyuds[incvi]*dx; // или течения
                end
                else if (iuds2typerho=1) then
                begin
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // или течения
                end;
             end;
         3 : begin
                if (iuds3typerho=0) then
                begin
                   dfe:=Vxuds[iecvi]*dy; // интенсивность
                   dfw:=Vxuds[iwcvi]*dy; // конвекции
                   dfn:=Vyuds[incvi]*dx; // или течения
                end
                else if (iuds3typerho=1) then
                begin
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // или течения
                end;
             end;
         4 : begin
                if (iuds4typerho=0) then
                begin
                   dfe:=Vxuds[iecvi]*dy; // интенсивность
                   dfw:=Vxuds[iwcvi]*dy; // конвекции
                   dfn:=Vyuds[incvi]*dx; // или течения
                end
                else if (iuds4typerho=1) then
                begin
                   dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                   dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                   dfn:=densuty_in_surface(ipi,ini)*Vyuds[incvi]*dx; // или течения
                end;
             end;
      end;

      // инициализация.
      dke:=1.0;
      dkw:=1.0;
      dkn:=1.0;


      case icurentuds of
        1 : begin
               // теплопроводность на грани контрольного объёма
               if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iei])<epsilonD0)) then
               begin
                  dke:=0.0;
               end
               else
               begin
                  dke:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));
               end;
               if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iwi])<epsilonD0)) then
               begin
                  dkw:=0.0;
               end
               else
               begin
                  dkw:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));
               end;
               if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[ini])<epsilonD0)) then
               begin
                  dkn:=0.0;
               end
               else
               begin
                  dkn:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));
               end;
            end;
        2 : begin
               // теплопроводность на грани контрольного объёма
               if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iei])<epsilonD0)) then
               begin
                  dke:=0.0;
               end
               else
               begin
                  dke:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));
               end;
               if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iwi])<epsilonD0)) then
               begin
                  dkw:=0.0;
               end
               else
               begin
                  dkw:=2*uds2diffusivity[ipi]*uds2diffusivity[iwi]/((uds2diffusivity[ipi]+uds2diffusivity[iwi]));
               end;
               if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[ini])<epsilonD0)) then
               begin
                  dkn:=0.0;
               end
               else
               begin
                  dkn:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));
               end;
            end;
        3 : begin
               // теплопроводность на грани контрольного объёма
                if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iei])<epsilonD0)) then
               begin
                  dke:=0.0;
               end
               else
               begin
                  dke:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));
               end;
               if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iwi])<epsilonD0)) then
               begin
                  dkw:=0.0;
               end
               else
               begin
                  dkw:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));
               end;
                if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[ini])<epsilonD0)) then
               begin
                  dkn:=0.0;
               end
               else
               begin
                  dkn:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));
               end;
            end;
        4 : begin
               // теплопроводность на грани контрольного объёма
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iei])<epsilonD0)) then
               begin
                  dke:=0.0;
               end
               else
               begin
                  dke:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));
               end;
               if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iwi])<epsilonD0)) then
               begin
                  dkw:=0.0;
               end
               else
               begin
                  dkw:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));
               end;
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[ini])<epsilonD0)) then
               begin
                  dkn:=0.0;
               end
               else
               begin
                  dkn:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));
               end;
            end;
      end;

      dde:=dke*dy/dxe;  // диффузионная
      ddw:=dkw*dy/dxw;  // составляющая.
      ddn:=dkn*dx/dyn;
      if (fabs(ddn)<epsilonD0) then
      begin
         dpn:=1e30;
      end
      else
      begin
         dpn:=dfn/ddn;  // Значения
      end;
         if (fabs(dde)<epsilonD0) then
      begin
         dpe:=1e30;
      end
      else
      begin
         dpe:=dfe/dde;  //  чисел Пекле.
      end;
        if (fabs(ddw)<epsilonD0) then
      begin
         dpw:=1e30;
      end
      else
      begin
         dpw:=dfw/ddw;
      end;
      // коэффициенты дискретного аналога
      m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0);
      m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);
      m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0);
      m[ipi].das:=0.0;

      dap0:=0.0; // инициализация.

      if (btimedepend) then
      begin
         // нестационарный солвер

         case icurentuds of
           1 : begin
                  if (itypeuds1unsteadyfunction=1) then
                  begin
                     // нестационарный
                     if (iuds1typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds1typerho=1) then
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end
                   else if (itypeuds1unsteadyfunction=0) then
                  begin
                     // стационарный
                     dap0:=0.0;
                  end;
               end;
           2 : begin
                  if (itypeuds2unsteadyfunction=1) then
                  begin
                     // нестационарный
                     if (iuds2typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds2typerho=1) then
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end
                   else if (itypeuds2unsteadyfunction=0) then
                  begin
                     // стационарный
                     dap0:=0.0;
                  end;
               end;
           3 : begin
                  if (itypeuds3unsteadyfunction=1) then
                  begin
                     // нестационарный
                     if (iuds3typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds3typerho=1) then
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end
                   else if (itypeuds3unsteadyfunction=0) then
                  begin
                     // стационарный
                     dap0:=0.0;
                  end;
               end;
           4 : begin
                  if (itypeuds4unsteadyfunction=1) then
                  begin
                     // нестационарный
                     if (iuds4typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else if (iuds4typerho=1) then
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end
                   else if (itypeuds4unsteadyfunction=0) then
                  begin
                     // стационарный
                     dap0:=0.0;
                  end;
               end;
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      case icurentuds of
           1 : begin
                 db[ipi]:=qbbottom; // неизменная составляющая источникового члена
               end;
           2 : begin
                  db[ipi]:=qbbottom; // неизменная составляющая источникового члена
               end;
           3 : begin
                  db[ipi]:=qbbottom; // неизменная составляющая источникового члена
               end;
           4 : begin
                  db[ipi]:=qbbottom; // неизменная составляющая источникового члена
               end;
         end;

      {$IFDEF dSourceBoundary}
      // добавок к источниковому члену определён.

        case icurentuds of
           1 : begin
                 db[ipi]:=db[ipi] + dSc1[ipi]*dV; // неизменная составляющая источникового члена
               end;
           2 : begin
                  db[ipi]:=db[ipi] + dSc2[ipi]*dV; // неизменная составляющая источникового члена
               end;
           3 : begin
                  db[ipi]:=db[ipi] + dSc3[ipi]*dV; // неизменная составляющая источникового члена
               end;
           4 : begin
                  db[ipi]:=db[ipi] + dSc4[ipi]*dV; // неизменная составляющая источникового члена
               end;
         end;

      {$ENDIF}

      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         case icurentuds of
           1 : begin
                  if (itypeuds1unsteadyfunction=1) then
                  begin
                     db[ipi]:=db[ipi]+ dap0*uds1oldTimeStep[ipi];
                  end;
               end;
           2 : begin
                  if (itypeuds2unsteadyfunction=1) then
                  begin
                     db[ipi]:=db[ipi]+ dap0*uds2oldTimeStep[ipi];
                  end;
               end;
           3 : begin
                  if (itypeuds3unsteadyfunction=1) then
                  begin
                     db[ipi]:=db[ipi]+ dap0*uds3oldTimeStep[ipi];
                  end;
               end;
           4 : begin
                  if (itypeuds4unsteadyfunction=1) then
                  begin
                     db[ipi]:=db[ipi]+ dap0*uds4oldTimeStep[ipi];
                  end;
               end;
         end;
      end;
     // m[ipi].dap:= m[ipi].dan + m[ipi].dae + m[ipi].daw;
      m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+ ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0);
      case icurentuds of
           1 : begin
                  m[ipi].dap:=m[ipi].dap+ dap0;
               end;
           2 : begin
                  m[ipi].dap:=m[ipi].dap+ dap0;
               end;
           3 : begin
                  m[ipi].dap:=m[ipi].dap+ dap0;
               end;
           4 : begin
                  m[ipi].dap:=m[ipi].dap+ dap0;
               end;
      end;

       {$IFDEF dSourceBoundary}
      // добавок к диагональному члену определён.

      case icurentuds of
           1 : begin
                  m[ipi].dap:=m[ipi].dap - dSp1[ipi]*dV;
               end;
           2 : begin
                  m[ipi].dap:=m[ipi].dap - dSp2[ipi]*dV;
               end;
           3 : begin
                  m[ipi].dap:=m[ipi].dap - dSp3[ipi]*dV;
               end;
           4 : begin
                  m[ipi].dap:=m[ipi].dap - dSp4[ipi]*dV;
               end;
      end;

      {$ENDIF}


   end; // with

end; // UDSBoundaryCoefConvBottom

// Граничное условие II рода на нижней стенке
// для уравнения переноса непрерывного маркера с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.VofBoundaryCoefConvBottom(var m : array of MatrixCoef;
                                       var db : array of Float; // правая часть
                       qbbottom : Float; // заданный поток функции цвета на границе
                                           place : TmyNode; artificaldiffusion : Float); // место на карте
var
    iei,iwi,ini,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi : Integer;// номера узлов для граней контрольного объёма
    dke, dkw,dkn : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn : Float; // числа Пекле
    dfe, dfw, dfn : Float;
    dde, ddw, ddn : Float;
    dap0 : Float;  // нестационарный коэффициент
    dScVof, dSpVof : Float;

begin
   dScVof:=0.0;
   dSpVof:=0.0;
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      ini:=i+j*inx;  // север
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      incvi:=i+(j-1)*inx;
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      dfe:=Vx[iecvi]*dy; // интенсивность
      dfw:=Vx[iwcvi]*dy; // конвекции
      dfn:=Vy[incvi]*dx; // или течения
      // теплопроводность на грани контрольного объёма
      dke:=artificaldiffusion;
      dkw:=artificaldiffusion;
      dkn:=artificaldiffusion;
      dde:=dke*dy/dxe;  // диффузионная
      ddw:=dkw*dy/dxw;  // составляющая.
      ddn:=dkn*dx/dyn;
      if (artificaldiffusion<1.0e-20) then
      begin
         //dpn:=1.0e20;  // Значения
         //dpe:=1.0e20;  //  чисел Пекле.
         //dpw:=1.0e20;

         // коэффициенты дискретного аналога
         m[ipi].dae:=maxoper(-dfe,0);
         m[ipi].daw:=maxoper(dfw,0);
         m[ipi].dan:=maxoper(-dfn,0);
      end
       else
      begin
         dpn:=dfn/ddn;  // Значения
         dpe:=dfe/dde;  //  чисел Пекле.
         dpw:=dfw/ddw;

         // коэффициенты дискретного аналога
         m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconvvof) + maxoper(-dfe,0);
         m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconvvof) + maxoper(dfw,0);
         m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconvvof) + maxoper(-dfn,0);
      end;

      m[ipi].das:=0.0;
      if (btimedepend) then
      begin
         // нестационарный солвер
         if (bVOFsecondorder) then
         begin
            // формула Пейре второго порядка.
            dap0:=1.5*dV/dTimeStep; // неявная часть.
         end
          else
         begin
            // формула Эйлера первого порядка.
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dScVof*dV + qbbottom; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
          if (bVOFsecondorder) then
          begin
             // формула Пейре второго порядка на постоянном шаге по времени.
             db[ipi]:=db[ipi]+dV*(2.0*VOFOldTimeStep[ipi]-0.5*VOFOldOldTimeStep[ipi])/dTimeStep;
          end
           else
          begin
             // Формула Эйлера.
             db[ipi]:=db[ipi]+ dap0*VOFOldTimeStep[ipi];
          end;
      end;

       if (artificaldiffusion<1.0e-20) then
      begin
         m[ipi].dap:=maxoper(dfe,0)+maxoper(-dfw,0)+maxoper(dfn,0);
      end
       else
      begin
         m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconvvof) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconvvof) + maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconvvof) + maxoper(dfn,0);
      end;


      m[ipi].dap:=m[ipi].dap + dap0 - dSpVof*dV;
   end; // with

end; // VofBoundaryCoefConvBottom


// Граничное условие II рода на верхней стенке
// для уравнения теплопроводности с учётом конвективного члена.
                                     // коэффициенты дискретного аналога
procedure TForm1.TempBoundaryCoefConvTop(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                          qbtop : Float; // заданный тепловой поток на границе
                                         place : TmyNode); // место на карте
var
    //iei,iwi,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpw, dps : Float; // числа Пекле
    dfe, dfw, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, dds : Float; // диффузионный вклад
    dap0 : Float;  // нестационарный коэффициент

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      isi:=i+(j-2)*inx; // юг
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      iscvi:=i+(j-2)*inx;
      //dfe:=densuty_in_surface(ipi,iei)*dcp*Vx[iecvi]*dy; // интенсивность
      //dfw:=densuty_in_surface(ipi,iwi)*dcp*Vx[iwcvi]*dy; // конвекции
      //dfs:=densuty_in_surface(ipi,isi)*dcp*Vy[iscvi]*dx; // или течения
      dfe:=Vx[iecvi]*dy; // интенсивность
      dfw:=Vx[iwcvi]*dy; // конвекции
      dfs:=Vy[iscvi]*dx; // или течения
      // теплопроводность на грани контрольного объёма
      dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
      dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
      dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
      dde:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp);  // диффузионный
      ddw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp);  // вклад
      dds:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
      dpe:=dfe/dde; // Значения
      dpw:=dfw/ddw; // чисел
      dps:=dfs/dds; // Пекле
      // коэффициенты дискретного аналога
     // m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconvtemp) + maxoper(-dfe,0);
      //m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconvtemp) + maxoper(dfw,0);
      m[ipi].dae:=0.0;
      m[ipi].daw:=0.0;
      
      m[ipi].dan:=0.0;
      if ((ishconvtemp>=0)and(ishconvtemp<=7)) then
      begin
         m[ipi].das:=dds*ApproxConvective(abs(dps),ishconvtemp) + maxoper(dfs,0);
      end
       else
      begin
         m[ipi].das:=dds + maxoper(dfs,0);
      end;
      if (btimedepend) then
      begin
         // нестационарный солвер
          if (bsecondordertemp) then
         begin
            // Схема Пейре.
            dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
         end
          else
         begin
            //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=(dSc[ipi]*dV + dx*qbtop)/(densuty_in_surface(ipi,iwi)*dcp); // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         if (bsecondordertemp) then
         begin
            // Схема Пейре второго порядка по времени !!!
            db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
         end
           else
         begin
            db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
         end;
      end;
      m[ipi].dap:=m[ipi].das+m[ipi].dae+m[ipi].daw+dap0-dSp*dV/(densuty_in_surface(ipi,iwi)*dcp);
      //m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconvtemp) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconvtemp) + maxoper(-dfw,0)+dds*ApproxConvective(abs(dps),ishconvtemp) + maxoper(-dfs,0) +dap0-dSp*dV;

   end; // with
end; // TempBoundaryCoefConvTop

// Граничное условие II рода на верхней стенке
// для уравнения User-Defined Scalar`a с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.UDSBoundaryCoefConvTop(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                          qbtop : Float; // заданный тепловой поток на границе
                                      place : TmyNode); // место на карте

const
   epsilonD0=1e-30;
   
var
    //iei,iwi,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpw, dps : Float; // числа Пекле
    dfe, dfw, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, dds : Float; // диффузионный вклад
    dap0 : Float;  // нестационарный коэффициент

// модуль вещественного числа.    
function fabs(myf : Float) : Float;
begin
   if (myf<0.0) then
   begin
      fabs:=-myf;
   end
   else
   begin
      fabs:=myf;
   end;
end;

begin
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      isi:=i+(j-2)*inx; // юг
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      iscvi:=i+(j-2)*inx;

      // инициализация
      dfe:=0.0;
      dfw:=0.0;
      dfs:=0.0;

      case icurentuds of
        1 : begin
               if (iuds1typerho=0) then
               begin
                  // единичная плотность.
                  dfe:=Vxuds[iecvi]*dy; // интенсивность
                  dfw:=Vxuds[iwcvi]*dy; // конвекции
                  dfs:=Vyuds[iscvi]*dx; // или течения
               end
                else if (iuds1typerho=1) then
               begin
                  // гидродинамическая плотность.
                  dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                  dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                  dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // или течения
               end;
            end;
        2 : begin
               if (iuds2typerho=0) then
               begin
                  // единичная плотность.
                  dfe:=Vxuds[iecvi]*dy; // интенсивность
                  dfw:=Vxuds[iwcvi]*dy; // конвекции
                  dfs:=Vyuds[iscvi]*dx; // или течения
               end
                else if (iuds2typerho=1) then
               begin
                  // гидродинамическая плотность.
                  dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                  dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                  dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // или течения
               end;
            end;
        3 : begin
               if (iuds3typerho=0) then
               begin
                  // единичная плотность.
                  dfe:=Vxuds[iecvi]*dy; // интенсивность
                  dfw:=Vxuds[iwcvi]*dy; // конвекции
                  dfs:=Vyuds[iscvi]*dx; // или течения
               end
                else if (iuds3typerho=1) then
               begin
                  // гидродинамическая плотность.
                  dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                  dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                  dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // или течения
               end;
            end;
        4 : begin
               if (iuds4typerho=0) then
               begin
                  // единичная плотность.
                  dfe:=Vxuds[iecvi]*dy; // интенсивность
                  dfw:=Vxuds[iwcvi]*dy; // конвекции
                  dfs:=Vyuds[iscvi]*dx; // или течения
               end
                else if (iuds4typerho=1) then
               begin
                  // гидродинамическая плотность.
                  dfe:=densuty_in_surface(ipi,iei)*Vxuds[iecvi]*dy; // интенсивность
                  dfw:=densuty_in_surface(ipi,iwi)*Vxuds[iwcvi]*dy; // конвекции
                  dfs:=densuty_in_surface(ipi,isi)*Vyuds[iscvi]*dx; // или течения
               end;
            end;
      end;

      // инициализация
      dke:=1.0;
      dkw:=1.0;
      dks:=1.0;

      case icurentuds of
        1 : begin
               // теплопроводность на грани контрольного объёма
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));
               end;
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));
               end;
                if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));
                end;
            end;
        2 : begin
               // теплопроводность на грани контрольного объёма
                if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));
                end;
               if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds2diffusivity[ipi]*uds2diffusivity[iwi]/((uds2diffusivity[ipi]+uds2diffusivity[iwi]));
                end;
                if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));
                end;
            end;
        3 : begin
               // теплопроводность на грани контрольного объёма
               if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));
                end;
                if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));
                end;
                if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));
                end;
            end;
        4 : begin
               // теплопроводность на грани контрольного объёма
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iei])<epsilonD0)) then
                begin
                   dke:=0.0;
                end
                 else
                begin
                   dke:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));
                end;
                 if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iwi])<epsilonD0)) then
                begin
                   dkw:=0.0;
                end
                 else
                begin
                   dkw:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));
               end;
                if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[isi])<epsilonD0)) then
                begin
                   dks:=0.0;
                end
                 else
                begin
                   dks:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));
               end;
            end;
      end;

      dde:=dke*dy/dxe;  // диффузионный
      ddw:=dkw*dy/dxw;  // вклад
      dds:=dks*dx/dys;
      if (fabs(dde)<epsilonD0) then
      begin
         dpe:=1e30;
      end
      else
      begin
         dpe:=dfe/dde; // Значения
      end;
      if (fabs(ddw)<epsilonD0) then
      begin
         dpw:=1e30;
      end
      else
      begin
         dpw:=dfw/ddw; // чисел
      end;
      if (fabs(dds)<epsilonD0) then
      begin
         dps:=1e30;
      end
      else
      begin
         dps:=dfs/dds; // Пекле
      end;
      // коэффициенты дискретного аналога
      m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0);
      m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);
      m[ipi].dan:=0.0;
      m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

      dap0:=0.0; // инициализация.

      if (btimedepend) then
      begin
         // нестационарный солвер

         case icurentuds of
           1 : begin
                  if (itypeuds1unsteadyfunction=0) then
                  begin
                     dap0:=0.0;
                  end
                  else if (itypeuds1unsteadyfunction=1) then
                  begin
                     if (iuds1typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
           2 : begin
                  if (itypeuds2unsteadyfunction=0) then
                  begin
                     dap0:=0.0;
                  end
                  else if (itypeuds2unsteadyfunction=1) then
                  begin
                     if (iuds2typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
           3 : begin
                  if (itypeuds3unsteadyfunction=0) then
                  begin
                     dap0:=0.0;
                  end
                  else if (itypeuds3unsteadyfunction=1) then
                  begin
                     if (iuds3typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
           4 : begin
                  if (itypeuds4unsteadyfunction=0) then
                  begin
                     dap0:=0.0;
                  end
                  else if (itypeuds4unsteadyfunction=1) then
                  begin
                     if (iuds4typerho=0) then
                     begin
                        dap0:=dV/dTimeStep; // нестаионарный вклад
                     end
                     else
                     begin
                        dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                     end;
                  end;
               end;
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;

      case icurentuds of
        1 : begin
               db[ipi]:=qbtop; // неизменная составляющая источникового члена
            end;
        2 : begin
               db[ipi]:=qbtop; // неизменная составляющая источникового члена
            end;
        3 : begin
               db[ipi]:=qbtop; // неизменная составляющая источникового члена
            end;
        4 : begin
               db[ipi]:=qbtop; // неизменная составляющая источникового члена
            end;
      end;

      {$IFDEF dSourceBoundary}
      // добавок к источниковому члену определён.

        case icurentuds of
           1 : begin
                 db[ipi]:=db[ipi] + dSc1[ipi]*dV; // неизменная составляющая источникового члена
               end;
           2 : begin
                  db[ipi]:=db[ipi] + dSc2[ipi]*dV; // неизменная составляющая источникового члена
               end;
           3 : begin
                  db[ipi]:=db[ipi] + dSc3[ipi]*dV; // неизменная составляющая источникового члена
               end;
           4 : begin
                  db[ipi]:=db[ipi] + dSc4[ipi]*dV; // неизменная составляющая источникового члена
               end;
         end;

      {$ENDIF}


      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену

         case icurentuds of
           1 : begin
                  db[ipi]:=db[ipi]+ dap0*uds1oldTimeStep[ipi];
               end;
           2 : begin
                  db[ipi]:=db[ipi]+ dap0*uds2oldTimeStep[ipi];
               end;
           3 : begin
                  db[ipi]:=db[ipi]+ dap0*uds3oldTimeStep[ipi];
               end;
           4 : begin
                  db[ipi]:=db[ipi]+ dap0*uds4oldTimeStep[ipi];
               end;
         end;
      end;
     // m[ipi].dap:=m[ipi].das+m[ipi].dae+m[ipi].daw;
      m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0);

      case icurentuds of
        1 : begin
               m[ipi].dap:=m[ipi].dap+dap0;
            end;
        2 : begin
               m[ipi].dap:=m[ipi].dap+dap0;
            end;
        3 : begin
               m[ipi].dap:=m[ipi].dap+dap0;
            end;
        4 : begin
               m[ipi].dap:=m[ipi].dap+dap0;
            end;
      end;

      {$IFDEF dSourceBoundary}
      // добавок к диагональному члену определён.

      case icurentuds of
           1 : begin
                  m[ipi].dap:=m[ipi].dap - dSp1[ipi]*dV;
               end;
           2 : begin
                  m[ipi].dap:=m[ipi].dap - dSp2[ipi]*dV;
               end;
           3 : begin
                  m[ipi].dap:=m[ipi].dap - dSp3[ipi]*dV;
               end;
           4 : begin
                  m[ipi].dap:=m[ipi].dap - dSp4[ipi]*dV;
               end;
      end;

      {$ENDIF}

   end; // with
end; // UDSBoundaryCoefConvTop


// Граничное условие II рода на верхней стенке
// для уравнения переноса непрерывного маркера с учётом конвективного члена.
// коэффициенты дискретного аналога
procedure TForm1.VofBoundaryCoefConvTop(var m : array of MatrixCoef;
                                      var db : array of Float; // правая часть
                          qbtop : Float; // заданный тепловой поток на границе
                                         place : TmyNode; artificaldiffusion : Float); // место на карте
var
    iei,iwi,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe, dpw, dps : Float; // числа Пекле
    dfe, dfw, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, dds : Float; // диффузионный вклад
    dap0 : Float;  // нестационарный коэффициент
    dScVof, dSpVof : Float; // источниковый член.

begin
   dScVof:=0.0;
   dSpVof:=0.0;
   with place do
   begin
      ipi:=i+(j-1)*inx; // текущая точка на границе
      isi:=i+(j-2)*inx; // юг
      iwi:=(i-1)+(j-1)*inx; // запад
      iei:=(i+1)+(j-1)*inx; // восток
      iecvi:=i+(j-1)*(inx-1); // в массиве Vx
      iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
      iscvi:=i+(j-2)*inx;
      dfe:=Vx[iecvi]*dy; // интенсивность
      dfw:=Vx[iwcvi]*dy; // конвекции
      dfs:=Vy[iscvi]*dx; // или течения
      // теплопроводность на грани контрольного объёма
      dke:=artificaldiffusion;
      dkw:=artificaldiffusion;
      dks:=artificaldiffusion;
      dde:=dke*dy/dxe;  // диффузионный
      ddw:=dkw*dy/dxw;  // вклад
      dds:=dks*dx/dys;
      if (artificaldiffusion<1.0e-20) then
      begin
         //dpe:=1.0e20; // Значения
         //dpw:=1.0e20; // чисел
         //dps:=1.0e20; // Пекле
         // коэффициенты дискретного аналога
         m[ipi].dae:=maxoper(-dfe,0);
         m[ipi].daw:=maxoper(dfw,0);
         m[ipi].das:=maxoper(dfs,0);
      end
       else
      begin
         dpe:=dfe/dde; // Значения
         dpw:=dfw/ddw; // чисел
         dps:=dfs/dds; // Пекле
         // коэффициенты дискретного аналога
         m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0);
         m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);
         m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
      end;

      m[ipi].dan:=0.0;

      if (btimedepend) then
      begin
         // нестационарный солвер
         if (bVOFsecondorder) then
         begin
            // формула Пейре второго порядка.
            dap0:=1.5*dV/dTimeStep; // неявная часть.
         end
          else
         begin
            // формула Эйлера первого порядка.
            dap0:=dV/dTimeStep; // нестаионарный вклад
         end;
      end
       else
      begin
         // стационарный солвер
         dap0:=0.0; // стационарный вклад
      end;
      db[ipi]:=dScVof*dV + qbtop; // неизменная составляющая источникового члена
      if (btimedepend) then
      begin
         // нестационарный добавок к источниковому члену
         if (bVOFsecondorder) then
         begin
            // формула Пейре второго порядка на постоянном шаге по времени.
            db[ipi]:=db[ipi]+dV*(2.0*VOFOldTimeStep[ipi]-0.5*VOFOldOldTimeStep[ipi])/dTimeStep;
         end
          else
         begin
            // Формула Эйлера.
            db[ipi]:=db[ipi]+ dap0*VOFOldTimeStep[ipi];
         end;
      end;

      if (artificaldiffusion<1.0e-20) then
      begin
         m[ipi].dap:=maxoper(dfe,0)+maxoper(-dfw,0)+maxoper(-dfs,0);
      end
      else
      begin
         m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0)+ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0);
      end;

      m[ipi].dap:=m[ipi].dap+dap0-dSpVof*dV;
   end; // with
end; // VofBoundaryCoefConvTop

// вычисляет коэффициенты дискретного аналога для
// уравнения теплопроводности с учётом конвективного члена
//  Операция составления дискретного аналога выполнена универсальным
// образом. Т.е. она подходит и для процессов не зависящих от времени, а также
// для нестационарных процессов.
// Внимание: перед использованием этой процедуры массиву
// ToldTimeStep должна быть выделена оперативная память и
//  он должен быть проинициализирован соответствующим образом.
procedure TForm1.TempConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                              var db : array of Float); // правая часть
var
    iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    ieei,inni,issi,iwwi : Integer;
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw,dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dfe, dfw, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    k : Integer; // счётчик для вычисления коэффициентов дискретного аналога
    bneiman : Boolean; // если граничное условие Неймана
    qb : Float; // значение теплового потока на границе расчётной области,
    //den : Float;
    // den - значение плотности на грани контрольного объёма
    f_forvardx, f_backvardx, f_forvardy, f_backvardy, attrs : Float; // High Resolution добавка в правую часть.
    DirichVal, mf : Float;

// Возвращает модуль вещественного числа x97.
function fabs(x97 : Float) : Float;
var
   r : Float;
begin
   if (x97<0.0) then
   begin
      r:=-x97;
   end
   else
   begin
      r:=x97;
   end;
   Result:=r;
end;

begin

   // проход по всем внутренним точкам
   // для определения коэффициентов
   // дискретного аналога  m и db

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // Для High Resolution Схемы
            inni:=i+(j+1)*inx; // север
            issi:=i+(j-3)*inx; // юг
            iwwi:=(i-2)+(j-1)*inx; // запад
            ieei:=(i+2)+(j-1)*inx; // восток
            // для шахматной сетки (для компонент скорости)
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            //den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
            //dfe:=den*dcp*Vx[iecvi]*dy; // интенсивность
            dfe:=Vx[iecvi]*dy; // интенсивность
            //den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
            //dfw:=den*dcp*Vx[iwcvi]*dy; // конвекции
            dfw:=Vx[iwcvi]*dy; // конвекции
            //den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
            //dfn:=den*dcp*Vy[incvi]*dx; // или
            dfn:=Vy[incvi]*dx; // или
            //den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
            //dfs:=den*dcp*Vy[iscvi]*dx; // течения
            dfs:=Vy[iscvi]*dx; // течения
            // теплопроводность на грани контрольного объёма
            dke:=2*lambda[ipi]*lambda[iei]/((lambda[ipi]+lambda[iei]));
            dkw:=2*lambda[ipi]*lambda[iwi]/((lambda[ipi]+lambda[iwi]));
            dkn:=2*lambda[ipi]*lambda[ini]/((lambda[ipi]+lambda[ini]));
            dks:=2*lambda[ipi]*lambda[isi]/((lambda[ipi]+lambda[isi]));
            dde:=dke*dy/(dxe*densuty_in_surface(ipi,iei)*dcp);  // коэффициенты
            ddw:=dkw*dy/(dxw*densuty_in_surface(ipi,iwi)*dcp);  // дискретного
            ddn:=dkn*dx/(dyn*densuty_in_surface(ipi,ini)*dcp);  // аналога
            dds:=dks*dx/(dys*densuty_in_surface(ipi,isi)*dcp);
            dpe:=dfe/dde; // значения
            dpw:=dfw/ddw; // чисел
            dpn:=dfn/ddn; // Пекле
            dps:=dfs/dds;
            // коэффициенты дискретного аналога
            // Центральные разности здесь содержаться как частный вариант.
            if ((ishconvtemp>=1)and(ishconvtemp<=7)) then
            begin
               m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconvtemp)+maxoper(-dfe,0);
               m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconvtemp)+maxoper(dfw,0);
               m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconvtemp)+maxoper(-dfn,0);
               m[ipi].das:=dds*ApproxConvective(abs(dps),ishconvtemp)+maxoper(dfs,0);
            end
            else
            begin
               // High Resolution схема неявная противопоточная часть.
               m[ipi].dae:=dde+maxoper(-dfe,0);
               m[ipi].daw:=ddw+maxoper(dfw,0);
               m[ipi].dan:=ddn+maxoper(-dfn,0);
               m[ipi].das:=dds+maxoper(dfs,0);
            end;


            attrs:=0.0;
            if (brealistictemperature and ((ishconvtemp>=1)and(ishconvtemp<=7))) then
            begin
                 // Неявно учитывается противопоточная часть а для неё
                 // ApproxConvective(abs(dpe),ishconvtemp)=1.0
                 m[ipi].dae:=dde+maxoper(-dfe,0);
                 m[ipi].daw:=ddw+maxoper(dfw,0);
                 m[ipi].dan:=ddn+maxoper(-dfn,0);
                 m[ipi].das:=dds+maxoper(dfs,0);

                 // Центрально-разностная схема второго порядка точности с помощью
                 // метода отложенной коррекции (неявно учитывается противопоточная часть).
                 f_forvardx:=0.5*(T[ipi]+T[iei]);
                 attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-T[ipi])+maxoper(-dfe,0.0)*(f_forvardx-T[iei]);
                 f_backvardx:=0.5*(T[ipi]+T[iwi]);
                 attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-T[ipi])+maxoper(dfw,0.0)*(f_backvardx-T[iwi]);
                 f_forvardy:=0.5*(T[ipi]+T[ini]);
                 attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-T[ipi])+maxoper(-dfn,0.0)*(f_forvardy-T[ini]);
                 f_backvardy:=0.5*(T[ipi]+T[isi]);
                 attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-T[ipi])+maxoper(dfs,0.0)*(f_backvardy-T[isi]);
            end;

            if ((ishconvtemp>=1000) and (ishconvtemp<=1015)) then
            begin
               attrs:=0.0;
               if (is_internal_HO(iwi,ipi,iei,ieei)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_forvardx:=cell_face_value_global(ishconvtemp,Vx[iecvi],T[iwi],T[ipi],T[iei],T[ieei]);
                  attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-T[ipi])+maxoper(-dfe,0.0)*(f_forvardx-T[iei]);
               end;
               if (is_internal_HO(iwwi,iwi,ipi,iei)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_forvardx:=cell_face_value_global(ishconvtemp,Vx[iwcvi],T[iwwi],T[iwi],T[ipi],T[iei]);
                  attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-T[ipi])+maxoper(dfw,0.0)*(f_backvardx-T[iwi]);
               end;
               if (is_internal_HO(isi,ipi,ini,inni)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_forvardy:=cell_face_value_global(ishconvtemp,Vy[incvi],T[isi],T[ipi],T[ini],T[inni]);
                  attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-T[ipi])+maxoper(-dfn,0.0)*(f_forvardy-T[ini]);
               end;
               if (is_internal_HO(issi,isi,ipi,ini)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_forvardy:=cell_face_value_global(ishconvtemp,Vy[iscvi],T[issi],T[isi],T[ipi],T[ini]);
                   attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-T[ipi])+maxoper(dfs,0.0)*(f_backvardy-T[isi]);
               end;
            end;



            if (btimedepend) then
            begin
               // нестационарный солвер
               if (bsecondordertemp) then
               begin
                  // Схема Пейре.
                  dap0:=1.5*dV/dTimeStep; // нестаионарный вклад
               end
                else
               begin
                  //dap0:=density(ipi)*dcp*dV/dTimeStep; // нестаионарный вклад
                  dap0:=dV/dTimeStep; // нестаионарный вклад
               end;
            end
             else
            begin
               // стационарный солвер
               dap0:=0.0; // стационарный вклад
            end;
            db[ipi]:=dSc[ipi]*dV+attrs;// неизменная составляющая источникового члена
            if (btimedepend) then
            begin
               if (bsecondordertemp) then
               begin
                  // Схема Пейре второго порядка по времени !!!
                  db[ipi]:=db[ipi]+dV*(2.0*TOldTimeStep[ipi]-0.5*TOldOldTimeStep[ipi])/dTimeStep;
               end
                else
               begin
                  // нестационарный добавок к источниковому члену
                  db[ipi]:=db[ipi]+ dap0*ToldTimeStep[ipi];
               end;
            end;
            //m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;

            if (brealistictemperature and ((ishconvtemp>=1)and(ishconvtemp<=7))) then
            begin
               // Неявно учитывается лишь UDS схема.
               m[ipi].dap:=dde+maxoper(dfe,0)+ddw+maxoper(-dfw,0)+ddn+maxoper(dfn,0)+dds+maxoper(-dfs,0);
            end
            else
            begin
               if (ApproxConvectionForm.CheckBoxKIvanovApprox.Checked=true) then
               begin
                  // Аппроксимация К.А. Иванова
                  m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconvtemp)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconvtemp)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconvtemp)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconvtemp)+maxoper(-dfs,0);
               end
               else
               begin
                  //Обычная аппроксимация.
                  m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;
               end;
            end;

            (*
            // 18 ноября 2014года
            // Если сделать bISezai для температуры то в следе
            // за обтекаемым квадратом мы будем наблюдать температуры меньшие чем на входе
            // в расчётную область, а это по видимому не соответствует физическому смыслу.
            // Поэтому данный фрагмент кода должен быть всегда закоментирован.
            if ((bISezai) and (not(btimedepend))) then
            begin
               if (ApproxConvectionForm.CheckBoxISezainofabs.Checked) then
               begin
                  // возможное ослабление диагонали.
                  mf:=(dfe-dfw+dfn-dfs);
               end
                else
               begin
                  // только усиление диагонали.
                  mf:=fabs(dfe-dfw+dfn-dfs);
               end;
               m[ipi].dap:=m[ipi].dap+mf;
            end;
            *)

            m[ipi].dap:=m[ipi].dap + dap0-dSp*dV;

            // нижняя релаксация для температуры.
            m[ipi].dap:=m[ipi].dap/myrelaxfactors.pSORTempreture;
            db[ipi]:=db[ipi]+(1.0-myrelaxfactors.pSORTempreture)*m[ipi].dap*T[ipi];

         end;

         if (itype = 2 ) then
         begin
            // граничный узел
            // возможны условия Неймана
            // словесно порядок действий следующий:
            // каждая граничная точка принадлежит
            // какойлибо определенной границе с уникальным номером
            // по этому уникальному номеру (идентификатору) граница
            //  должна быть найдена и для неё должно быть проверено
            //  поставлено ли на ней условие Неймана.

            // на границе поставлено условие Неймана
            if (iugol=0) then
            begin
               // iboundary - уникальный номер границы
               bneiman:=GridGenForm.isneimanqb(iboundary, 'T', qb);
               // охватывает условие симметрии и условиезаданного теплового потока.
               if (bneiman) then
               begin
                  // точка не является угловой
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             //TempBoundaryCoefConvBottom(m, db, qb, mapPT[k]);
                             TempBoundaryCoefBottom(m, db, qb, mapPT[k]);
                          end;
                    'S' : begin
                             // На верхней границе.
                             //TempBoundaryCoefConvTop(m, db, qb, mapPT[k]);
                             TempBoundaryCoefTop(m, db, qb, mapPT[k]);
                          end;
                    'W' : begin
                             // Правая стенка
                             //TempBoundaryCoefConvRight(m, db, qb, mapPT[k]);
                             TempBoundaryCoefRight(m, db, qb, mapPT[k]);
                          end;
                    'E' : begin
                             // Левая стенка
                             //TempBoundaryCoefConvLeft(m, db, qb, mapPT[k]);
                             TempBoundaryCoefLeft(m, db, qb, mapPT[k]);
                          end;
                  end; // case
               end // Нейман
               else if (GridGenForm.isoutflow(iboundary, 'T', chnormal)) then
               begin
                  // Особое условие на выходной границе.
                  ipi:=i+(j-1)*inx; // текущая точка
                  //ini:=i+j*inx;  // север
                  //isi:=i+(j-2)*inx; // юг
                  //iwi:=(i-1)+(j-1)*inx; // запад
                  //iei:=(i+1)+(j-1)*inx; // восток
                  case chnormal of
                      'N' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=2.0;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=0.0;
                               db[ipi]:=-T[i+(j+1)*inx];
                            end;
                      'S' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=2.0;
                               db[ipi]:=-T[i+(j-3)*inx];
                            end;
                      'W' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=2.0;
                               m[ipi].das:=0.0;
                               db[ipi]:=-T[i-2+(j-1)*inx];
                            end;
                      'E' : begin
                               m[ipi].dap:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dae:=2.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=0.0;
                               db[ipi]:=-T[i+2+(j-1)*inx];
                            end;
                  end;
               end;
            end // точка лежащая внутри границы расчётной области
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               ini:=i+j*inx;  // север
               isi:=i+(j-2)*inx; // юг
               iwi:=(i-1)+(j-1)*inx; // запад
               iei:=(i+1)+(j-1)*inx; // восток
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
               // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    2 : // правый нижний угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    3 : // верхний левый угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    4 : // верхний правый угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    5 : // пятиточечная звезда
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;

                          if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'T', DirichVal)) then
                        begin
                           T[iei]:=DirichVal;
                           T[ipi]:=T[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'T', DirichVal)) then
                        begin
                           T[ini]:=DirichVal;
                           T[ipi]:=T[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'T', DirichVal)) then
                        begin
                           T[iwi]:=DirichVal;
                           T[ipi]:=T[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'T', DirichVal)) then
                        begin
                           T[isi]:=DirichVal;
                           T[ipi]:=T[isi];
                        end
                         else
                        begin

                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;
                        end;
                     end;
                  end; // case
               end; // угловая точка
         end; // граничная точка
      end; // with
   end;

end; // TempConvCoef

// вычисляет коэффициенты дискретного аналога для
// User-Defined Scalar с учётом конвективного члена
//  Операция составления дискретного аналога выполнена универсальным
// образом. Т.е. она подходит и для процессов не зависящих от времени, а также
// для нестационарных процессов.
// Внимание: перед использованием этой процедуры массиву
// UDS<number>oldTimeStep должна быть выделена оперативная память и
//  он должен быть проинициализирован соответствующим образом,
// здесь number - номер соответствующей UDS.
procedure TForm1.UDSCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                              var db : array of Float); // правая часть

const
   epsilonD0 = 1e-36;
var
    //iei,iwi,ini,isi,ipi,
    ivelindex : Integer; // номера узлов на пятиточечном шаблоне
    ieei, iwwi, inni, issi : Integer; // High Resolution Scheme !!!
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw,dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dfe, dfw, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    k : Integer; // счётчик для вычисления коэфффициентов дискретного аналога
    bneiman, bzerocurent, bzerodiff,  bfirstpointmetall : Boolean; // если граничное условие Неймана
    qb, den, myG : Float; // значение теплового потока на границе расчётной области,
    // den - значение плотности на грани контрольного объёма
    f_forvardx, f_backvardx, f_forvardy, f_backvardy, attrs : Float;
    Dart : Float; // искуственная диффузия в условиях ток равен нулю.
    iart1, iart2 : Integer; // вспомогательные индексы для касательной скорости.
    DirichVal : Float;

// модуль вещественного числа.
function fabs(myf : Float) : Float;
begin
   if (myf<0.0) then
   begin
      fabs:=-myf;
   end
   else
   begin
      fabs:=myf;
   end;
end;

begin

   // проход по всем внутренним точкам
   // для определения коэффициентов
   // дискретного аналога  m и db
   bfirstpointmetall:=True;

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin

            // debug
            //Application.MessageBox(PChar('dV='+FloatToStr(dV)+'dx='+FloatToStr(dx)+'dy='+FloatToStr(dy)),'debug',MB_OK);

            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            // for High Resolution Scheme
            inni:=i+(j+1)*inx;  // север
            issi:=i+(j-3)*inx; // юг
            iwwi:=(i-2)+(j-1)*inx; // запад
            ieei:=(i+2)+(j-1)*inx; // восток
            // Центральный узел !!!
            ipi:=i+(j-1)*inx; // текущая точка
            // для шахматной сетки (для компонент скорости)
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше

            den:=1.0;

             case icurentuds of
               1 : begin
                     if (iuds1typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds1typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
                     end;
                  end;
               2 : begin
                     if (iuds2typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds2typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
                     end;
                  end;
               3 : begin
                     if (iuds3typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds3typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
                     end;
                  end;
               4 : begin
                     if (iuds4typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds4typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
                     end;
                  end;
              end;
            dfe:=den*Vxuds[iecvi]*dy; // интенсивность

             case icurentuds of
               1 : begin
                     if (iuds1typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds1typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
                     end;
                  end;
               2 : begin
                     if (iuds2typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds2typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
                     end;
                  end;
               3 : begin
                     if (iuds3typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds3typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
                     end;
                  end;
               4 : begin
                     if (iuds4typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds4typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
                     end;
                  end;
              end;
            dfw:=den*Vxuds[iwcvi]*dy; // конвекции

             case icurentuds of
               1 : begin
                     if (iuds1typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds1typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
                     end;
                  end;
               2 : begin
                     if (iuds2typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds2typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
                     end;
                  end;
               3 : begin
                     if (iuds3typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds3typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
                     end;
                  end;
                4 : begin
                     if (iuds4typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds4typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
                     end;
                  end;
              end;
            dfn:=den*Vyuds[incvi]*dx; // или

             case icurentuds of
               1 : begin
                     if (iuds1typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds1typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
                     end;
                  end;
               2 : begin
                     if (iuds2typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds2typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
                     end;
                  end;
               3 : begin
                     if (iuds3typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds3typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
                     end;
                  end;
               4 : begin
                     if (iuds4typerho=0) then
                     begin
                        // единичная плотность
                        den:=1.0;
                     end
                     else if (iuds4typerho=1) then
                     begin
                        // гидродинамическая плотность.
                        den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
                     end;
                  end;
              end;
            dfs:=den*Vyuds[iscvi]*dx; // течения

            // инициализация.
            dke:=1.0;
            dkw:=1.0;
            dkn:=1.0;
            dks:=1.0;

            case icurentuds of
               1 : begin
                      // теплопроводность на грани контрольного объёма
                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iei])<epsilonD0)) then
                      begin
                         dke:=0.0;
                      end
                      else
                      begin
                         dke:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));
                      end;
                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[iwi])<epsilonD0)) then
                      begin
                         dkw:=0.0;
                      end
                      else
                      begin
                         dkw:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));
                      end;
                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[ini])<epsilonD0)) then
                      begin
                         dkn:=0.0;
                      end
                      else
                      begin
                         dkn:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));
                      end;
                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) and (fabs(uds1diffusivity[isi])<epsilonD0)) then
                      begin
                         dks:=0.0;
                      end
                      else
                      begin
                         dks:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));
                      end;
                   end;
               2 : begin
                      // теплопроводность на грани контрольного объёма
                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iei])<epsilonD0)) then
                      begin
                         dke:=0.0;
                      end
                      else
                      begin
                         dke:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));
                      end;
                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[iwi])<epsilonD0)) then
                      begin
                         dkw:=0.0;
                      end
                      else
                      begin
                         dkw:=2*uds2diffusivity[ipi]*uds2diffusivity[iwi]/((uds2diffusivity[ipi]+uds2diffusivity[iwi]));
                      end;
                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[ini])<epsilonD0)) then
                      begin
                         dkn:=0.0;
                      end
                      else
                      begin
                         dkn:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));
                      end;
                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) and (fabs(uds2diffusivity[isi])<epsilonD0)) then
                      begin
                         dks:=0.0;
                      end
                      else
                      begin
                         dks:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));
                      end;
                   end;
               3 : begin
                      // теплопроводность на грани контрольного объёма
                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iei])<epsilonD0)) then
                      begin
                         dke:=0.0;
                      end
                      else
                      begin
                         dke:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));
                      end;
                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[iwi])<epsilonD0)) then
                      begin
                         dkw:=0.0;
                      end
                      else
                      begin
                         dkw:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));
                      end;
                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[ini])<epsilonD0)) then
                      begin
                         dkn:=0.0;
                      end
                      else
                      begin
                         dkn:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));
                      end;
                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) and (fabs(uds3diffusivity[isi])<epsilonD0)) then
                      begin
                         dks:=0.0;
                      end
                      else
                      begin
                         dks:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));
                      end;
                   end;
               4 : begin
                      // теплопроводность на грани контрольного объёма
                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iei])<epsilonD0)) then
                      begin
                         dke:=0.0;
                      end
                      else
                      begin
                         dke:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));
                      end;
                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[iwi])<epsilonD0)) then
                      begin
                         dkw:=0.0;
                      end
                      else
                      begin
                         dkw:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));
                      end;
                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[ini])<epsilonD0)) then
                      begin
                         dkn:=0.0;
                      end
                      else
                      begin
                         dkn:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));
                      end;
                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) and (fabs(uds4diffusivity[isi])<epsilonD0)) then
                      begin
                         dks:=0.0;
                      end
                      else
                      begin
                         dks:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));
                      end;
                   end;
            end;

            attrs:=0.0; // Схема высокого порядка.
            case icurentuds of
              1 : begin
                     if ((ishconv1>=1000) and (ishconv1<=1015)) then
                     begin
                        if (is_internal_HO(iwi,ipi,iei,ieei)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_forvardx:=cell_face_value_global(ishconv1,Vxuds[iecvi],UDS1[iwi],UDS1[ipi],UDS1[iei],UDS1[ieei]);
                           attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-UDS1[ipi])+maxoper(-dfe,0.0)*(f_forvardx-UDS1[iei]);
                        end;
                        if (is_internal_HO(iwwi,iwi,ipi,iei)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_backvardx:=cell_face_value_global(ishconv1,Vxuds[iwcvi],UDS1[iwwi],UDS1[iwi],UDS1[ipi],UDS1[iei]);
                           attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-UDS1[ipi])+maxoper(dfw,0.0)*(f_backvardx-UDS1[iwi]);
                        end;
                        if (is_internal_HO(isi,ipi,ini,inni)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_forvardy:=cell_face_value_global(ishconv1,Vyuds[incvi],UDS1[isi],UDS1[ipi],UDS1[ini],UDS1[inni]);
                           attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-UDS1[ipi])+maxoper(-dfn,0.0)*(f_forvardy-UDS1[ini]);
                        end;
                        if (is_internal_HO(issi,isi,ipi,ini)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_backvardy:=cell_face_value_global(ishconv1,Vyuds[iscvi],UDS1[issi],UDS1[isi],UDS1[ipi],UDS1[ini]);
                           attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-UDS1[ipi])+maxoper(dfs,0.0)*(f_backvardy-UDS1[isi]);
                        end;
                     end;
                  end;
              2 : begin
                     if ((ishconv2>=1000) and (ishconv2<=1015)) then
                     begin
                        if (is_internal_HO(iwi,ipi,iei,ieei)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_forvardx:=cell_face_value_global(ishconv2,Vxuds[iecvi],UDS2[iwi],UDS2[ipi],UDS2[iei],UDS2[ieei]);
                           attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-UDS2[ipi])+maxoper(-dfe,0.0)*(f_forvardx-UDS2[iei]);
                        end;
                        if (is_internal_HO(iwwi,iwi,ipi,iei)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_backvardx:=cell_face_value_global(ishconv2,Vxuds[iwcvi],UDS2[iwwi],UDS2[iwi],UDS2[ipi],UDS2[iei]);
                           attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-UDS2[ipi])+maxoper(dfw,0.0)*(f_backvardx-UDS2[iwi]);
                        end;
                        if (is_internal_HO(isi,ipi,ini,inni)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_forvardy:=cell_face_value_global(ishconv2,Vyuds[incvi],UDS2[isi],UDS2[ipi],UDS2[ini],UDS2[inni]);
                           attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-UDS2[ipi])+maxoper(-dfn,0.0)*(f_forvardy-UDS2[ini]);
                        end;
                        if (is_internal_HO(issi,isi,ipi,ini)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_backvardy:=cell_face_value_global(ishconv2,Vyuds[iscvi],UDS2[issi],UDS2[isi],UDS2[ipi],UDS2[ini]);
                           attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-UDS2[ipi])+maxoper(dfs,0.0)*(f_backvardy-UDS2[isi]);
                        end;
                     end;
                  end;
              3 : begin
                      if ((ishconv3>=1000) and (ishconv3<=1015)) then
                      begin
                         if (is_internal_HO(iwi,ipi,iei,ieei)) then
                         begin
                            // можно обрабатывать грань схемой высокого порядка
                            f_forvardx:=cell_face_value_global(ishconv3,Vxuds[iecvi],UDS3[iwi],UDS3[ipi],UDS3[iei],UDS3[ieei]);
                            attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-UDS3[ipi])+maxoper(-dfe,0.0)*(f_forvardx-UDS3[iei]);
                         end;
                         if (is_internal_HO(iwwi,iwi,ipi,iei)) then
                         begin
                            // можно обрабатывать грань схемой высокого порядка
                            f_backvardx:=cell_face_value_global(ishconv3,Vxuds[iwcvi],UDS3[iwwi],UDS3[iwi],UDS3[ipi],UDS3[iei]);
                            attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-UDS3[ipi])+maxoper(dfw,0.0)*(f_backvardx-UDS3[iwi]);
                         end;
                         if (is_internal_HO(isi,ipi,ini,inni)) then
                         begin
                            // можно обрабатывать грань схемой высокого порядка
                            f_forvardy:=cell_face_value_global(ishconv3,Vyuds[incvi],UDS3[isi],UDS3[ipi],UDS3[ini],UDS3[inni]);
                            attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-UDS3[ipi])+maxoper(-dfn,0.0)*(f_forvardy-UDS3[ini]);
                         end;
                         if (is_internal_HO(issi,isi,ipi,ini)) then
                         begin
                            // можно обрабатывать грань схемой высокого порядка
                            f_backvardy:=cell_face_value_global(ishconv3,Vyuds[iscvi],UDS3[issi],UDS3[isi],UDS3[ipi],UDS3[ini]);
                            attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-UDS3[ipi])+maxoper(dfs,0.0)*(f_backvardy-UDS3[isi]);
                         end;
                     end;
                  end;
              4 : begin
                     if ((ishconv4>=1000) and (ishconv4<=1015)) then
                     begin
                        if (is_internal_HO(iwi,ipi,iei,ieei)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_forvardx:=cell_face_value_global(ishconv4,Vxuds[iecvi],UDS4[iwi],UDS4[ipi],UDS4[iei],UDS4[ieei]);
                           attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-UDS4[ipi])+maxoper(-dfe,0.0)*(f_forvardx-UDS4[iei]);
                        end;
                        if (is_internal_HO(iwwi,iwi,ipi,iei)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_backvardx:=cell_face_value_global(ishconv4,Vxuds[iwcvi],UDS4[iwwi],UDS4[iwi],UDS4[ipi],UDS4[iei]);
                           attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-UDS4[ipi])+maxoper(dfw,0.0)*(f_backvardx-UDS4[iwi]);
                        end;
                        if (is_internal_HO(isi,ipi,ini,inni)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_forvardy:=cell_face_value_global(ishconv4,Vyuds[incvi],UDS4[isi],UDS4[ipi],UDS4[ini],UDS4[inni]);
                           attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-UDS4[ipi])+maxoper(-dfn,0.0)*(f_forvardy-UDS4[ini]);
                         end;
                        if (is_internal_HO(issi,isi,ipi,ini)) then
                        begin
                           // можно обрабатывать грань схемой высокого порядка
                           f_backvardy:=cell_face_value_global(ishconv4,Vyuds[iscvi],UDS4[issi],UDS4[isi],UDS4[ipi],UDS4[ini]);
                           attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-UDS4[ipi])+maxoper(dfs,0.0)*(f_backvardy-UDS4[isi]);
                        end;
                     end;
                  end;
            end;



            dde:=dke*dy/dxe;  // коэффициенты
            ddw:=dkw*dy/dxw;  // дискретного
            ddn:=dkn*dx/dyn;  // аналога
            dds:=dks*dx/dys;
            if (fabs(dde)<epsilonD0) then
            begin
               dpe:=1e30;
            end
            else
            begin
               dpe:=dfe/dde; // значения
            end;
            if (fabs(ddw)<epsilonD0) then
            begin
               dpw:=1e30;
            end
            else
            begin
               dpw:=dfw/ddw; // чисел
            end;
            if (fabs(ddn)<epsilonD0) then
            begin
               dpn:=1e30;
            end
            else
            begin
               dpn:=dfn/ddn; // Пекле
            end;
            if (fabs(dds)<epsilonD0) then
            begin
               dps:=1e30;
            end
            else
            begin
               dps:=dfs/dds;
            end;
            // коэффициенты дискретного аналога
            case icurentuds of
             1 : begin

                    if (ishconv1=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dae:=dde - 0.5*dfe;
                       m[ipi].daw:=ddw + 0.5*dfw;
                       m[ipi].dan:=ddn - 0.5*dfn;
                       m[ipi].das:=dds + 0.5*dfs;
                    end
                    else
                    if ((ishconv1>=1000) and (ishconv1<=1015)) then
                    begin
                       m[ipi].dae:=dde + maxoper(-dfe,0);
                       m[ipi].daw:=ddw + maxoper(dfw,0);
                       m[ipi].dan:=ddn + maxoper(-dfn,0);
                       m[ipi].das:=dds + maxoper(dfs,0);
                    end
                     else
                    begin
                       m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv1)+maxoper(-dfe,0);
                       m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv1)+maxoper(dfw,0);
                       m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv1)+maxoper(-dfn,0);
                       m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv1)+maxoper(dfs,0);
                    end;
                 end;
             2 : begin
                    if (ishconv2=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dae:=dde - 0.5*dfe;
                       m[ipi].daw:=ddw + 0.5*dfw;
                       m[ipi].dan:=ddn - 0.5*dfn;
                       m[ipi].das:=dds + 0.5*dfs;
                    end
                     else
                    if ((ishconv2>=1000) and (ishconv2<=1015)) then
                    begin
                       m[ipi].dae:=dde + maxoper(-dfe,0);
                       m[ipi].daw:=ddw + maxoper(dfw,0);
                       m[ipi].dan:=ddn + maxoper(-dfn,0);
                       m[ipi].das:=dds + maxoper(dfs,0);
                    end
                     else
                    begin
                       m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv2)+maxoper(-dfe,0);
                       m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv2)+maxoper(dfw,0);
                       m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv2)+maxoper(-dfn,0);
                       m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv2)+maxoper(dfs,0);
                    end;
                 end;
             3 : begin

                    if (ishconv3=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dae:=dde - 0.5*dfe;
                       m[ipi].daw:=ddw + 0.5*dfw;
                       m[ipi].dan:=ddn - 0.5*dfn;
                       m[ipi].das:=dds + 0.5*dfs;
                    end
                     else
                    if ((ishconv3>=1000) and (ishconv3<=1015)) then
                    begin
                       m[ipi].dae:=dde + maxoper(-dfe,0);
                       m[ipi].daw:=ddw + maxoper(dfw,0);
                       m[ipi].dan:=ddn + maxoper(-dfn,0);
                       m[ipi].das:=dds + maxoper(dfs,0);
                    end
                     else
                    begin
                       m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv3)+maxoper(-dfe,0);
                       m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv3)+maxoper(dfw,0);
                       m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv3)+maxoper(-dfn,0);
                       m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv3)+maxoper(dfs,0);
                    end;
                 end;
             4 : begin
                    if (ishconv4=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dae:=dde - 0.5*dfe;
                       m[ipi].daw:=ddw + 0.5*dfw;
                       m[ipi].dan:=ddn - 0.5*dfn;
                       m[ipi].das:=dds + 0.5*dfs;
                    end
                     else
                    if ((ishconv4>=1000) and (ishconv4<=1015)) then
                    begin
                       m[ipi].dae:=dde + maxoper(-dfe,0);
                       m[ipi].daw:=ddw + maxoper(dfw,0);
                       m[ipi].dan:=ddn + maxoper(-dfn,0);
                       m[ipi].das:=dds + maxoper(dfs,0);
                    end
                     else
                    begin
                       m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv4)+maxoper(-dfe,0);
                       m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv4)+maxoper(dfw,0);
                       m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv4)+maxoper(-dfn,0);
                       m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv4)+maxoper(dfs,0);
                    end;
                 end;
            end;

            if (btimedepend) then
            begin
               // нестационарный солвер

               case icurentuds of
               1 : begin
                      if (itypeuds1unsteadyfunction=1) then
                      begin
                         if (iuds1typerho=0) then
                         begin
                            // единичная плотность
                            dap0:=dV/dTimeStep; // нестаионарный вклад
                         end
                          else if (iuds1typerho=1) then
                         begin
                            // гидродинамическая плотность.
                            dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                         end;
                      end
                       else
                      begin
                         dap0:=0.0; // стационарная задача.
                      end;
                  end;
               2 : begin
                      if (itypeuds2unsteadyfunction=1) then
                      begin
                         if (iuds2typerho=0) then
                         begin
                            // единичная плотность
                            dap0:=dV/dTimeStep; // нестаионарный вклад
                         end
                          else if (iuds2typerho=1) then
                         begin
                            // гидродинамическая плотность.
                            dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                         end;
                      end
                       else
                      begin
                         dap0:=0.0; // стационарная задача.
                      end;
                  end;
               3 : begin
                      if (itypeuds3unsteadyfunction=1) then
                      begin

                         if (iuds3typerho=0) then
                         begin
                            // единичная плотность
                            dap0:=dV/dTimeStep; // нестаионарный вклад
                         end
                          else if (iuds3typerho=1) then
                         begin
                            // гидродинамическая плотность.
                            dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                         end;
                      end
                       else
                      begin
                         dap0:=0.0; // стационарная задача.
                      end;
                  end;
               4 : begin
                      if (itypeuds4unsteadyfunction=1) then
                      begin
                         if (iuds4typerho=0) then
                         begin
                            // единичная плотность
                            dap0:=dV/dTimeStep; // нестаионарный вклад
                         end
                          else if (iuds4typerho=1) then
                         begin
                            // гидродинамическая плотность.
                            dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
                         end;
                      end
                       else
                      begin
                         dap0:=0.0; // стационарная задача.
                      end;
                  end;
              end;
            end
             else
            begin
               // стационарный солвер
               dap0:=0.0; // стационарный вклад
            end;

            case icurentuds of
              1 : begin
                     db[ipi]:=dSc1[ipi]*dV+ attrs;// неизменная составляющая источникового члена
                    // db[ipi]:=db[ipi]+(dfe-dfw+dfn-dfs)*UDS1[ipi];
                  end;
              2 : begin
                     db[ipi]:=dSc2[ipi]*dV+ attrs;
                     //db[ipi]:=db[ipi]+(dfe-dfw+dfn-dfs)*UDS2[ipi];
                  end;
              3 : begin
                     db[ipi]:=dSc3[ipi]*dV+ attrs;
                     //db[ipi]:=db[ipi]+(dfe-dfw+dfn-dfs)*UDS3[ipi];
                  end;
              4 : begin
                     db[ipi]:=dSc4[ipi]*dV+ attrs;
                     //db[ipi]:=db[ipi]+(dfe-dfw+dfn-dfs)*UDS4[ipi];
                  end;
            end;



            if (btimedepend) then
            begin
               // нестационарный добавок к источниковому члену
               case icurentuds of
                 1 : begin
                        if (itypeuds1unsteadyfunction=1) then
                        begin
                           db[ipi]:=db[ipi]+ dap0*uds1oldTimeStep[ipi];
                        end;
                     end;
                 2 : begin
                        if (itypeuds2unsteadyfunction=1) then
                        begin
                           db[ipi]:=db[ipi]+ dap0*uds2oldTimeStep[ipi];
                        end;
                     end;
                 3 : begin
                        if (itypeuds3unsteadyfunction=1) then
                        begin
                           db[ipi]:=db[ipi]+ dap0*uds3oldTimeStep[ipi];
                        end;
                     end;
                  4 : begin
                        if (itypeuds4unsteadyfunction=1) then
                        begin
                           db[ipi]:=db[ipi]+ dap0*uds4oldTimeStep[ipi];
                        end;
                     end;
               end;
            end;

            case icurentuds of
             1 : begin
                    if (ishconv1=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dap:=dde+ddw+ddn+dds+0.5*(dfe-dfw+dfn-dfs);
                    end
                    else
                    begin
                       //m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;

                       m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv1)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv1)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv1)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv1)+maxoper(-dfs,0);
                    end;
                 end;
             2 : begin
                    if (ishconv2=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dap:=dde+ddw+ddn+dds+0.5*(dfe-dfw+dfn-dfs);
                    end
                     else
                    begin
                       //m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;

                       m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv2)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv2)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv2)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv2)+maxoper(-dfs,0);
                    end;
                 end;
             3 : begin
                    if (ishconv3=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dap:=dde+ddw+ddn+dds+0.5*(dfe-dfw+dfn-dfs);
                    end
                     else
                    begin
                       //m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;

                       m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv3)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv3)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv3)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv3)+maxoper(-dfs,0);
                    end;
                 end;
             4 : begin
                    if (ishconv4=1) then
                    begin
                       // Центрально разностная схема.
                       // 23 августа 2013 года.
                       m[ipi].dap:=dde+ddw+ddn+dds+0.5*(dfe-dfw+dfn-dfs);
                    end
                     else
                    begin
                       //m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;

                      m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconv4)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv4)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv4)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv4)+maxoper(-dfs,0);
                    end;
                 end;
            end;




            case icurentuds of
              1 : begin
                      m[ipi].dap:=m[ipi].dap + dap0-dSp1[ipi]*dV;
                  end;
              2 : begin
                     m[ipi].dap:=m[ipi].dap + dap0-dSp2[ipi]*dV;
                  end;
              3 : begin
                     m[ipi].dap:=m[ipi].dap + dap0-dSp3[ipi]*dV;
                  end;
              4 : begin
                     m[ipi].dap:=m[ipi].dap + dap0-dSp4[ipi]*dV;
                  end;
            end;

            case icurentuds of
               1 : begin
                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds1)*m[ipi].dap*UDS1[ipi]/myrelaxfactors.uds1;
                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds1;
                   end;
               2 : begin
                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds2)*m[ipi].dap*UDS2[ipi]/myrelaxfactors.uds2;
                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds2;
                   end;
               3 : begin
                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds3)*m[ipi].dap*UDS3[ipi]/myrelaxfactors.uds3;
                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds3;
                   end;
               4 : begin
                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds4)*m[ipi].dap*UDS4[ipi]/myrelaxfactors.uds4;
                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds4;
                   end;
            end;

         end;

         if (itype = 2 ) then
         begin
            // граничный узел
            // возможны условия Неймана
            // словесно порядок действий следующий:
            // каждая граничная точка принадлежит
            // какой либо определенной границе с уникальным номером
            // по этому уникальному номеру (идентификатору) граница
            //  должна быть найдена и для неё должно быть проверено
            //  поставлено ли на ней условие Неймана.

            // на границе поставлено условие Неймана
            if (iugol=0) then
            begin
               // iboundary - уникальный номер границы
               bneiman:=GridGenForm.isneimanqb(iboundary, 'C', qb);
               // охватывает условие симметрии и условие заданного теплового потока.
               if (bneiman) then
               begin
                  // точка не является угловой
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             UDSBoundaryCoefConvBottom(m, db, qb, mapPT[k]);
                          end;
                    'S' : begin
                             // На верхней границе.
                             UDSBoundaryCoefConvTop(m, db, qb, mapPT[k]);
                          end;
                    'W' : begin
                             // Правая стенка
                             UDSBoundaryCoefConvRight(m, db, qb, mapPT[k]);
                          end;
                    'E' : begin
                             // Левая стенка
                             UDSBoundaryCoefConvLeft(m, db, qb, mapPT[k]);
                          end;
                  end; // case
               end; // Нейман

               // нулевая нормальная дифузионная составляющая.
               bzerodiff:=GridGenForm.isCzeroDiff(iboundary);
               if (bzerodiff) then
               begin
                  // нулевая нормальная составляющая диффузионного тока на границе.
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             // Количество узлов для вертикальной скорости на один меньше поэтому на нижней границе
                             // индекс скорости равен ipi.
                             ini:=i+j*inx;
                             ipi:=i+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) or (fabs(uds1diffusivity[ini])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));
                                      end;
                                   end;
                               2 : begin
                                       if ((fabs(uds2diffusivity[ipi])<epsilonD0) or (fabs(uds2diffusivity[ini])<epsilonD0)) then
                                       begin
                                          myG:=0.0;
                                       end
                                        else
                                       begin
                                          myG:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));
                                       end;
                                   end;
                               3 : begin
                                       if ((fabs(uds3diffusivity[ipi])<epsilonD0) or (fabs(uds3diffusivity[ini])<epsilonD0)) then
                                       begin
                                          myG:=0.0;
                                       end
                                        else
                                       begin
                                          myG:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));
                                       end;
                                   end;
                               4 : begin
                                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) or (fabs(uds4diffusivity[ini])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                        else
                                      begin
                                         myG:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));
                                      end;
                                   end;
                             end;
                              if (fabs(myG)<epsilonD0) then
                             begin
                                m[ipi].dan:=1.0;
                                m[ipi].dap:=1.0;
                             end
                              else
                             begin
                                m[ipi].dap:=myG*dx/(ypos[j+1]-ypos[j]);
                                m[ipi].dan:=myG*dx/(ypos[j+1]-ypos[j]);
                             end;
                          end;
                    'S' : begin
                             // На верхней границе.
                             // Размерность Vy по вертикали на одну меньше поэтому для верхней границы для Vy надо использовать isi!!!
                             isi:=i+(j-2)*inx;
                             ipi:=i+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].dan:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) or (fabs(uds1diffusivity[isi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));
                                      end;
                                   end;
                               2 : begin
                                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) or (fabs(uds2diffusivity[isi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));
                                      end;
                                   end;
                               3 : begin
                                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) or (fabs(uds3diffusivity[isi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                        myG:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));
                                      end;
                                   end;
                               4 : begin
                                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) or (fabs(uds4diffusivity[isi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));
                                      end;
                                   end;
                             end;
                              if (fabs(myG)<epsilonD0) then
                             begin
                                m[ipi].das:=1.0;
                                m[ipi].dap:=1.0;
                             end
                              else
                             begin
                                m[ipi].das:=myG*dx/(ypos[j]-ypos[j-1]);
                                m[ipi].dap:=myG*dx/(ypos[j]-ypos[j-1]);
                             end;
                          end;
                    'W' : begin
                             // Правая стенка
                             ipi:=i+(j-1)*inx;
                             iwi:=i-1+(j-1)*inx;
                             // для горизонтальной скорости ячеек на одну меньше по оси x.
                             //ivelindex:=mapPT[k].i-1+(mapPT[k].j-1)*(inx-1);
                             m[ipi].dae:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) or (fabs(uds1diffusivity[iwi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                        myG:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));
                                      end;
                                   end;
                               2 : begin
                                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) or (fabs(uds2diffusivity[iwi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds2diffusivity[ipi]*uds2diffusivity[iwi]/((uds2diffusivity[ipi]+uds2diffusivity[iwi]));
                                      end;
                                   end;
                               3 : begin
                                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) or (fabs(uds3diffusivity[iwi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                       else
                                      begin
                                         myG:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));
                                      end;
                                   end;
                               4 : begin
                                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) or (fabs(uds4diffusivity[iwi])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                       else
                                      begin
                                         myG:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));
                                      end;
                                   end;
                             end;
                             if (fabs(myG)<epsilonD0) then
                             begin
                                m[ipi].daw:=1.0;
                                m[ipi].dap:=1.0;
                             end
                              else
                             begin
                                m[ipi].daw:=myG*dy/(xpos[i]-xpos[i-1]);
                                m[ipi].dap:=myG*dy/(xpos[i]-xpos[i-1]);
                             end;
                          end;
                    'E' : begin
                             // Левая стенка
                             ipi:=i+(j-1)*inx;
                             iei:=i+1+(j-1)*inx;
                             // для горизонтальной скорости ячеек на одну меньше по оси x.
                             //ivelindex:=mapPT[k].i+(mapPT[k].j-1)*(inx-1);
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      if ((fabs(uds1diffusivity[ipi])<epsilonD0) or (fabs(uds1diffusivity[iei])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));
                                      end;
                                   end;
                               2 : begin
                                      if ((fabs(uds2diffusivity[ipi])<epsilonD0) or (fabs(uds2diffusivity[iei])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                        myG:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));
                                      end;
                                   end;
                               3 : begin
                                      if ((fabs(uds3diffusivity[ipi])<epsilonD0) or (fabs(uds3diffusivity[iei])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));
                                      end;
                                   end;
                               4 : begin
                                      if ((fabs(uds4diffusivity[ipi])<epsilonD0) or (fabs(uds4diffusivity[iei])<epsilonD0)) then
                                      begin
                                         myG:=0.0;
                                      end
                                      else
                                      begin
                                         myG:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));
                                      end;
                                   end;
                             end;
                             if (fabs(myG)<epsilonD0) then
                             begin
                                m[ipi].dae:=1.0;
                                m[ipi].dap:=1.0;
                             end
                             else
                             begin
                                m[ipi].dae:=myG*dy/(xpos[i+1]-xpos[i]);
                                m[ipi].dap:=myG*dy/(xpos[i+1]-xpos[i]);
                             end;
                          end;
                  end;
               end;


               bzerocurent:=GridGenForm.isCzerocurent(iboundary);
               if (bzerocurent) then
               begin
                  // нулевая нормальная составляющая диффузионного тока на границе.
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             // Количество узлов для вертикальной скорости на один меньше поэтому на нижней границе
                             // индекс скорости равен ipi.
                             ini:=i+j*inx;
                             ipi:=i+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             db[ipi]:=0.0;

                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));
                                   end;
                               2 : begin
                                       myG:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));
                                   end;
                             end;
                             // Компоненты скорости определяются на шахматной сетке.
                             m[ipi].dap:=myG*dx/(ypos[j+1]-ypos[j])+dx*maxoper(0.0,Vyuds[ipi]);
                             m[ipi].dan:=myG*dx/(ypos[j+1]-ypos[j])+dx*maxoper(0.0,-Vyuds[ipi]);
                          end;
                    'S' : begin
                             // На верхней границе.
                             // Размерность Vy по вертикали на одну меньше поэтому для верхней границы для Vy надо использовать isi!!!
                             isi:=i+(j-2)*inx;
                             ipi:=i+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].dan:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));
                                   end;
                             end;
                             // Компоненты скорости определяются на шахматной сетке.
                             m[ipi].das:=myG*dx/(ypos[j]-ypos[j-1])+dx*maxoper(0.0,Vyuds[isi]);
                             m[ipi].dap:=myG*dx/(ypos[j]-ypos[j-1])+dx*maxoper(0.0,-Vyuds[isi]);
                          end;
                    'W' : begin
                             // Правая стенка
                             ipi:=i+(j-1)*inx;
                             iwi:=i-1+(j-1)*inx;
                             // для горизонтальной скорости ячеек на одну меньше по оси x.
                             ivelindex:=i-1+(j-1)*(inx-1);
                             m[ipi].dae:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[ipi]*uds2diffusivity[iwi]/((uds2diffusivity[ipi]+uds2diffusivity[iwi]));
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));
                                   end;
                             end;
                             m[ipi].daw:=myG*dy/(xpos[i]-xpos[i-1])+dy*maxoper(0.0,Vxuds[ivelindex]);
                             m[ipi].dap:=myG*dy/(xpos[i]-xpos[i-1])+dy*maxoper(0.0,-Vxuds[ivelindex]);
                          end;
                    'E' : begin
                             // Левая стенка
                             ipi:=i+(j-1)*inx;
                             iei:=i+1+(j-1)*inx;
                             // для горизонтальной скорости ячеек на одну меньше по оси x.
                             ivelindex:=i+(j-1)*(inx-1);
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.0;
                             db[ipi]:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));
                                   end;
                             end;
                             m[ipi].dae:=myG*dy/(xpos[i+1]-xpos[i])+dy*maxoper(0.0,-Vxuds[ivelindex]);
                             m[ipi].dap:=myG*dy/(xpos[i+1]-xpos[i])+dy*maxoper(0.0,Vxuds[ivelindex]);
                          end;
                  end;
               end;

               // нулевая нормальная дифузионная составляющая.

               if (GridGenForm.isFreeMetall(iboundary)) then
               begin
                  // нулевая нормальная составляющая диффузионного тока на границе.
                  case chnormal of
                    'N' : begin
                             if (bfirstpointmetall=true) then
                             begin
                                // На нижней границе.
                                iei:=i+1+(j-1)*inx;
                                ini:=i+(j-1+1)*inx;
                                ipi:=i+(j-1)*inx;
                                m[ipi].dae:=0.5;
                                m[ipi].daw:=0.0;
                                m[ipi].das:=0.0;
                                m[ipi].dan:=0.5;
                                m[ipi].dap:=1.0;
                                db[ipi]:=0.0;
                                bfirstpointmetall:=false;
                             end
                              else
                             begin

                                // На нижней границе.
                                iei:=i+1+(j-1)*inx;
                                ipi:=i+(j-1)*inx;
                                m[ipi].dae:=1.0;
                                m[ipi].daw:=0.0;
                                m[ipi].das:=0.0;
                                m[ipi].dan:=0.0;
                                m[ipi].dap:=1.0;
                                db[ipi]:=0.0;
                             end;
                          end;
                    'S' : begin
                             if (bfirstpointmetall=true) then
                             begin
                                // На верхней границе.
                                iwi:=i-1+(j-1)*inx;
                                ipi:=i+(j-1)*inx;
                                 isi:=i+(j-1-1)*inx;
                                m[ipi].dae:=0.0;
                                m[ipi].daw:=0.5;
                                m[ipi].das:=0.5;
                                m[ipi].dan:=0.0;
                                m[ipi].dap:=1.0;
                                db[ipi]:=0.0;
                                bfirstpointmetall:=false;
                             end
                             else
                             begin
                                // На верхней границе.
                                iwi:=i-1+(j-1)*inx;
                                ipi:=i+(j-1)*inx;
                                m[ipi].dae:=0.0;
                                m[ipi].daw:=1.0;
                                m[ipi].das:=0.0;
                                m[ipi].dan:=0.0;
                                m[ipi].dap:=1.0;
                                db[ipi]:=0.0;
                             end;
                          end;
                    'E' : begin
                             if (bfirstpointmetall=true) then
                             begin
                                // На левой границе.
                               isi:=i+(j-2)*inx;
                               ipi:=i+(j-1)*inx;
                               iei:=i+1+(j-1)*inx;
                               m[ipi].dae:=0.5;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=0.5;
                               m[ipi].dan:=0.0;
                               m[ipi].dap:=1.0;
                               db[ipi]:=0.0;
                               bfirstpointmetall:=false;
                             end
                             else
                             begin

                               // На левой границе.
                               isi:=i+(j-2)*inx;
                               ipi:=i+(j-1)*inx;
                               m[ipi].dae:=0.0;
                               m[ipi].daw:=0.0;
                               m[ipi].das:=1.0;
                               m[ipi].dan:=0.0;
                               m[ipi].dap:=1.0;
                               db[ipi]:=0.0;
                             end;
                          end;
                    'W' : begin
                             if (bfirstpointmetall=true) then
                             begin
                                // На правой границе.
                             ini:=i+(j-1+1)*inx;
                             ipi:=i+(j-1)*inx;
                             iwi:=i-1+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.5;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.5;
                             m[ipi].dap:=1.0;
                             db[ipi]:=0.0;
                                bfirstpointmetall:=false;
                             end
                             else
                             begin

                             // На правой границе.
                             ini:=i+(j-1+1)*inx;
                             ipi:=i+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=1.0;
                             m[ipi].dap:=1.0;
                             db[ipi]:=0.0;
                             end;
                          end;
                    end;
                  end;
               (*
               // Неправильные соотношения для условия полный нормальный ток равен нулю!!!
               if (bzerocurent) then
               begin
                  // нулевой ток на границе.
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             // Количество узлов для вертикальной скорости на один меньше поэтому на нижней границе
                             // индекс скорости равен ipi.
                             ini:=i+j*inx;
                             ipi:=i+(j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[ini]/((uds1diffusivity[ipi]+uds1diffusivity[ini]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*sqrt(Vyuds[ipi]*Vyuds[ipi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*fabs(Vyuds[ipi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;


                                      m[ipi].dap:=myG/(ypos[j+1]-ypos[j])+maxoper(0.0,Vyuds[ipi]);
                                      m[ipi].dan:=myG/(ypos[j+1]-ypos[j]);
                                      db[ipi]:=-fmin(0.0,Vyuds[ipi])*UDS1[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds1)*m[ipi].dap*UDS1[ipi]/myrelaxfactors.uds1;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds1;
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[ipi]*uds2diffusivity[ini]/((uds2diffusivity[ipi]+uds2diffusivity[ini]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*sqrt(Vyuds[ipi]*Vyuds[ipi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*fabs(Vyuds[ipi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;


                                      (*
                                      m[ipi].dap:=myG/(ypos[j+1]-ypos[j])+maxoper(0.0,Vyuds[ipi]);
                                      m[ipi].dan:=myG/(ypos[j+1]-ypos[j]);
                                      db[ipi]:=-fmin(0.0,Vyuds[ipi])*UDS2[ipi];
                                      *) (*

                                      // концентрация аппроксимируется на грани средним арифметическим.
                                      m[ipi].dap:=myG/(ypos[j+1]-ypos[j])+0.5*maxoper(0.0,Vyuds[ipi]);
                                      m[ipi].dan:=myG/(ypos[j+1]-ypos[j]);
                                      db[ipi]:=-0.5*fmin(0.0,Vyuds[ipi])*UDS2[ipi]-0.5*Vyuds[ipi]*UDS2[ini];

                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds2)*m[ipi].dap*UDS2[ipi]/myrelaxfactors.uds2;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds2;
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[ini]/((uds3diffusivity[ipi]+uds3diffusivity[ini]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*sqrt(Vyuds[ipi]*Vyuds[ipi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*fabs(Vyuds[ipi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;


                                      m[ipi].dap:=myG/(ypos[j+1]-ypos[j])+maxoper(0.0,Vyuds[ipi]);
                                      m[ipi].dan:=myG/(ypos[j+1]-ypos[j]);
                                      db[ipi]:=-fmin(0.0,Vyuds[ipi])*UDS3[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds3)*m[ipi].dap*UDS3[ipi]/myrelaxfactors.uds3;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds3;
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[ini]/((uds4diffusivity[ipi]+uds4diffusivity[ini]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*sqrt(Vyuds[ipi]*Vyuds[ipi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j+1]-ypos[j]),dx)*fabs(Vyuds[ipi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].dap:=myG/(ypos[j+1]-ypos[j])+maxoper(0.0,Vyuds[ipi]);
                                      m[ipi].dan:=myG/(ypos[j+1]-ypos[j]);
                                      db[ipi]:=-fmin(0.0,Vyuds[ipi])*UDS4[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds4)*m[ipi].dap*UDS4[ipi]/myrelaxfactors.uds4;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds4;
                                   end;
                             end;

                          end;
                    'S' : begin
                             // На верхней границе.
                             // Размерность Vy по вертикали на одну меньше поэтому для верхней границы для Vy надо использовать isi!!!
                             isi:=mapPT[k].i+(mapPT[k].j-2)*inx;
                             ipi:=mapPT[k].i+(mapPT[k].j-1)*inx;
                             m[ipi].dae:=0.0;
                             m[ipi].daw:=0.0;
                             m[ipi].dan:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[isi]/((uds1diffusivity[ipi]+uds1diffusivity[isi]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*sqrt(Vyuds[isi]*Vyuds[isi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*fabs(Vyuds[isi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;


                                      m[ipi].das:=myG/(ypos[j]-ypos[j-1]);
                                      m[ipi].dap:=myG/(ypos[j]-ypos[j-1])-fmin(0.0,Vyuds[isi]);
                                      db[ipi]:=maxoper(0.0,Vyuds[isi])*UDS1[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds1)*m[ipi].dap*UDS1[ipi]/myrelaxfactors.uds1;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds1;
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[ipi]*uds2diffusivity[isi]/((uds2diffusivity[ipi]+uds2diffusivity[isi]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*sqrt(Vyuds[isi]*Vyuds[isi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*fabs(Vyuds[isi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      (*
                                      m[ipi].das:=myG/(ypos[j]-ypos[j-1]);
                                      m[ipi].dap:=myG/(ypos[j]-ypos[j-1])-fmin(0.0,Vyuds[isi]);
                                      db[ipi]:=maxoper(0.0,Vyuds[isi])*UDS2[ipi];
                                      *)   (*

                                      // концентрация аппроксимируется на грани средним арифметическим.
                                      m[ipi].dap:=myG/(ypos[j]-ypos[j-1])-0.5*fmin(0.0,Vyuds[isi]);
                                      m[ipi].das:=myG/(ypos[j]-ypos[j-1]);
                                      db[ipi]:=+0.5*maxoper(0.0,Vyuds[isi])*UDS2[ipi]+0.5*Vyuds[isi]*UDS2[isi];

                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds2)*m[ipi].dap*UDS2[ipi]/myrelaxfactors.uds2;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds2;
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[isi]/((uds3diffusivity[ipi]+uds3diffusivity[isi]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*sqrt(Vyuds[isi]*Vyuds[isi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*fabs(Vyuds[isi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].das:=myG/(ypos[j]-ypos[j-1]);
                                      m[ipi].dap:=myG/(ypos[j]-ypos[j-1])-fmin(0.0,Vyuds[isi]);
                                      db[ipi]:=maxoper(0.0,Vyuds[isi])*UDS3[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds3)*m[ipi].dap*UDS3[ipi]/myrelaxfactors.uds3;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds3;
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[isi]/((uds4diffusivity[ipi]+uds4diffusivity[isi]));

                                      // Искусственная диффузия :
                                      iart1:=i-1+(j-1)*(inx-1);
                                      iart2:=iart1+1;
                                      Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*sqrt(Vyuds[isi]*Vyuds[isi]+0.25*(Vxuds[iart1]+Vxuds[iart2])*(Vxuds[iart1]+Vxuds[iart2]));
                                      //Dart:=0.5*maxoper((ypos[j]-ypos[j-1]),dx)*fabs(Vyuds[isi]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].das:=myG/(ypos[j]-ypos[j-1]);
                                      m[ipi].dap:=myG/(ypos[j]-ypos[j-1])-fmin(0.0,Vyuds[isi]);
                                      db[ipi]:=maxoper(0.0,Vyuds[isi])*UDS4[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds4)*m[ipi].dap*UDS4[ipi]/myrelaxfactors.uds4;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds4;
                                   end;
                             end;
                          end;
                    'W' : begin
                             // Правая стенка
                             ipi:=mapPT[k].i+(mapPT[k].j-1)*inx;
                             iwi:=mapPT[k].i-1+(mapPT[k].j-1)*inx;
                             // для горизонтальной скорости ячеек на одну меньше по оси x.
                             ivelindex:=mapPT[k].i-1+(mapPT[k].j-1)*(inx-1);
                             m[ipi].dae:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[iwi]/((uds1diffusivity[ipi]+uds1diffusivity[iwi]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;


                                      m[ipi].daw:=myG/(xpos[i]-xpos[i-1]);
                                      m[ipi].dap:=myG/(xpos[i]-xpos[i-1])-fmin(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=maxoper(0.0,Vxuds[ivelindex])*UDS1[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds1)*m[ipi].dap*UDS1[ipi]/myrelaxfactors.uds1;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds1;
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[iwi]*uds2diffusivity[ipi]/((uds2diffusivity[iwi]+uds2diffusivity[ipi]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;


                                      m[ipi].daw:=myG/(xpos[i]-xpos[i-1]);
                                      m[ipi].dap:=myG/(xpos[i]-xpos[i-1])-fmin(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=maxoper(0.0,Vxuds[ivelindex])*UDS2[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds2)*m[ipi].dap*UDS2[ipi]/myrelaxfactors.uds2;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds2;
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[iwi]/((uds3diffusivity[ipi]+uds3diffusivity[iwi]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].daw:=myG/(xpos[i]-xpos[i-1]);
                                      m[ipi].dap:=myG/(xpos[i]-xpos[i-1])-fmin(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=maxoper(0.0,Vxuds[ivelindex])*UDS3[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds3)*m[ipi].dap*UDS3[ipi]/myrelaxfactors.uds3;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds3;
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[iwi]/((uds4diffusivity[ipi]+uds4diffusivity[iwi]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i]-xpos[i-1]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].daw:=myG/(xpos[i]-xpos[i-1]);
                                      m[ipi].dap:=myG/(xpos[i]-xpos[i-1])-fmin(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=maxoper(0.0,Vxuds[ivelindex])*UDS4[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds4)*m[ipi].dap*UDS4[ipi]/myrelaxfactors.uds4;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds4;
                                   end;
                             end;
                          end;
                    'E' : begin
                             // Левая стенка
                             ipi:=mapPT[k].i+(mapPT[k].j-1)*inx;
                             iei:=mapPT[k].i+1+(mapPT[k].j-1)*inx;
                             // для горизонтальной скорости ячеек на одну меньше по оси x.
                             ivelindex:=mapPT[k].i+(mapPT[k].j-1)*(inx-1);
                             m[ipi].daw:=0.0;
                             m[ipi].das:=0.0;
                             m[ipi].dan:=0.0;
                             case icurentuds of
                               1 : begin
                                      myG:=2*uds1diffusivity[ipi]*uds1diffusivity[iei]/((uds1diffusivity[ipi]+uds1diffusivity[iei]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].dae:=myG/(xpos[i+1]-xpos[i]);
                                      m[ipi].dap:=myG/(xpos[i+1]-xpos[i])+maxoper(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=-fmin(0.0,Vxuds[ivelindex])*UDS1[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds1)*m[ipi].dap*UDS1[ipi]/myrelaxfactors.uds1;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds1;
                                   end;
                               2 : begin
                                      myG:=2*uds2diffusivity[ipi]*uds2diffusivity[iei]/((uds2diffusivity[ipi]+uds2diffusivity[iei]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].dae:=myG/(xpos[i+1]-xpos[i]);
                                      m[ipi].dap:=myG/(xpos[i+1]-xpos[i])+maxoper(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=-fmin(0.0,Vxuds[ivelindex])*UDS2[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds2)*m[ipi].dap*UDS2[ipi]/myrelaxfactors.uds2;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds2;
                                   end;
                               3 : begin
                                      myG:=2*uds3diffusivity[ipi]*uds3diffusivity[iei]/((uds3diffusivity[ipi]+uds3diffusivity[iei]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].dae:=myG/(xpos[i+1]-xpos[i]);
                                      m[ipi].dap:=myG/(xpos[i+1]-xpos[i])+maxoper(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=-fmin(0.0,Vxuds[ivelindex])*UDS3[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds3)*m[ipi].dap*UDS3[ipi]/myrelaxfactors.uds3;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds3;
                                   end;
                               4 : begin
                                      myG:=2*uds4diffusivity[ipi]*uds4diffusivity[iei]/((uds4diffusivity[ipi]+uds4diffusivity[iei]));

                                      // Искусственная диффузия :
                                      iart1:=i+(j-2)*inx;
                                      iart2:=i+(j-1)*inx;
                                      Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*sqrt(Vxuds[ivelindex]*Vxuds[ivelindex]+0.25*(Vyuds[iart1]+Vyuds[iart2])*(Vyuds[iart1]+Vyuds[iart2]));
                                      //Dart:=0.5*maxoper((xpos[i+1]-xpos[i]),dy)*fabs(Vxuds[ivelindex]);
                                      if (myG<Dart) then
                                      begin
                                         myG:=Dart;
                                      end;

                                      m[ipi].dae:=myG/(xpos[i+1]-xpos[i]);
                                      m[ipi].dap:=myG/(xpos[i+1]-xpos[i])+maxoper(0.0,Vxuds[ivelindex]);
                                      db[ipi]:=-fmin(0.0,Vxuds[ivelindex])*UDS4[ipi];
                                      // введём процедуру нижней релаксации.
                                      db[ipi]:=db[ipi]+(1.0-myrelaxfactors.uds4)*m[ipi].dap*UDS4[ipi]/myrelaxfactors.uds4;
                                      m[ipi].dap:=m[ipi].dap/myrelaxfactors.uds4;
                                   end;
                             end;
                          end;
                  end;
               end; *)
            end // точка лежащая внутри границы расчётной области
              else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах

               case icurentuds of
               1 : begin
                      // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iei]:=DirichVal;
                           UDS1[ipi]:=UDS1[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[ini]:=DirichVal;
                           UDS1[ipi]:=UDS1[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iwi]:=DirichVal;
                           UDS1[ipi]:=UDS1[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[ini]:=DirichVal;
                           UDS1[ipi]:=UDS1[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iei]:=DirichVal;
                           UDS1[ipi]:=UDS1[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[isi]:=DirichVal;
                           UDS1[ipi]:=UDS1[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    4 : // верхний правый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iwi]:=DirichVal;
                           UDS1[ipi]:=UDS1[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[isi]:=DirichVal;
                           UDS1[ipi]:=UDS1[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    5 : // пятиточечная звезда
                     begin
                         m[ipi].dap:=1.0;
                         m[ipi].dae:=0.25;
                         m[ipi].dan:=0.25;
                         m[ipi].das:=0.25;
                         m[ipi].daw:=0.25;


                          if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iei]:=DirichVal;
                           UDS1[ipi]:=UDS1[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[ini]:=DirichVal;
                           UDS1[ipi]:=UDS1[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[iwi]:=DirichVal;
                           UDS1[ipi]:=UDS1[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS1[isi]:=DirichVal;
                           UDS1[ipi]:=UDS1[isi];
                        end
                         else
                        begin

                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;
                        end;
                     end;
                  end; // case
                   end;
                  2 : begin
                      // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iei]:=DirichVal;
                           UDS2[ipi]:=UDS2[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[ini]:=DirichVal;
                           UDS2[ipi]:=UDS2[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    2 : // правый нижний угол
                     begin
                          m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iwi]:=DirichVal;
                           UDS2[ipi]:=UDS2[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[ini]:=DirichVal;
                           UDS2[ipi]:=UDS2[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    3 : // верхний левый угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iei]:=DirichVal;
                           UDS2[ipi]:=UDS2[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[isi]:=DirichVal;
                           UDS2[ipi]:=UDS2[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    4 : // верхний правый угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iwi]:=DirichVal;
                           UDS2[ipi]:=UDS2[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[isi]:=DirichVal;
                           UDS2[ipi]:=UDS2[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    5 : // пятиточечная звезда
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;

                          if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iei]:=DirichVal;
                           UDS2[ipi]:=UDS2[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[ini]:=DirichVal;
                           UDS2[ipi]:=UDS2[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[iwi]:=DirichVal;
                           UDS2[ipi]:=UDS2[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS2[isi]:=DirichVal;
                           UDS2[ipi]:=UDS2[isi];
                        end
                         else
                        begin

                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;
                        end;
                     end;
                  end; // case
                   end;

                   3 : begin
                      // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iei]:=DirichVal;
                           UDS3[ipi]:=UDS3[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[ini]:=DirichVal;
                           UDS3[ipi]:=UDS3[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    2 : // правый нижний угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iwi]:=DirichVal;
                           UDS3[ipi]:=UDS3[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[ini]:=DirichVal;
                           UDS3[ipi]:=UDS3[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    3 : // верхний левый угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iei]:=DirichVal;
                           UDS3[ipi]:=UDS3[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[isi]:=DirichVal;
                           UDS3[ipi]:=UDS3[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    4 : // верхний правый угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;


                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iwi]:=DirichVal;
                           UDS3[ipi]:=UDS3[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[isi]:=DirichVal;
                           UDS3[ipi]:=UDS3[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    5 : // пятиточечная звезда
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;

                          if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iei]:=DirichVal;
                           UDS3[ipi]:=UDS3[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[ini]:=DirichVal;
                           UDS3[ipi]:=UDS3[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[iwi]:=DirichVal;
                           UDS3[ipi]:=UDS3[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS3[isi]:=DirichVal;
                           UDS3[ipi]:=UDS3[isi];
                        end
                         else
                        begin

                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;
                        end;
                     end;
                  end; // case
                   end;

                   4 : begin
                      // угловая точка
                  case iugol of
                    1 : // левый нижний угол
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iei]:=DirichVal;
                           UDS4[ipi]:=UDS4[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[ini]:=DirichVal;
                           UDS4[ipi]:=UDS4[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    2 : // правый нижний угол
                     begin
                          m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iwi]:=DirichVal;
                           UDS4[ipi]:=UDS4[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[ini]:=DirichVal;
                           UDS4[ipi]:=UDS4[ini];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.5;
                           m[ipi].das:=0.0;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;

                        if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iei]:=DirichVal;
                           UDS4[ipi]:=UDS4[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[isi]:=DirichVal;
                           UDS4[ipi]:=UDS4[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.5;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.0;
                        end;
                     end;
                    4 : // верхний правый угол
                     begin
                        m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;

                        if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iwi]:=DirichVal;
                           UDS4[ipi]:=UDS4[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[isi]:=DirichVal;
                           UDS4[ipi]:=UDS4[isi];
                        end
                         else
                        begin
                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.0;
                           m[ipi].dan:=0.0;
                           m[ipi].das:=0.5;
                           m[ipi].daw:=0.5;
                        end;
                     end;
                    5 : // пятиточечная звезда
                     begin
                         m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;


                          if (GridGenForm.isDirichlet(mapPT[iei].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iei]:=DirichVal;
                           UDS4[ipi]:=UDS4[iei];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[ini].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[ini]:=DirichVal;
                           UDS4[ipi]:=UDS4[ini];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[iwi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[iwi]:=DirichVal;
                           UDS4[ipi]:=UDS4[iwi];
                        end
                         else if (GridGenForm.isDirichlet(mapPT[isi].iboundary, 'C', DirichVal)) then
                        begin
                           UDS4[isi]:=DirichVal;
                           UDS4[ipi]:=UDS4[isi];
                        end
                         else
                        begin

                           m[ipi].dap:=1.0;
                           m[ipi].dae:=0.25;
                           m[ipi].dan:=0.25;
                           m[ipi].das:=0.25;
                           m[ipi].daw:=0.25;
                        end;
                     end;
                  end; // case
                   end;

               end; // case

               end; // угловая точка
               
         end; // граничная точка
      end; // with
   end;

end; // UDSCoef


// вычисляет коэффициенты дискретного аналога для
// уравнения переноса непрерывного маркера.
//  Операция составления дискретного аналога выполнена универсальным
// образом. Т.е. она подходит и для процессов не зависящих от времени, а также
// для нестационарных процессов. Уравнение переноса функции цвета должно быть именно нестационарным.
// Внимание: перед использованием этой процедуры массиву
// ToldTimeStep должна быть выделена оперативная память и
//  он должен быть проинициализирован соответствующим образом.
// Вообще говоря уравнение для функции цвета содержит нулевой коэффициент диффузии,
// но здесь оставлена возможность задать в ручную нужный небольшой коэффициент диффузии.
procedure TForm1.VOFCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                              var db : array of Float); // правая часть
var
    iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    ieei, iwwi, inni, issi : Integer; // High Resolution Scheme !!!
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw,dkn, dks : Float; // коэффициент диффузии на гранях контрольного объёма
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dfe, dfw, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    k : Integer; // счётчик для вычисления коэфффициентов дискретного аналога
    bneiman : Boolean; // если граничное условие Неймана
    qb : Float; // значение теплового потока на границе расчётной области,
    // den - значение плотности на грани контрольного объёма
    artificaldiffusion : Float; // должна быть нулём.
    // плотность тождественная единица.
    dScVof, dSpVof : Float;
    f_forvardx, f_backvardx, f_forvardy, f_backvardy, attrs : Float;

begin

   dScVof:=0.0; // постоянная составляющая источникового члена в VOF методе.
   dSpVof:=0.0;
   artificaldiffusion:=0.0; // вообще без диффузии.

   // проход по всем внутренним точкам
   // для определения коэффициентов
   // дискретного аналога  m и db

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            // for High Resolution Scheme
            inni:=i+(j+1)*inx;  // север
            issi:=i+(j-3)*inx; // юг
            iwwi:=(i-2)+(j-1)*inx; // запад
            ieei:=(i+2)+(j-1)*inx; // восток
            
            ipi:=i+(j-1)*inx; // текущая точка
            // для шахматной сетки (для компонент скорости)
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше


            dfe:=Vx[iecvi]*dy; // интенсивность
            dfw:=Vx[iwcvi]*dy; // конвекции
            dfn:=Vy[incvi]*dx; // или
            dfs:=Vy[iscvi]*dx; // течения

            // теплопроводность на грани контрольного объёма
            dke:=artificaldiffusion;
            dkw:=artificaldiffusion;
            dkn:=artificaldiffusion;
            dks:=artificaldiffusion;

            attrs:=0.0;
            if ((ishconvvof>=1000) and (ishconvvof<=1015)) then
            begin
               if (is_internal_HO(iwi,ipi,iei,ieei)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_forvardx:=cell_face_value_global(ishconvvof,Vx[iecvi],VOF[iwi],VOF[ipi],VOF[iei],VOF[ieei]);
                  attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-VOF[ipi])+maxoper(-dfe,0.0)*(f_forvardx-VOF[iei]);
               end;
               if (is_internal_HO(iwwi,iwi,ipi,iei)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_backvardx:=cell_face_value_global(ishconvvof,Vx[iwcvi],VOF[iwwi],VOF[iwi],VOF[ipi],VOF[iei]);
                  attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-VOF[ipi])+maxoper(dfw,0.0)*(f_backvardx-VOF[iwi]);
               end;
               if (is_internal_HO(isi,ipi,ini,inni)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_forvardy:=cell_face_value_global(ishconvvof,Vy[incvi],VOF[isi],VOF[ipi],VOF[ini],VOF[inni]);
                  attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-VOF[ipi])+maxoper(-dfn,0.0)*(f_forvardy-VOF[ini]);
               end;
               if (is_internal_HO(issi,isi,ipi,ini)) then
               begin
                  // можно обрабатывать грань схемой высокого порядка
                  f_backvardy:=cell_face_value_global(ishconvvof,Vy[iscvi],VOF[issi],VOF[isi],VOF[ipi],VOF[ini]);
                  attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-VOF[ipi])+maxoper(dfs,0.0)*(f_backvardy-VOF[isi]);
               end;
            end;


            dde:=dke*dy/dxe;  // коэффициенты
            ddw:=dkw*dy/dxw;  // дискретного
            ddn:=dkn*dx/dyn;  // аналога
            dds:=dks*dx/dys;
            if (artificaldiffusion<1.0e-20) then
            begin
               // Нулевая диффузия.
               // Бесконечно большие числа Пекле.
               dpe:=1.0e20;
               dpw:=1.0e20;
               dpn:=1.0e20;
               dps:=1.0e20;

               // ApproxConvective(модуль числа Пекле, любая схема) это тождественный ноль.

               // Внимание только противопоточная часть так как диффузионная тождественный ноль.
               // коэффициенты дискретного аналога
               m[ipi].dae:=maxoper(-dfe,0);
               m[ipi].daw:=maxoper(dfw,0);
               m[ipi].dan:=maxoper(-dfn,0);
               m[ipi].das:=maxoper(dfs,0);

            end
             else
            begin
               dpe:=dfe/dde; // значения
               dpw:=dfw/ddw; // чисел
               dpn:=dfn/ddn; // Пекле
               dps:=dfs/dds;

               // коэффициенты дискретного аналога
               m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconvvof)+maxoper(-dfe,0);
               m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconvvof)+maxoper(dfw,0);
               m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconvvof)+maxoper(-dfn,0);
               m[ipi].das:=dds*ApproxConvective(abs(dps),ishconvvof)+maxoper(dfs,0);
            end;

            if (btimedepend) then
            begin
               // нестационарный солвер
               if (bVOFsecondorder) then
               begin
                  // формула Пейре второго порядка.
                  dap0:=1.5*dV/dTimeStep; // неявная часть.
               end
                else
               begin
                  // формула Эйлера первого порядка.
                  dap0:=dV/dTimeStep; // нестаионарный вклад
               end;
            end
             else
            begin
               // стационарный солвер
               dap0:=0.0; // стационарный вклад
            end;
            db[ipi]:=dScVof*dV+ attrs;// неизменная составляющая источникового члена плюс добавок который даёт схема высокой разрешающей способности.
            if (btimedepend) then
            begin
               // нестационарный добавок к источниковому члену
               if (bVOFsecondorder) then
               begin
                  // формула Пейре второго порядка на постоянном шаге по времени.
                  db[ipi]:=db[ipi]+dV*(2.0*VOFOldTimeStep[ipi]-0.5*VOFOldOldTimeStep[ipi])/dTimeStep;
               end
                else
               begin
                  // Формула Эйлера.
                  db[ipi]:=db[ipi]+ dap0*VOFOldTimeStep[ipi];
               end;
            end;
           // диагональный коэффициент.
           if (artificaldiffusion<1.0e-20) then
            begin
               m[ipi].dap:=maxoper(dfe,0)+maxoper(dfn,0)+maxoper(-dfw,0)+maxoper(-dfs,0);
            end
              else
            begin
               m[ipi].dap:=dde*ApproxConvective(abs(dpe),ishconvvof)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconvvof)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconvvof)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconvvof)+maxoper(-dfs,0);
            end;
            m[ipi].dap:=m[ipi].dap + dap0-dSpVof*dV;
         end;

         if (itype = 2 ) then
         begin
            // граничный узел
            // возможны условия Неймана
            // словесно порядок действий следующий:
            // каждая граничная точка принадлежит
            // какойлибо определенной границе с уникальным номером
            // по этому уникальному номеру (идентификатору) граница
            //  должна быть найдена и для неё должно быть проверено
            //  поставлено ли на ней условие Неймана.

            // на границе поставлено условие Неймана
            if (iugol=0) then
            begin
               // iboundary - уникальный номер границы
               bneiman:=GridGenForm.isneimanVof(iboundary, qb, chnormal);
               if (bneiman) then
               begin
                  // точка не является угловой
                  case chnormal of
                    'N' : begin
                             // На нижней границе.
                             VofBoundaryCoefConvBottom(m, db, qb, mapPT[k], artificaldiffusion);
                          end;
                    'S' : begin
                             // На верхней границе.
                             VofBoundaryCoefConvTop(m, db, qb, mapPT[k], artificaldiffusion);
                          end;
                    'W' : begin
                             // Правая стенка
                             VofBoundaryCoefConvRight(m, db, qb, mapPT[k], artificaldiffusion);
                          end;
                    'E' : begin
                             // Левая стенка
                             VofBoundaryCoefConvLeft(m, db, qb, mapPT[k], artificaldiffusion);
                          end;
                  end; // case
               end; // Нейман
            end // точка лежащая внутри границы расчётной области
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
                 // угловая точка
                  case iugol of
                  1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;
                     end;
                  2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.5;
                     end;
                  3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.0;
                     end;
                  4 : // верхний правй угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.5;
                     end;
                  5 : // пятиточечная звезда
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.25;
                        m[ipi].dan:=0.25;
                        m[ipi].das:=0.25;
                        m[ipi].daw:=0.25;
                     end;
                  end; // case
               end; // угловая точка
         end; // граничная точка
      end; // with
   end;

end; // VOFCoef

// вычисляет коэффициенты дискретного аналога для
// уравнения переноса завихрённости с учётом конвективного члена
//  Операция составления дискретного аналога выполнена универсальным
// образом. Т.е. она подходит и для процессов не зависящих от времени, а также
// для нестационарных процессов.
// Внимание: перед использованием этой процедуры массиву
// OmegaoldTimeStep должна быть выделена оперативная память и
//  он должен быть проинициализирован соответствующим образом.
procedure TForm1.OmegaConvCoef(var m : array of MatrixCoef; // коэффициенты дискретного аналога
                               var db : array of Float); // правая часть
var
    iei,iwi,ini,isi,ipi : Integer; // номера узлов на пятиточечном шаблоне
    // четыре величины снизу используются для компонент скорости
    iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней контрольного объёма
    dke, dkw,dkn, dks : Float; // теплопроводность на гранях контрольного объёма
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dfe, dfw, dfn, dfs : Float; // интенсивность конвекции или течения
    dde, ddw, ddn, dds : Float;
    dap0 : Float;  // нестационарный коэффициент
    k : Integer; // счётчик для вычисления коэфффициентов дискретного аналога
    bneiman : Boolean; // если граничное условие Неймана
    den : Float; // значение плотности на грани контрольного объёма
    dgxeffective, dgyeffective :  Float; // эффективное ускорение свободного падения (нужно для вибрационного воздействия).

begin

   // проход по всем внутренним точкам
   // для определения коэффициентов
   // дискретного аналога  m и db

   for k:=1 to imaxnumbernode do
   begin
      with mapPT[k] do
      begin
         if (itype = 1 ) then
         begin
            // внутренний узел
            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // для шахматной сетки (для компонент скорости)
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в массиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            den:=2*density(ipi)*density(iei)/((density(ipi)+density(iei)));
            dfe:=den*Vx[iecvi]*dy; // интенсивность
            den:=2*density(ipi)*density(iwi)/((density(ipi)+density(iwi)));
            dfw:=den*Vx[iwcvi]*dy; // конвекции
            den:=2*density(ipi)*density(ini)/((density(ipi)+density(ini)));
            dfn:=den*Vy[incvi]*dx; // или
            den:=2*density(ipi)*density(isi)/((density(ipi)+density(isi)));
            dfs:=den*Vy[iscvi]*dx; // течения
            // теплопроводность на грани контрольного объёма
            dke:=2*viscosity(ipi)*viscosity(iei)/((viscosity(ipi)+viscosity(iei)));
            dkw:=2*viscosity(ipi)*viscosity(iwi)/((viscosity(ipi)+viscosity(iwi)));
            dkn:=2*viscosity(ipi)*viscosity(ini)/((viscosity(ipi)+viscosity(ini)));
            dks:=2*viscosity(ipi)*viscosity(isi)/((viscosity(ipi)+viscosity(isi)));
            dde:=dke*dy/dxe;  // коэффициенты
            ddw:=dkw*dy/dxw;  // дискретного
            ddn:=dkn*dx/dyn;  // аналога
            dds:=dks*dx/dys;
            dpe:=dfe/dde; // значения
            dpw:=dfw/ddw; // чисел
            dpn:=dfn/ddn; // Пекле
            dps:=dfs/dds;
            // коэффициенты дискретного аналога
            m[ipi].dae:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(-dfe,0);
            m[ipi].daw:=ddw*ApproxConvective(abs(dpw),ishconv)+maxoper(dfw,0);
            m[ipi].dan:=ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(-dfn,0);
            m[ipi].das:=dds*ApproxConvective(abs(dps),ishconv)+maxoper(dfs,0);
            if (btimedepend) then
            begin
               // нестационарный солвер
               dap0:=density(ipi)*dV/dTimeStep; // нестаионарный вклад
            end
             else
            begin
               // стационарный солвер
               dap0:=0.0; // стационарный вклад
            end;
            // неизменная составляющая источникового члена
            db[ipi]:=defmysource.Omega.dSc*dV;
            // сила тяжести
            dgxeffective:=dgx; dgyeffective:=dgy;
            // В случае силы тяжести меняющейся по гармоническому закону:
            if ((btimedepend) and (rgravVib.bOn)) then
            begin
               // Только в том случае если процесс нестационарный и
               // сила тяжести меняется по гармоническому закону.

               dgxeffective:= dgxeffective + GetRealGravity('x');
               dgyeffective:= dgyeffective + GetRealGravity('y');
            end;
            // Приближение Буссинеска.
            if (bBussinesk) then
            begin
               // Здесь записывается источниковый вклад в модели Буссинеска,
               // где плотность линейно зависит от температуры. Подробнее можно
               // посмотреть у Г.З. Гершини и Е.М. Жуховицкого.
               db[ipi]:=db[ipi]+density(ipi)*dbeta*dgxeffective*(T[ini]-T[isi])*dV/(ypos[j+1]-ypos[j-1]);
               db[ipi]:=db[ipi]+density(ipi)*dbeta*dgyeffective*(T[iei]-T[iwi])*dV/(xpos[i+1]-xpos[i-1]);
            end;

            if (btimedepend) then
            begin
               // нестационарный добавок к источниковому члену
              db[ipi]:=db[ipi]+ dap0*OmegaoldTimeStep[ipi];
            end;
            m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das;
            m[ipi].dap:=m[ipi].dap + dap0 - defmysource.Omega.dSp*dV;
         end;

         if (itype = 2 ) then
         begin
            // граничный узел

            ini:=i+j*inx;  // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx; // текущая точка
            // Условие Тома.
            m[ipi].dae:=0;
            m[ipi].daw:=0;
            m[ipi].dan:=0;
            m[ipi].das:=0;
            m[ipi].dap:=1.0;

            // на границе поставлено условие Тома
            if (iugol=0) then
            begin
               // точка не является угловой
               case chnormal of
                 'N' : begin
                         // Условие Тома.
                         // На нижней границе.
                         db[ipi]:=2*(SF[ini]-SF[ipi])/((ypos[j+1]-ypos[j])*(ypos[j+1]-ypos[j]));
                       end;
                 'S' : begin
                          // Условие Тома.
                          // На верхней границе.
                          db[ipi]:=2*(SF[isi]-SF[ipi])/((ypos[j]-ypos[j-1])*(ypos[j]-ypos[j-1]));
                       end;
                 'W' : begin
                          // Условие Тома.
                          // Правая стенка
                          db[ipi]:=2*(SF[iwi]-SF[ipi])/((xpos[i]-xpos[i-1])*(xpos[i]-xpos[i-1]));
                       end;
                 'E' : begin
                          // Условие Тома.
                          // Левая стенка
                          db[ipi]:=2*(SF[iei]-SF[ipi])/((xpos[i+1]-xpos[i])*(xpos[i+1]-xpos[i]));
                       end;
               end; // case

            end // точка лежащая внутри границы расчётной области
             else
            begin
               ipi:=i+(j-1)*inx; // текущая точка
               db[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               // температуры во включаемых узлах
                 // угловая точка
                  case iugol of
                  1 : // левый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.0;
                     end;
                  2 : // правый нижний угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.5;
                        m[ipi].das:=0.0;
                        m[ipi].daw:=0.5;
                     end;
                  3 : // верхний левый угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.5;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.0;
                     end;
                  4 : // верхний правй угол
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.0;
                        m[ipi].dan:=0.0;
                        m[ipi].das:=0.5;
                        m[ipi].daw:=0.5;
                     end;
                  5 : // пятиточечная звезда
                     begin
                        m[ipi].dap:=1.0;
                        m[ipi].dae:=0.25;
                        m[ipi].dan:=0.25;
                        m[ipi].das:=0.25;
                        m[ipi].daw:=0.25;
                     end;
                  end; // case
               end; // угловая точка
         end; // граничная точка
      end; // with
   end;

end; // OmegaConvCoef


// нестационарный температурный солвер с конвекцией
procedure TForm1.SolveTempUnsteady(bconv : Boolean);
var
    j : Integer; //  j - номер временного шага

begin
   // показать ход выполнения
   myProgressBarUnsteadyForm.Show;


   // теперь сам температурный солвер
   // с учётом  или без учёта конвекции
   j:=1;
   while ((bweShouldContinue) and (j <= inumbertimestep)) do
   begin // шаги по времени
      // глобальная переменная realFlowTime
      // используется как параметр при различных вибрационных воздействиях.
      realFlowTime:=realFlowTime + dTimeStep; // Текущее время при нестационарном расчёте

      // третий параметр true означает
      // что решается уравнение теплопроводности
      //  с учётом конвективного члена.
      SolveTempSteady(true, itercount, bconv);

      // запоминаем поле температур в переменной ToldTimeStep
      RememberTOldTimeStep(true);
      // переход к следующему временному слою
      MainMemo.Lines.Add('time ' + FloatToStr(realFlowTime));

      // временное прерывание расчётов
      // для того чтобы программа смогла
      // среагировать на другие события от
      // пользователя или операционной системы.
      Application.ProcessMessages;

      // скорость выполнения шагов по времени
      myProgressBarUnsteadyForm.ProgressBar1.Position:=round(j/inumbertimestep*100);
      j:=j+1; // переход к следующему временному слою.
   end; // j - временные шаги

   bweShouldContinue:=true; // восстанавливаем готовность к решению.

   myProgressBarUnsteadyForm.ProgressBar1.Position:=0; // обнуление
   myProgressBarUnsteadyForm.ProgressBar2.Position:=0; // индикаторов
   myProgressBarUnsteadyForm.Close; // закрыть индикатор хода выплнения
end; // SolveTempUnsteadyConv


// Готовит калькулятор к вычислениям
// Custom - Field Function
procedure TForm1.getreadycalc(var fex : T2myDynArray);
var
   laplasxuds1, laplasxuds2, laplasxuds3, laplasxuds4 : array of Float;
   laplasyuds1, laplasyuds2, laplasyuds3 , laplasyuds4 : array of Float;
   laplasuds1, laplasuds2, laplasuds3 , laplasuds4 : array of Float;
   gradxmapptuds1, gradxmapptuds2, gradxmapptuds3 , gradxmapptuds4 : array of Float;
   gradymapptuds1, gradymapptuds2, gradymapptuds3 , gradymapptuds4: array of Float;
   k : Integer;
   bOk : Boolean;
begin

   // Из-за того что вычисления градиентов производятся полностью снова
   // для каждой точки сетки этот скорее всего будет очень неэкономичным.
   case imaxUDS of
             0 : begin
                    // Выделение памяти.
                    SetLength(laplasxuds1,0);
                    SetLength(laplasxuds2,0);
                    SetLength(laplasxuds3,0);
                    SetLength(laplasxuds4,0);
                    SetLength(laplasyuds1,0);
                    SetLength(laplasyuds2,0);
                    SetLength(laplasyuds3,0);
                    SetLength(laplasyuds4,0);
                    SetLength(laplasuds1,0);
                    SetLength(laplasuds2,0);
                    SetLength(laplasuds3,0);
                    SetLength(laplasuds4,0);
                    SetLength(gradxmapptuds1,0);
                    SetLength(gradxmapptuds2,0);
                    SetLength(gradxmapptuds3,0);
                    SetLength(gradxmapptuds4,0);
                    SetLength(gradymapptuds1,0);
                    SetLength(gradymapptuds2,0);
                    SetLength(gradymapptuds3,0);
                    SetLength(gradymapptuds4,0);
                 end;
              1 : begin
                     // Выделение памяти.
                     SetLength(laplasxuds1,inx*iny+1);
                     SetLength(laplasxuds2,0);
                     SetLength(laplasxuds3,0);
                     SetLength(laplasxuds4,0);
                     SetLength(laplasyuds1,inx*iny+1);
                     SetLength(laplasyuds2,0);
                     SetLength(laplasyuds3,0);
                     SetLength(laplasyuds4,0);
                     SetLength(laplasuds1,inx*iny+1);
                     SetLength(laplasuds2,0);
                     SetLength(laplasuds3,0);
                     SetLength(laplasuds4,0);
                     SetLength(gradxmapptuds1,inx*iny+1);
                     SetLength(gradxmapptuds2,0);
                     SetLength(gradxmapptuds3,0);
                     SetLength(gradxmapptuds4,0);
                     SetLength(gradymapptuds1,inx*iny+1);
                     SetLength(gradymapptuds2,0);
                     SetLength(gradymapptuds3,0);
                     SetLength(gradymapptuds4,0);
                     // Вычисление.
                     universallaplasx(UDS1,laplasxuds1);
                     universallaplasy(UDS1,laplasyuds1);
                     universallaplas(UDS1,laplasuds1);
                     universalgradx_mapPT(UDS1,gradxmapptuds1);
                     universalgrady_mapPT(UDS1,gradymapptuds1);
                  end;
              2 : begin
                     // Выделение памяти.
                    SetLength(laplasxuds1,inx*iny+1);
                    SetLength(laplasxuds2,inx*iny+1);
                    SetLength(laplasxuds3,0);
                    SetLength(laplasxuds4,0);
                    SetLength(laplasyuds1,inx*iny+1);
                    SetLength(laplasyuds2,inx*iny+1);
                    SetLength(laplasyuds3,0);
                    SetLength(laplasyuds4,0);
                    SetLength(laplasuds1,inx*iny+1);
                    SetLength(laplasuds2,inx*iny+1);
                    SetLength(laplasuds3,0);
                    SetLength(laplasuds4,0);
                    SetLength(gradxmapptuds1,inx*iny+1);
                    SetLength(gradxmapptuds2,inx*iny+1);
                    SetLength(gradxmapptuds3,0);
                    SetLength(gradxmapptuds4,0);
                    SetLength(gradymapptuds1,inx*iny+1);
                    SetLength(gradymapptuds2,inx*iny+1);
                    SetLength(gradymapptuds3,0);
                     SetLength(gradymapptuds4,0);
                    // Вычисление.
                    universallaplasx(UDS1,laplasxuds1);
                    universallaplasx(UDS2,laplasxuds2);
                    universallaplasy(UDS1,laplasyuds1);
                    universallaplasy(UDS2,laplasyuds2);
                    universallaplas(UDS1,laplasuds1);
                    universallaplas(UDS2,laplasuds2);
                    universalgradx_mapPT(UDS1,gradxmapptuds1);
                    universalgradx_mapPT(UDS2,gradxmapptuds2);
                    universalgrady_mapPT(UDS1,gradymapptuds1);
                    universalgrady_mapPT(UDS2,gradymapptuds2);
                  end;
              3 : begin
                     // Выделение памяти.
                     SetLength(laplasxuds1,inx*iny+1);
                     SetLength(laplasxuds2,inx*iny+1);
                     SetLength(laplasxuds3,inx*iny+1);
                     SetLength(laplasxuds4,0);
                     SetLength(laplasyuds1,inx*iny+1);
                     SetLength(laplasyuds2,inx*iny+1);
                     SetLength(laplasyuds3,inx*iny+1);
                     SetLength(laplasyuds4,0);
                     SetLength(laplasuds1,inx*iny+1);
                     SetLength(laplasuds2,inx*iny+1);
                     SetLength(laplasuds3,inx*iny+1);
                     SetLength(laplasuds4,0);
                     SetLength(gradxmapptuds1,inx*iny+1);
                     SetLength(gradxmapptuds2,inx*iny+1);
                     SetLength(gradxmapptuds3,inx*iny+1);
                     SetLength(gradxmapptuds4,0);
                     SetLength(gradymapptuds1,inx*iny+1);
                     SetLength(gradymapptuds2,inx*iny+1);
                     SetLength(gradymapptuds3,inx*iny+1);
                     SetLength(gradymapptuds4,0);
                     // Вычисление.
                     universallaplasx(UDS1,laplasxuds1);
                     universallaplasx(UDS2,laplasxuds2);
                     universallaplasx(UDS3,laplasxuds3);
                     universallaplasy(UDS1,laplasyuds1);
                     universallaplasy(UDS2,laplasyuds2);
                     universallaplasy(UDS3,laplasyuds3);
                     universallaplas(UDS1,laplasuds1);
                     universallaplas(UDS2,laplasuds2);
                     universallaplas(UDS3,laplasuds3);
                     universalgradx_mapPT(UDS1,gradxmapptuds1);
                     universalgradx_mapPT(UDS2,gradxmapptuds2);
                     universalgradx_mapPT(UDS3,gradxmapptuds3);
                     universalgrady_mapPT(UDS1,gradymapptuds1);
                     universalgrady_mapPT(UDS2,gradymapptuds2);
                     universalgrady_mapPT(UDS3,gradymapptuds3);
                  end;
              4 : begin
                     // Выделение памяти.
                     SetLength(laplasxuds1,inx*iny+1);
                     SetLength(laplasxuds2,inx*iny+1);
                     SetLength(laplasxuds3,inx*iny+1);
                     SetLength(laplasxuds4,inx*iny+1);
                     SetLength(laplasyuds1,inx*iny+1);
                     SetLength(laplasyuds2,inx*iny+1);
                     SetLength(laplasyuds3,inx*iny+1);
                     SetLength(laplasyuds4,inx*iny+1);
                     SetLength(laplasuds1,inx*iny+1);
                     SetLength(laplasuds2,inx*iny+1);
                     SetLength(laplasuds3,inx*iny+1);
                     SetLength(laplasuds4,inx*iny+1);
                     SetLength(gradxmapptuds1,inx*iny+1);
                     SetLength(gradxmapptuds2,inx*iny+1);
                     SetLength(gradxmapptuds3,inx*iny+1);
                     SetLength(gradxmapptuds4,inx*iny+1);
                     SetLength(gradymapptuds1,inx*iny+1);
                     SetLength(gradymapptuds2,inx*iny+1);
                     SetLength(gradymapptuds3,inx*iny+1);
                     SetLength(gradymapptuds4,inx*iny+1);
                     // Вычисление.
                     universallaplasx(UDS1,laplasxuds1);
                     universallaplasx(UDS2,laplasxuds2);
                     universallaplasx(UDS3,laplasxuds3);
                     universallaplasx(UDS4,laplasxuds4);
                     universallaplasy(UDS1,laplasyuds1);
                     universallaplasy(UDS2,laplasyuds2);
                     universallaplasy(UDS3,laplasyuds3);
                     universallaplasy(UDS4,laplasyuds4);
                     universallaplas(UDS1,laplasuds1);
                     universallaplas(UDS2,laplasuds2);
                     universallaplas(UDS3,laplasuds3);
                     universallaplas(UDS4,laplasuds4);
                     universalgradx_mapPT(UDS1,gradxmapptuds1);
                     universalgradx_mapPT(UDS2,gradxmapptuds2);
                     universalgradx_mapPT(UDS3,gradxmapptuds3);
                     universalgradx_mapPT(UDS4,gradxmapptuds4);
                     universalgrady_mapPT(UDS1,gradymapptuds1);
                     universalgrady_mapPT(UDS2,gradymapptuds2);
                     universalgrady_mapPT(UDS3,gradymapptuds3);
                     universalgrady_mapPT(UDS4,gradymapptuds4);
                  end;
          end;


   for k:=1 to imaxnumbernode do
   begin
   with Form1.mapPT[k] do
                        begin
                           if (itype<>0) then
                           begin
                              ipi:=i+(j-1)*inx;

                              // список поддерживаемых переменных
                              // $x, $y - декартовы координаты.
                              // $udm1, $udm2, $udm3 - если есть.  Пользовательская память.
                              // $uds1, $uds2, $uds3 - если есть.  Пользовательские скаляры.
                              // $diff1, $diff2, $diff3 - коэффициенты диффузии для пользовательских скаляров.
                              // Если нет то тождественный ноль.
                              Form1.ivar:=33; // 2 переменные x и y
                              SetLength(Form1.parametric,Form1.ivar);
                              Form1.parametric[0].svar:='$x';
                              Form1.parametric[1].svar:='$y';
                              Form1.parametric[0].sval:=FloatToStr(Form1.xpos[i]);
                              Form1.parametric[1].sval:=FloatToStr(Form1.ypos[j]);
                              // Пользовательская память.
                              Form1.parametric[2].svar:='$udm1';
                              Form1.parametric[3].svar:='$udm2';
                              Form1.parametric[4].svar:='$udm3';
                              // Пользовательский скаляр.
                              Form1.parametric[5].svar:='$uds1';
                              Form1.parametric[6].svar:='$uds2';
                              Form1.parametric[7].svar:='$uds3';
                              Form1.parametric[8].svar:='$uds4';
                              // Коэффициенты диффузии для пользовательских скаляров с предыдущей итерации.
                              Form1.parametric[9].svar:='$diff1';
                              Form1.parametric[10].svar:='$diff2';
                              Form1.parametric[11].svar:='$diff3';
                              Form1.parametric[12].svar:='$diff4';
                              // производные
                              Form1.parametric[13].svar:='$laplas1';
                              Form1.parametric[14].svar:='$laplas2';
                              Form1.parametric[15].svar:='$laplas3';
                              Form1.parametric[16].svar:='$laplas4';
                              Form1.parametric[17].svar:='$laplasx1';
                              Form1.parametric[18].svar:='$laplasx2';
                              Form1.parametric[19].svar:='$laplasx3';
                              Form1.parametric[20].svar:='$laplasx4';
                              Form1.parametric[21].svar:='$laplasy1';
                              Form1.parametric[22].svar:='$laplasy2';
                              Form1.parametric[23].svar:='$laplasy3';
                              Form1.parametric[24].svar:='$laplasy4';
                              Form1.parametric[25].svar:='$gradxuds1';
                              Form1.parametric[26].svar:='$gradxuds2';
                              Form1.parametric[27].svar:='$gradxuds3';
                              Form1.parametric[28].svar:='$gradxuds4';
                              Form1.parametric[29].svar:='$gradyuds1';
                              Form1.parametric[30].svar:='$gradyuds2';
                              Form1.parametric[31].svar:='$gradyuds3';
                              Form1.parametric[32].svar:='$gradyuds4';

                              case imaxUDM of
                              0 : begin
                                     Form1.parametric[2].sval:='0.0';
                                     Form1.parametric[3].sval:='0.0';
                                     Form1.parametric[4].sval:='0.0';
                                  end;
                              1 : begin
                                     Form1.parametric[2].sval:=FloatToStr(UDM1[ipi]);
                                     Form1.parametric[3].sval:='0.0';
                                     Form1.parametric[4].sval:='0.0';
                                  end;
                              2 : begin
                                     Form1.parametric[2].sval:=FloatToStr(UDM1[ipi]);
                                     Form1.parametric[3].sval:=FloatToStr(UDM2[ipi]);
                                     Form1.parametric[4].sval:='0.0';
                                  end;
                              3 : begin
                                     Form1.parametric[2].sval:=FloatToStr(UDM1[ipi]);
                                     Form1.parametric[3].sval:=FloatToStr(UDM2[ipi]);
                                     Form1.parametric[4].sval:=FloatToStr(UDM3[ipi]);
                                  end;
                              end;
                              case imaxUDS of
                               0 : begin
                                      Form1.parametric[5].sval:='0.0';
                                      Form1.parametric[6].sval:='0.0';
                                      Form1.parametric[7].sval:='0.0';
                                      Form1.parametric[8].sval:='0.0';
                                      Form1.parametric[9].sval:='1.0';
                                      Form1.parametric[10].sval:='1.0';
                                      Form1.parametric[11].sval:='1.0';
                                      Form1.parametric[12].sval:='1.0';
                                      Form1.parametric[13].sval:='0.0';
                                      Form1.parametric[14].sval:='0.0';
                                      Form1.parametric[15].sval:='0.0';
                                      Form1.parametric[16].sval:='0.0';
                                      Form1.parametric[17].sval:='0.0';
                                      Form1.parametric[18].sval:='0.0';
                                      Form1.parametric[19].sval:='0.0';
                                      Form1.parametric[20].sval:='0.0';
                                      Form1.parametric[21].sval:='0.0';
                                      Form1.parametric[22].sval:='0.0';
                                      Form1.parametric[23].sval:='0.0';
                                      Form1.parametric[24].sval:='0.0';
                                      Form1.parametric[25].sval:='0.0';
                                      Form1.parametric[26].sval:='0.0';
                                      Form1.parametric[27].sval:='0.0';
                                      Form1.parametric[28].sval:='0.0';
                                      Form1.parametric[29].sval:='0.0';
                                      Form1.parametric[30].sval:='0.0';
                                      Form1.parametric[31].sval:='0.0';
                                      Form1.parametric[32].sval:='0.0';
                                   end;
                               1 : begin
                                      Form1.parametric[5].sval:=FloatToStr(UDS1[ipi]);
                                      Form1.parametric[6].sval:='0.0';
                                      Form1.parametric[7].sval:='0.0';
                                      Form1.parametric[8].sval:='0.0';
                                      Form1.parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                                      Form1.parametric[10].sval:='1.0';
                                      Form1.parametric[11].sval:='1.0';
                                      Form1.parametric[12].sval:='1.0';

                                      Form1.parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                                      Form1.parametric[14].sval:='0.0';
                                      Form1.parametric[15].sval:='0.0';
                                      Form1.parametric[16].sval:='0.0';
                                      Form1.parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                                      Form1.parametric[18].sval:='0.0';
                                      Form1.parametric[19].sval:='0.0';
                                      Form1.parametric[20].sval:='0.0';
                                      Form1.parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                                      Form1.parametric[22].sval:='0.0';
                                      Form1.parametric[23].sval:='0.0';
                                      Form1.parametric[24].sval:='0.0';
                                      Form1.parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                                      Form1.parametric[26].sval:='0.0';
                                      Form1.parametric[27].sval:='0.0';
                                      Form1.parametric[28].sval:='0.0';
                                      Form1.parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                                      Form1.parametric[30].sval:='0.0';
                                      Form1.parametric[31].sval:='0.0';
                                      Form1.parametric[32].sval:='0.0';
                                   end;
                               2 : begin
                                      Form1.parametric[5].sval:=FloatToStr(UDS1[ipi]);
                                      Form1.parametric[6].sval:=FloatToStr(UDS2[ipi]);
                                      Form1.parametric[7].sval:='0.0';
                                      Form1.parametric[8].sval:='0.0';
                                      Form1.parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                                      Form1.parametric[10].sval:=FloatToStr(uds2diffusivity[ipi]);
                                      Form1.parametric[11].sval:='1.0';
                                      Form1.parametric[12].sval:='1.0';

                                      Form1.parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                                      Form1.parametric[14].sval:=FloatToStr(laplasuds2[ipi]);
                                      Form1.parametric[15].sval:='0.0';
                                      Form1.parametric[16].sval:='0.0';
                                      Form1.parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                                      Form1.parametric[18].sval:=FloatToStr(laplasxuds2[ipi]);
                                      Form1.parametric[19].sval:='0.0';
                                      Form1.parametric[20].sval:='0.0';
                                      Form1.parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                                      Form1.parametric[22].sval:=FloatToStr(laplasyuds2[ipi]);
                                      Form1.parametric[23].sval:='0.0';
                                      Form1.parametric[24].sval:='0.0';
                                      Form1.parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                                      Form1.parametric[26].sval:=FloatToStr(gradxmapptuds2[ipi]);
                                      Form1.parametric[27].sval:='0.0';
                                      Form1.parametric[28].sval:='0.0';
                                      Form1.parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                                      Form1.parametric[30].sval:=FloatToStr(gradymapptuds2[ipi]);
                                      Form1.parametric[31].sval:='0.0';
                                      Form1.parametric[32].sval:='0.0';
                                   end;
                               3 : begin
                                      Form1.parametric[5].sval:=FloatToStr(UDS1[ipi]);
                                      Form1.parametric[6].sval:=FloatToStr(UDS2[ipi]);
                                      Form1.parametric[7].sval:=FloatToStr(UDS3[ipi]);
                                      Form1.parametric[8].sval:='0.0';
                                      Form1.parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                                      Form1.parametric[10].sval:=FloatToStr(uds2diffusivity[ipi]);
                                      Form1.parametric[11].sval:=FloatToStr(uds3diffusivity[ipi]);
                                      Form1.parametric[12].sval:='0.0';

                                      Form1.parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                                      Form1.parametric[14].sval:=FloatToStr(laplasuds2[ipi]);
                                      Form1.parametric[15].sval:=FloatToStr(laplasuds3[ipi]);
                                      Form1.parametric[16].sval:='0.0';
                                      Form1.parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                                      Form1.parametric[18].sval:=FloatToStr(laplasxuds2[ipi]);
                                      Form1.parametric[19].sval:=FloatToStr(laplasxuds3[ipi]);
                                      Form1.parametric[20].sval:='0.0';
                                      Form1.parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                                      Form1.parametric[22].sval:=FloatToStr(laplasyuds2[ipi]);
                                      Form1.parametric[23].sval:=FloatToStr(laplasyuds3[ipi]);
                                      Form1.parametric[24].sval:='0.0';
                                      Form1.parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                                      Form1.parametric[26].sval:=FloatToStr(gradxmapptuds2[ipi]);
                                      Form1.parametric[27].sval:=FloatToStr(gradxmapptuds3[ipi]);
                                      Form1.parametric[28].sval:='0.0';
                                      Form1.parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                                      Form1.parametric[30].sval:=FloatToStr(gradymapptuds2[ipi]);
                                      Form1.parametric[31].sval:=FloatToStr(gradymapptuds3[ipi]);
                                      Form1.parametric[32].sval:='0.0';
                                   end;
                               4 : begin
                                      Form1.parametric[5].sval:=FloatToStr(UDS1[ipi]);
                                      Form1.parametric[6].sval:=FloatToStr(UDS2[ipi]);
                                      Form1.parametric[7].sval:=FloatToStr(UDS3[ipi]);
                                      Form1.parametric[8].sval:=FloatToStr(UDS4[ipi]);
                                      Form1.parametric[9].sval:=FloatToStr(uds1diffusivity[ipi]);
                                      Form1.parametric[10].sval:=FloatToStr(uds2diffusivity[ipi]);
                                      Form1.parametric[11].sval:=FloatToStr(uds3diffusivity[ipi]);
                                      Form1.parametric[12].sval:=FloatToStr(uds4diffusivity[ipi]);

                                      Form1.parametric[13].sval:=FloatToStr(laplasuds1[ipi]);
                                      Form1.parametric[14].sval:=FloatToStr(laplasuds2[ipi]);
                                      Form1.parametric[15].sval:=FloatToStr(laplasuds3[ipi]);
                                      Form1.parametric[16].sval:=FloatToStr(laplasuds4[ipi]);
                                      Form1.parametric[17].sval:=FloatToStr(laplasxuds1[ipi]);
                                      Form1.parametric[18].sval:=FloatToStr(laplasxuds2[ipi]);
                                      Form1.parametric[19].sval:=FloatToStr(laplasxuds3[ipi]);
                                      Form1.parametric[20].sval:=FloatToStr(laplasxuds4[ipi]);
                                      Form1.parametric[21].sval:=FloatToStr(laplasyuds1[ipi]);
                                      Form1.parametric[22].sval:=FloatToStr(laplasyuds2[ipi]);
                                      Form1.parametric[23].sval:=FloatToStr(laplasyuds3[ipi]);
                                      Form1.parametric[24].sval:=FloatToStr(laplasyuds4[ipi]);
                                      Form1.parametric[25].sval:=FloatToStr(gradxmapptuds1[ipi]);
                                      Form1.parametric[26].sval:=FloatToStr(gradxmapptuds2[ipi]);
                                      Form1.parametric[27].sval:=FloatToStr(gradxmapptuds3[ipi]);
                                      Form1.parametric[28].sval:=FloatToStr(gradxmapptuds4[ipi]);
                                      Form1.parametric[29].sval:=FloatToStr(gradymapptuds1[ipi]);
                                      Form1.parametric[30].sval:=FloatToStr(gradymapptuds2[ipi]);
                                      Form1.parametric[31].sval:=FloatToStr(gradymapptuds3[ipi]);
                                      Form1.parametric[32].sval:=FloatToStr(gradymapptuds4[ipi]);
                                   end;
                              end;
                           end;
                        end;

      bOk:=true;
      fex[0][k]:=my_real_convert(cff1str,bOk);
      bOk:=true;
      fex[1][k]:=my_real_convert(cff2str,bOk);
      bOk:=true;
      fex[2][k]:=my_real_convert(cff3str,bOk);
      bOk:=true;
      fex[3][k]:=my_real_convert(cff4str,bOk);
      bOk:=true;
      fex[4][k]:=my_real_convert(cff5str,bOk);
      bOk:=true;
      fex[5][k]:=my_real_convert(cff6str,bOk);
      bOk:=true;
      fex[6][k]:=my_real_convert(cff7str,bOk);
      bOk:=true;
      fex[7][k]:=my_real_convert(cff8str,bOk);
      bOk:=true;
      fex[8][k]:=my_real_convert(cff9str,bOk);
      bOk:=true;
      fex[9][k]:=my_real_convert(cff10str,bOk);
   end;
end;

procedure TForm1.exportVx();
var
  f : TStrings;
  i : Integer;
  fname, sbuf : String;
begin
    // экспортирует данные в программу tecplot
       f:=TStringList.Create();
   f.Add('TITLE = " X-Velocity_debug "');
   f.Add('VARIABLES = X,Y, "x-vel"');

   f.Add('ZONE T="Rampant", N='+IntToStr((inx-1)*iny)+', E='+IntToStr((inx-2)*(iny-1))+' ET=QUADRILATERAL, F=FEBLOCK');
   f.Add('');

   // x - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
          if (mapPT[i].i<>inx) then
          begin

          sbuf:=sbuf + FloatToStr(0.5*(xpos[mapPT[i].i]+xpos[mapPT[i].i+1]))+' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
            end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // y - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
           if (mapPT[i].i<>inx) then
          begin
          sbuf:=sbuf + FloatToStr(ypos[mapPT[i].j])+' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
            end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


       // Vx - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode-1 do
       begin
            if (mapPT[i].i<>inx) then
          begin
          sbuf:=sbuf + FloatToStr(Vx[mapPT[i].i+(inx-1)*(mapPT[i].j-1)])+' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
            end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
          if ((mapPT[i].i < inx-1) and (mapPT[i].j < iny)) then
          begin

                    // все четыре узла внутренние
                    sbuf:=IntToStr(mapPT[i].i+(mapPT[i].j-1)*(inx-1))+' '+
                    IntToStr(mapPT[i].i+1+(mapPT[i].j-1)*(inx-1))+' '
                    +IntToStr(mapPT[i].i+1+(mapPT[i].j)*(inx-1))+' '
                    +IntToStr(mapPT[i].i+(mapPT[i].j)*(inx-1))+' ';
                    f.Add(sbuf);

          end;
       end;

       fname:='c:test_debug.PLT';
      f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',pChar(fname),nil,SW_SHOW);
       f.Free;

end;

// создаёт файл для программы tecplot
// переменная  ifuncexport отвечает за то какое значение передавать
// в программу tecplot 360:
// 1 - со значением вихря,
// 2 - со значением функции тока,
// 3 - со значением поля температур,
// 4 - со значением распределения давления.
// 5 - со значением горизонтальной скорости,
// 6 - со значением вертикальной скорости.
// 7 - со значением функции цвета (VOF)
// 8 - со значением User-Defined Memory
// 9 - со значением User-Defined Scalar
procedure TForm1.exporttecplotUniversal(ifuncexport : Integer);
var
   f : TStrings; // переменная типа объект TStringList
   fname, sbuf, scor : String; // имя создаваемого файла
   iNum, iE, kscan : Integer;
   i,i1, j,ius : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости
   // экспортируемые функции для визуализации:
   fex : T2myDynArray;
   blogudm : Boolean;
   ubuf1, ubuf2 : array of Float;



begin

   blogudm:=False;
   // инициализация
   ihigh:=1; // по умолчанию несоответствие сетки и вычисляемой функции.
   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   case ifuncexport of
     1 : ihigh:=0; // Custom Field Function
     2 : begin
            // Вихрь и Функция тока
            ihigh:= High(SF) - (mzapas*inx*iny); // функция тока
            if (ihigh=0) then
            begin
               ihigh:= High(Omega) - (mzapas*inx*iny); // вихрь
            end;
         end;
     3 : ihigh:= High(T) - (mzapas*inx*iny); // поле температур
     4 : ihigh:= High(Pressureabsolute) - (mzapas*inx*iny); // давление
     5 : ihigh:= High(Vx) - (mzapas*(inx-1)*iny); // горизонтальная компонента скорости
     6 : ihigh:= High(Vy) - (mzapas*inx*(iny-1)); // вертикальная компонента скорости
     7 : ihigh:= High(VOF) - (mzapas*inx*iny); // функция цвета VOF method
     8 : begin
            // User-Defined Memory
            case imaxUDM of
              0: ihigh:=0; // нет User-Defined Memory
              1 : begin
                     ihigh:=High(UDM1)-(mzapas*inx*iny);
                  end;
              2 : begin
                     ihigh:=High(UDM1)-(mzapas*inx*iny);
                     if (ihigh=0) then
                     begin
                        ihigh:=High(UDM2)-(mzapas*inx*iny);
                     end;
                  end;
              3 : begin
                     ihigh:=High(UDM1)-(mzapas*inx*iny);
                     if (ihigh=0) then
                     begin
                        ihigh:=High(UDM2)-(mzapas*inx*iny);
                        if (ihigh=0) then
                        begin
                           ihigh:=High(UDM3)-(mzapas*inx*iny);
                        end;
                     end;
                  end;
            end;
         end;
     9 : begin
            // User-Defined Scalar
            case imaxUDS of
              0: ihigh:=0; // нет User-Defined Scalar
              1 : begin
                     ihigh:=High(UDS1)-(mzapas*inx*iny);
                  end;
              2 : begin
                     ihigh:=High(UDS1)-(mzapas*inx*iny);
                     if (ihigh=0) then
                     begin
                        ihigh:=High(UDS2)-(mzapas*inx*iny);
                     end;
                  end;
              3 : begin
                     ihigh:=High(UDS1)-(mzapas*inx*iny);
                     if (ihigh=0) then
                     begin
                        ihigh:=High(UDS2)-(mzapas*inx*iny);
                        if (ihigh=0) then
                        begin
                           ihigh:=High(UDS3)-(mzapas*inx*iny);
                        end;
                     end;
                  end;
              4 : begin
                     ihigh:=High(UDS1)-(mzapas*inx*iny);
                     if (ihigh=0) then
                     begin
                        ihigh:=High(UDS2)-(mzapas*inx*iny);
                        if (ihigh=0) then
                        begin
                           ihigh:=High(UDS3)-(mzapas*inx*iny);
                           if (ihigh=0) then
                           begin
                              ihigh:=High(UDS4)-(mzapas*inx*iny);
                           end;
                        end;
                     end;
                  end;
            end;
         end;
   end;



   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for i:=1 to imaxnumbernode do
       begin
          if ((mapPT[i].i < inx) and (mapPT[i].j < iny)) then
          begin
             if ((GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[(mapPT[i].i+1)+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[(mapPT[i].i+1)+(mapPT[i].j)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j)*inx].itypenode > 0)) then
             begin
                // все четыре узла внутренние
                inc(iE);
             end;
          end;
       end;
       // экспортирует данные в программу tecplot
       f:=TStringList.Create();
       case ifuncexport of
         1 : // Custom Field Function
            begin
               f.Add('TITLE = Custom Field Function');
               case inumCFF of
                0 : begin
                       f.Add('VARIABLES = X,Y ');
                    end;
                1 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'"');
                    end;
                2 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'"');
                    end;
                3 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'"');
                    end;
                4 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'"');
                    end;
                5 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'", "'+cff5name+'"');
                    end;
                6 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'", "'+cff5name+'", "'+cff6name+'"');
                    end;
                7 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'", "'+cff5name+'", "'+cff6name+'", "'+cff7name+'"');
                    end;
                8 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'", "'+cff5name+'", "'+cff6name+'", "'+cff7name+'", "'+cff8name+'"');
                    end;
                9 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'", "'+cff5name+'", "'+cff6name+'", "'+cff7name+'", "'+cff8name+'", "'+cff9name+'"');
                    end;
                10 : begin
                       f.Add('VARIABLES = X,Y, "'+cff1name+'", "'+cff2name+'", "'+cff3name+'", "'+cff4name+'", "'+cff5name+'", "'+cff6name+'", "'+cff7name+'", "'+cff8name+'", "'+cff9name+'", "'+cff10name+'"');
                    end;
               end;

            end;
         2 : // вихрь функция тока
            begin
               f.Add('TITLE = " Vortex - Stream Function "');
               f.Add('VARIABLES = X,Y, " Omega ", "stream function"');
            end;
         3 : // поле температур
            begin
               f.Add('TITLE = " Tempreture "');
               f.Add('VARIABLES = X,Y, "tempreture", "grad x temperature", "grad y temperature",  "magnitude grad temperature"');
            end;
         4 : // распределение давления
            begin
              f.Add('TITLE = " Pressure_absolute "');
              f.Add('VARIABLES = X,Y, "pressure"');
            end;
         5 : // горизонтальная компонента скорости
            begin
               f.Add('TITLE = " X-Velocity "');
               f.Add('VARIABLES = X,Y, "x-velocity"');
            end;
         6 : // вертикальная компонента скорости
            begin
               f.Add('TITLE = " Y-Velocity "');
               f.Add('VARIABLES = X,Y, "y-velocity"');
            end;
         7 : // функция цвета (VOF method)
            begin
              f.Add('TITLE = " Phases "');
              f.Add('VARIABLES = X,Y, "phases"');
            end;
         8 : // User-Defined Memory
            begin
               f.Add('TITLE = " User_Defined_Memory "');
               case imaxUDM of
              0:  f.Add('VARIABLES = X,Y');// нет User-Defined Memory
              1 : begin

                     blogudm:=True;
                     for i:=1 to imaxnumbernode do
                     begin
                        if ((mapPT[i].itype=1)or (mapPT[i].itype=2)) then
                        begin
                           if (UDM1[i]<1.0) then
                           begin
                               blogudm:=False;
                           end;
                        end;
                     end;
                     if (blogudm) then
                     begin
                        f.Add('VARIABLES = X,Y, "UDM1", "logUDM1"');
                     end
                     else
                     begin
                        f.Add('VARIABLES = X,Y, "UDM1"');
                     end;
                  end;
              2 : begin
                     f.Add('VARIABLES = X,Y, "UDM1", "UDM2"');
                  end;
              3 : begin
                     f.Add('VARIABLES = X,Y, "UDM1", "UDM2", "UDM3"');
                  end;
               end;
            end;
         9 : // User-Defined Scalar
            begin
               f.Add('TITLE = " User_Defined_Scalar "');
               case imaxUDS of
              0:  f.Add('VARIABLES = X,Y');// нет User-Defined Memory
              1 : begin
                     f.Add('VARIABLES = X,Y, "UDS1"');
                  end;
              2 : begin
                     f.Add('VARIABLES = X,Y, "UDS1", "UDS2"');
                  end;
              3 : begin
                     f.Add('VARIABLES = X,Y, "UDS1", "UDS2", "UDS3"');
                  end;
              4 : begin
                     f.Add('VARIABLES = X,Y, "UDS1", "UDS2", "UDS3", "UDS4"');
                  end;
               end;
            end;
       end;





       // отладочная печать.
       //ShowMessage('inx*iny='+IntToStr(inx*iny)+'iNum'+IntToStr(imaxnumbernode));
       iNum:=1;
       SetLength(number,inx*iny+1);
       for i:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
       begin                                                                     //m
          //number[mapPT[i].i+(mapPT[i].j-1)*inx]:=i; // уникальные номера для каждого узла
          number[mapPT[i].i+(mapPT[i].j-1)*inx]:=iNum;
          inc(iNum);
       end;                                                                         //m
       end;

       dec(iNum);

       f.Add('ZONE T="Rampant", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       f.Add('');

       // x - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
       begin
          scor:=FloatToStr(lengthscaleplot.xscale*xpos[mapPT[i].i]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
          sbuf:=sbuf +scor +' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
       end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // y - coordinate
       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
       begin
          scor:=FloatToStr(lengthscaleplot.yscale*ypos[mapPT[i].j]);
          for kscan:=1 to length(scor) do
          begin
             if (scor[kscan]=',') then
             begin
                scor[kscan]:='.';
             end;
          end;
          sbuf:=sbuf + scor+' ';
          if ((i+1) mod 10 = 0) then
            begin
               f.Add(sbuf);
               sbuf:='';
            end;
            end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       if (ifuncexport=1) then
       begin
          // Custom Field Functions
          SetLength(fex,10);
          for i:=0 to 9 do
          begin
             SetLength(fex[i],inx*iny+1);
          end;

           // Вычисляет всё необходимое.
          getreadycalc(fex);

          for i1:=0 to (inumCFF - 1) do
          begin
              // Очередная custom field function.
              sbuf:='';
              for i:=1 to imaxnumbernode do
              begin
              if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
              begin
                 scor:=FloatToStr(fex[i1][i]);
                 for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                 sbuf:=sbuf+scor+' ';
                 if ((i+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
               end;
              end;
              if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
          end;

       end;

       if (ifuncexport=2) then
       begin
          // Вихрь - Функция тока
          // Вихрь
          sbuf:='';
          for i:=1 to imaxnumbernode do
          begin
          if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(Omega[mapPT[i].i+(mapPT[i].j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
             end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
          // Функция тока
          sbuf:='';
          for i:=1 to imaxnumbernode do
          begin
          if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(SF[mapPT[i].i+(mapPT[i].j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
             end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
       end;

       if ((ifuncexport>2) and (ifuncexport<8)) then
       begin

         if (ifuncexport=3)  then
         begin

         SetLength(ubuf1,inx*iny+1);
         universalgradx_mapPT(T,ubuf1);
         SetLength(ubuf2,inx*iny+1);
         universalgrady_mapPT(T,ubuf2);

         sbuf:='';
         for i:=1 to imaxnumbernode do
         begin
         if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(T[mapPT[i].i+(mapPT[i].j-1)*inx]);
             // поле температур
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
          end;
          if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

         sbuf:='';
         for i:=1 to imaxnumbernode do
         begin
         if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             // поле температур
             scor:=FloatToStr(ubuf1[mapPT[i].i+(mapPT[i].j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
          end;
          if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

         sbuf:='';
         for i:=1 to imaxnumbernode do
         begin
         if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             // поле температур
             scor:=FloatToStr(ubuf2[mapPT[i].i+(mapPT[i].j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
          end;
          if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


         sbuf:='';
         for i:=1 to imaxnumbernode do
         begin
         if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             // поле температур
             scor:=FloatToStr(sqrt(sqr(ubuf1[mapPT[i].i+(mapPT[i].j-1)*inx])+sqr(ubuf2[mapPT[i].i+(mapPT[i].j-1)*inx])));
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
          end;
          if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


           SetLength(ubuf1,0);
           SetLength(ubuf2,0);

         end;



         sbuf:='';
         for i:=1 to imaxnumbernode do
         begin
         if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
           case ifuncexport of
              (*
               1 : // Вихрь
                 begin
                    sbuf:=sbuf+FloatToStr(Omega[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                 end;
               2 : // функция тока
                 begin
                    sbuf:=sbuf+FloatToStr(SF[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                 end;
                 *)
                 (*
               3 : // поле температур
                 begin
                    sbuf:=sbuf+FloatToStr(T[mapPT[i].i+(mapPT[i].j-1)*inx])+' ';
                 end;
                 *)
               4 : // распределение давления
                  begin
                     scor:=FloatToStr(Pressureabsolute[mapPT[i].i+(mapPT[i].j-1)*inx]);
                     for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                     sbuf:=sbuf+scor+' ';
                  end;
               5 : // горизонтальная компонента скорости
                  begin
                     dresult:=0.0; // инициализация
                     if (mapPT[i].i=1) then dresult:=Vx[1+(mapPT[i].j-1)*(inx-1)];
                     if (mapPT[i].i=inx) then dresult:=Vx[(inx-1)+(mapPT[i].j-1)*(inx-1)];
                     if ((mapPT[i].i<>1) and (mapPT[i].i<>inx)) then
                     begin
                        // используется линейная интерполяция
                        // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                        // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                        dfe:=(xpos[mapPT[i].i+1]-xpos[mapPT[i].i])/(xpos[mapPT[i].i+1]-xpos[mapPT[i].i-1]); // учёт неравномерности сетки
                        dresult:=dfe*Vx[(mapPT[i].i-1)+(mapPT[i].j-1)*(inx-1)]+(1-dfe)*Vx[mapPT[i].i+(mapPT[i].j-1)*(inx-1)];
                     end;
                     scor:=FloatToStr(dresult);
                     for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                     sbuf:=sbuf+scor+' ';
                  end;
               6 : // вертикальная компонента скорости
                  begin
                     dresult:=0.0; // инициализация
                     if (mapPT[i].j=1) then
                     begin
                        dresult:=Vy[mapPT[i].i];
                     end;
                     if (mapPT[i].j=iny) then
                     begin
                        dresult:=Vy[mapPT[i].i+(iny-2)*inx];
                     end;
                     if ((mapPT[i].j<>1) and (mapPT[i].j<>iny)) then
                     begin
                        // линейная интерполяция
                        // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                        // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                        dfe:=(ypos[mapPT[i].j+1]-ypos[mapPT[i].j])/(ypos[mapPT[i].j+1]-ypos[mapPT[i].j-1]);
                        dresult:=dfe*Vy[mapPT[i].i+(mapPT[i].j-2)*inx]+(1-dfe)*Vy[mapPT[i].i+(mapPT[i].j-1)*inx];
                     end;
                     scor:=FloatToStr(dresult);
                     for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                     sbuf:=sbuf+scor+' ';
                  end;
                7 : // распределение функции цвета
                  begin
                     scor:=FloatToStr(VOF[mapPT[i].i+(mapPT[i].j-1)*inx]);
                     for kscan:=1 to length(scor) do
                     begin
                        if (scor[kscan]=',') then
                        begin
                           scor[kscan]:='.';
                        end;
                     end;
                     sbuf:=sbuf+scor+' ';
                  end;
             end;
             if ((i+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
             end;
         end;
         if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
       end;

       if (ifuncexport=8) then
       begin
       case imaxUDM of
         1 : begin

                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
                scor:=FloatToStr(UDM1[mapPT[i].i+(mapPT[i].j-1)*inx]);
                  for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                if (blogudm) then
                begin
                    sbuf:='';
                    for i:=1 to imaxnumbernode do
                    begin
                    if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(Log10(UDM1[mapPT[i].i+(mapPT[i].j-1)*inx]));
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                       sbuf:=sbuf+scor+' ';
                       if ((i+1) mod 10 =0) then
                       begin
                          f.Add(sbuf);
                          sbuf:='';
                       end;
                       end;
                    end;
                    if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                end;
             end;
         2 : begin
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDM1[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDM2[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
             end;
         3 : begin
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDM1[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
                begin
                scor:=FloatToStr(UDM2[mapPT[i].i+(mapPT[i].j-1)*inx]);
                for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDM3[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
             end;
       end;
       end;

       if (ifuncexport=9) then
       begin
       case imaxUDS of
         1 : begin

                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
             end;
         2 : begin
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
             end;
         3 : begin
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]);
                   for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
             end;
         4 : begin
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(UDS1[mapPT[i].i+(mapPT[i].j-1)*inx]);
                   for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
             scor:=FloatToStr(UDS2[mapPT[i].i+(mapPT[i].j-1)*inx]);
                  for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDS3[mapPT[i].i+(mapPT[i].j-1)*inx]);
                   for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
                sbuf:='';
                for i:=1 to imaxnumbernode do
                begin
                if (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) then //m
          begin
          scor:=FloatToStr(UDS4[mapPT[i].i+(mapPT[i].j-1)*inx]);
          for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                   sbuf:=sbuf+scor+' ';
                   if ((i+1) mod 10 =0) then
                   begin
                      f.Add(sbuf);
                      sbuf:='';
                   end;
                   end;
                end;
                if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
             end;
       end;
       end;

       sbuf:='';
       for i:=1 to imaxnumbernode do
       begin
          if ((mapPT[i].i < inx) and (mapPT[i].j < iny)) then
          begin
             if ((GridGenForm.tnm[mapPT[i].i+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+1+(mapPT[i].j-1)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+1+(mapPT[i].j)*inx].itypenode > 0) and
                 (GridGenForm.tnm[mapPT[i].i+(mapPT[i].j)*inx].itypenode > 0)) then
                 begin
                    // все четыре узла внутренние
                    sbuf:=IntToStr(number[mapPT[i].i+(mapPT[i].j-1)*inx])+' '+
                    IntToStr(number[mapPT[i].i+1+(mapPT[i].j-1)*inx])+' '
                    +IntToStr(number[mapPT[i].i+1+(mapPT[i].j)*inx])+' '
                    +IntToStr(number[mapPT[i].i+(mapPT[i].j)*inx])+' ';
                    f.Add(sbuf);
                 end;
          end;
       end;


       case ifuncexport of
         1 : // Custom Field Function
            begin
               fname:='custom_field_function.PLT';
            end;
         2 : // Вихрь - функция тока
            begin
               fname:='vortex_streamfunctec.PLT';
            end;
         3 : // поле температур
            begin
               fname:='temptec.PLT';
            end;
         4 : // распределение давления
            begin
               fname:='pressuretec.PLT';
            end;
         5 : // распределение горизонтальной скорости
            begin
               fname:='x_velocity.PLT';
            end;
         6 : // распределение вертикальной скорости
            begin
               fname:='y_velocity.PLT';
            end;
         7 : // распределение функции цвета (VOF метод)
            begin
               fname:='phases.PLT';
            end;
         8 : // user-defined memory
            begin
               fname:='user_defined_memory.PLT';
            end;
         9 : // user-defined scalar
            begin
               fname:='user_defined_scalar.PLT';
            end;
       end;

       f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',pChar(fname),nil,SW_SHOW);
       f.Free;
   end
   else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Custom Field Function
            begin
               MainMemo.Lines.Add('Вы не вычисляли custom field function на данной сетке.');
               MainMemo.Lines.Add('custom field functions не могут быть отображёны.');
               Application.MessageBox('Вы не рассчитывали custom field function на данной сетке.','',MB_OK);
            end;
        2 : // вихрь и Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь и функцию тока на данной сетке.');
               MainMemo.Lines.Add('вихрь и Функция тока не могут быть отображены.');
               Application.MessageBox('Вы не рассчитывали вихрь и функцию тока на данной сетке.','',MB_OK);
            end;
        3 : // поле температур
            begin
               MainMemo.Lines.Add('Вы не вычисляли поле температур на данной сетке.');
               MainMemo.Lines.Add('Поле температур не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали поле температур на данной сетке.','',MB_OK);
            end;
        4 : // распределение давления
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение давления на данной сетке.');
               MainMemo.Lines.Add('распределение давления не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение давления на данной сетке.','',MB_OK);
            end;
        5 : // распределение горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение горизонтальной компоненты скорости на данной сетке.');
               MainMemo.Lines.Add('распределение горизонтальной компоненты скорости не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение горизонтальной компоненты скорости на данной сетке.','',MB_OK);
            end;
        6 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение вертикальной компоненты скорости на данной сетке.');
               MainMemo.Lines.Add('распределение вертикальной компоненты скорости не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение вертикальной компоненты скорости на данной сетке.','',MB_OK);
            end;
        7 : // распределение функции цвета
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение функции цвета на данной сетке.');
               MainMemo.Lines.Add('распределение функции цвета не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение функции цвета на данной сетке.','',MB_OK);
            end;
        8 : // распределение user-defined memory
            begin
               MainMemo.Lines.Add('Вы не задавали распределение user-defined memory на данной сетке.');
               MainMemo.Lines.Add('распределение user-defined memory не может быть отображено.');
               Application.MessageBox('Вы не задавали распределение user-defined memory на данной сетке.','',MB_OK);
            end;
        9 : // распределение user-defined scalar
            begin
               MainMemo.Lines.Add('Вы не рассчитывали распределение user-defined scalar на данной сетке.');
               MainMemo.Lines.Add('распределение user-defined scalar не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение user-defined scalar на данной сетке.','',MB_OK);
            end;
      end;

   end;
end; //exporttecplotUniversal

// создаёт файл для программы tecplot
// со всеми расчитанными функциями.
// в программу tecplot:
//
// 1 - мат ожидание вихря,
// 2 - мат. ожидание температуры
// 3 - мат. ожидание горизонтальной скорости,
// 4 - мат. ожидание  вертикальной скорости.
// 5 - мат. ожидание модуля скорости.
// 6 - математическое ожидание функции тока
procedure TForm1.exporttecplotmeanUniversalComplete;
var
   f : TStrings; // переменная типа объект TStringList
   fname, sbuf, scor : String; // имя создаваемого файла
   iNum, iE : Integer;
   i1,j1,k,ius, kscan : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости
   ifuncexport : Integer; // где случилась ошибка
   meanvelmag : array of Float; // мат ожидание модуля скорости

begin
   // инициализация

   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   // выделение памяти
     SetLength(meanvelmag,inx*iny+1);
     // инициализация
     for i1:=1 to inx do
     begin
         for j1:=1 to iny do
         begin
             meanvelmag[i1+(j1-1)*inx]:=0.0;
         end;
     end;

     // по умолчанию проверка на несоответствие сетки и вычисляемой функции
     // для функции вихрь.
     ihigh:= High(meanOmega) - (mzapas*inx*iny); // вихрь
     if (ihigh=0) then
     begin
        ihigh:= High(SF) - (mzapas*inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=1;
     end;
     if (Form1.imodelEquation<>3 ) then
     begin
        if (ihigh=0) then
        begin
           ihigh:= High(meanT) - (mzapas*inx*iny); // осреднённая температура
        end
         else
        begin
           ifuncexport:=2;
        end;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(meanVx) - (mzapas*(inx-1)*iny); // осреднённая горизонтальная компонента скорости
     end
      else
     begin
        ifuncexport:=3;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(meanVy) - (mzapas*inx*(iny-1)); // осреднённая вертикальная компонента скорости
     end
      else
     begin
        ifuncexport:=4;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(meanSF) - (mzapas*inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=5;
     end;
     if (ihigh <> 0) then ifuncexport:=6;


   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j)*inx].itypenode > 0) and
                    (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                begin
                   // все четыре узла внутренние
                   inc(iE);
                end;
             end;
          end;
       end;
       // экспортирует данные в программу tecplot
       f:=TStringList.Create();
       f.Add('TITLE = " CFD Vahl-DavisTestDelphi "');
       if (Form1.imodelEquation<>3 ) then
       begin
          f.Add('VARIABLES = X,Y, "mean-omega", "mean-T", "mean-x-velocity", "mean-y-velocity", "mean-vel-mag", "mean-SF"');
       end
        else
       begin
          f.Add('VARIABLES = X,Y, "mean-omega", "mean-x-velocity", "mean-y-velocity", "mean-vel-mag", "mean-SF"');
       end;

       f.Add('ZONE T="Rampant", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       f.Add('');

       SetLength(number,inx*iny+1);
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             number[i+(j-1)*inx]:=k; // уникальные номера для каждого узла
          end;
       end;

       // значения X
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(lengthscaleplot.xscale*xpos[i]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf + scor +' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Значения Y
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(lengthscaleplot.yscale*ypos[j]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf + scor +' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-Omega
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(meanOmega[i+(j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

        if (Form1.imodelEquation<>3 ) then
        begin
           // mean-T
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
              with mapPT[k] do
              begin
                 scor:=FloatToStr(meanT[i+(j-1)*inx]);
                 for kscan:=1 to length(scor) do
                 begin
                    if (scor[kscan]=',') then
                    begin
                       scor[kscan]:='.';
                    end;
                 end;
                 sbuf:=sbuf+scor+' ';
                 if ((k+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
              end;
           end;
           if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
        end;

       // mean-x-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (i=1) then dresult:=meanVx[1+(j-1)*(inx-1)];
             if (i=inx) then dresult:=meanVx[(inx-1)+(j-1)*(inx-1)];
             // используется линейная интерполяция
             // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
             // из книжки С.Патанкара. (это лучше для неравномерных сеток).
             if ((i<>1) and (i<>inx)) then
             begin
                dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                dresult:=dfe*meanVx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*meanVx[i+(j-1)*(inx-1)];
             end;
             scor:=FloatToStr(dresult);
              for kscan:=1 to length(scor) do
                 begin
                    if (scor[kscan]=',') then
                    begin
                       scor[kscan]:='.';
                    end;
                 end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-y-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (j=1) then
             begin
                dresult:=meanVy[i];
             end;
             if (j=iny) then
             begin
                dresult:=meanVy[i+(iny-2)*inx];
             end;
             // линейная интерполяция
             // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
             // из книжки С. Патанкара. (это лучше для неравномерных сеток).
             if ((j<>1) and (j<>iny)) then
             begin
                dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                dresult:=dfe*meanVy[i+(j-2)*inx]+(1-dfe)*meanVy[i+(j-1)*inx];
             end;
             scor:=FloatToStr(dresult);
              for kscan:=1 to length(scor) do
                 begin
                    if (scor[kscan]=',') then
                    begin
                       scor[kscan]:='.';
                    end;
                 end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-vel-mag
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
           with mapPT[k] do
           begin
              dresult:=0.0; // инициализация
              if (i=1) then dresult:=meanVx[1+(j-1)*(inx-1)];
              if (i=inx) then dresult:=meanVx[(inx-1)+(j-1)*(inx-1)];
              // используется линейная интерполяция
              // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
              // из книжки С.Патанкара. (это лучше для неравномерных сеток).
              if ((i<>1) and (i<>inx)) then
              begin
                 dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                 dresult:=dfe*meanVx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*meanVx[i+(j-1)*(inx-1)];
              end;
              meanvelmag[i+(j-1)*inx]:=dresult*dresult;
              dresult:=0.0; // инициализация
              if (j=1) then
              begin
                  dresult:=meanVy[i];
              end;
              if (j=iny) then
              begin
                 dresult:=meanVy[i+(iny-2)*inx];
              end;
              // линейная интерполяция
              // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
              // из книжки С. Патанкара. (это лучше для неравномерных сеток).
              if ((j<>1) and (j<>iny)) then
              begin
                 dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                 dresult:=dfe*meanVy[i+(j-2)*inx]+(1-dfe)*meanVy[i+(j-1)*inx];
              end;
              meanvelmag[i+(j-1)*inx]:=meanvelmag[i+(j-1)*inx] + dresult*dresult;
              scor:=FloatToStr(sqrt(meanvelmag[i+(j-1)*inx]));
              for kscan:=1 to length(scor) do
              begin
                 if (scor[kscan]=',') then
                 begin
                    scor[kscan]:='.';
                 end;
              end;
              sbuf:=sbuf+scor+' ';
              if ((k+1) mod 10 =0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
           end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // mean-SF
         sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
              scor:=FloatToStr(meanSF[i+(j-1)*inx]);
              for kscan:=1 to length(scor) do
              begin
                 if (scor[kscan]=',') then
                 begin
                    scor[kscan]:='.';
                 end;
              end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                   begin
                      // все четыре узла внутренние
                      sbuf:=IntToStr(number[i+(j-1)*inx])+' '+
                      IntToStr(number[i+1+(j-1)*inx])+' '
                      +IntToStr(number[i+1+(j)*inx])+' '
                      +IntToStr(number[i+(j)*inx])+' ';
                      f.Add(sbuf);
                   end;
             end;
          end; // with
       end;

       fname:='CFDmeanFlow.PLT';
       f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',pChar(fname),nil,SW_SHOW);
       f.Free;
   end
    else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Вихрь
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь на данной сетке.');
               MainMemo.Lines.Add('Вихрь не может быть отображён.');
               Application.MessageBox('Вы не рассчитывали вихрь на данной сетке.','',MB_OK);
            end;
        2 : // Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли мат. ожидания поля температур на данной сетке.');
               MainMemo.Lines.Add('мат. ожидание поля температур не может быть отображена.');
               Application.MessageBox('Вы не рассчитывали мат ожидание поля температур на данной сетке.','',MB_OK);
            end;
        3 : // распределение осреднённой температуры
            begin
               MainMemo.Lines.Add('Вы не вычисляли mean-T на данной сетке.');
               MainMemo.Lines.Add('mean-T не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали mean-T на данной сетке.','',MB_OK);
            end;
        4 : // распределение осреднённой горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение mean-x-velocity на данной сетке.');
               MainMemo.Lines.Add('mean-x-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение mean-x-velocity на данной сетке.','',MB_OK);
            end;
        5 : // распределение осреднённой вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение mean-y-velocity на данной сетке.');
               MainMemo.Lines.Add('mean-y-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение mean-y-velocity на данной сетке.','',MB_OK);
            end;
        6 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение математического ожидания от функции тока на данной сетке.');
               MainMemo.Lines.Add('математическое ожидание от функции тока не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали мат ожидание от функции тока на данной сетке.','',MB_OK);
            end;
      end;

   end;
end; //exporttecplotmeanUniversalComplete

// записывает заголовок для анимации очищая хранилище анимационных кадров.
procedure TForm1.writeanimationTitle;
begin
  fanimationtecplot.Clear;
  fanimationtecplot.Add('TITLE = " CFD Vahl-DavisTestDelphi "');
  if ((Form1.imodelEquation=1) or (Form1.imodelEquation=4) ) then
  begin
     fanimationtecplot.Add('VARIABLES = X,Y, "omega", "T", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure_absolute"');
  end
   else if (Form1.imodelEquation=3) then
  begin
     // Чистая гидродинамика.
     fanimationtecplot.Add('VARIABLES = X,Y, "omega", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure_absolute"');
  end
   else if (Form1.imodelEquation=5) then
  begin
     // Гидродинамика и VOF метод.
     fanimationtecplot.Add('VARIABLES = X,Y, "Phases", "omega", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure_absolute"');
  end;
end;

// Запускает файл с анимацией !.
procedure TForm1.animationStart;
var
    fname : string;
begin
   fname:='CFDAnimation.PLT';
   fanimationtecplot.SaveToFile(fname);
   ShellExecute(Form1.Handle, nil,'tec360',PChar(fname),nil,SW_SHOW);
end;

// записывает тело анимации каждый шаг по времени
// создаёт файл для программы tecplot
// со всеми расчитанными функциями.
// в программу tecplot:
//
// 1 -  вихрь,
// 2 -  температура,
// 3 -  горизонтальная скорость,
// 4 -  вертикальная скорость,
// векторное поле скоростей может быть автоматически
// сгенерировано используя пункты 3 и 4.
// 5 -  модуль скорости,
// 6 -  функция тока,
// 7 - давление.
procedure TForm1.AnimationBody(cadrname : string);

const inewstring=100;

var
   sbuf : String; // имя создаваемого файла
   iNum, iE : Integer;
   i1,j1,k,ius : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости
   ifuncexport : Integer; // где случилась ошибка
   velmag : array of Float; //  модуль скорости

procedure patch_s(var s : string);
var
   i : Integer;
begin
   // Замена запятых на точки при экспорте в техплот.
   for i := 1 to length(s) do
   begin
      if (s[i]=',') then
      begin
        s[i]:='.';
      end;
   end;
end;

begin
   // инициализация

   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   // выделение памяти
     SetLength(velmag,inx*iny+1);
     // инициализация
     for i1:=1 to inx do
     begin
        for j1:=1 to iny do
        begin
           velmag[i1+(j1-1)*inx]:=0.0;
        end;
     end;

     ifuncexport:=0;

     // по умолчанию проверка на несоответствие сетки и вычисляемой функции
     // для вихря.
     ihigh:= High(Omega) - (mzapas*inx*iny); // вихрь
     if (ihigh=0) then
     begin
        ihigh:= High(SF) - (mzapas*inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=1;
     end;
     if ((Form1.imodelEquation=1) or (Form1.imodelEquation=4) ) then
     begin
        if (ihigh=0) then
        begin
           ihigh:= High(T) - (mzapas*inx*iny); //  температура
        end
         else
        begin
           ifuncexport:=2;
        end;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Vx) - (mzapas*(inx-1)*iny); //  горизонтальная компонента скорости
     end
      else
     begin
        ifuncexport:=3;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Vy) - (mzapas*inx*(iny-1)); //  вертикальная компонента скорости
     end
      else
     begin
        ifuncexport:=4;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Pressureabsolute) - (mzapas*inx*iny); // давление
     end
      else
     begin
        ifuncexport:=5;
     end;
     if (ihigh<>0) then ifuncexport:=6;
     if (ihigh=0) then
     begin
        if (Form1.imodelEquation=5) then
        begin
           // VOF method.
           ihigh:= High(VOF) - (mzapas*inx*iny); //  функция цвета.
        end;
     end
      else
     begin
        ifuncexport:=6;
     end;
     if (Form1.imodelEquation=5) then
     begin
        if (ihigh<>0) then ifuncexport:=7;
     end;



   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j)*inx].itypenode > 0) and
                    (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                begin
                   // все четыре узла внутренние
                   inc(iE);
                end;
             end;
          end;
       end;


       fanimationtecplot.Add('ZONE T="'+cadrname+'", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       fanimationtecplot.Add('');

       SetLength(number,inx*iny+1);
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             number[i+(j-1)*inx]:=k; // уникальные номера для каждого узла
          end;
       end;

       // значения X
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf + FloatToStr(lengthscaleplot.xscale*xpos[i])+' ';
             if ((k+1) mod inewstring = 0) then
              begin
                 patch_s(sbuf);
                 fanimationtecplot.Add(sbuf);
                 sbuf:='';
              end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
           patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       // Значения Y
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf + FloatToStr(lengthscaleplot.yscale*ypos[j])+' ';
             if ((k+1) mod inewstring = 0) then
              begin
                  patch_s(sbuf);
                 fanimationtecplot.Add(sbuf);
                 sbuf:='';
              end;
          end;
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
           patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       if (Form1.imodelEquation=5) then
       begin
          // VOF method
          // Omega
          sbuf:='';
          for k:=1 to imaxnumbernode do
          begin
             with mapPT[k] do
             begin
                sbuf:=sbuf+FloatToStr(VOF[i+(j-1)*inx])+' ';
                if ((k+1) mod inewstring =0) then
                begin
                    patch_s(sbuf);
                   fanimationtecplot.Add(sbuf);
                   sbuf:='';
                end;
             end;
          end;
          if ((imaxnumbernode+1) mod inewstring <> 0) then
          begin
              patch_s(sbuf);
              fanimationtecplot.Add(sbuf);
          end;
       end;

       // Omega
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(Omega[i+(j-1)*inx])+' ';
             if ((k+1) mod inewstring =0) then
             begin
                 patch_s(sbuf);
                fanimationtecplot.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
           patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
        end;

        if ((Form1.imodelEquation=1 ) or (Form1.imodelEquation=4)) then
        begin
           // T
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
              with mapPT[k] do
              begin
                 sbuf:=sbuf+FloatToStr(T[i+(j-1)*inx])+' ';
                 if ((k+1) mod inewstring =0) then
                 begin
                    patch_s(sbuf);
                    fanimationtecplot.Add(sbuf);
                    sbuf:='';
                 end;
              end;
           end;
           if ((imaxnumbernode+1) mod inewstring <> 0) then
           begin
              patch_s(sbuf);
              fanimationtecplot.Add(sbuf);
           end;
        end;

       // x-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (i=1) then dresult:=Vx[1+(j-1)*(inx-1)];
             if (i=inx) then dresult:=Vx[(inx-1)+(j-1)*(inx-1)];
             if ((i<>1) and (i<>inx)) then
             begin
                // используется линейная интерполяция
                // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                dresult:=dfe*Vx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*Vx[i+(j-1)*(inx-1)];
             end;
             sbuf:=sbuf+FloatToStr(dresult)+' ';
             if ((k+1) mod inewstring = 0) then
             begin
                 patch_s(sbuf);
                fanimationtecplot.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
          patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       // y-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (j=1) then
             begin
                dresult:=Vy[i];
             end;
             if (j=iny) then
             begin
                dresult:=Vy[i+(iny-2)*inx];
             end;

             if ((j<>1) and (j<>iny)) then
             begin
                // линейная интерполяция
                // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                dresult:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
             end;
             sbuf:=sbuf+FloatToStr(dresult)+' ';
             if ((k+1) mod inewstring =0) then
             begin
                patch_s(sbuf);
                fanimationtecplot.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
          patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       // vel-mag
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
           with mapPT[k] do
           begin
              dresult:=0.0; // инициализация
              if (i=1) then dresult:=Vx[1+(j-1)*(inx-1)];
              if (i=inx) then dresult:=Vx[(inx-1)+(j-1)*(inx-1)];
              if ((i<>1) and (i<>inx)) then
              begin
                 // используется линейная интерполяция
                 // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                 // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                 dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                 dresult:=dfe*Vx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*Vx[i+(j-1)*(inx-1)];
              end;
              velmag[i+(j-1)*inx]:=dresult*dresult;
              dresult:=0.0; // инициализация
              if (j=1) then
              begin
                  dresult:=Vy[i];
              end;
              if (j=iny) then
              begin
                 dresult:=Vy[i+(iny-2)*inx];
              end;
              if ((j<>1) and (j<>iny)) then
              begin
                 // линейная интерполяция
                 // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                 // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                 dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                 dresult:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
              end;
              velmag[i+(j-1)*inx]:=velmag[i+(j-1)*inx] + dresult*dresult;
              sbuf:=sbuf+FloatToStr(sqrt(velmag[i+(j-1)*inx]))+' ';
              if ((k+1) mod inewstring =0) then
              begin
                  patch_s(sbuf);
                 fanimationtecplot.Add(sbuf);
                 sbuf:='';
              end;
           end; // with
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
          patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       // SF
         sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(SF[i+(j-1)*inx])+' ';
             if ((k+1) mod inewstring =0) then
             begin
                 patch_s(sbuf);
                fanimationtecplot.Add(sbuf);
                sbuf:='';
             end;
          end; // with
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
          patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       // Давление абсолютное с учётом гидростатического.
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             sbuf:=sbuf+FloatToStr(Pressureabsolute[i+(j-1)*inx])+' ';
             if ((k+1) mod inewstring =0) then
             begin
                patch_s(sbuf);
                fanimationtecplot.Add(sbuf);
                sbuf:='';
             end;
          end;
       end;
       if ((imaxnumbernode+1) mod inewstring <> 0) then
       begin
          patch_s(sbuf);
          fanimationtecplot.Add(sbuf);
       end;

       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                   begin
                      // все четыре узла внутренние
                      sbuf:=IntToStr(number[i+(j-1)*inx])+' '+
                      IntToStr(number[i+1+(j-1)*inx])+' '
                      +IntToStr(number[i+1+(j)*inx])+' '
                      +IntToStr(number[i+(j)*inx])+' ';
                      fanimationtecplot.Add(sbuf);
                   end;
             end;
          end; // with
       end;

   end
    else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Вихрь
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь на данной сетке.');
               MainMemo.Lines.Add('Вихрь не может быть отображён.');
               Application.MessageBox(PChar('Вы не рассчитывали вихрь на данной сетке.'),PChar(''),MB_OK);
            end;
        2 : // Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли функцию тока на данной сетке.');
               MainMemo.Lines.Add(' функция тока не может быть отображена.');
               Application.MessageBox(PChar('Вы не рассчитывали функцию тока на данной сетке.'),PChar(''),MB_OK);
            end;
        3 : // распределение температуры
            begin
               MainMemo.Lines.Add('Вы не вычисляли поле температур на данной сетке.');
               MainMemo.Lines.Add('поле температур не может быть отображено.');
               Application.MessageBox('warning','Вы не рассчитывали поле температур на данной сетке.',MB_OK);
            end;
        4 : // распределение горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение x-velocity на данной сетке.');
               MainMemo.Lines.Add('x-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение x-velocity на данной сетке.','warning',MB_OK);
            end;
        5 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение y-velocity на данной сетке.');
               MainMemo.Lines.Add('y-velocity не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали распределение y-velocity на данной сетке.','warning',MB_OK);
            end;
        6 : // распределение давления
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение давления на данной сетке.');
               MainMemo.Lines.Add('поле давления не может быть отображено.');
               Application.MessageBox('Вы не рассчитывали давление на данной сетке.','warning',MB_OK);
            end;
        7 : // распределение функции цвета.
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение функции цвета на данной сетке.');
               MainMemo.Lines.Add('функция цвета не может быть отображена.');
               Application.MessageBox('Вы не рассчитывали функцию цвета на данной сетке.','warning',MB_OK);
            end;
      end;

   end;
end; // animationBody

// создаёт файл для программы tecplot
// со всеми расчитанными функциями.
// в программу tecplot:
//
// 1 -  вихрь,
// 2 -  температура,
// 3 -  горизонтальная скорость,
// 4 -  вертикальная скорость,
// векторное поле скоростей может быть автоматически
// сгенерировано используя пункты 3 и 4.
// 5 -  модуль скорости,
// 6 -  функция тока,
// 7 - давление.
procedure TForm1.exporttecplotUniversalComplete;
var
   f : TStrings; // переменная типа объект TStringList
   sbuf : String; // имя создаваемого файла
   fname, scor : String;
   iNum, iE, kscan : Integer;
   i1,j1,k,ius : Integer; // Счётчики
   number : array of Integer; // массив с номерами узлов
   ihigh : Integer; // для согласования сеток проверка ошибок
   dfe, dresult : Float; // для компонент скорости
   ifuncexport : Integer; // где случилась ошибка
   velmag, ubuf1, ubuf2 : array of Float; //  модуль скорости

begin
   // инициализация

   // Здесь нужно предусмотреть защиту
   // если размер массива не совпадает с размером сетки
   // то значит мы будет обращатся по несуществующему адресу
   // и это вызовет ошибку приложения
   // выделение памяти
     SetLength(velmag,inx*iny+1);
     // инициализация
     for i1:=1 to inx do
     begin
         for j1:=1 to iny do
         begin
             velmag[i1+(j1-1)*inx]:=0.0;
         end;
     end;

     ifuncexport:=1; // инициализация.

     // по умолчанию проверка на несоответствие сетки и вычисляемой функции
     // для вихря.
     ihigh:= High(Omega) - (mzapas*inx*iny); // вихрь
     if (ihigh=0) then
     begin
        ihigh:= High(SF) - (mzapas*inx*iny); // функция тока
     end
      else
     begin
        ifuncexport:=1;
     end;
     if ((Form1.imodelEquation=1) or (Form1.imodelEquation=4) ) then
     begin
        if (ihigh=0) then
        begin
           ihigh:= High(T) - (mzapas*inx*iny); //  температура
        end
         else
        begin
           ifuncexport:=2;
        end;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Vx) - (mzapas*(inx-1)*iny); //  горизонтальная компонента скорости
     end
      else
     begin
        ifuncexport:=3;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Vy) - (mzapas*inx*(iny-1)); //  вертикальная компонента скорости
     end
      else
     begin
        ifuncexport:=4;
     end;
     if (ihigh=0) then
     begin
        ihigh:= High(Pressureabsolute) - (mzapas*inx*iny); // давление
     end
      else
     begin
        ifuncexport:=5;
     end;
     if (ihigh<>0) then ifuncexport:=6;
     if (ihigh=0) then
     begin
        if (Form1.imodelEquation=5) then
        begin
           // VOF method.
           ihigh:= High(VOF) - (mzapas*inx*iny); //  функция цвета.
        end;
     end
      else
     begin
        ifuncexport:=6;
     end;
     if (Form1.imodelEquation=5) then
     begin
        if (ihigh<>0) then ifuncexport:=7;
     end;


   if (ihigh = 0) then
   begin
       // число элементов в соответствующем массиве соответствует размерности сетки
       // iNum:=inx*iny; // число узлов
       iNum:=imaxnumbernode;
       // iE:=(inx-1)*(iny-1); // число прямоугольников
       iE:=0;
       // подсчёт количества ячеек сетки.
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j-1)*inx].itypenode > 0) and
                    (GridGenForm.tnm[(i+1)+(j)*inx].itypenode > 0) and
                    (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                begin
                   // все четыре узла внутренние
                   inc(iE);
                end;
             end;
          end;
       end;
       // экспортирует данные в программу tecplot
       f:=TStringList.Create();
       f.Add('TITLE = " CFD Vahl-DavisTestDelphi "');
       if ((Form1.imodelEquation=1) or (Form1.imodelEquation=4) ) then
       begin
          f.Add('VARIABLES = X,Y, "omega", "T", "grad x temperature", "grad y temperature", "magnitude grad temperature", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure_absolute"');
       end
        else if (Form1.imodelEquation=3) then
       begin
          // Чистая гидродинамика.
          f.Add('VARIABLES = X,Y, "omega", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure_absolute"');
       end
        else if (Form1.imodelEquation=5) then
       begin
          // Гидродинамика и VOF метод.
          f.Add('VARIABLES = X,Y, "Phases", "omega", "x-velocity", "y-velocity", "vel-mag", "SF", "Pressure_absolute"');
       end;

       // отладочная печать.
       //ShowMessage('inx*iny='+IntToStr(inx*iny)+'iNum'+IntToStr(imaxnumbernode));
       iNum:=1;
       SetLength(number,inx*iny+1);
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin                                                                     //m
          //number[mapPT[i].i+(mapPT[i].j-1)*inx]:=i; // уникальные номера для каждого узла
          number[mapPT[k].i+(mapPT[k].j-1)*inx]:=iNum;
          inc(iNum);
       end;                                                                         //m
       end;

       dec(iNum);

       f.Add('ZONE T="Rampant", N='+IntToStr(iNum)+', E='+IntToStr(iE)+' ET=QUADRILATERAL, F=FEBLOCK');
       f.Add('');



       // значения X
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(lengthscaleplot.xscale*xpos[i]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf + scor+' ';
             if ((k+1) mod 10 = 0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
          end; // with
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Значения Y
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(lengthscaleplot.yscale*ypos[j]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf + scor+' ';
             if ((k+1) mod 10 = 0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       if (Form1.imodelEquation=5) then
       begin

          // VOF method
          sbuf:='';
          for k:=1 to imaxnumbernode do
          begin
          if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
             with mapPT[k] do
             begin
                scor:=FloatToStr(VOF[i+(j-1)*inx]);
                for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                sbuf:=sbuf+scor+' ';
                if ((k+1) mod 10 =0) then
                begin
                   f.Add(sbuf);
                   sbuf:='';
                end;
             end;
            end;
          end;
          if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);
       end;

       // Omega
       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(Omega[i+(j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

        if ((Form1.imodelEquation=1 )or (Form1.imodelEquation=4)) then
        begin
           // T
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
           if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
              with mapPT[k] do
              begin
                 scor:=FloatToStr(T[i+(j-1)*inx]);
                 for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                 sbuf:=sbuf+scor+' ';
                 if ((k+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
              end;//with
              end;
           end;
           if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


              // градиент температуры по х
              SetLength(ubuf1,inx*iny+1);
              universalgradx_mapPT(T,ubuf1);
              // градиент температуры по y
              SetLength(ubuf2,inx*iny+1);
              universalgrady_mapPT(T,ubuf2);

              // grad x Temperature
              sbuf:='';
              for k:=1 to imaxnumbernode do
              begin
                 if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
                 begin
                    with mapPT[k] do
                    begin
                       scor:=FloatToStr(ubuf1[i+(j-1)*inx]);
                       for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                       sbuf:=sbuf+scor+' ';
                       if ((k+1) mod 10 =0) then
                       begin
                          f.Add(sbuf);
                          sbuf:='';
                       end;
                    end;
                 end;
                 end;
                 if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);


           // grad y Temperature
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
           if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
              with mapPT[k] do
              begin
                 scor:=FloatToStr(ubuf2[i+(j-1)*inx]);
                 for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                 sbuf:=sbuf+scor+' ';
                 if ((k+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
              end;// with
              end;
              end;
           if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);



        // magnitude grad  Temperature
           sbuf:='';
           for k:=1 to imaxnumbernode do
           begin
           if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
              with mapPT[k] do
              begin
                 scor:=FloatToStr(sqrt(sqr(ubuf1[i+(j-1)*inx])+sqr(ubuf2[i+(j-1)*inx])));
                 for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
                 sbuf:=sbuf+scor+' ';
                 if ((k+1) mod 10 =0) then
                 begin
                    f.Add(sbuf);
                    sbuf:='';
                 end;
              end;// with
              end;
              end;
           if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);



           SetLength(ubuf1,0);
           SetLength(ubuf2,0);

        end;                  

       // x-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (i=1) then dresult:=Vx[1+(j-1)*(inx-1)];
             if (i=inx) then dresult:=Vx[(inx-1)+(j-1)*(inx-1)];
             if ((i<>1) and (i<>inx)) then
             begin
                // используется линейная интерполяция
                // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                dresult:=dfe*Vx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*Vx[i+(j-1)*(inx-1)];
             end;
             scor:=FloatToStr(dresult);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // y-velocity
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
          with mapPT[k] do
          begin
             dresult:=0.0; // инициализация
             if (j=1) then
             begin
                dresult:=Vy[i];
             end;
             if (j=iny) then
             begin
                dresult:=Vy[i+(iny-2)*inx];
             end;

             if ((j<>1) and (j<>iny)) then
             begin
                // линейная интерполяция
                // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                dresult:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
             end;
             scor:=FloatToStr(dresult);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // vel-mag
        sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
           with mapPT[k] do
           begin
              dresult:=0.0; // инициализация
              if (i=1) then dresult:=Vx[1+(j-1)*(inx-1)];
              if (i=inx) then dresult:=Vx[(inx-1)+(j-1)*(inx-1)];
              if ((i<>1) and (i<>inx)) then
              begin
                 // используется линейная интерполяция
                 // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                 // из книжки С.Патанкара. (это лучше для неравномерных сеток).
                 dfe:=(xpos[i+1]-xpos[i])/(xpos[i+1]-xpos[i-1]); // учёт неравномерности сетки
                 dresult:=dfe*Vx[(i-1)+(j-1)*(inx-1)]+(1-dfe)*Vx[i+(j-1)*(inx-1)];
              end;
              velmag[i+(j-1)*inx]:=dresult*dresult;
              dresult:=0.0; // инициализация
              if (j=1) then
              begin
                  dresult:=Vy[i];
              end;
              if (j=iny) then
              begin
                 dresult:=Vy[i+(iny-2)*inx];
              end;
              if ((j<>1) and (j<>iny)) then
              begin
                 // линейная интерполяция
                 // в промежуточном узле скорость задаётся по формуле (3.5) и (3.6)
                 // из книжки С. Патанкара. (это лучше для неравномерных сеток).
                 dfe:=(ypos[j+1]-ypos[j])/(ypos[j+1]-ypos[j-1]);
                 dresult:=dfe*Vy[i+(j-2)*inx]+(1-dfe)*Vy[i+(j-1)*inx];
              end;
              velmag[i+(j-1)*inx]:=velmag[i+(j-1)*inx] + dresult*dresult;
              scor:=FloatToStr(sqrt(velmag[i+(j-1)*inx]));
              for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
              sbuf:=sbuf+scor+' ';
              if ((k+1) mod 10 =0) then
              begin
                 f.Add(sbuf);
                 sbuf:='';
              end;
           end; // with
           end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // SF
         sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(SF[i+(j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end; // with
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       // Давление абсолютное с учётом гидростатического.
       sbuf:='';
       for k:=1 to imaxnumbernode do
       if (GridGenForm.tnm[mapPT[k].i+(mapPT[k].j-1)*inx].itypenode > 0) then //m
       begin
       begin
          with mapPT[k] do
          begin
             scor:=FloatToStr(Pressureabsolute[i+(j-1)*inx]);
             for kscan:=1 to length(scor) do
             begin
                if (scor[kscan]=',') then
                begin
                   scor[kscan]:='.';
                end;
             end;
             sbuf:=sbuf+scor+' ';
             if ((k+1) mod 10 =0) then
             begin
                f.Add(sbuf);
                sbuf:='';
             end;
          end;
          end;
       end;
       if ((imaxnumbernode+1) mod 10 <> 0) then f.Add(sbuf);

       sbuf:='';
       for k:=1 to imaxnumbernode do
       begin
          with mapPT[k] do
          begin
             if ((i < inx) and (j < iny)) then
             begin
                if ((GridGenForm.tnm[i+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j-1)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+1+(j)*inx].itypenode > 0) and
                   (GridGenForm.tnm[i+(j)*inx].itypenode > 0)) then
                   begin
                      // все четыре узла внутренние
                      sbuf:=IntToStr(number[i+(j-1)*inx])+' '+
                      IntToStr(number[i+1+(j-1)*inx])+' '
                      +IntToStr(number[i+1+(j)*inx])+' '
                      +IntToStr(number[i+(j)*inx])+' ';
                      f.Add(sbuf);
                   end;
             end;
          end; // with
       end;

       fname:='CFDFlow.PLT';
       f.SaveToFile(fname);
       ShellExecute(Form1.Handle, nil,'tec360',PChar(fname),nil,SW_SHOW);
       f.Free;
   end
    else
   begin
      // печать диагностического сообщения
      case ifuncexport of
        1 : // Вихрь
            begin
               MainMemo.Lines.Add('Вы не вычисляли вихрь на данной сетке.');
               MainMemo.Lines.Add('Вихрь не может быть отображён.');
               Application.MessageBox(PChar('Вы не рассчитывали вихрь на данной сетке.'),PChar(''),MB_OK);
            end;
        2 : // Функция-тока
            begin
               MainMemo.Lines.Add('Вы не вычисляли функцию тока на данной сетке.');
               MainMemo.Lines.Add(' функция тока не может быть отображена.');
               Application.MessageBox(PChar('Вы не рассчитывали функцию тока на данной сетке.'),PChar(''),MB_OK);
            end;
        3 : // распределение температуры
            begin
               MainMemo.Lines.Add('Вы не вычисляли поле температур на данной сетке.');
               MainMemo.Lines.Add('поле температур не может быть отображено.');
               Application.MessageBox(PChar('Вы не рассчитывали поле температур на данной сетке.'),PChar(''),MB_OK);
            end;
        4 : // распределение горизонтальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение x-velocity на данной сетке.');
               MainMemo.Lines.Add('x-velocity не может быть отображено.');
               Application.MessageBox(PChar('Вы не рассчитывали распределение x-velocity на данной сетке.'),PChar(''),MB_OK);
            end;
        5 : // распределение вертикальной компоненты скорости
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение y-velocity на данной сетке.');
               MainMemo.Lines.Add('y-velocity не может быть отображено.');
               Application.MessageBox(PChar('Вы не рассчитывали распределение y-velocity на данной сетке.'),PChar(''),MB_OK);
            end;
        6 : // распределение давления
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение давления на данной сетке.');
               MainMemo.Lines.Add('поле давления не может быть отображено.');
               Application.MessageBox(PChar('Вы не рассчитывали давление на данной сетке.'),PChar(''),MB_OK);
            end;
        7 : // распределение функции цвета.
            begin
               MainMemo.Lines.Add('Вы не вычисляли распределение функции цвета на данной сетке.');
               MainMemo.Lines.Add('функция цвета не может быть отображена.');
               Application.MessageBox(PChar('Вы не рассчитывали функцию цвета на данной сетке.'),PChar(''),MB_OK);
            end;
      end;

   end;
end; //exporttecplotUniversalComplete

// по значениям функции тока находит
// горизонтальную скорость.
procedure TForm1.VxConstruct;
var
   i,j : Integer; // счётчики
   ipi,ini,isi : Integer;
   VxL,VxR : Float; // значения горизонтальной скорости слева и справа
begin
   for i:=1 to (inx-1) do
   begin
      for j:=1 to iny do
      begin
         if ((j>1) and (j<iny)) then
         begin
            ini:=i+j*inx;
            isi:=i+(j-2)*inx;
            VxL:=(SF[ini]-SF[isi])/(ypos[j+1]-ypos[j-1]);
            ini:=(i+1)+j*inx;
            isi:=(i+1)+(j-2)*inx;
            VxR:=(SF[ini]-SF[isi])/(ypos[j+1]-ypos[j-1]);
            ipi:=i+(j-1)*(inx-1);
            Vx[ipi]:=0.5*(VxL+VxR);
         end;
         if (j=1) then
         begin
            ini:=i+j*inx;
            ipi:=i+(j-1)*inx;
            VxL:=(SF[ini]-SF[ipi])/(ypos[j+1]-ypos[j]);
            ini:=(i+1)+j*inx;
            ipi:=(i+1)+(j-1)*inx;
            VxR:=(SF[ini]-SF[ipi])/(ypos[j+1]-ypos[j]);
            ipi:=i+(j-1)*(inx-1);
            Vx[ipi]:=0.5*(VxL+VxR);
         end;
         if (j=iny) then
         begin
            ipi:=i+(j-1)*inx;
            isi:=i+(j-2)*inx;
            VxL:=(SF[ipi]-SF[isi])/(ypos[j]-ypos[j-1]);
            ipi:=(i+1)+(j-1)*inx;
            isi:=(i+1)+(j-2)*inx;
            VxR:=(SF[ipi]-SF[isi])/(ypos[j]-ypos[j-1]);
            ipi:=i+(j-1)*(inx-1);
            Vx[ipi]:=0.5*(VxL+VxR);
         end;
      end;
   end;
end; // VxConstruct

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
procedure TForm1.Vxcoef(i, j : Integer; var m : MatrixCoef; var mf : Float; var attrs : Float);
var
    // номера узлов для Vx на пятиточечном шаблоне
    iei,iwi,ipi,ini,isi : Integer;
    ieei, iwwi, inni, issi : Integer; // Для High Resolution Scheme
    je, jw, jeu, jwu, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu, jywd, jyed : Integer; // номера для компонента скорости Vy
    dfe, dfw, dfn, dfs : Float; // конвективные члены
    dmuA,dmuB : Float; // для двойной интерполяции по dmu
    dge, dgw, dgn, dgs : Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // значения плотности
    dre, drw, drn, drs : Float; // значения плотности
    dikoef    : Float; // интерполяционный коэффициент для Vx скорости
    dde, ddw, ddn, dds : Float;
    dpe,dpw,dpn,dps : Float; // числа Пекле
    dap0 : Float; // нестационарный коэффициент
    f_forvardx, f_backvardx, f_forvardy, f_backvardy: Float; // High Resolution добавка в правую часть.

// модуль вещественного числа
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin
   // Внимание !!! скорость должна браться с предыдущей итерации.

   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка
   ini:=i+(j)*(inx-1);  // север
   isi:=i+(j-2)*(inx-1); // юг
   // for High Resolution Scheme
   iwwi:= i-2+(j-1)*(inx-1);
   ieei:= i+2+(j-1)*(inx-1);
   inni:=i+(j+1)*(inx-1);
   issi:=i+(j-3)*(inx-1);

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*VxOld[ipi]*VxOld[iei]/(VxOld[ipi]+VxOld[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*VxOld[ipi]*VxOld[iwi]/(VxOld[ipi]+VxOld[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   //dfe:=dre*(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   dfe:=(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*0.5*(ypos[j+1]-ypos[j-1]);
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   //dfw:=drw*(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   dfw:=(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*0.5*(ypos[j+1]-ypos[j-1]);
   //drhoA:=2*density(jwu)*density(jw)/(density(jw)+density(jwu)); //двойная
   //drhoB:=2*density(jeu)*density(je)/(density(jeu)+density(je)); // интерполяция
   drhoA:=densuty_in_surface(jwu,jw);
   drhoB:=densuty_in_surface(jeu,je);
   //drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   drn:=0.5*(drhoA+drhoB);
   //dfn:=drn*(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]); // или
   dfn:=(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]);
   //drhoA:=2*density(jw)*density(jwd)/(density(jw)+density(jwd)); // двойная
   //drhoB:=2*density(je)*density(jed)/(density(je)+density(jed)); // интерполяция
   drhoA:=densuty_in_surface(jw,jwd);
   drhoB:=densuty_in_surface(je,jed);
   //drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   drs:=0.5*(drhoA+drhoB);
   //dfs:=drs*(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]); // течения
   dfs:=(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]);

   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма

   (*
   if (bGarberArtDiffusion) then
   begin
      dge:=maxoper(dge,0.25*(xpos[i+2]-xpos[i])*Speede);
      Speede - модуль скорости на грани e.
   end;
   *)


   // Диффузия
   dde:=dge*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+2]-xpos[i]))/dre;  // коэффициенты
   ddw:=dgw*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+1]-xpos[i-1]))/drw;  // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j])/drn;  // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1])/drs;

   dpe:=dfe/dde; // значения
   dpw:=dfw/ddw; // чисел
   dpn:=dfn/ddn; // Пекле
   dps:=dfs/dds;

   if (not(brealisticflow)) then
   begin
      // Без метода отложенной коррекции.
      attrs:=0.0;

      if ( ishconv=1) then
      begin
         // Центрально разностная схема.
         // Без метода отложенной коррекции.
         // 23 августа 2013 года.
         m.dae:=dde - 0.5*dfe;
         m.daw:=ddw + 0.5*dfw;
         m.dan:=ddn - 0.5*dfn;
         m.das:=dds + 0.5*dfs;
      end
       else  if ((ishconv>=2)and(ishconv<=7)) then
      begin
         // все другие схемы без метода отложенной коррекции.

         m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
         m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
         m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
         m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
      end
      else
      begin
         // High Resolution Scheme
         // Неявно учитывается противопоточная схема.

         m.dae:=dde + maxoper(-dfe,0); // коэффициенты
         m.daw:=ddw + maxoper(dfw,0);  // дискретного
         m.dan:=ddn + maxoper(-dfn,0); // аналога
         m.das:=dds + maxoper(dfs,0);

           attrs:=0.0;
           if (is_internal_HO_Vx(iwi,ipi,iei,ieei)) then
           begin
               dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
               f_forvardx:=cell_face_value_global(ishconv,(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei]),VxActing[iwi],VxActing[ipi],VxActing[iei],VxActing[ieei]);
               attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-VxActing[ipi])+maxoper(-dfe,0.0)*(f_forvardx-VxActing[iei]);
           end;
           if (is_internal_HO_Vx(iwwi,iwi,ipi,iei)) then
           begin
               dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
               f_backvardx:=cell_face_value_global(ishconv,(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi]),VxActing[iwwi],VxActing[iwi],VxActing[ipi],VxActing[iei]);
               attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-VxActing[ipi])+maxoper(dfw,0.0)*(f_backvardx-VxActing[iwi]);
           end;
           if (is_internal_HO_Vx(isi,ipi,ini,inni)) then
           begin
              f_forvardy:= cell_face_value_global(ishconv,(0.5*(VyActing[jywu]+VyActing[jyeu])),VxActing[isi],VxActing[ipi],VxActing[ini],VxActing[inni]);
              attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-VxActing[ipi])+maxoper(-dfn,0.0)*(f_forvardy-VxActing[ini]);
           end;
           if (is_internal_HO_Vx(issi,isi,ipi,ini)) then
           begin
              f_backvardy:= cell_face_value_global(ishconv,(0.5*(VyActing[jywd]+VyActing[jyed])),VxActing[issi],VxActing[isi],VxActing[ipi],VxActing[ini]);
              attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-VxActing[ipi])+maxoper(dfs,0.0)*(f_backvardy-VxActing[isi]);
           end;

      end;
   end
   else
   begin
       // с методом отлженной коррекции.
       if (ishconv=1) then
       begin
          // для центрально разностной схемы.

          // Неявно учитывается противопоточная часть а для неё
          // ApproxConvective(abs(dpe),ishconvtemp)=1.0
          m.dae:=dde+maxoper(-dfe,0);
          m.daw:=ddw+maxoper(dfw,0);
          m.dan:=ddn+maxoper(-dfn,0);
          m.das:=dds+maxoper(dfs,0);


          // Центрально-разностная схема второго порядка точности с помощью
          // метода отложенной коррекции (неявно учитывается противопоточная часть).
           attrs:=0.0;
           //f_forvardx:=0.5*(VxActing[ipi]+VxActing[iei]);
           f_forvardx:=((xpos[i+2]-xpos[i+1])*VxActing[ipi]+(xpos[i+1]-xpos[i])*VxActing[iei])/(xpos[i+2]-xpos[i]);
           attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-VxActing[ipi])+maxoper(-dfe,0.0)*(f_forvardx-VxActing[iei]);
           //f_backvardx:=0.5*(VxActing[ipi]+VxActing[iwi]);
           f_backvardx:=((xpos[i+1]-xpos[i])*VxActing[iwi]+(xpos[i]-xpos[i-1])*VxActing[ipi])/(xpos[i+1]-xpos[i-1]);
           attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-VxActing[ipi])+maxoper(dfw,0.0)*(f_backvardx-VxActing[iwi]);
           f_forvardy:=0.5*(VxActing[ipi]+VxActing[ini]);
           attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-VxActing[ipi])+maxoper(-dfn,0.0)*(f_forvardy-VxActing[ini]);
           f_backvardy:=0.5*(VxActing[ipi]+VxActing[isi]);
           attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-VxActing[ipi])+maxoper(dfs,0.0)*(f_backvardy-VxActing[isi]);
       end
        else
       begin
          Application.MessageBox('схема не предусмотрена програмистом','ERROR!',MB_OK);
       end;
   end;



   if (btimedepend) then
   begin
      // нестационарный

      // с постоянным шагом по времени
      //drhoA:=2*density(jw)*density(je)/(density(jw)+density(je));
      //drhoA:=densuty_in_surface(jw,je);
      if (bsecondorderflow) then
      begin
         // Схема Пейре
         //dap0:=1.5*drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         dap0:=1.5*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
      end
       else
      begin
         // Схема Эйлера.
         //dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         dap0:=(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
      end;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
   end;

    if (ApproxConvectionForm.CheckBoxKIvanovApprox.Checked) then
    begin
       if (not(brealisticflow)) then
       begin
          // метод отложенной коррекции не используется:

          if ( ishconv=1) then
          begin
             // Обычная центрально разностная схема.
              m.dap:= dde+ddw+ddn+dds+0.5*(dfe-dfw+dfn-dfs) + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
          end
            else
           begin
              // другие схемы без метода отложенной коррекции:
              m.dap:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv)+maxoper(-dfs,0)+ dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
           end;
       end
       else
       begin
          if (ishconv=1) then
          begin
             // Центральные разности с учетом метода отложенной коррекции
             m.dap:=dde+maxoper(dfe,0)+ddw+maxoper(-dfw,0)+ddn+maxoper(dfn,0)+dds+maxoper(-dfs,0)+ dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
          end
           else
          begin
             Application.MessageBox('схема не предусмотрена програмистом','ERROR!',MB_OK);
          end;
        end; // метод отложенной коррекции
    end
    else
    begin
        // Общепринятая схема (не Иванова).
        m.dap:= m.dae + m.daw + m.dan + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
     end;



   if ((bISezai) and (not(btimedepend))) then
   begin
      if (ApproxConvectionForm.CheckBoxISezainofabs.Checked) then
      begin
         // возможное ослабление диагонали.
         mf:=(dfe-dfw+dfn-dfs);
      end
      else
      begin
         // только усиление диагонали.
         mf:=fabs(dfe-dfw+dfn-dfs);
      end;
      m.dap:=m.dap+mf;
   end;


   // debug
   if (m.dap<1.0e-30) then
   begin
      bweShouldContinue:=False; // остановить вычисления.
      MainMemo.Lines.Add('FATAL ERROR');
      MainMemo.Lines.Add(PChar('Diffusion: De='+FloatTOStr(dge)+'Dw='+FloatTOStr(dgw)+'Dn='+FloatTOStr(dgn)+'Ds='+FloatTOStr(dgs)));
      MainMemo.Lines.Add(PChar('Convection: Fe='+FloatToStr(dfe)+'Fw='+FloatToStr(dfw)+'Fn='+FloatToStr(dfn)+'Fs='+FloatToStr(dfs)));
      MainMemo.Lines.Add(PChar('Vxcoef function : ap='+FloatToStr(m.dap)+'ae='+FloatToStr(m.dae)+'aw='+FloatToStr(m.daw)+'an='+FloatToStr(m.dan)+'as='+FloatToStr(m.das)));
   end;

end; // Vxcoef

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// для нижней границы
procedure TForm1.VxcoefBottom(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    iei,iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu : Integer; // номера для компонента скорости Vy
    dfe, dfw, dfn : Float; // конвективные члены
    dmuA,dmuB : Float; // для двойной интерполяции по dmu
    dge, dgw, dgn : Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // значения плотности
    dre, drw, drn : Float; // значения плотности
    dikoef    : Float; // интерполяционный коэффициент для Vx скорости
    dde, ddw, ddn : Float;
    dpe,dpw,dpn : Float; // числа Пекле
    dap0 : Float; // нестационарный коэффициент
    dSquare : Float; // площадь контрольного объёма.

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;


   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка


    // нижняя граница.  Площадь контрольного объёма.
   dSquare:=0.5*(ypos[j+1]-ypos[j]);

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*VxOld[ipi]*VxOld[iei]/(VxOld[ipi]+VxOld[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*VxOld[ipi]*VxOld[iwi]/(VxOld[ipi]+VxOld[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   //dfe:=dre*(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*dSquare; // интенсивность
   dfe:=(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*dSquare;
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   //dfw:=drw*(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*dSquare; // конвекции
   dfw:=(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*dSquare;
   drhoA:=densuty_in_surface(jwu,jw); //двойная
   drhoB:=densuty_in_surface(jeu,je); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   //dfn:=drn*(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]); // или
   dfn:=(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]);


   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   // Диффузия
   dde:=dge*(dSquare)/(0.5*(xpos[i+2]-xpos[i]))/dre;  // коэффициенты
   ddw:=dgw*(dSquare)/(0.5*(xpos[i+1]-xpos[i-1]))/drw;  // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j])/drn;  // аналога


   dpe:=dfe/dde; // значения
   dpw:=dfw/ddw; // чисел
   dpn:=dfn/ddn; // Пекле
   //m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
   //m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
   m.dae:=0.0;
   m.daw:=0.0;
   if ((ishconv>=1)and(ishconv<=7)) then
   begin
      m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
   end
    else
   begin
      m.dan:=ddn + maxoper(-dfn,0); // аналога
   end;
   m.das:=0.0; //dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
      //drhoA:=densuty_in_surface(jw,je);
      if (bsecondorderflow) then
      begin
          //dap0:=1.5*drhoA*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         dap0:=1.5*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         db:=(2.0*VxOldTimeStep[ipi]-0.5*VxOldOldTimeStep[ipi])*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
      end
      else
      begin
         //dap0:=drhoA*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         dap0:=(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         db:=dap0*VxOldTimeStep[ipi];
      end;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
     db:=0.0;
   end;


   m.dap:= m.dae + m.daw + m.dan  + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(dSquare);
   //m.dap:= dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0)+ dap0 - dSpVx*(xpos[i+1]-xpos[i])*(dSquare);

end; // VxcoefBottom

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// для выходной границы
procedure TForm1.VxcoefTop(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    iei,iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywd, jyed : Integer; // номера для компонента скорости Vy
    dfe, dfw, dfs : Float; // конвективные члены
    dmuA,dmuB : Float; // для двойной интерполяции по dmu
    dge, dgw,  dgs : Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drs : Float; // значения плотности
    dikoef    : Float; // интерполяционный коэффициент для Vx скорости
    dde, ddw, dds : Float;
    dpe,dpw,dps : Float; // числа Пекле
    dap0 : Float; // нестационарный коэффициент
    dSquare : Float; // площадь грани контрольного объёма.

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // верхняя граница.  Площадь контрольного объёма.
   dSquare:=0.5*(ypos[j]-ypos[j-1]);

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*VxActing[ipi]*VxActing[iei]/(VxActing[ipi]+VxActing[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*VxActing[ipi]*VxActing[iwi]/(VxActing[ipi]+VxActing[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
  // dfe:=dre*(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*dSquare; // интенсивность
    dfe:=(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*dSquare;
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   //dfw:=drw*(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*dSquare; // конвекции
    dfw:=(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*dSquare;
   // или
   drhoA:=densuty_in_surface(jw,jwd); // двойная
   drhoB:=densuty_in_surface(je,jed); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   //dfs:=drs*(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]); // течения
   dfs:=(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]);

   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия
   dde:=dge*(dSquare)/(0.5*(xpos[i+2]-xpos[i]))/dre;  // коэффициенты
   ddw:=dgw*(dSquare)/(0.5*(xpos[i+1]-xpos[i-1]))/drw;  // дискретного
     // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1])/drs;

   dpe:=dfe/dde; // значения
   dpw:=dfw/ddw; // чисел
   // Пекле
   dps:=dfs/dds;
  // m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
  // m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
  m.dae:=0.0;
  m.daw:=0.0;
   m.dan:=0.0;// аналога
   if ((ishconv>=1)and(ishconv<=7)) then
   begin
      m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
   end
   else
   begin
      m.das:=dds + maxoper(dfs,0);
   end;

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
       if (bsecondorderflow) then
      begin
         //drhoA:=densuty_in_surface(jw,je);
         // dap0:=1.5*drhoA*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         dap0:=1.5*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         db:=(2.0*VxOldTimeStep[ipi]-0.5*VxOldOldTimeStep[ipi])*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
      end
      else
      begin
         //drhoA:=densuty_in_surface(jw,je);
         // dap0:=drhoA*(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         dap0:=(xpos[i+1]-xpos[i])*(dSquare)/dTimeStep;
         db:=dap0*VxOldTimeStep[ipi];
      end;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
     db:=0.0;
   end;

   m.dap:= m.dae + m.daw  + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(dSquare);
   //m.dap:= dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0) +ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0)+ dap0 - dSpVx*(xpos[i+1]-xpos[i])*(dSquare);

end; // VxcoefTop

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j в случае когда этот узел находится на правой выходной границе
procedure TForm1.VxcoefRight(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    iwi,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu, jywd, jyed : Integer; // номера для компонента скорости Vy
    dfw, dfn, dfs : Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    drw, drn, drs : Float; // значения плотности
    dikoef    :  Float; // интерполяционный коэффициент для Vx скорости
    ddw, ddn, dds :  Float;
    dpw,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iwi:=i-1+(j-1)*(inx-1); // запад
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*Vx[ipi]*Vx[iei]/(Vx[ipi]+Vx[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*Vx[ipi]*Vx[iwi]/(Vx[ipi]+Vx[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   // интенсивность
   dikoef:=(xpos[i+1]-xpos[i])/(xpos[i]-xpos[i-1]);
   drw:=density(jw);
   //dfw:=drw*(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   dfw:=(dikoef*VxActing[iwi]+(1-dikoef)*VxActing[ipi])*0.5*(ypos[j+1]-ypos[j-1]);
   drhoA:=densuty_in_surface(jwu,jw); //двойная
   drhoB:=densuty_in_surface(jeu,je); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   //dfn:=drn*(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]); // или
   dfn:=(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]);
   drhoA:=densuty_in_surface(jw,jwd); // двойная
   drhoB:=densuty_in_surface(je,jed); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   //dfs:=drs*(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]); // течения
   dfs:=(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]);

   // переменная динамическая вязкость
   // динамическая вязкость
   dgw:=viscosity(jw); // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия

   ddw:=dgw*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+1]-xpos[i-1]))/drw;  // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j])/drn;  // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1])/drs;

   // значения
   dpw:=dfw/ddw; // чисел
   dpn:=dfn/ddn; // Пекле
   dps:=dfs/dds;
   m.dae:=0.0; // нет влияния справа, так как поток справа неизвестен
   if ((ishconv>=1)and(ishconv<=7)) then
   begin
      m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
   end
   else
   begin
       m.daw:=ddw + maxoper(dfw,0);
   end;
   //m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
   //m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
   m.dan:=0.0;
   m.das:=0.0;

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
       if (bsecondorderflow) then
      begin
         //drhoA:=densuty_in_surface(jw,je);
         //dap0:=1.5*drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         dap0:=1.5*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         db:=(2.0*VxOldTimeStep[ipi]-0.5*VxOldOldTimeStep[ipi])*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
      end
      else
      begin
         //drhoA:=densuty_in_surface(jw,je);
         //dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         dap0:=(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         db:=dap0*VxOldTimeStep[ipi];
      end;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
     db:=0.0;
   end;

   m.dap:= 0.0 + m.daw + m.dan + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
  // m.dap:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+ ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0) +dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
end; // VxcoefRight

// данная процедура по позиции i,j в матрице для Vx
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// в случае когда выходная граница находится слева
procedure TForm1.VxcoefLeft(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    iei,ipi : Integer; // номера узлов для Vx на пятиточечном шаблоне
    je, jw, jeu, jwu, jed, jwd : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jywu, jyeu, jywd, jyed : Integer; // номера для компонента скорости Vy
    dfe, dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // значения плотности
    dre, drn, drs : Float; // значения плотности
    dikoef    :  Float; // интерполяционный коэффициент для Vx скорости
    dde, ddn, dds :  Float;
    dpe,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin
   //  номера узлов для массива Vx
   // здесь они присутствуют из-за нелинейности уравнения
   iei:=i+1+(j-1)*(inx-1); // восток
   ipi:=i+(j-1)*(inx-1); // текущая точка

   // номера обычных узлов для переменных T и P
   je:=(i+1)+(j-1)*inx; // для обычных переменных
   jw:=i+(j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
   jeu:=(i+1)+j*inx;  // u - up верхние узлы
   jwu:=i+j*inx;
   jed:=(i+1)+(j-1)*inx;  // d - douwn нижние узлы
   jwd:=i+(j-1)*inx;

   // точки для компонента скорости Vy
   jywu:=i+(j-1)*inx;      // (w - левая , u - верхняя) точка
   jyeu:=(i+1)+(j-1)*inx;  // (e - правая, u - верхняя) точка
   jywd:=i+(j-2)*inx;      // (w - левая, d - нижняя) точка
   jyed:=(i+1)+(j-2)*inx;  // (e - правая, d - нижняя) точка

   // осторожно нелинейность
   // такая интерполяция для Vx скорости по-моему работает только для равномерной сетки
   // скорость может принимать  значения разных знаков значение суммы может быть равно нулю
   // но для очень резких изменений скорости эта аппроксимация вроде лучше
   //dfe:=drho*(2*VxOld[ipi]*VxOld[iei]/(VxOld[ipi]+VxOld[iei]))*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
   //dfw:=drho*(2*VxOld[ipi]*VxOld[iwi]/(VxOld[ipi]+VxOld[iwi]))*0.5*(ypos[j+1]-ypos[j-1]); // конвекции
   // здесь предполагается линейное изменение скорости
   // причём учитывается неравномерность расчётной сетки через dikoef
   dikoef:=(xpos[i+2]-xpos[i+1])/(xpos[i+1]-xpos[i]);
   dre:=density(je);
   //dfe:=dre*(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*0.5*(ypos[j+1]-ypos[j-1]); // интенсивность
    dfe:=(dikoef*VxActing[ipi]+(1-dikoef)*VxActing[iei])*0.5*(ypos[j+1]-ypos[j-1]);
    // конвекции
   drhoA:=densuty_in_surface(jwu,jw); //двойная
   drhoB:=densuty_in_surface(jeu,je); // интерполяция
   drn:= 2*drhoA*drhoB/(drhoA+drhoB); // контрольного
   //dfn:=drn*(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]); // или
   dfn:=(0.5*(VyActing[jywu]+VyActing[jyeu]))*(xpos[i+1]-xpos[i]);
   drhoA:=densuty_in_surface(jw,jwd); // двойная
   drhoB:=densuty_in_surface(je,jed); // интерполяция
   drs:=2*drhoA*drhoB/(drhoA+drhoB); // объёма
   //dfs:=drs*(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]); // течения
   dfs:=(0.5*(VyActing[jywd]+VyActing[jyed]))*(xpos[i+1]-xpos[i]);

   // переменная динамическая вязкость
   dge:=viscosity(je); // динамическая вязкость
    // на грани
   dmuA:=2*viscosity(jwu)*viscosity(jw)/(viscosity(jw)+viscosity(jwu)); //двойная
   dmuB:=2*viscosity(jeu)*viscosity(je)/(viscosity(jeu)+viscosity(je)); // интерполяция
   dgn:=2*dmuA*dmuB/(dmuA+dmuB); // контрольного
   dmuA:=2*viscosity(jw)*viscosity(jwd)/(viscosity(jw)+viscosity(jwd)); // двойная
   dmuB:=2*viscosity(je)*viscosity(jed)/(viscosity(je)+viscosity(jed)); // интерполяция
   dgs:=2*dmuA*dmuB/(dmuA+dmuB); // объёма
   // Диффузия
   dde:=dge*(0.5*(ypos[j+1]-ypos[j-1]))/(0.5*(xpos[i+2]-xpos[i]))/dre;  // коэффициенты
     // дискретного
   ddn:=dgn*(xpos[i+1]-xpos[i])/(ypos[j+1]-ypos[j])/drn;  // аналога
   dds:=dgs*(xpos[i+1]-xpos[i])/(ypos[j]-ypos[j-1])/drs;

   dpe:=dfe/dde; // значения
    // чисел
   dpn:=dfn/ddn; // Пекле
   dps:=dfs/dds;
   if ((ishconv>=1)and(ishconv<=7)) then
   begin
      m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
   end
   else
   begin
      m.dae:=dde + maxoper(-dfe,0);
   end;
   m.daw:=0.0;  // дискретного
  // m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
  // m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
  m.dan:=0.0;
  m.das:=0.0;

   if (btimedepend) then
   begin
      // нестационарный
      // с постоянным шагом по времени
       if (bsecondorderflow) then
      begin
          //drhoA:=densuty_in_surface(jw,je);
          //dap0:=1.5*drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
          dap0:=1.5*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
          db:=(2.0*VxOldTimeStep[ipi]-0.5*VxOldOldTimeStep[ipi])*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
      end
      else
      begin
         //drhoA:=densuty_in_surface(jw,je);
         //dap0:=drhoA*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         dap0:=(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]))/dTimeStep;
         db:=dap0*VxOldTimeStep[ipi];
      end;
   end
   else
   begin
     // стационарный
     dap0:=0.0;
     db:=0.0;
   end;

   m.dap:= m.dae  + m.dan + m.das + dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
   //m.dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0)+ dap0 - dSpVx*(xpos[i+1]-xpos[i])*(0.5*(ypos[j+1]-ypos[j-1]));
end; // VxcoefLeft



// коэффициенты дискретного аналога для
// горизонтальной компоненты скорости
procedure TForm1.VxGlobalCoef(var mglobal : array of MatrixCoef;  // все коэффициенты дискретного аналога
                              var dbglobal : array of  Float;
                              bPressureSimpler : Boolean);  // часть источникового члена

var
   m  : MatrixCoef; // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   ipi : Integer; // текущая узловая точка для Vx на пятиточечном шаблоне
   je, jw : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
   drhointerpol, drhoold : Float; // для интерполяции плотности
   db :  Float; // коэффициент
   dpressure :  Float; // действующий градиент давления
   i, i1 : Integer; // счётчики
   dap0 :  Float; // нестационарный коэффициент
   dgxeffective :  Float; // эффективное ускорение свободного падения (нужно для вибрационного воздействия).
   rBodyForceBussinesknew, rBodyForceBussineskold :  Float; // учёт приближения Буссинеска
   bout : Boolean; // условие на выходной границе
   dSquare : Float; // Площадь грани контрольного объёма.
   apbuf : Float;
   mf, attrsCR : Float;
   Vol : Float; // Объём контрольного объёма


// модуль вещественного числа
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin
   // Внимание при bPressureSimpler=true никакой нижней релаксации в данной функции вычисления псевдоскоростей
   // быть не должно.


   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
    for i:=1 to imaxnumbernodeVx do
    begin
       //  номера узлов для массива Vx
         ipi:=mapVx[i].i+(mapVx[i].j-1)*(inx-1); // текущая точка

        if (mapVx[i].itype=1) then
        begin
           // внутренний узел


           // значение полей m не инициализировано, но
           // по возвращении из процедуры Vxcoef
           // соответствующие поля m будут соответствовать соответствующим коэффициентам
           // дискретного аналога
           Vxcoef(mapVx[i].i, mapVx[i].j, m, mf, attrsCR); // вычисление коэффициентов дискретного аналога
           // если коэффициенты дискретного аналога вычислялись
            // то осталось только вычислить исто чниковый член



            // номера обычных узлов для переменных T и P
            je:=(mapVx[i].i+1)+(mapVx[i].j-1)*inx; // для обычных переменных
            jw:=mapVx[i].i+(mapVx[i].j-1)*inx; //   число точек  по горизонтали на одну больше нежели чем для Vx
            //drhointerpol:=2*density(jw)*density(je)/(density(jw)+density(je));
            drhointerpol:=densuty_in_surface(jw,je);
            // debug
            //Application.MessageBox(PChar('High(DensityOldTimeStep)='+IntToStr(High(DensityOldTimeStep))),'debug',MB_OK);
            //drhoold:=2.0*DensityOldTimeStep[jw]*DensityOldTimeStep[je]/(DensityOldTimeStep[jw]+DensityOldTimeStep[je]);
            //drhoold:=densuty_in_surface(jw,je);

            Vol:=(xpos[mapVx[i].i+1]-xpos[mapVx[i].i])*(0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]));

            db:=dScVx*Vol; // постоянная составляющая источникового члена
            db:=db+attrsCR; // Схема второго порядка через метод отложенной коррекции.
            if ((bISezai) and (not(btimedepend))) then
            begin
               db:=db+mf*VxOld[ipi];
            end;
            if (btimedepend) then
            begin
               // нестационарный вклад
               // с постоянным шагом по времени
               if (bsecondorderflow) then
               begin
                  db:=db+(2.0*VxOldTimeStep[ipi]-0.5*VxOldOldTimeStep[ipi])*Vol/dTimeStep;
               end
               else
               begin
                  // Схема Эйлера
                  // dap0:=drhoold*Vol/dTimeStep;
                  dap0:=Vol/dTimeStep;
                  db:=db + dap0*VxOldTimeStep[ipi]; // учёт нестационарности если требуется.
               end;
            end;

            dgxeffective:=dgx; // ускорение свободного падения

            // В случае силы тяжести меняющейся по гармоническому закону:
            if ((btimedepend) and (rgravVib.bOn)) then
            begin
               // Только в том случае если процесс нестационарный и
               // сила тяжести меняется по гармоническому закону.

               dgxeffective:= dgxeffective + GetRealGravity('x');
            end;

            // учёт приближения Буссинеска
            // температура аппроксимирована как среднее арефметическое
            if (bBussinesk) then
            begin
               // Здесь записывается источниковый вклад в модели Буссинеска,
               // где плотность линейно зависит от температуры. Подробнее можно
               // посмотреть у Г.З. Гершини и Е.М. Жуховицкого.

               // в некоторых случаях, например при больших значениях,
               // чисел Рэлея, имеет смысл замедлить изменение источникового члена от итерации к итерации.
               //rBodyForceBussinesknew:= - drhointerpol*dbeta*dgxeffective*0.5*(T[jw]+T[je]);
              // rBodyForceBussineskold:= - drhointerpol*dbeta*dgxeffective*0.5*(TOldIteration[jw]+TOldIteration[je]);
               rBodyForceBussinesknew:= - dbeta*dgxeffective*0.5*(T[jw]+T[je]);
               rBodyForceBussineskold:= - dbeta*dgxeffective*0.5*(TOldIteration[jw]+TOldIteration[je]);
               db:= db + (myrelaxfactors.prelaxBodyForce*rBodyForceBussinesknew + (1-myrelaxfactors.prelaxBodyForce)*rBodyForceBussineskold)*Vol;
               // Буссинесковская сила всплытия основанная на UDS.
                case imaxUDS of
                  1 : begin
                         db:= db - dbetaUDS1*dgxeffective*0.5*(UDS1[jw]+UDS1[je])*Vol;
                      end;
                  2 : begin
                         db:= db - dbetaUDS1*dgxeffective*0.5*(UDS1[jw]+UDS1[je])*Vol;
                         db:= db - dbetaUDS2*dgxeffective*0.5*(UDS2[jw]+UDS2[je])*Vol;
                      end;
                  3 : begin
                         db:= db - dbetaUDS1*dgxeffective*0.5*(UDS1[jw]+UDS1[je])*Vol;
                         db:= db - dbetaUDS2*dgxeffective*0.5*(UDS2[jw]+UDS2[je])*Vol;
                         db:= db - dbetaUDS3*dgxeffective*0.5*(UDS3[jw]+UDS3[je])*Vol;
                      end;
                  4 : begin
                         db:= db - dbetaUDS1*dgxeffective*0.5*(UDS1[jw]+UDS1[je])*Vol;
                         db:= db - dbetaUDS2*dgxeffective*0.5*(UDS2[jw]+UDS2[je])*Vol;
                         db:= db - dbetaUDS3*dgxeffective*0.5*(UDS3[jw]+UDS3[je])*Vol;
                         db:= db - dbetaUDS4*dgxeffective*0.5*(UDS4[jw]+UDS4[je])*Vol;
                      end;
                end;
            end
             else
            begin
               // Здесь просто учитывается сила тяжести.
               // К приближению Буссинеска это не имеет отношения.
               // См. ГИДРОДИНАМИКА Л.Д. Ландау и Е.М. Лифшица стр. 16.

               //db:= db +  drhointerpol*dgxeffective*(xpos[mapVx[i].i+1]-xpos[mapVx[i].i])*(0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]));
               db:= db +  dgxeffective*Vol;

            end;

            if (bCSF) then
            begin
               // continuum surface force.
               // CSFx - определено на сетке для Vx.
               db:=db + CSFx[ipi]*Vol;
            end;

            //dpressure:=(P[jw]-P[je])*0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]); // сила давления действующая на контрольный объём
            // Теперь с учётом гидростатического давления !!!
           // dpressure:=(Pressureabsolute[jw]-Pressureabsolute[je])*0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]); // сила давления действующая на контрольный объём
            dpressure:=(Pressureabsolute[jw]-Pressureabsolute[je])*0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1])/drhointerpol; // сила давления действующая на контрольный объём



            mglobal[ipi].dae:=m.dae; // коэффициенты
            mglobal[ipi].daw:=m.daw; // дискретного
            mglobal[ipi].dan:=m.dan; // аналога
            mglobal[ipi].das:=m.das;

            if (bPressureSimpler) then
            begin
               mglobal[ipi].dap:=m.dap;
            end
            else
            begin
               mglobal[ipi].dap:=m.dap/myrelaxfactors.Momentum;
            end;


            // VxOld - глобальный параметр, значение скорости с предыдущей итерации алгоритма
            // SIMPLE удовлетворяющее уравнению непрерывности (сохранению массы)
            if (bPressureSimpler) then
            begin
               dbglobal[ipi]:= db;  // вклад источникового члена
            end
             else
            begin
               dbglobal[ipi]:= db + dpressure+((1.0-myrelaxfactors.Momentum)*m.dap*VxOld[ipi])/myrelaxfactors.Momentum;  // вклад источникового члена
            end;

         end;  // end внутренний узел

         if (mapVx[i].itype=2) then
         begin
            // граничный узел
            // нужно проверить принадлежит ли этот узел выходной границе


            if (mapVx[i].iugol = 0) then
            begin
               // точка не является угловой.

               // ищем границу к которой принадлежит эта точка
               bout:=GridGenForm.isoutflow(mapVx[i].iboundary, 'U',mapVx[i].chnormal);
               if (bout) then
               begin

                  // Это неверно, т.к. на выходной границе должны ставится мягкие условия
                  // F[i]=2F[i-1]-F[i-2]


                  // это выходная граница расчётной области
                  // внутренняя нормаль
                  case (mapVx[i].chnormal) of
                   'W' : // правая (здесь внутренняя нормаль
                       begin
                          dSquare:=0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]);
                          // выходная граница находится справа
                          VxcoefRight(mapVx[i].i, mapVx[i].j,mglobal[ipi],dbglobal[ipi]);

                       end;
                   'E' : // левая сторона (внутренняя нормаль)
                       begin
                          dSquare:=0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j-1]);
                          // выходная граница находится слева
                          VxcoefLeft(mapVx[i].i, mapVx[i].j, mglobal[ipi],dbglobal[ipi]);
                       end;
                   'S' : // верхняя граница
                       begin
                          dSquare:=0.5*(ypos[mapVx[i].j]-ypos[mapVx[i].j-1]);
                          VxcoefTop(mapVx[i].i, mapVx[i].j, mglobal[ipi],dbglobal[ipi]);
                       end;
                   'N' : //  нижняя граница
                       begin
                          dSquare:=0.5*(ypos[mapVx[i].j+1]-ypos[mapVx[i].j]);
                          VxcoefBottom(mapVx[i].i, mapVx[i].j, mglobal[ipi],dbglobal[ipi]);
                       end;
                  end; // case

                  // Не нужно модифицировать диагональный член. Процедура нижней релаксации
                  // Не должна отражаться неявно в матрице СЛАУ.
                   if (not(bPressureSimpler)) then
                  begin
                      //apbuf:=mglobal[ipi].dap; // он пригодится при вычислении правой части т.е. b.
                     //mglobal[ipi].dap:=mglobal[ipi].dap/myrelaxfactors.Momentum;
                  end;


                  //je:=(mapVx[i].i+1)+(mapVx[i].j-1)*inx; // для обычных переменных
                  //jw:=mapVx[i].i+(mapVx[i].j-1)*inx;
                  if (bPressureSimpler) then
                  begin
                     dbglobal[ipi]:=dbglobal[ipi]+0.0; // нет источникового члена
                  end
                   else
                  begin
                     //dpressure:=(P[jw]-P[je])*dSquare;
                     // Теперь с учётом гидростатического давления.
                     //dpressure:=(Pressureabsolute[jw]-Pressureabsolute[je])*dSquare/densuty_in_surface(jw,je);
                    // dbglobal[ipi]:=dpressure + ((1.0-myrelaxfactors.Momentum)*apbuf*VxOld[ipi])/myrelaxfactors.Momentum; // нет источникового члена

                     dbglobal[ipi]:=dbglobal[ipi]+0.0; // TODO 3 июня 2013
                  end;

               end  // boutflow
                else
               begin
                   // Внимание. Данная секция кода жизненно необходима для SIMPLER (SIMPLE Revised) алгоритма.

                   // НЕ boutflow.
                   // и  это граничная точка.
                   // скорее всего это условие Дирихле и надо задать элементы матрицы и правую часть.
                   mglobal[ipi].dap:=1.0;
                   mglobal[ipi].dae:=0.0;
                   mglobal[ipi].dan:=0.0;
                   mglobal[ipi].das:=0.0;
                   mglobal[ipi].daw:=0.0;
                   // Заданная скорость на данной границе.
                   for i1:=1 to GridGenForm.inumboundary do
                   begin
                       if (GridGenForm.edgelist[i1].idescriptor = mapVx[i].iboundary) then
                       begin
                          // граница найдена
                          dbglobal[ipi]:=GridGenForm.edgelist[i1].Vx;
                       end;
                   end;
               end;
            end
             else
            begin
               dbglobal[ipi]:=0.0; // нет источникового члена
               // здесь всё будет построено на среднем арефметическом
               case mapVx[i].iugol of
                1 : // левый нижний угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.5;
                     mglobal[ipi].dan:=0.5;
                     mglobal[ipi].das:=0.0;
                     mglobal[ipi].daw:=0.0;
                  end;
                2 : // правый нижний угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.0;
                     mglobal[ipi].dan:=0.5;
                     mglobal[ipi].das:=0.0;
                     mglobal[ipi].daw:=0.5;
                  end;
                3 : // верхний левый угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.5;
                     mglobal[ipi].dan:=0.0;
                     mglobal[ipi].das:=0.5;
                     mglobal[ipi].daw:=0.0;
                  end;
                4 : // верхний правый угол
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.0;
                     mglobal[ipi].dan:=0.0;
                     mglobal[ipi].das:=0.5;
                     mglobal[ipi].daw:=0.5;
                  end;
                5 : // пятиточечная звезда
                  begin
                     mglobal[ipi].dap:=1.0;
                     mglobal[ipi].dae:=0.25;
                     mglobal[ipi].dan:=0.25;
                     mglobal[ipi].das:=0.25;
                     mglobal[ipi].daw:=0.25;
                  end;
               end; // case


            end;
         end;


      end;
end;  // VxGlobalCoef

// решение нелинейного уравнения для горизонтальной скорости
// реализовано вычисление коэффициентв дискретного аналога, а также
// есть два солвера: Гаусс-Зейдель и
// метод переменных направлений.
procedure TForm1.SolveVx(var mglobal : array of MatrixCoef;
                         var dbglobal : array of  Float);
const
   kgold = 3;

var
   //mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
   //dbglobal : array of  Float; // часть источникового члена
   i,k,k1 : Integer; // счётчики внутренний и преодоления нелинейности
   bflagconstruct : Boolean;
   Aseqx, Aseqy : TPeacemanRachford;
   QneiC : TQneiC;
   u1, u2, u3 : array of Float;
   dsum1, dsum2 : Float;
   ipi : Integer;

begin
    for k:=1 to 20 do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false;
      end;
   end;

   // выделение оперативной памяти
   //SetLength(mglobal,(inx-1)*iny+1); // основные коэффициенты дискретного аналога
   //SetLength(dbglobal,(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
   bflagconstruct:=True;

   // iterSimple.iterVxLin - количество итераций для решения внутренней номинально линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.


      // цикл преодоления нелинейности
      // шаг 1:
      // вычисление коэффициентов дискретного аналога
      // проход по всем внутренним точкам
      VxGlobalCoef(mglobal,dbglobal,false);

      // шаг 2:
      // решение по сути линейного уравнения
      // с полученными ранее коэффициентами
      if (itypesolver.ivelocity < 3) then
      begin
         if (itypesolver.ivelocity=1) then
         begin
            if (bIlyinvel) then
            begin
               SetLength(u1,mzapas*(inx-1)*iny+1);
               SetLength(u2,mzapas*(inx-1)*iny+1);
               SetLength(u3,mzapas*(inx-1)*iny+1);
               dsum1:=0.0;
               dsum2:=0.0;
            end;
         end;


         for i:=1 to iterSimple.iterVxLin do
         begin
            case itypesolver.ivelocity of
            1 : // Гаусс-Зейдель
              begin
                 if (bIlyinvel) then
                 begin
                    if (i<4) then
                    begin
                       relaxIlyin:=1.0;
                    end;
                 end;
                 // одна итерация методом Гаусса-Зейделя
                 GZUniversal(Vx,inx-1,iny, mapVx, 'U',  mglobal,dbglobal,QneiC);
                 if (bIlyinvel) then
                 begin
                    if (i mod kgold= 0) then
                    begin
                       for k:=1 to imaxnumbernodeVx do
                       begin
                          if ((mapVx[k].itype=1)or(mapVx[k].itype=2)) then
                          begin
                             u1[mapVx[k].i+(mapVx[k].j-1)*(inx-1)]:=Vx[mapVx[k].i+(mapVx[k].j-1)*(inx-1)];
                          end;
                       end;
                    end;
                    if ((i-1)mod kgold=0) then
                    begin
                       for k:=1 to imaxnumbernodeVx do
                       begin
                          if ((mapVx[k].itype=1)or(mapVx[k].itype=2)) then
                          begin
                             u2[mapVx[k].i+(mapVx[k].j-1)*(inx-1)]:=Vx[mapVx[k].i+(mapVx[k].j-1)*(inx-1)];
                          end;
                       end;
                    end;
                    if ((i-2)mod kgold = 0) then
                    begin
                       for k:=1 to imaxnumbernodeVx do
                       begin
                          if ((mapVx[k].itype=1)or(mapVx[k].itype=2)) then
                          begin
                             u3[mapVx[k].i+(mapVx[k].j-1)*(inx-1)]:=Vx[mapVx[k].i+(mapVx[k].j-1)*(inx-1)];
                          end;
                       end;
                       dsum1:=0.0;
                       dsum2:=0.0;
                       for k:=1 to imaxnumbernodeVx do
                       begin
                          if ((mapVx[k].itype=1)or(mapVx[k].itype=2)) then
                          begin
                            ipi:=mapVx[k].i+(mapVx[k].j-1)*(inx-1);
                            dsum1:=dsum1+(u3[ipi]-u2[ipi])*(u3[ipi]-u2[ipi]);
                            dsum2:=dsum2+(u2[ipi]-u1[ipi])*(u2[ipi]-u1[ipi]);
                          end;
                       end;
                       if (abs(dsum2)>1.0e-30) then
                       begin
                          dsum1:=sqrt(dsum1/dsum2);
                          relaxIlyin:=2.0/(1.0+sqrt(fmax(1.0-dsum1,0.002))); // оптимальный параметр релаксации.
                       end;
                    end;
                 end;
              end;
            2 : // метод переменных направлений
              begin
                 // одна итерация методом переменных направлений
                 TDMAGibridGZUniversal(Vx,inx-1,iny, mapVx, 'U', mglobal, dbglobal,Aseqx, Aseqy, bflagconstruct);
                 bflagconstruct:=False;
              end;
            end; // case

         end; // i - решение линейной системы



         if (itypesolver.ivelocity=1) then
         begin
            if (bIlyinvel) then
            begin
               // Освобождение памяти.
               SetLength(u1,0);
               SetLength(u2,0);
               SetLength(u3,0);
               dsum1:=0.0;
               dsum2:=0.0;
            end;
         end;
      end
      else
      begin
         case itypesolver.ivelocity of
         3 : // алгоритм Ю.Г. Соловейчика [1993]
            begin
               // itypesolver.ivelocity = 3
               // с учётом конвективного члена, без печати диагностических сообщений,
               // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
               // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
               SoprGradCRSUniversal( Vx, inx-1, iny, mapVx, 'U', mglobal, true, false, iterSimple.iterVxLin, rcs.Vx*rcs.Vx, 1,dbglobal);
            end;
         4 : // прямой метод исключения Гаусса
            begin
               GaussUniversal(Vx, inx-1, iny, mapVx, 'U',  mglobal, dbglobal,false);
            end;
         5 : // Агломеративный классический алгебраический многосеточный метод
            begin
               //GaussUniversal(Vx, inx-1, iny, mapVx, 'U',  mglobal, dbglobal,false);
               classical_aglomeration_amg(Vx, inx-1, iny, mapVx, 'U', mglobal, dbglobal, false);
            end;
         end; // case
      end;

end; // SolveVx

// по значениям функции тока находит
// вертикальную скорость.
procedure TForm1.VyConstruct;
var
    i,j : Integer; // счётчики
    ipi, iei, iwi : Integer;
    VyT, VyB : Float; // значения вертикальной скорости сверху и снизу
begin
   for i:=1 to inx do
   begin
      for j:=1 to (iny-1) do
      begin
         if ((i>1) and (i<inx)) then
         begin
            iei:=(i+1)+(j-1)*inx;
            iwi:=(i-1)+(j-1)*inx;
            VyB:=(SF[iei]-SF[iwi])/(xpos[i+1]-xpos[i-1]);
            iei:=(i+1)+(j)*inx;
            iwi:=(i-1)+(j)*inx;
            VyT:=(SF[iei]-SF[iwi])/(xpos[i+1]-xpos[i-1]);
            ipi:=i+(j-1)*inx;
            Vy[ipi]:=-0.5*(VyB+VyT);
         end;
         if (i=1) then
         begin
            ipi:=i+(j-1)*inx;
            iei:=(i+1)+(j-1)*inx;
            VyB:=(SF[iei]-SF[ipi])/(xpos[i+1]-xpos[i]);
            ipi:=i+(j)*inx;
            iei:=(i+1)+(j)*inx;
            VyT:=(SF[iei]-SF[ipi])/(xpos[i+1]-xpos[i]);
            ipi:=i+(j-1)*inx;
            Vy[ipi]:=-0.5*(VyB+VyT);
         end;
         if (i=inx) then
         begin
            ipi:=i+(j-1)*inx;
            iwi:=(i-1)+(j-1)*inx;
            VyB:=(SF[ipi]-SF[iwi])/(xpos[i]-xpos[i-1]);
            ipi:=i+(j)*inx;
            iwi:=(i-1)+(j)*inx;
            VyT:=(SF[ipi]-SF[iwi])/(xpos[i]-xpos[i-1]);
            ipi:=i+(j-1)*inx;
            Vy[ipi]:=-0.5*(VyB+VyT);
         end;
      end;
   end;
end; // VyConstruct


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
procedure TForm1.Vycoef(i, j : Integer; var m : MatrixCoef; var mf : Float; var attrs : Float);
var
    ini,isi,ipi,iwi,iei : Integer; // номера узлов для Vy на пятиточечном шаблоне
    ieei, iwwi, inni, issi : Integer; // Для High Resolution Scheme
    jn, js, jnl, jsl, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed, jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfe, dfw, dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drn, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddw, ddn, dds :  Float;  // диффузионные члены
    dpe,dpw,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент
    f_forvardx, f_backvardx, f_forvardy, f_backvardy : Float; // High Resolution добавка в правую часть.

// модуль вещественного числа
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка
        iei:=i+1+(j-1)*inx;
        iwi:=i-1+(j-1)*inx;

        // for High Resolution Scheme
        inni:= i+(j+1)*inx;
        issi:= i+(j-3)*inx;
        ieei:=i+2+(j-1)*inx;
        iwwi:=i-2+(j-1)*inx;

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        //drhoA:= 2*density(jn)*density(jnr)/(density(jn)+density(jnr));
        //drhoB:= 2*density(js)*density(jsr)/(density(js)+density(jsr));
        drhoA:=densuty_in_surface(jn,jnr);
        drhoB:=densuty_in_surface(js,jsr);
        //dre:=2*drhoA*drhoB/(drhoA+drhoB);
        dre:=0.5*(drhoA+drhoB);
        //dfe:=dre*(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        dfe:=(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]);
        // здесь dikoef=0.5
        //drhoA:= 2*density(jnl)*density(jn)/(density(jnl)+density(jn));
        //drhoB:= 2*density(jsl)*density(js)/(density(jsl)+density(js));
        drhoA:=densuty_in_surface(jnl,jn);
        drhoB:=densuty_in_surface(jsl,js);
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfw:=drw*(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dfw:=(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        //dfn:=drn*(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(0.5*(xpos[i+1]-xpos[i-1])); // или
        dfn:=(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(0.5*(xpos[i+1]-xpos[i-1]));
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        //dfs:=drs*(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения
         dfs:=(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgn:=viscosity(jn);
        dgs:=viscosity(js);

        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i])/dre;  // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1])/drw;  // дискретного
        ddn:=dgn*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+2]-ypos[j]))/drn;  // аналога
        dds:=dgs*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+1]-ypos[j-1]))/drs;

        dpe:=dfe/dde; // значения
        dpw:=dfw/ddw; // чисел
        dpn:=dfn/ddn; // Пекле
        dps:=dfs/dds;

        if (not(brealisticflow)) then
        begin
           // без метода отложеной коррекции
           attrs:=0.0;
           if  (ishconv=1) then
           begin
              // Центрально разностная схема.
              // 23 августа 2013 года.
              m.dae:=dde - 0.5*dfe;
              m.daw:=ddw + 0.5*dfw;
              m.dan:=ddn - 0.5*dfn;
              m.das:=dds + 0.5*dfs;
           end
             else if ((ishconv>=2)and(ishconv<=7)) then
           begin
              m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
              m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
              m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
              m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
           end
           else
           begin
               // High Resolution Scheme
               // Неявно учитываем лишь противопоточную часть.

               m.dae:=dde + maxoper(-dfe,0); // коэффициенты
               m.daw:=ddw + maxoper(dfw,0);  // дискретного
               m.dan:=ddn + maxoper(-dfn,0); // аналога
               m.das:=dds + maxoper(dfs,0);

               attrs:=0.0;
               if (is_internal_HO(iwi,ipi,iei,ieei)) then
               begin
                   f_forvardx:=cell_face_value_global(ishconv,(0.5*(VxActing[jxed]+VxActing[jxeu])),VyActing[iwi],VyActing[ipi],VyActing[iei],VyActing[ieei]);
                   attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-VyActing[ipi])+maxoper(-dfe,0.0)*(f_forvardx-VyActing[iei]);
               end;
               if (is_internal_HO(iwwi,iwi,ipi,iei)) then
               begin
                   f_backvardx:=cell_face_value_global(ishconv,(0.5*(VxActing[jxwu]+VxActing[jxwd])),VyActing[iwwi],VyActing[iwi],VyActing[ipi],VyActing[iei]);
                   attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-VyActing[ipi])+maxoper(dfw,0.0)*(f_backvardx-VyActing[iwi]);
               end;
               if (is_internal_HO(isi,ipi,ini,inni)) then
               begin
                  dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
                  f_forvardy:=cell_face_value_global(ishconv,(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini]),VyActing[isi],VyActing[ipi],VyActing[ini],VyActing[inni]);
                  attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-VyActing[ipi])+maxoper(-dfn,0.0)*(f_forvardy-VyActing[ini]);
               end;
               if (is_internal_HO(issi,isi,ipi,ini)) then
               begin
                  dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
                  f_backvardy:=cell_face_value_global(ishconv,(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi]),VyActing[issi],VyActing[isi],VyActing[ipi],VyActing[ini]);
                  attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-VyActing[ipi])+maxoper(dfs,0.0)*(f_backvardy-VyActing[isi]);
               end;

           end;
        end
        else
        begin
            // С методом отложенной коррекции.
            if (ishconv=1) then
            begin
               // Неявно учитывается противопоточная часть а для неё
               // ApproxConvective(abs(dpe),ishconvtemp)=1.0
               m.dae:=dde+maxoper(-dfe,0);
               m.daw:=ddw+maxoper(dfw,0);
               m.dan:=ddn+maxoper(-dfn,0);
               m.das:=dds+maxoper(dfs,0);

               // Центрально-разностная схема второго порядка точности с помощью
               // метода отложенной коррекции (неявно учитывается противопоточная часть).
               attrs:=0.0;
               f_forvardx:=0.5*(VyActing[ipi]+VyActing[iei]);
               attrs:=attrs-maxoper(dfe,0.0)*(f_forvardx-VyActing[ipi])+maxoper(-dfe,0.0)*(f_forvardx-VyActing[iei]);
               f_backvardx:=0.5*(VyActing[ipi]+VyActing[iwi]);
               attrs:=attrs-maxoper(-dfw,0.0)*(f_backvardx-VyActing[ipi])+maxoper(dfw,0.0)*(f_backvardx-VyActing[iwi]);
               f_forvardy:=((ypos[j+2]-ypos[j+1])*VyActing[ipi]+(ypos[j+1]-ypos[j])*VyActing[ini])/(ypos[j+2]-ypos[j]);
               //f_forvardy:=0.5*(VxActing[ipi]+VxActing[ini]);
               attrs:=attrs-maxoper(dfn,0.0)*(f_forvardy-VyActing[ipi])+maxoper(-dfn,0.0)*(f_forvardy-VyActing[ini]);
               //f_backvardy:=0.5*(VyActing[ipi]+VyActing[isi]);
               f_backvardy:=((ypos[j+1]-ypos[j])*VyActing[isi]+(ypos[j]-ypos[j-1])*VyActing[ipi])/(ypos[j+1]-ypos[j-1]);
               attrs:=attrs-maxoper(-dfs,0.0)*(f_backvardy-VyActing[ipi])+maxoper(dfs,0.0)*(f_backvardy-VyActing[isi]);
            end
          else
            begin
               Application.MessageBox('Схема аппроксимации не предусмотрена программистом','ERROR!',MB_OK);
            end;
        end;



        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          //drhoA:= 2*density(jn)*density(js)/(density(jn)+density(js));
          //drhoA:=densuty_in_surface(jn,js);

          if (bsecondorderflow) then
          begin
             //dap0:=1.5*drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=1.5*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
          end
          else
          begin
             // схема Эйлера
             //dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
          end;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
        end;

        if (ApproxConvectionForm.CheckBoxKIvanovApprox.Checked) then
        begin

           if (not(brealisticflow)) then
           begin
              // без метода отложенной коррекции
              if (ishconv=1) then
              begin
                  // Обычная центрально разностная схема.
                  m.dap:= dde+ddw+ddn+dds+0.5*(dfe-dfw+dfn-dfs) + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);
              end
               else
              begin
                 m.dap:=dde*ApproxConvective(abs(dpe),ishconv)+maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv)+maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv)+maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv)+maxoper(-dfs,0)+ dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);
              end;
           end
           else
           begin
              // Метод отложенной корекции
              if (ishconv=1) then
              begin
                 m.dap:=dde+maxoper(dfe,0)+ddw+maxoper(-dfw,0)+ddn+maxoper(dfn,0)+dds+maxoper(-dfs,0)+ dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);
              end
               else
              begin
                 Application.MessageBox('Схема аппроксимации не предусмотрена программистом','ERROR!',MB_OK);
              end;
           end;

        end
        else
        begin
           // Обычная схема.
           m.dap:= m.dae + m.daw + m.dan + m.das + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);
        end;


        if ((bISezai) and (not(btimedepend))) then
        begin
            if (ApproxConvectionForm.CheckBoxISezainofabs.Checked) then
            begin
               // возможное ослабление диагонали.
               mf:=(dfe-dfw+dfn-dfs);
            end
             else
            begin
               // только усиление диагонали.
               mf:=fabs(dfe-dfw+dfn-dfs);
            end;
            m.dap:=m.dap+mf;
          end;


        // debug
        if (m.dap<1.0e-30) then
        begin
           bweShouldContinue:=False; // остановить вычисления.
           MainMemo.Lines.Add('FATAL ERROR');
           MainMemo.Lines.Add(PChar('Diffusion: De='+FloatTOStr(dge)+'Dw='+FloatTOStr(dgw)+'Dn='+FloatTOStr(dgn)+'Ds='+FloatTOStr(dgs)));
           MainMemo.Lines.Add(PChar('Convection: Fe='+FloatToStr(dfe)+'Fw='+FloatToStr(dfw)+'Fn='+FloatToStr(dfn)+'Fs='+FloatToStr(dfs)));
           MainMemo.Lines.Add(PChar('Vycoef function : ap='+FloatToStr(m.dap)+'ae='+FloatToStr(m.dae)+'aw='+FloatToStr(m.daw)+'an='+FloatToStr(m.dan)+'as='+FloatToStr(m.das)));
        end;

end; // Vycoef


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// правая стенка.
procedure TForm1.VycoefRight(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    ini,isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfw, dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dgw, dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    drw, drn, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    ddw, ddn, dds :  Float;  // диффузионные члены
    dpw,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент
    dSquare : Float; // площадь поверхности контрольного объёма.

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
          // r - right правые узлы


        // номера узлов для горизонтальной компоненты скорости Vx
         // e - правый u - верхний
         // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        // интенсивность
        // здесь dikoef=0.5
        drhoA:=densuty_in_surface(jnl,jn);
        drhoB:=densuty_in_surface(jsl,js);
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfw:=drw*(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dfw:=(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);

        // Правая стенка. Площадь контрольного объёма.
        dSquare:=0.5*(xpos[i]-xpos[i-1]);

        //dfn:=drn*(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(dSquare); // или
         dfn:=(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(dSquare);
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        //dfs:=drs*(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(dSquare); // течения
         dfs:=(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(dSquare); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgn:=viscosity(jn);
        dgs:=viscosity(js);

        // Диффузия
          // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1])/drw;  // дискретного
        ddn:=dgn*(dSquare)/(0.5*(ypos[j+2]-ypos[j]))/drn;  // аналога
        dds:=dgs*(dSquare)/(0.5*(ypos[j+1]-ypos[j-1]))/drs;

         // значения
        dpw:=dfw/ddw; // чисел
        dpn:=dfn/ddn; // Пекле
        dps:=dfs/dds;
        m.dae:=0.0; // коэффициенты
        if ((ishconv>=1)and(ishconv<=7)) then
        begin
           m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        end
         else
        begin
            m.daw:=ddw + maxoper(dfw,0);
        end;
       // m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        //m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
        m.dan:=0.0;
        m.das:=0.0;

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          if (bsecondorderflow) then
          begin
             //drhoA:= densuty_in_surface(jn,js);
             //dap0:=1.5*drhoA*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=1.5*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=(2.0*VyOldTimeStep[ipi]-0.5*VyOldOldTimeStep[ipi])*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
          end
          else
          begin
             //drhoA:= densuty_in_surface(jn,js);
             //dap0:=drhoA*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=dap0*VyOldTimeStep[ipi];
          end;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
           db:=0.0;
        end;

        m.dap:=  m.daw + m.dan + m.das + dap0 - dSpVy*(dSquare)*(ypos[j+1]-ypos[j]);
       // m.dap:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+ ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0) +dap0 - dSpVy*(dSquare)*(ypos[j+1]-ypos[j]);
end; // VycoefRight



// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// левая стенка
procedure TForm1.VycoefLeft(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    ini,isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed  : Integer; // номера узлов для горизонтальной скорости Vx
    dfe,  dfn, dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge,  dgn, dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drn, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddn, dds :  Float;  // диффузионные члены
    dpe,dpn,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент
    dSquare : Float; // площадь грани контрольного объёма.

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ

        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
         // w - левый, u - верхний
         // w - левый, d - нижний.

         // Правая стенка. Площадь контрольного объёма.
        dSquare:=0.5*(xpos[i+1]-xpos[i]);


        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:=densuty_in_surface(jn,jnr);
        drhoB:=densuty_in_surface(js,jsr);
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfe:=dre*(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        dfe:=(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]);
        // здесь dikoef=0.5
         // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        //dfn:=drn*(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(dSquare); // или
         dfn:=(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(dSquare); // или
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
        //dfs:=drs*(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(dSquare); // течения
        dfs:=(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(dSquare); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);

        dgn:=viscosity(jn);
        dgs:=viscosity(js);


        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i])/dre;  // коэффициенты
         // дискретного
        ddn:=dgn*(dSquare)/(0.5*(ypos[j+2]-ypos[j]))/drn;  // аналога
        dds:=dgs*(dSquare)/(0.5*(ypos[j+1]-ypos[j-1]))/drs;

        dpe:=dfe/dde; // значения
         // чисел
        dpn:=dfn/ddn; // Пекле
        dps:=dfs/dds;
        if ((ishconv>=1)and(ishconv<=7)) then
        begin
           m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
        end
         else
        begin
            m.dae:=dde + maxoper(-dfe,0);
        end;
        m.daw:=0.0;  // дискретного
        //m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        //m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
        m.dan:=0.0;
        m.das:=0.0;

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          if (bsecondorderflow) then
          begin
             //drhoA:=densuty_in_surface(jn,js);
             //dap0:=1.5*drhoA*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=1.5*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=(2.0*VyOldTimeStep[ipi]-0.5*VyOldOldTimeStep[ipi])*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
          end
          else
          begin
             //drhoA:=densuty_in_surface(jn,js);
             //dap0:=drhoA*(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=(dSquare)*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=dap0*VyOldTimeStep[ipi];
          end;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
            db:=0.0;
        end;

         m.dap:= m.dae  + m.dan + m.das + dap0 - dSpVy*(dSquare)*(ypos[j+1]-ypos[j]);
       // m.dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0) + dap0 - dSpVy*(dSquare)*(ypos[j+1]-ypos[j]);

end; // VycoefLeft


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// нижняя граница
procedure TForm1.VycoefBottom(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    ini,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed, jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfe, dfw, dfn :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw, dgn :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drn :  Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddw, ddn :  Float;  // диффузионные члены
    dpe,dpw,dpn :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
        ini:=i+j*inx;  // север
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:=densuty_in_surface(jn,jnr);
        drhoB:=densuty_in_surface(js,jsr);
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfe:=dre*(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        dfe:=(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]);
        // здесь dikoef=0.5
        drhoA:=densuty_in_surface(jnl,jn);
        drhoB:=densuty_in_surface(jsl,js);
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfw:=drw*(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dfw:=(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        dikoef:=(ypos[j+2]-ypos[j+1])/(ypos[j+1]-ypos[j]);
        drn:=density(jn);
        //dfn:=drn*(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(0.5*(xpos[i+1]-xpos[i-1])); // или
        dfn:=(dikoef*VyActing[ipi]+(1-dikoef)*VyActing[ini])*(0.5*(xpos[i+1]-xpos[i-1]));

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgn:=viscosity(jn);

        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i])/dre;  // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1])/drw;  // дискретного
        ddn:=dgn*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+2]-ypos[j]))/drn;  // аналога

        dpe:=dfe/dde; // значения
        dpw:=dfw/ddw; // чисел
        dpn:=dfn/ddn; // Пекле
       // m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
       // m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        m.dae:=0.0;
        m.daw:=0.0;
        if ((ishconv>=1)and(ishconv<=7)) then
        begin
           m.dan:=ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(-dfn,0); // аналога
        end
        else
        begin
            m.dan:=ddn + maxoper(-dfn,0); // аналога
        end;
        m.das:=0.0;

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          //drhoA:= densuty_in_surface(jn,js);
          if (bsecondorderflow) then
          begin
             //dap0:=1.5*drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=1.5*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=(2.0*VyOldTimeStep[ipi]-0.5*VyOldOldTimeStep[ipi])*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
          end
          else
          begin
             //dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=dap0*VyOldTimeStep[ipi];
          end;
        end
         else
        begin
           // стационарный
           dap0:=0.0;
           db:=0.0;
        end;

        m.dap:= m.dae + m.daw + m.dan  + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);
       // m.dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+ddn*ApproxConvective(abs(dpn),ishconv) + maxoper(dfn,0) + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // VycoefBottom


// данная процедура по позиции i,j в матрице для Vy
// возвращает значения коэффициентов на пятиточечном шаблоне
// для данного узла i,j
// для выходной границы
procedure TForm1.VycoefTop(i, j : Integer; var m : MatrixCoef; var db : Float);
var
    isi,ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js, jnl, jsl, jnr, jsr : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    jxeu, jxed, jxwu, jxwd : Integer; // номера узлов для горизонтальной скорости Vx
    dfe, dfw,  dfs :  Float; // конвективные члены
    dmuA,dmuB :  Float; // для двойной интерполяции по dmu
    dge, dgw,  dgs :  Float; // коэффициент диффузии на гранях контрольного объёма
    drhoA, drhoB : Float; // для двойной интерполяции плотности
    dre, drw, drs : Float; // плотность
    dikoef    :  Float; // интерполяционный коэффициент для Vy скорости
    dde, ddw, dds :  Float;  // диффузионные члены
    dpe,dpw,dps :  Float; // числа Пекле
    dap0 :  Float; // нестационарный коэффициент

begin

        //  номера узлов для массива Vy
          // север
        isi:=i+(j-2)*inx; // юг
        ipi:=i+(j-1)*inx; // текущая точка

        // номера обычных узлов для переменных T и P
        jn:=i+j*inx; // для обычных переменных
        js:=i+(j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
        // n - верх, s - низ
        jnl:=(i-1)+j*inx;  // l - left левые узлы
        jsl:=(i-1)+(j-1)*inx;
        jnr:=(i+1)+j*inx;  // r - right правые узлы
        jsr:=(i+1)+(j-1)*inx;

        // номера узлов для горизонтальной компоненты скорости Vx
        jxeu:=i+j*(inx-1);  // e - правый u - верхний
        jxed:=i+(j-1)*(inx-1); // e - правый, d - нижний
        jxwu:=i-1+j*(inx-1);  // w - левый, u - верхний
        jxwd:=i-1+(j-1)*(inx-1); // w - левый, d - нижний.

        // осторожно нелинейность
        // здесь предполагается линейное изменение скорости
        // причём учитывается неравномерность расчётной сетки через dikoef
        // здесь dikoef=0.5
        drhoA:=densuty_in_surface(jn,jnr);
        drhoB:=densuty_in_surface(js,jsr);
        dre:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfe:=dre*(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        dfe:=(0.5*(VxActing[jxed]+VxActing[jxeu]))*(ypos[j+1]-ypos[j]); // интенсивность
        // здесь dikoef=0.5
        drhoA:=densuty_in_surface(jnl,jn);
        drhoB:=densuty_in_surface(jsl,js);
        drw:=2*drhoA*drhoB/(drhoA+drhoB);
        //dfw:=drw*(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
         dfw:=(0.5*(VxActing[jxwu]+VxActing[jxwd]))*(ypos[j+1]-ypos[j]); // конвекции
        // или
        dikoef:=(ypos[j+1]-ypos[j])/(ypos[j]-ypos[j-1]);
        drs:=density(js);
       // dfs:=drs*(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения
         dfs:=(dikoef*VyActing[isi]+(1-dikoef)*VyActing[ipi])*(0.5*(xpos[i+1]-xpos[i-1])); // течения

        // переменная динамическая вязкость
        dmuA:= 2*viscosity(jn)*viscosity(jnr)/(viscosity(jn)+viscosity(jnr));
        dmuB:= 2*viscosity(js)*viscosity(jsr)/(viscosity(js)+viscosity(jsr));
        dge:=2*dmuA*dmuB/(dmuA+dmuB);
        dmuA:= 2*viscosity(jnl)*viscosity(jn)/(viscosity(jnl)+viscosity(jn));
        dmuB:= 2*viscosity(jsl)*viscosity(js)/(viscosity(jsl)+viscosity(js));
        dgw:=2*dmuA*dmuB/(dmuA+dmuB);
        dgs:=viscosity(js);


        // Диффузия
        dde:=dge*(ypos[j+1]-ypos[j])/(xpos[i+1]-xpos[i])/dre;  // коэффициенты
        ddw:=dgw*(ypos[j+1]-ypos[j])/(xpos[i]-xpos[i-1])/drw;  // дискретного
        // аналога
        dds:=dgs*(0.5*(xpos[i+1]-xpos[i-1]))/(0.5*(ypos[j+1]-ypos[j-1]))/drs;

        dpe:=dfe/dde; // значения
        dpw:=dfw/ddw; // чисел
         // Пекле
        dps:=dfs/dds;
        //m.dae:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(-dfe,0); // коэффициенты
        //m.daw:=ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(dfw,0);  // дискретного
        m.dae:=0.0;
        m.daw:=0.0;
        m.dan:=0.0; // аналога
        if ((ishconv>=1)and(ishconv<=7)) then
        begin
           m.das:=dds*ApproxConvective(abs(dps),ishconv) + maxoper(dfs,0);
        end
        else
        begin
            m.das:=dds + maxoper(dfs,0);
        end;

        if (btimedepend) then
        begin
          // нестационарный
          // с постоянным шагом по времени
          if (bsecondorderflow) then
          begin
             //drhoA:=densuty_in_surface(jn,js);
             //dap0:=1.5*drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=1.5*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=(2.0*VyOldTimeStep[ipi]-0.5*VyOldOldTimeStep[ipi])*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
          end
          else
          begin
             //drhoA:=densuty_in_surface(jn,js);
             //dap0:=drhoA*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             dap0:=(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j])/dTimeStep;
             db:=dap0*VyOldTimeStep[ipi];
          end;
        end
        else
        begin
           // стационарный
           dap0:=0.0;
           db:=0.0;
        end;


         m.dap:= m.dae + m.daw  + m.das + dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);
       // m.dap:=dde*ApproxConvective(abs(dpe),ishconv) + maxoper(dfe,0)+ ddw*ApproxConvective(abs(dpw),ishconv) + maxoper(-dfw,0)+dds*ApproxConvective(abs(dps),ishconv) + maxoper(-dfs,0)+ dap0 - dSpVy*(0.5*(xpos[i+1]-xpos[i-1]))*(ypos[j+1]-ypos[j]);

end; // VycoefTop


// коэффициенты дискретного аналога для
// вертикальной компоненты скорости
procedure TForm1.VyGlobalCoef(var mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
                              var dbglobal : array of  Float;
                              bPressureSimpler : Boolean); // часть источникового члена
var
    m : MatrixCoef; // значение коэффициентов дискретного аналога на пятиточечном шаблоне
    ipi : Integer; // номера узлов для Vy на пятиточечном шаблоне
    jn, js : Integer; // номера узлов основной сетки (переменные dmu, T и давление).
    drhointerpol, drhoold : Float; // для интерполяции плотности
    db :  Float;  // коэффициент
    dpressure :  Float; // действующий градиент давления
    i, i1 : Integer; // счётчики
    dap0 :  Float; // нестационарный коэффициент
    dgyeffective :  Float; // эффективное ускорение свободного падения (нужно для вибрационного воздействия).
    rBodyForceBussinesknew, rBodyForceBussineskold :  Float; // учёт приближения Буссинеска
    bout : Boolean; // условие на выходной границе
    dSquare : Float; // площадь грани КО.
    apbuf : Float;
    mf, attrsCR : Float;   // для I.Sezai
    Vol : Float; // объём контрольного объёма.


begin
   // Внимание при bPressureSimpler=true никакой нижней релаксации в данной функции вычисления псевдоскоростей
   // быть не должно.


   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
    for i:=1 to imaxnumbernodeVy do
    begin



        if (mapVy[i].itype=1) then
        begin
           // внутренний узел

          // значение полей m не инициализировано, но
          // по возвращении из процедуры Vycoef
          // соответствующие поля m будут соответствовать соответствующим коэффициентам
          // дискретного аналога для переменной Vy
          Vycoef(mapVy[i].i, mapVy[i].j, m, mf, attrsCR);

           //  номера узлов для массива Vy
          ipi:=mapVy[i].i+(mapVy[i].j-1)*inx; // текущая точка


          // номера обычных узлов для переменных T и P
          // n - верх, s - низ
          jn:=mapVy[i].i+mapVy[i].j*inx; // для обычных переменных
          js:=mapVy[i].i+(mapVy[i].j-1)*inx; //   число точек  по вертикали на одну больше нежели чем для Vy
          //drhointerpol:= 2*density(jn)*density(js)/(density(jn)+density(js));
          drhointerpol:=densuty_in_surface(jn,js);
          //drhoold:= 2*DensityOldTimeStep[jn]*DensityOldTimeStep[js]/(DensityOldTimeStep[jn]+DensityOldTimeStep[js]);
          // В статье Хирта и Николса плотность берётся с верхнего временного слоя !
          // К тому же для плотности они используют линейную интерполяцию.
          //drhoold:=densuty_in_surface(jn,js);

          Vol:=(0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]))*(ypos[mapVy[i].j+1]-ypos[mapVy[i].j]);

          db:=dScVy*Vol; // постоянная составляющая источникового члена
          db:=db+attrsCR;
          if ((bISezai) and (not(btimedepend))) then
          begin
               db:=db+mf*VyOld[ipi];
          end;
          if (btimedepend) then
          begin
             // нестационарный  вклад
             // с постоянным шагом по времени
             if (bsecondorderflow) then
             begin
                // схема Пейре
                 db:=db+(2.0*VyOldTimeStep[ipi]-0.5*VyOldOldTimeStep[ipi])*Vol/dTimeStep;
             end
              else
             begin
                // схема Эйлера
                // dap0:=drhoold*(0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]))*(ypos[mapVy[i].j+1]-ypos[mapVy[i].j])/dTimeStep;
                dap0:=Vol/dTimeStep;
                db:=db + dap0*VyOldTimeStep[ipi]; // вклад нестационарного члена если требуется.
             end;
          end;

          dgyeffective:=dgy; // ускорение свободного падения

          // В случае силы тяжести меняющейся по гармоническому закону:
          if ((btimedepend) and (rgravVib.bOn)) then
          begin
             // Только в том случае если процесс нестационарный и
             // сила тяжести меняется по гармоническому закону.

             dgyeffective:= dgyeffective + GetRealGravity('y');
          end;

          // учёт приближения Буссинеска
          // температура аппроксимирована как среднее арефметическое
          if (bBussinesk) then
          begin
             // Здесь записывается источниковый вклад в модели Буссинеска,
             // где плотность линейно зависит от температуры. Подробнее можно
             // посмотреть у Г.З. Гершини и Е.М. Жуховицкого.

             // в некоторых случаях, например при больших значениях,
             // чисел Рэлея, имеет смысл замедлить изменение источникового члена от итерации к итерации.
             //rBodyForceBussinesknew:= - drhointerpol*dbeta*dgyeffective*0.5*(T[js]+T[jn]);
             //rBodyForceBussineskold:= - drhointerpol*dbeta*dgyeffective*0.5*(TOldIteration[js]+TOldIteration[jn]);
             rBodyForceBussinesknew:= - dbeta*dgyeffective*0.5*(T[js]+T[jn]);
             rBodyForceBussineskold:= - dbeta*dgyeffective*0.5*(TOldIteration[js]+TOldIteration[jn]);
             db:= db + (myrelaxfactors.prelaxBodyForce*rBodyForceBussinesknew + (1-myrelaxfactors.prelaxBodyForce)*rBodyForceBussineskold)*Vol;
             case imaxUDS of
              1 : begin
                     db:= db - dbetaUDS1*dgyeffective*0.5*(UDS1[js]+UDS1[jn])*Vol;
                  end;
              2 : begin
                     db:= db - dbetaUDS1*dgyeffective*0.5*(UDS1[js]+UDS1[jn])*Vol;
                     db:= db - dbetaUDS2*dgyeffective*0.5*(UDS2[js]+UDS2[jn])*Vol;
                  end;
              3 : begin
                     db:= db - dbetaUDS1*dgyeffective*0.5*(UDS1[js]+UDS1[jn])*Vol;
                     db:= db - dbetaUDS2*dgyeffective*0.5*(UDS2[js]+UDS2[jn])*Vol;
                     db:= db - dbetaUDS3*dgyeffective*0.5*(UDS3[js]+UDS3[jn])*Vol;
                  end;
              4 : begin
                     db:= db - dbetaUDS1*dgyeffective*0.5*(UDS1[js]+UDS1[jn])*Vol;
                     db:= db - dbetaUDS2*dgyeffective*0.5*(UDS2[js]+UDS2[jn])*Vol;
                     db:= db - dbetaUDS3*dgyeffective*0.5*(UDS3[js]+UDS3[jn])*Vol;
                     db:= db - dbetaUDS4*dgyeffective*0.5*(UDS4[js]+UDS4[jn])*Vol;
                  end;
             end;
          end
           else
          begin
             // Здесь просто учитывается сила тяжести.
             // К приближению Буссинеска это не имеет отношения.
             // См. ГИДРОДИНАМИКА Л.Д. Ландау и Е.М. Лифшица стр. 16.

            // db:= db +  drhointerpol*dgyeffective*(0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]))*(ypos[mapVy[i].j+1]-ypos[mapVy[i].j]);
            db:= db +  dgyeffective*Vol;
          end;

          if (bCSF) then
          begin
             // continuum surface force.
             // определено на сетке для Vy.
             db:=db + CSFy[ipi]*Vol;
          end;

          //dpressure:=(P[js]-P[jn])*0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]); // сила давления действующая на контрольный объём
          // Теперь с учётом гидростатического давления !!!
          dpressure:=(Pressureabsolute[js]-Pressureabsolute[jn])*0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1])/drhointerpol; // сила давления действующая на контрольный объём


          mglobal[ipi].dae:=m.dae;  // коэффициенты
          mglobal[ipi].daw:=m.daw;  // дискретного
          mglobal[ipi].dan:=m.dan;  // аналога
          mglobal[ipi].das:=m.das;
          // Процедура нижней релаксации не должна отражаться на матрице СЛАУ.
          if (bPressureSimpler) then
          begin
             mglobal[ipi].dap:=m.dap;
          end
           else
          begin
             mglobal[ipi].dap:=m.dap/myrelaxfactors.Momentum;
          end;

          if (bPressureSimpler) then
          begin
             dbglobal[ipi]:= db;  // вклад источникового члена
          end
           else
          begin
             dbglobal[ipi]:= db + dpressure + ((1.0-myrelaxfactors.Momentum)*m.dap*VyOld[ipi])/myrelaxfactors.Momentum;  // вклад источникового члена
          end;
       end;


       if (mapVy[i].itype=2) then
        begin
           // граничный узел
           //  номера узлов для массива Vy
           ipi:=mapVy[i].i+(mapVy[i].j-1)*inx; // текущая точка
           // нужно проверить принадлежит ли
           // этот узел выходной зоне потока из расчётной области

           if (mapVy[i].iugol = 0) then
           begin
              bout:=GridGenForm.isoutflow(mapVy[i].iboundary, 'V',mapVy[i].chnormal);
              if (bout) then
               begin

                 // точка не является угловой.
                 // это выходная граница расчётной области
                 case (mapVy[i].chnormal) of
                 'N' :  // выходная граница находится снизу
                     begin
                       dSquare:=0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]);
                        VycoefBottom(mapVy[i].i, mapVy[i].j, mglobal[ipi],dbglobal[ipi]);
                     end;
                 'S' : // выходная граница находится сверху
                     begin
                       dSquare:=0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i-1]);
                        VycoefTop(mapVy[i].i, mapVy[i].j, mglobal[ipi],dbglobal[ipi]);
                     end;
                 'E' : // выходная граница находится слева
                      begin
                         dSquare:=0.5*(xpos[mapVy[i].i+1]-xpos[mapVy[i].i]);
                         VycoefLeft(mapVy[i].i, mapVy[i].j, mglobal[ipi],dbglobal[ipi]);
                      end;
                 'W' : // выходная граница находится справа
                       begin
                         dSquare:=0.5*(xpos[mapVy[i].i]-xpos[mapVy[i].i-1]);
                         VycoefRight(mapVy[i].i, mapVy[i].j, mglobal[ipi],dbglobal[ipi]);
                       end;
                 end; // case

                 // процедура нижней релаксации не должна отражаться на матрице СЛАУ.
                 if (not(bPressureSimpler)) then
                 begin
                    //apbuf:=mglobal[ipi].dap;
                    //mglobal[ipi].dap:= mglobal[ipi].dap/myrelaxfactors.Momentum;
                 end;


                 // номера обычных узлов для переменных T и P
                 // n - верх, s - низ
                 //jn:=mapVy[i].i+mapVy[i].j*inx; // для обычных переменных
                 //js:=mapVy[i].i+(mapVy[i].j-1)*inx;
                 if (bPressureSimpler) then
                 begin
                    dbglobal[ipi]:=dbglobal[ipi]+0.0;
                 end
                  else
                 begin
                    //dpressure:=(P[js]-P[jn])*dSquare;
                    // Теперь с учётом гидростатического давления.
                    // dpressure:=(Pressureabsolute[js]-Pressureabsolute[jn])*dSquare/densuty_in_surface(jn,js);;
                    // dbglobal[ipi]:= dbglobal[ipi] + dpressure + ((1.0-myrelaxfactors.Momentum)*apbuf*VyOld[ipi])/myrelaxfactors.Momentum;

                    dbglobal[ipi]:=dbglobal[ipi]+0.0; // TODO 3 июня 2013
                 end;
                end // bout
                else
               begin
                   // Внимание. Данная секция кода жизненно необходима для SIMPLER (SIMPLE Revised) алгоритма.

                   // НЕ boutflow.
                   // и  это граничная точка.
                   // скорее всего это условие Дирихле и надо задать элементы матрицы и правую часть.
                   mglobal[ipi].dap:=1.0;
                   mglobal[ipi].dae:=0.0;
                   mglobal[ipi].dan:=0.0;
                   mglobal[ipi].das:=0.0;
                   mglobal[ipi].daw:=0.0;
                   // Заданная скорость на данной границе.
                   for i1:=1 to GridGenForm.inumboundary do
                   begin
                       if (GridGenForm.edgelist[i1].idescriptor = mapVy[i].iboundary) then
                       begin
                          // граница найдена
                          dbglobal[ipi]:=GridGenForm.edgelist[i1].Vy;
                       end;
                   end;
               end;
            end
             else
              begin
                 dbglobal[ipi]:=0.0; // нет источникового члена
                 // здесь всё будет построено на среднем арефметическом
                 case mapVy[i].iugol of
                 1 : // левый нижний угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.5;
                        mglobal[ipi].dan:=0.5;
                        mglobal[ipi].das:=0.0;
                        mglobal[ipi].daw:=0.0;
                     end;
                 2 : // правый нижний угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.0;
                        mglobal[ipi].dan:=0.5;
                        mglobal[ipi].das:=0.0;
                        mglobal[ipi].daw:=0.5;
                     end;
                 3 : // верхний левый угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.5;
                        mglobal[ipi].dan:=0.0;
                        mglobal[ipi].das:=0.5;
                        mglobal[ipi].daw:=0.0;
                     end;
                  4 : // верхний правй угол
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.0;
                        mglobal[ipi].dan:=0.0;
                        mglobal[ipi].das:=0.5;
                        mglobal[ipi].daw:=0.5;
                     end;
                  5 : // пятиточечная звезда
                     begin
                        mglobal[ipi].dap:=1.0;
                        mglobal[ipi].dae:=0.25;
                        mglobal[ipi].dan:=0.25;
                        mglobal[ipi].das:=0.25;
                        mglobal[ipi].daw:=0.25;
                     end;
                  end; //case

              end;
          end;
       end;
end;  // VyGlobalCoef

// решение нелинейного уравнения для вертикальной скорости
// методом переменных направлений.
// в стационарном случае
procedure TForm1.SolveVy(var mglobal : array of MatrixCoef;
                         var dbglobal : array of  Float);
const
   kgold = 3;

var
    //mglobal : array of MatrixCoef; // все коэффициенты дискретного аналога
    //dbglobal : array of  Float; // часть источникового члена
    i,k,k1 : Integer; // счётчики: внутренний и для преодоления нелинейности
    bflagconstruct : Boolean;
    Aseqx, Aseqy : TPeacemanRachford;
    QneiC : TQneiC;
    u1, u2, u3 : array of Float;
   dsum1, dsum2 : Float;
   ipi : Integer;

begin
    for k:=1 to 20 do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false;
      end;
   end;

   bflagconstruct:=True;

   // выделение оперативной памяти
   //SetLength(mglobal,inx*(iny-1)+1); // основные коэффициенты дискретного аналога
   //SetLength(dbglobal,inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам

   // iterSimple.iterVyLin - число итераций необходимое для решения линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.



     // цикл преодоления нелинейности
     // шаг 1:
     // вычисление коэффициентов дискретного аналога
     // проход по всем внутренним точкам
     VyGlobalCoef(mglobal,dbglobal,false);
     // шаг 2:
     // решение по сути линейного уравнения
     // с полученными ранее коэффициентами
     if (itypesolver.ivelocity < 3) then
     begin
        if (itypesolver.ivelocity=1) then
         begin
            if (bIlyinvel) then
            begin
               SetLength(u1, inx*(iny-1)+1);
               SetLength(u2, inx*(iny-1)+1);
               SetLength(u3, inx*(iny-1)+1);
               dsum1:=0.0;
               dsum2:=0.0;
            end;
         end;

        for i:=1 to iterSimple.iterVyLin do
        begin
           case itypesolver.ivelocity of
             1 : // ГЗ
                begin
                   if (bIlyinvel) then
                   begin
                      if (i<4) then
                      begin
                         relaxIlyin:=1.0;
                      end;
                   end;
                   // одна итерация методом Гаусса-Зейделя
                   GZUniversal(Vy,inx,iny-1, mapVy, 'V',  mglobal,dbglobal,QneiC);
                   if (bIlyinvel) then
                 begin
                    if (i mod kgold =0) then
                    begin
                       for k:=1 to imaxnumbernodeVy do
                       begin
                          if ((mapVy[k].itype=1)or(mapVy[k].itype=2)) then
                          begin
                             u1[mapVy[k].i+(mapVy[k].j-1)*inx]:=Vy[mapVy[k].i+(mapVy[k].j-1)*inx];
                          end;
                       end;
                    end;
                    if ((i-1) mod kgold = 0) then
                    begin
                       for k:=1 to imaxnumbernodeVy do
                       begin
                          if ((mapVy[k].itype=1)or(mapVy[k].itype=2)) then
                          begin
                             u2[mapVy[k].i+(mapVy[k].j-1)*inx]:=Vy[mapVy[k].i+(mapVy[k].j-1)*inx];
                          end;
                       end;
                    end;
                    if ((i-2)mod kgold = 0) then
                    begin
                       for k:=1 to imaxnumbernodeVy do
                       begin
                          if ((mapVy[k].itype=1)or(mapVy[k].itype=2)) then
                          begin
                             u3[mapVy[k].i+(mapVy[k].j-1)*inx]:=Vy[mapVy[k].i+(mapVy[k].j-1)*inx];
                          end;
                       end;
                       dsum1:=0.0;
                       dsum2:=0.0;
                       for k:=1 to imaxnumbernodeVy do
                       begin
                          if ((mapVy[k].itype=1)or(mapVy[k].itype=2)) then
                          begin
                            ipi:=mapVy[k].i+(mapVy[k].j-1)*inx;
                            dsum1:=dsum1+(u3[ipi]-u2[ipi])*(u3[ipi]-u2[ipi]);
                            dsum2:=dsum2+(u2[ipi]-u1[ipi])*(u2[ipi]-u1[ipi]);
                          end;
                       end;
                       if (abs(dsum2)>1.0e-30) then
                       begin
                          dsum1:=sqrt(dsum1/dsum2);
                          relaxIlyin:=2.0/(1.0+sqrt(fmax(1.0-dsum1,0.002))); // оптимальный параметр релаксации.
                       end;
                    end;
                 end;
                end;
             2 : // метод переменных направлений
                begin
                   // одна итерация методом переменных направлений
                   TDMAGibridGZUniversal(Vy,inx,iny-1, mapVy, 'V', mglobal, dbglobal, Aseqx, Aseqy, bflagconstruct);
                   bflagconstruct:=False;
                end;
           end; // case

        end; // i - конец решения линейной системы

        if (itypesolver.ivelocity=1) then
         begin
            if (bIlyinvel) then
            begin
               // Освобождение памяти.
               SetLength(u1,0);
               SetLength(u2,0);
               SetLength(u3,0);
               dsum1:=0.0;
               dsum2:=0.0;
            end;
         end;
     end
      else
     begin
        case itypesolver.ivelocity of
           3 : // алгоритм Ю.Г. Соловейчика [1993]
           begin
              // itypesolver.ivelocity = 3
              // с учётом конвективного члена, без печати диагностических сообщений,
              // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
              // квадрат значения невязки передаётся для того чтобы нормы были сопоставимы (сравнимы по значениям для разных методов).
              SoprGradCRSUniversal( Vy, inx, iny-1, mapVy, 'V', mglobal, true, false, iterSimple.iterVyLin, rcs.Vy*rcs.Vy, 1, dbglobal);
           end;
           4 : // прямой метод исключения Гаусса
           begin
              GaussUniversal(Vy,inx,iny-1, mapVy, 'V',  mglobal,dbglobal,false);
           end;
           5 : // классический алгломеративный алгебраический многосеточный метод.
           begin
              //GaussUniversal(Vy,inx,iny-1, mapVy, 'V',  mglobal,dbglobal,false);
              classical_aglomeration_amg(Vy,inx,iny-1, mapVy, 'V', mglobal, dbglobal, false);
           end;
         end; // case
     end;

end; // solveVy

(*
// совместное решение уравнений для горизонтальной
// и вертикальной компонент скорости
// по-моему это несколько улучшит скорость сходимости
// нелинейных уравнений для компонент скорости
procedure TForm1.SolveVxVyCoupled;
var
    mVxGlobal : array of MatrixCoef; // все коэффициенты дискретного аналога для Vx
    dbVxGlobal : array of  Float; // часть источникового члена  для Vx
    mVyGlobal : array of MatrixCoef; // все коэффициенты дискретного аналога  для Vy
    dbVyGlobal : array of  Float; // часть источникового члена  для Vy
    i, j : Integer; // счётчики внутренний и преодоления нелинейности
    // данные переменные позволяют судить о нахождении решения
    // нелинейного уравнения для верикальной компоненты скорости
    VxOldNonLin : array of  Float; // поле скорости Vx с предыдущей итерации по устранению нелинейности
    VyOldNonLin : array of  Float; // поле скорости Vy с предыдущей итерации по устранению нелинейности
    deviationVx, deviationVy :  Float;  // отклонение по каждой из компонент скорости
    deviation :  Float; // отклонение от скорости на предыдущей итерации по устранению нелинейности

begin
   // выделение оперативной памяти
   SetLength(mVxGlobal,(inx-1)*iny+1); // основные коэффициенты дискретного аналога
   SetLength(dbVxGlobal,(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(VxOldNonLin,(inx-1)*iny+1); // выделение памяти под скорость с предыдущей итерации
   // iterSimple.iterVxLin - количество итераций для решения внутренней номинально линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.
   SetLength(mVyGlobal,inx*(iny-1)+1); // основные коэффициенты дискретного аналога
   SetLength(dbVyGlobal,inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(VyOldNonLin,inx*(iny-1)+1); // выделение памяти под скорость с предыдущей итерации
   // iterSimple.iterVyLin - число итераций необходимое для решения линейной системы
   // замечание: количество внутренних итераций может быть и меньше,
   // здесь главное достич некой сходимости. Тратить много услилий на решение этой задачи не имеет смысла
   // т.к. коэффициенты на данном этапе известны лишь приближённо.
   // iterSimple.iterVyNonLin - количество циклов преодоления нелинейности

   RememberXvel(VxOldNonLin); // запоминание горизонтальной скорости
   RememberYvel(VyOldNonLin); // запоминание вертикальной скорости
   deviation:=1e3; // некоторое большое число
   j:=1;


   while (( deviation > min(rcs.Vx, rcs.Vy)) and (j <= max(iterSimple.iterVxNonLin,iterSimple.iterVyNonLin))) do
   begin
      // цикл преодоления нелинейности
      // шаг 1:
      // вычисление коэффициентов дискретного аналога
      // для горизонтальной компоненты скорости.
      // проход по всем внутренним точкам
      VxGlobalCoef(mVxGlobal,dbVxGlobal);

      // шаг 2:
      // решение по сути линейного уравнения
      // с полученными ранее коэффициентами
      if (itypesolver.ivelocity < 3) then
      begin
         for i:=1 to iterSimple.iterVxLin do
         begin
            case itypesolver.ivelocity of
             1 : // Гаусс-Зейдель
                begin
                   // одна итерация методом Гаусса-Зейделя
                   GZUniversal(Vx,inx-1,iny, mapVx, 'U', mVxGlobal,dbVxGlobal);
                end;
             2 : // метод переменных направлений
                begin
                   // одна итерация методом переменных направлений
                   TDMAGibridGZUniversal(Vx,inx-1,iny, mapVx, 'U', mVxGlobal,dbVxGlobal);
                end;
            end; // case

         end; // i - решение линейной системы
      end
       else
      begin
        case itypesolver.ivelocity of
           3 : // алгоритм Ю.Г. Соловейчика [1993]
           begin
              // itypesolver.ivelocity = 3
              // с учётом конвективного члена, без печати диагностических сообщений,
              // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
              SoprGradCRSUniversal( Vx, inx-1, iny, mapVx, 'U', mVxGlobal, true, false, iterSimple.iterVxLin, rcs.Vx, 1,dbVxGlobal);
            end;
           4 : // прямой метод исключения Гаусса
           begin
              GaussUniversal(Vx, inx-1, iny, mapVx, 'U',  mVxGlobal, dbVxGlobal,false);
           end;
        end; // case
      end;

      // шаг 3:
      // вычисление коэффициентов дискретного аналога
      // для вертикальной компоненты скорости Vy.
      // проход по всем внутренним точкам
      VyGlobalCoef(mVyGlobal,dbVyGlobal);

      // шаг 4:
      // решение по сути линейного уравнения
      // с полученными ранее коэффициентами
      if (itypesolver.ivelocity < 3) then
      begin
         for i:=1 to iterSimple.iterVyLin do
         begin
            case itypesolver.ivelocity of
              1 : // ГЗ
                 begin
                    // одна итерация методом Гаусса-Зейделя
                    GZUniversal(Vy,inx,iny-1, mapVy, 'V', mVyGlobal,dbVyGlobal);
                 end;
              2 : // метод переменных направлений
                 begin
                    // одна итерация методом переменных направлений
                    TDMAGibridGZUniversal(Vy,inx,iny-1, mapVy, 'V', mVyGlobal,dbVyGlobal);
                 end;
            end; // case

         end; // i - конец решения линейной системы
      end
       else
      begin
         case itypesolver.ivelocity of
           3 : // алгоритм Ю.Г. Соловейчика [1993]
           begin
              // itypesolver.ivelocity = 3
              // с учётом конвективного члена, без печати диагностических сообщений,
              // количество итераций равное кол-ву итераций в линейной системе, с соответствующим пороговым значением невязки
              SoprGradCRSUniversal( Vy, inx, iny-1, mapVy, 'V', mVyGlobal, true, false, iterSimple.iterVyLin, rcs.Vy, 1, dbVyGlobal);
           end;
           4 : // прямой метод исключения Гаусса
           begin
              GaussUniversal(Vy,inx,iny-1, mapVy, 'V',  mVyGlobal ,dbVyGlobal,false);
           end;
         end;//case
      end;


     j:=j+1; // переход к следующему циклу устранения нелинейности
     deviationVx:=mySupNorma2(Vx,VxOldNonLin,inx-1,iny);  // отклонение от предыдущей итерации
     RememberXvel(VxOldNonLin); // запоминание скорости
     deviationVy:=mySupNorma2(Vy,VyOldNonLin,inx,iny-1);  // отклонение от предыдущей итерации
     RememberYvel(VyOldNonLin); // запоминание скорости
     deviation:=max(deviationVx,deviationVy);
     //freport.Add(FloatToStr(deviation)); // для диагностики

   end; // нелинейность преодолена ?
   // смотри значение deviation


end; // SolveVxVyCoupled
*)

// преобразованные коэффициенты дискретного аналога
// компонент скорости (см. idirect : 1 - x, 2 - y)
// которые используются в уравнении для поправки давления.
function TForm1.Vcoefpam(i : Integer; j : Integer; idirect : Integer) :  Float;
var
   m : MatrixCoef; // для компонент скорости
   dapvel :  Float; // возвращаемое значение
   mf, attrsCR : Float;

function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin
   case idirect of
     1 : Vxcoef(i,j,m,mf,attrsCR); // m.dap=ae
     2 : Vycoef(i,j,m,mf,attrsCR); // m.dap=an
   end;

   if (bsimplec) then
   begin
      // ВНИМАНИЕ !!! ЭТО тождественный ноль при таком определении.
      // Определение неверно скорее всего.

      // НЕВЕРНОЕ определение.
      // Неверное определение осалось как пример ошибки, для того чтобы в будущем не делать
      // подобных ошибок.
      // алгоритм SIMPLEC
      // здесь может быть деление на ноль в будущем,
      // его нужно избежать:
      //dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
      // Ниже константа 1e-7 выбрана импирически чтобы избежать деления на ноль.
      // В принципе её значение спорно и может быть несколько другим.
      // Для задачи с изотермической каверной это работает.
      //if (fabs(dapvel) < 1e-17) then dapvel:=m.dap; // то-же значение что и в алгоритме SIMPLE.

      // Верное определение.
      // см. Гаврилов Андрей.
      dapvel:=(1.0-myrelaxfactors.Momentum)*m.dap;
   end
    else
   begin
      // алгоритм SIMPLE and SIMPLER
      dapvel:=m.dap;
   end;

   Result:=dapvel;
end; // Vcoefpam


// находится на стадии тестирования
// По всей видимости использование сверхрелаксации с параметром 1.9
// или какой-либо другой сверх релаксации здесь себя не оправдывает т.к.
// наблюдается остановка процесса сходимости в то время как она ещё не достигнута.
// Например, если не использовать сверхрелаксацию то процесс сходимости
// застрянет на значении 1e-5 в то время как если не использовать сверхрелаксацию
// вовсе, а использовать чистого Гаусса-Зейделя то невязки уменьшаются до значений 1e-10.
// Перед решением уравнения для поправки давления поле поправки давления
// надо инициализировать нулевым значением.
// решает линейное уравнение для поправки давления
// ускоренным методом Гаусса-Зейделя
// ускорение достигается за счёт того, что коэффициенты
// дискретного аналога не зависят от искомой функции
// т.е. уравнение линейно и эти коэффициенты можно
// вычислить только один раз и запомнить.
procedure TForm1.SolveGZPamendment(bipifix : Boolean; // фиксировать ли уровень поправки давления  ?
                                   var rescontinity :  Float); // нескомпенсированные источники массы
const bmax0 = false; // ограничение для давления снизу
      kgold = 3;
var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для поправки давления
   db : array of  Float; // коэффициенты источникового члена
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i1,j1,k,k1 : Integer;
   myrP : array of  Float; // невязка для поправки давления
   // следующая переменная используется для сверхрелаксации
   Ptilda :  Float; // новое приближение i-ой компоненты поправки давления
   deviation :  Float; // критерий выхода из цикла
   dapvel, rhointerpol :  Float;
   bnei, bvisit : Boolean;
   residual_history: array of  Float;
   relaxfactor : Float;
   bflagconstruct : Boolean;
   Aseqx, Aseqy : TPeacemanRachford;
   u1,u2,u3 : array of Float;
   dsum1, dsum2 : Float;
   mapPTold : TdynArraymyNodeold;

function fabs(rin : Float) : Float;
begin
    if (rin<0.0) then
    begin
        fabs:=-rin;
    end
     else
    begin
       fabs:=rin;
    end;
end;

begin
   bflagconstruct:=True;
   // если передаваемый параметр bipifix = true, то нужно фиксировать уровень поправки давления
   // на нулевом уровне, иначе bipifix = false поправка давления будет сама искать свой уровень.
   // Когда поправка давления сама ищет свой уровень, то это может означать более быструю сходимость,
   // т.к. отсутствует точка ipifix в центре расчётной области которая всё портит.
   // Однако для прямого методаисключения Гаусса фиксировать точку ipifix обязательно.

   // выделение памяти
   SetLength(mp,inx*iny+1); // массив коэффициентов
   SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
   SetLength(myrP,inx*iny+1); // выделение памяти под невязку
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
   while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя

    // предварительное вычисление индексов чтобы не тратить время на умножения на icolx.
    for k1:=1 to imaxnumbernode do
      begin
         with mapPT[k1] do
         begin
               // внутренний узел

               // координаты узлов для поправки давления
               // используется обыкновенная сетка
               ini:=i+j*inx; // север
               isi:=i+(j-2)*inx; // юг
               iwi:=(i-1)+(j-1)*inx; // запад
               iei:=(i+1)+(j-1)*inx; // восток
               ipi:=i+(j-1)*inx;  // текущая точка
         end;
      end;
   

  for k1:=1 to imaxnumbernode do
  begin
      with mapPT[k1] do
      begin
         // инициализация значений переменных
         //ipi:=i1+(j1-1)*inx;  // текущая точка
         // нулевыми значениями
         db[ipi]:=0.0;
         mp[ipi].dae:=0.0;
         mp[ipi].daw:=0.0;
         mp[ipi].dan:=0.0;
         mp[ipi].das:=0.0;
         mp[ipi].dap:=1.0; // т.к. на эту точку возможно деление
         myrP[ipi]:=0.0; // обнуление невязки
      end;
   end;


   // вычисление коэффициентов
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел

            bvisit:=false; // если true то поправка равна нулю

            // координаты узлов для поправки давления
            // используется обыкновенная сетка
            //ipi:=i+(j-1)*inx;  // текущая точка
            //iei:=(i+1)+(j-1)*inx; // восток
            //iwi:=(i-1)+(j-1)*inx; // запад
            //ini:=i+(j)*inx; // север
            //isi:=i+(j-2)*inx; // юг
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для поправки давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
            // требуется покрайней мере в четыре раза больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.
            // Здесь граничные коэффициенты дискретного аналога обнуляюся
            // и физически это означает, что граничные значения не влияют
            // на поле давления внутри расчётной области.
            // По этому поводу см. Патанкар ст. 108, 109.


            // в линейной струкруре карты mapPT
            // ориентация по сторонам света
            // юг, север, восток и запад происходит
            // всё по тем же правилам
            //rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
            rhointerpol:=densuty_in_surface(ipi,iei);
            if (mapPT[iei].itype <> 2) then
            begin
               // если северная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               //mp[ipi].dae:=rhointerpol*dy*dy/dapvel;
               mp[ipi].dae:=dy*dy/dapvel/rhointerpol;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[iei].iboundary, 'P',mapPT[iei].chnormal);
               if (not(bnei)) then
               begin
                  // поправка равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dae:=0.0; // нет влияния от давления на границе
               end;
           end;

           //rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
           rhointerpol:=densuty_in_surface(ipi,iwi);
           if (mapPT[iwi].itype <> 2) then
           begin
              // если южная точка не является граничной
              dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
              //mp[ipi].daw:=rhointerpol*dy*dy/dapvel;
              mp[ipi].daw:=dy*dy/dapvel/rhointerpol;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[iwi].iboundary, 'P',mapPT[iwi].chnormal);
              if (not(bnei)) then
              begin
                 // поправка равна нулю
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].daw:=0.0; // нет влияния от давления на границе
              end;
           end;

           //rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
           rhointerpol:=densuty_in_surface(ipi,ini);
           if (mapPT[ini].itype <> 2) then
           begin
              // если северная точка не является граничной
              dapvel:=Vcoefpam(i,j,2); // Vycoef
              //mp[ipi].dan:=rhointerpol*dx*dx/dapvel;
              mp[ipi].dan:=dx*dx/dapvel/rhointerpol;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[ini].iboundary, 'P', mapPT[ini].chnormal);
              if (not(bnei)) then
              begin
                 // поправка равна нулю
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].dan:=0.0; // нет влияния граничных условий
              end;
            end;

            //rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
            rhointerpol:=densuty_in_surface(ipi,isi);
            if (mapPT[isi].itype <> 2) then
            begin
               // если южная точка не является граничной
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               //mp[ipi].das:=rhointerpol*dx*dx/dapvel;
               mp[ipi].das:=dx*dx/dapvel/rhointerpol;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[isi].iboundary, 'P',mapPT[isi].chnormal);
               if (not(bnei)) then
               begin
                  // поправка равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].das:=0.0; // нет влияния граничных значений
               end;
            end;

            if (bvisit) then
            begin
               // поправка равна нулю
               mp[ipi].dap:=1.0;
               db[ipi]:=0.0;
               //db[ipi]:=0.0-P[ipi]; // Поправка такая чтобы давление было нулевым на выходной границе.
               mp[ipi].dae:=0.0;
               mp[ipi].daw:=0.0;
               mp[ipi].dan:=0.0;
               mp[ipi].das:=0.0;
            end
             else
            begin
               mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
               if (False and btimedepend) then
               begin
                  // нестационарный солвер.
                  db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                  //db[ipi]:=0.0;
               end
                else
               begin
                  db[ipi]:=0.0; // стационарный солвер.
               end;

               (*
               //rhointerpol:=2*density(ipi)*density(iwi)/(density(ipi)+density(iwi));
               rhointerpol:=densuty_in_surface(ipi,iwi);
               db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
               //rhointerpol:=2*density(ipi)*density(iei)/(density(ipi)+density(iei));
               rhointerpol:=densuty_in_surface(ipi,iei);
               db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
               //rhointerpol:=2*density(ipi)*density(isi)/(density(ipi)+density(isi));
               rhointerpol:=densuty_in_surface(ipi,isi);
               db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
               //rhointerpol:=2*density(ipi)*density(ini)/(density(ipi)+density(ini));
               rhointerpol:=densuty_in_surface(ipi,ini);
               db[ipi]:=db[ipi] - rhointerpol*Vy[incvi]*dx;
               *)
               db[ipi]:=db[ipi] + Vx[iwcvi]*dy;
               db[ipi]:=db[ipi] - Vx[iecvi]*dy;
               db[ipi]:=db[ipi] + Vy[iscvi]*dx;
               db[ipi]:=db[ipi] - Vy[incvi]*dx;

            end;
         end;
      end; // with
   end;

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity:
   case ibasenorma of
      1 : // евклидова норма
        begin
           rescontinity:=myEvklidNorma(db,inx,iny); // невязка continity
        end;
      2 : // кубическая
        begin
           rescontinity:=mySupNorma(db,inx,iny); // невязка continity
        end;
      3 : // октаэдрическая
        begin
           rescontinity:=mySup2Norma(db,inx,iny); // невязка continity
        end;
   end;

   SetLength(residual_history,iterSimple.iterPamendment+1);

   SetLength(mapPTold,imaxnumbernode+2);

    for k1:=1 to imaxnumbernode do
      begin
        mapPTold[k1].itype:=mapPT[k1].itype;
        mapPTold[k1].i:=mapPT[k1].i;
        mapPTold[k1].j:=mapPT[k1].j;
        mapPTold[k1].dx:=mapPT[k1].dx;
        mapPTold[k1].dy:=mapPT[k1].dy;
        mapPTold[k1].dV:=mapPT[k1].dV;
        mapPTold[k1].dxe:=mapPT[k1].dxe;
        mapPTold[k1].dxw:=mapPT[k1].dxw;
        mapPTold[k1].dyn:=mapPT[k1].dyn;
        mapPTold[k1].dys:=mapPT[k1].dys;
        mapPTold[k1].iboundary:=mapPT[k1].iboundary;
        mapPTold[k1].chnormal:=mapPT[k1].chnormal;
        mapPTold[k1].iugol:=mapPT[k1].iugol;
        mapPTold[k1].ini:=mapPT[k1].ini;
        mapPTold[k1].isi:=mapPT[k1].isi;
        mapPTold[k1].iwi:=mapPT[k1].iwi;
        mapPTold[k1].iei:=mapPT[k1].iei;
        mapPTold[k1].ipi:=mapPT[k1].ipi;
      end;

   case ilanguage of
    0 : begin
       // Язык Паскаль.

       if (itypesolver.ipamendment=1) then
       begin
           // Метод Гаусса-Зейделя

           // теперь когда все коэффициенты вычислены
           // можно приступить к решению.
           deviation:=1e300; // очень большое число
           k:=1;

           if (bIlyin) then
           begin
              SetLength(u1,inx*iny+1);
              SetLength(u2,inx*iny+1);
              SetLength(u3,inx*iny+1);
              dsum1:=0.0;
              dsum2:=0.0;
           end;

           while ((deviation > rcs.Pamendment) and (k<=iterSimple.iterPamendment)) do
           begin

              if (bIlyin) then
              begin
                 if (k<4) then
                 begin
                    relaxIlyin:=1.0;
                 end;
              end;

              // как быть с граничными условиями для поправки давления ?
              for k1:=1 to imaxnumbernode do
              begin
                 with mapPT[k1] do
                 begin
                    if (itype = 1) then
                    begin


                        // внутренний узел

                        // координаты узлов для поправки давления
                        // используется обыкновенная сетка
                        //ini:=i+j*inx; // север
                        //isi:=i+(j-2)*inx; // юг
                        //iwi:=(i-1)+(j-1)*inx; // запад
                        //iei:=(i+1)+(j-1)*inx; // восток
                        //ipi:=i+(j-1)*inx;  // текущая точка
                        // здесь может быть деление на ноль, его надо исключить
                        if (fabs(mp[ipi].dap) > 1e-37) then
                        begin
                           // здесь гарантировно нет деления на ноль
                           if ((bipifix) and (ipi=ipifix)) then
                           begin
                              Pamendment[ipifix]:=0.0; // фиксируем уровень
                           end
                            else
                           begin

                              // Сверхрелаксация с коэффициентом 1.9 убрана, т.к.
                              // по-моему, препятствует сходимости вычислительного
                              // процесса: невязки уменьшаются до определённого значения,
                              // скажем 1e-5 и дальше не падают.
                              // Если убрать какую-бы то ни было релаксацию и оставить
                              // чистого Гаусса-Зейделя то сходимость гарантирована.
                              // Здесь оставлен чистый Гаусс-Зейдель (соответствует значению 1.0).

                              // С другой стороны было выяснено что можно сократить время счёта на порядка 37% (что эквивалентно эффекту расчёта
                              // уравнения для поправки давления на 4 ядрах) сократив в 7 раз количество итераций для поправки давления, но
                              // скомпенсировав это тем что выставить параметр верхней релаксации для давления равный например 1.855.
                              // Это даст сходимость за тоже количество итераций что и раньше только быстрее на 37%.
                              Ptilda:=(mp[ipi].dae*Pamendment[iei]+mp[ipi].daw*Pamendment[iwi]+mp[ipi].dan*Pamendment[ini]+mp[ipi].das*Pamendment[isi]+db[ipi])/mp[ipi].dap;
                              // Внимание !!! неверно ограничивать поправку давления снизу значением нол и вообще ограничивать её.

                              if (bIlyin) then
                              begin
                                 Pamendment[ipi]:=Pamendment[ipi]+relaxIlyin*(Ptilda-Pamendment[ipi]);
                              end
                              else
                              begin
                                 Pamendment[ipi]:=Pamendment[ipi]+myrelaxfactors.pSORPressure*(Ptilda-Pamendment[ipi]);
                                 //Pamendment[ipi]:=Pamendment[ipi]+relaxfactor*(Ptilda-Pamendment[ipi]);
                              end;
                           end;
                        end;
                    end; // проход по
                 end; // with
              end; // внутренним точкам

              if (bIlyin) then
              begin
                 if (k mod kgold =0) then
                 begin
                    for k1:=1 to imaxnumbernode do
                    begin
                       with mapPT[k1] do
                       begin
                          if (itype = 1) then
                          begin
                             u1[ipi]:=Pamendment[ipi];
                          end;
                        end;
                    end;
                 end;
                 if ((k-1)mod kgold = 0) then
                 begin
                    for k1:=1 to imaxnumbernode do
                    begin
                       with mapPT[k1] do
                       begin
                          if (itype = 1) then
                          begin
                             u2[ipi]:=Pamendment[ipi];
                          end;
                        end;
                    end;
                 end;
                 if ((k-2)mod kgold = 0) then
                 begin
                    for k1:=1 to imaxnumbernode do
                    begin
                       with mapPT[k1] do
                       begin
                          if (itype = 1) then
                          begin
                             u3[ipi]:=Pamendment[ipi];
                          end;
                        end;
                    end;
                    dsum1:=0.0;
                    dsum2:=0.0;
                    for k1:=1 to imaxnumbernode do
                    begin
                       with mapPT[k1] do
                       begin
                          if (itype = 1) then
                          begin
                             dsum1:=dsum1+(u3[ipi]-u2[ipi])*(u3[ipi]-u2[ipi]);
                             dsum2:=dsum2+(u2[ipi]-u1[ipi])*(u2[ipi]-u1[ipi]);
                          end;
                        end;
                    end;
                    if (fabs(dsum2)>1.0e-30) then
                    begin
                       dsum1:=sqrt(dsum1/dsum2);
                       relaxIlyin:=2.0/(1.0+sqrt(fmax(1.0-dsum1,0.002)));
                    end;
                 end;
              end;

              // для существенного ускорения
              // времени счёта невязка будет вычисляться
              // каждую 0.5*(inx+iny) итерацию солвера Гаусса и Зейделя.
              // Время вычисления невязки равно времени одной итерации Г-З
              if (((2*k) mod (inx+iny)) = 0) then
              begin
                 // отслеживаем невязку Pamendment
                 for k1:=1 to imaxnumbernode do
                 begin
                    with (mapPT[k1]) do
                    begin
                       if (itype = 1) then
                       begin
                          // внутренний узел

                          // используется обыкновенная сетка
                          //ipi:=i+(j-1)*inx;  // текущая точка
                          if ((bipifix) and (ipi = ipifix)) then
                          begin
                             myrP[ipifix]:=0.0; // одно уравнение выполняется точно
                          end
                           else
                          begin
                             //ini:=i+j*inx; // север
                             //isi:=i+(j-2)*inx; // юг
                             //iwi:=(i-1)+(j-1)*inx; // запад
                             //iei:=(i+1)+(j-1)*inx; // восток
                             myrP[ipi]:=mp[ipi].dae*Pamendment[iei];
                             myrP[ipi]:=myrP[ipi]+mp[ipi].daw*Pamendment[iwi];
                             myrP[ipi]:=myrP[ipi]+mp[ipi].dan*Pamendment[ini];
                             myrP[ipi]:=myrP[ipi]+mp[ipi].das*Pamendment[isi];
                             myrP[ipi]:=myrP[ipi]+db[ipi]-mp[ipi].dap*Pamendment[ipi];
                          end;
                       end;
                    end; // with
                 end;


                 // проверка того насколько точно выполняется
                 // дискретный аналог
                 case ibasenorma of
                   1 : // евклидова норма
                      begin
                         // насколько точно выполняется дискретный аналог
                         deviation:=myEvklidNorma(myrP,inx,iny);
                      end;
                   2 : // кубическая
                      begin
                         // насколько точно выполняется дискретный аналог
                         deviation:=mySupNorma(myrP,inx,iny);
                      end;
                   3 : // октаэдрическая
                      begin
                         // насколько точно выполняется дискретный аналог
                         deviation:=mySup2Norma(myrP,inx,iny);
                      end;
                 end;

                 //freport.Add(FloatToStr(deviation));
              end;

              k:=k+1; // переход к следующей итерации
           end; // k

           if (bIlyin) then
           begin
              SetLength(u1,0);
              SetLength(u2,0);
              SetLength(u3,0);
              dsum1:=0.0;
              dsum2:=0.0;
           end;

       end
        else
       begin
          k:=1;
          deviation:=1e300;
          while ((deviation > rcs.Pamendment) and (k <= iterSimple.iterPamendment)) do
          begin
             // одна итерация методом переменных направлений
             // для поля температур и граничных условий первого рода
             TDMAGibridGZUniversal(Pamendment,inx,iny, mapPT, 'P',mp, db, Aseqx, Aseqy, bflagconstruct);
             bflagconstruct:=False;
             if (((2*k) mod (inx+iny)) = 0 ) then
             begin
                deviation:=myResidual(Pamendment, myrP, inx, iny, mapPT, 'P', mp, db);
             end;
             inc(k); // переход к следующей итерации
          end;
       end;



   end;

   1 : begin
          // язык Си

          if ((itypesolver.ipamendment=4) and (inx>4) and (iny>4)) then
          begin
             // Если сетка меньше чем 5x5 то данная реализация метода сопряжённых
             // градиентов не может быть применена и автоматически будет осуществлён переход
             // на метод Гаусса-Зейделя.

             // метод сопряжённых градиентов для давления и поправки давления.
             cg_pressure(rcs.Pamendment,
							 iterSimple.iterPamendment,
							 imaxnumbernode,
							 inx, iny,
							 bipifix,
						  ipifix,
							ibasenorma,
							@mp,
							@mapPTold,
							@Pamendment,
							@db,
							@myrP,
							@residual_history, // история изменеия невязок
							itypesorter,
              @pointerlist_gl,
              @pointerlistrevers_gl,
              bconstr, 0);
          end else if ((itypesolver.ipamendment=5) and (inx>4) and (iny>4)) then
          begin
             // Если сетка меньше чем 5x5 то данная реализация алгоритма Ван Дер Ворста
             // BiCGStab не может быть применена и автоматически будет осуществлён переход
             // на метод Гаусса-Зейделя.

             // метод сопряжённых градиентов для давления и поправки давления.
             cg_pressure(rcs.Pamendment,
							 iterSimple.iterPamendment,
							 imaxnumbernode,
							 inx, iny,
							 bipifix,
						  ipifix,
							ibasenorma,
							@mp,
							@mapPTold,
							@Pamendment,
							@db,
							@myrP,
							@residual_history, // история изменеия невязок
							itypesorter,
              @pointerlist_gl,
              @pointerlistrevers_gl,
              bconstr, 1);
          end
          else
          begin

          // Солвер Гаусса-Зейделя.


          seidel_pressure(rcs.Pamendment,
							iterSimple.iterPamendment,
							imaxnumbernode,
              inx, iny,
							bipifix,
						  ipifix,
							ibasenorma,
							@mp,
							@mapPTold,
							@Pamendment,
							@db,
							@myrP,
              myrelaxfactors.pSORPressure);

          end;

       end;

   2 : begin
          // язык Си с добавлением OpenMP

          seidel_pressure_omp(rcs.Pamendment,
							iterSimple.iterPamendment,
							imaxnumbernode,
              inx, iny,
							bipifix,
						  ipifix,
							ibasenorma,
							@mp,
							@mapPTold,
							@Pamendment,
							@db,
							@myrP,
              ig_nNumberOfThreads,
              myrelaxfactors.pSORPressure);

       end;

   end; // case

   // Восстановим значения поправки давления находящиеся вне расчётной области.
    for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
         begin
            if (itype=2) then
            begin
               //ipi:=i+(j-1)*inx;  // текущая точка

               case iugol of
                 0 : begin
                        // Неугловая и нужно снести поправку на границу области.
                        case chnormal of
                           'N' : begin
                                    Pamendment[ipi]:=Pamendment[i+(j-1+1)*inx];
                           end;
                           'S' : begin
                                    Pamendment[ipi]:=Pamendment[i+(j-1-1)*inx];
                           end;
                           'W' : begin
                                    Pamendment[ipi]:=Pamendment[i-1+(j-1)*inx];
                           end;
                           'E' : begin
                                    Pamendment[ipi]:=Pamendment[i+1+(j-1)*inx];
                           end;
                        end;
                     end;
                 1 : begin
                        // левый нижний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i+1+(j-1)*inx]+Pamendment[i+(j-1+1)*inx]);
                     end;
                 2 : begin
                        // правый нижний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i-1+(j-1)*inx]+Pamendment[i+(j-1+1)*inx]);
                     end;
                 3 : begin
                        // левый верхний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i+1+(j-1)*inx]+Pamendment[i+(j-1-1)*inx]);
                     end;
                 4 : begin
                        // правый верхний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i-1+(j-1)*inx]+Pamendment[i+(j-1-1)*inx]);
                     end;
                 5 : begin
                        // узел пятиточечный крест.
                        Pamendment[ipi]:=0.25*(Pamendment[i-1+(j-1)*inx]+Pamendment[i+(j-1-1)*inx]+Pamendment[i+1+(j-1)*inx]+Pamendment[i+(j-1+1)*inx]);
                     end;
               end;
            end;
         end;
      end;

     SetLength(mapPTold,0);
   //ShowMessage('k='+IntToStr(k));

end; // SolveGZPamendment

// нескомпенсированные источники массы
procedure TForm1.PamendmentCoef(var rescontinity :  Float;
            var mp : array of MatrixCoef; // коэффициенты дискретного аналога
            var db : array of  Float); // коэффициенты источникового члена
const
    epsilon = 1.0e-100;
var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   m : MatrixCoef; // используется для вычисления в компонентах скорости
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i1,j1,k,k1 : Integer;
   // следующая переменная используется для сверхрелаксации
   Ptilda :  Float; // новое приближение i-ой компоненты поправки давления
   deviation :  Float; // критерий выхода из цикла
   dapvel, rhointerpol :  Float;
   bnei: Boolean;
   dbuf : Float;

begin
   // если передаваемый параметр bipifix = true, то нужно фиксировать уровень поправки давления
   // на нулевом уровне, иначе bipifix = false поправка давления будет сама искать свой уровень.
   // Когда поправка давления сама ищет свой уровень, то это может означать более быструю сходимость,
   // т.к. отсутствует точка ipifix в центре расчётной области которая всё портит.
   // Однако для прямого методаисключения Гаусса фиксировать точку ipifix обязательно.


   // Инициализация обязательно важна
   for i1:=1 to inx do
   begin
      for j1:=1 to iny do
      begin
         // инициализация значений переменных
         ipi:=i1+(j1-1)*inx;  // текущая точка
         // нулевыми значениями
         db[ipi]:=0.0;
         mp[ipi].dae:=0.0;
         mp[ipi].daw:=0.0;
         mp[ipi].dan:=0.0;
         mp[ipi].das:=0.0;
         mp[ipi].dap:=1.0; // т.к. на эту точку возможно деление
      end;
   end;


   // вычисление коэффициентов
   for i1:=1 to imaxnumbernode do
   begin
      with mapPT[i1] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел

            // координаты узлов для поправки давления
            // используется обыкновенная сетка
            ipi:=i+(j-1)*inx;  // текущая точка
            iei:=(i+1)+(j-1)*inx; // восток
            iwi:=(i-1)+(j-1)*inx; // запад
            ini:=i+(j)*inx; // север
            isi:=i+(j-2)*inx; // юг
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для поправки давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты
            //  дискретного аналога) требуется покрайней мере в четыре раза
            // больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.
            // Здесь граничные коэффициенты дискретного аналога обнуляюся
            // и физически это означает, что граничные значения не влияют
            // на поле давления внутри расчётной области.
            // По этому поводу см. Патанкар ст. 108, 109.

            rhointerpol:=densuty_in_surface(ipi,iei);
            if (mapPT[iei].itype <> 2) then
            begin
               // если восточная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dae:=rhointerpol*dy*dy/dapvel;
            end
             else
            begin
               // есть влияние с востока
               // восточная точка  является граничной
               VxcoefRight(i,j,m,dbuf);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
               // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dae:=rhointerpol*dy*dy/dapvel;

                //mp[ipi].dae:=0.0; // нет влияния с востока
            end;

            rhointerpol:=densuty_in_surface(ipi,iwi);
            if (mapPT[iwi].itype <> 2) then
            begin
               // если западная точка не является граничной
               dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].daw:=rhointerpol*dy*dy/dapvel;
            end
             else
            begin

               // западная точка является граничной
               VxcoefLeft(i,j,m,dbuf);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
                // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].daw:=rhointerpol*dy*dy/dapvel;

               //mp[ipi].daw:=0.0;  // нет влияния с запада
            end;

            rhointerpol:=densuty_in_surface(ipi,ini);
            if (mapPT[ini].itype <> 2) then
            begin
               // если северная точка не является граничной
               dapvel:=Vcoefpam(i,j,2); // Vycoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dan:=rhointerpol*dx*dx/dapvel;
            end
             else
            begin

               // северная точка является граничной
               VycoefTop(i,j,m,dbuf);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
               // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].dan:=rhointerpol*dx*dx/dapvel;

                //mp[ipi].dan:=0.0; // нет влияния с севера
            end;

            rhointerpol:=densuty_in_surface(ipi,isi);
            if (mapPT[isi].itype <> 2) then
            begin
               // если южная точка не является граничной
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].das:=rhointerpol*dx*dx/dapvel;
            end
             else
            begin

               // южная точка является граничной
               // есть влияние от южной точки
               VycoefBottom(i,j,m,dbuf);
               if (bsimplec) then
               begin
                  dapvel:=m.dap - (m.dae + m.daw + m.dan + m.das);
                  if (abs(dapvel) < epsilon) then dapvel:=m.dap;
               end
                else
               begin
                  dapvel:=m.dap;
               end;
               // чтобы избежать деления на ноль.
               if (abs(dapvel) < epsilon) then dapvel:=1.0;
               mp[ipi].das:=rhointerpol*dx*dx/dapvel;

                //mp[ipi].das:=0.0; // нет влияния с юга
            end;

            // см Патанкар стр. 104.
            mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;

            if (btimedepend) then
            begin
               db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
            end
            else
            begin
               db[ipi]:=0.0;
            end;
            rhointerpol:=densuty_in_surface(ipi,iwi);
            db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
            rhointerpol:=densuty_in_surface(ipi,iei);
            db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
            rhointerpol:=densuty_in_surface(ipi,isi);
            db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
            rhointerpol:=densuty_in_surface(ipi,ini);
            db[ipi]:=db[ipi] - rhointerpol*Vy[incvi]*dx;

         end; // внутренний узел


         if (itype = 2) then
         begin
            // граничная точка

            ipi:=i+(j-1)*inx;  // текущая точка
            iei:=(i+1)+(j-1)*inx; // восток
            iwi:=(i-1)+(j-1)*inx; // запад
            ini:=i+(j)*inx; // север
            isi:=i+(j-2)*inx; // юг

            // граничный узел
            if (iugol=0) then
            begin
               // если граница выходная из расчётной области,
               // то возвращает false.
               // если на границе задано давление то возвращает false.
               // в любых других случаях возвращает true.

               bnei:=GridGenForm.isneiman(iboundary ,'P',chnormal);
               // граничная точка не являющаяся угловой
               case chnormal of
                'N' : // север
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].dan:=1;
                         iecvi:=i+(j-1)*(inx-1); // в массиве Vx
                         iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
                         if (btimedepend) then
                         begin
                            db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         end
                         else
                         begin
                            db[ipi]:=0.0;
                         end;
                         rhointerpol:=densuty_in_surface(ipi,iwi);
                         db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
                         rhointerpol:=densuty_in_surface(ipi,iei);
                         db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
                         mp[ipi].dap:=mp[ipi].dan;

                      end
                       else
                      begin
                         // нулевое значение поправки заданное давление на границе
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
                'S' : // юг
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].das:=1;
                         iecvi:=i+(j-1)*(inx-1); // в массиве Vx
                         iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
                         if (btimedepend) then
                         begin
                            db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         end
                         else
                         begin
                            db[ipi]:=0.0;
                         end;
                         rhointerpol:=densuty_in_surface(ipi,iwi);
                         db[ipi]:=db[ipi] + rhointerpol*Vx[iwcvi]*dy;
                         rhointerpol:=densuty_in_surface(ipi,iei);
                         db[ipi]:=db[ipi] - rhointerpol*Vx[iecvi]*dy;
                         mp[ipi].dap:=mp[ipi].das;
                      end
                       else
                      begin
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
                'W' : // запад  (правая стенка)
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].daw:=1;
                         incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
                         iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
                         if (btimedepend) then
                         begin
                            db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         end
                         else
                         begin
                            db[ipi]:=0.0;
                         end;
                         rhointerpol:=densuty_in_surface(ipi,isi);
                         db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
                         rhointerpol:=densuty_in_surface(ipi,ini);
                         db[ipi]:= db[ipi] - rhointerpol*Vy[incvi]*dx;
                         mp[ipi].dap:=mp[ipi].daw;
                      end
                       else
                      begin
                         // заданное давление на границе
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
                'E' : // восток
                   begin
                      if (bnei) then
                      begin
                         // нормальная производная равна нулю.
                         // нормаль внутренняя
                         mp[ipi].dae:=1;
                         incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
                         iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
                         if (btimedepend) then
                         begin
                            db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
                         end
                         else
                         begin
                            db[ipi]:=0.0;
                         end;
                         rhointerpol:=densuty_in_surface(ipi,isi);
                         db[ipi]:=db[ipi] + rhointerpol*Vy[iscvi]*dx;
                         rhointerpol:=densuty_in_surface(ipi,ini);
                         db[ipi]:= db[ipi] - rhointerpol*Vy[incvi]*dx;
                         mp[ipi].dap:=mp[ipi].dae;
                      end
                       else
                      begin
                         mp[ipi].dap:=1;
                         // остальные значения в силу предыдущей инициализации
                         // нулевое значение поправки соответствует заданному давлению на границе
                      end;
                   end;
               end; // case
            end
             else
            begin
               // угловая точка основано на среднем арефметическом
               case iugol of
                1 :  // левый нижний угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].dae:=0.5;
                     mp[ipi].dan:=0.5;
                     db[ipi]:= 0.0;
                  end;
                2 : // правый нижний угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].daw:=0.5;
                     mp[ipi].dan:=0.5;
                     db[ipi]:= 0.0;
                  end;
                3 : // верхний левый угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].dae:=0.5;
                     mp[ipi].das:=0.5;
                     db[ipi]:= 0.0;
                  end;
                4 : // верхний правый угол
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].daw:=0.5;
                     mp[ipi].das:=0.5;
                     db[ipi]:= 0.0;
                  end;
                5 : // пятиточечная звезда
                  begin
                     mp[ipi].dap:=1.0;
                     mp[ipi].dan:=0.25;
                     mp[ipi].das:=0.25;
                     mp[ipi].daw:=0.25;
                     mp[ipi].dae:=0.25;
                     db[ipi]:= 0.0;
                  end;
               end; // case
           end; // угловая точка
        end; // граничная точка
      end; // with
   end;  // конец цикла по всем точкам

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity:
   case ibasenorma of
      1 : // евклидова норма
        begin
           rescontinity:=myEvklidNorma(db,inx,iny); // невязка continity
        end;
      2 : // кубическая
        begin
           rescontinity:=mySupNorma(db,inx,iny); // невязка continity
        end;
      3 : // октаэдрическая
        begin
           rescontinity:=mySup2Norma(db,inx,iny); // невязка continity
        end;
   end;


end; // PamendmentCoef

// находится на стадии тестирования
// Операции по определению поля давления самые ресурсоёмкие.
// Перед решением уравнения для поправки давления поле поправки давления
// надо инициализировать нулевым значением.
// решает линейное уравнение для поправки давления
//  методом сопряжённых градиентов Хестенса и Штифмена.
// Здесь формируется матрица СЛАУ которая затем передаётся
// уточняющему солверу SoprGrad.
// этот метод неэффективен по памяти т.к. здесь очень много памяти
// уходит на большую матрицу СЛАУ.
procedure TForm1.SolveUniversalPamendment(bGaussTransform : Boolean;
                                          bHestensenShtifiel : Boolean;
                                          var rescontinity :  Float);
// bGaussTransform - нужно ли использовать Трансформацию Гаусса: true - ДА, false - НЕТ.
// bHestensenShtifiel - нужно ли использовать метод сопряжённых Градиентов,
// альтернативой которому служит прямой метод исключения Гаусса.
// rescontinity - показатель сходимости всей системы уравнений Навье-Стокса,
// нескомпенсированные источники массы которые должны быть скомпенсированы.

var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для поправки давления
   db : array of Float; // коэффициенты источникового члена
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i1,j1,k1 : Integer; // Счётчики цикла for
   dapvel :  Float; // коэффициент дискретного аналога в уравнениях для импульса
   dA  : array of TmyDynArray; // матрица СЛАУ
   move : array of Integer;
   dV  : array of  Float; // вектор правой части
   dx  : array of  Float; // вектор с решением
   bnei, bvisit : Boolean;

begin
   // TODO 4 июня

   // предположительно довольно много времени уходит
   // на выделение памяти
   // выделение памяти
   SetLength(mp,mzapas*inx*iny+1); // массив коэффициентов
   SetLength(db,mzapas*inx*iny+1); // коэффициенты связанные с наличием источникового члена
   SetLength(dA,mzapas*inx*iny); // Матрица СЛАУ
   SetLength(move, mzapas*inx*iny); // для ленточной матрицы
   for i1:=0 to (inx*iny-1) do SetLength(dA[i1], mzapas*inx*iny);
   SetLength(dV,mzapas*inx*iny); // вектор правой части
   SetLength(dx,mzapas*inx*iny); // вектор с результатом

   // обнуление матрицы dA
   for i1:=0 to (inx*iny-1) do for j1:=0 to (inx*iny-1) do dA[i1][j1]:=0.0;
   // инициализация векторов dx и dV
   for i1:=0 to (inx*iny-1) do
   begin
      dV[i1]:=0.0;
      dx[i1]:=0.0;
   end;

   // ipifix - фиксированная точка где-то в центре расчётной области
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;
   while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя

   // вычисление коэффициентов
   // дискретного аналога во внутренних точках
   // расчётной области
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         if (itype=1) then
         begin
            // внутренний узел

            bvisit:=false; // если true то поправка давления равна нулю

            // координаты узлов для поправки давления
            // используется обыкновенная сетка
            ini:=i+j*inx; // север
            isi:=i+(j-2)*inx; // юг
            iwi:=(i-1)+(j-1)*inx; // запад
            iei:=(i+1)+(j-1)*inx; // восток
            ipi:=i+(j-1)*inx;  // текущая точка
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для поправки давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
            // требуется покрайней мере в четыре раза больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.


            if (mapPT[iei].itype <> 2) then
            begin
               // если восточная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               mp[ipi].dae:=densuty_in_surface(iei,ipi)*dy*dy/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[iei].iboundary, 'P', mapPT[iei].chnormal);
               if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dae:=0; // нет влияния от давления на границе
               end;
            end;

            if (mapPT[iwi].itype <> 2) then
            begin
               dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
               mp[ipi].daw:=densuty_in_surface(iwi,ipi)*dy*dy/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[iwi].iboundary, 'P', mapPT[iwi].chnormal);
               if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].daw:=0; // нет влияния от давления на границе
               end;
            end;

            if (mapPT[ini].itype <> 2) then
            begin
                // если северная точка не является граничной
                dapvel:=Vcoefpam(i,j,2); // Vycoef
                mp[ipi].dan:=densuty_in_surface(ini,ipi)*dx*dx/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[ini].iboundary, 'P', mapPT[ini].chnormal);
               if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dan:=0; // нет влияния граничных условий
               end;
            end;

            if (mapPT[isi].itype <> 2) then
            begin
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               mp[ipi].das:=densuty_in_surface(isi,ipi)*dx*dx/dapvel;
            end
             else
            begin
               bnei:=GridGenForm.isneiman(mapPT[isi].iboundary, 'P', mapPT[isi].chnormal);
                if (not(bnei)) then
               begin
                  // поправка давления равна нулю
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].das:=0; // нет влияния граничных значений
               end;
            end;

            if (bvisit) then
            begin
               // поправка давления равна нулю
               mp[ipi].dap:=1.0;
               db[ipi]:=0.0;
               mp[ipi].dae:=0.0;
               mp[ipi].daw:=0.0;
               mp[ipi].dan:=0.0;
               mp[ipi].das:=0.0;
            end
             else
            begin
               mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
               db[ipi]:=drho*(Vx[iwcvi]-Vx[iecvi])*dy+drho*(Vy[iscvi]-Vy[incvi])*dx;
            end;

            if ((i+(j-1)*inx) <> ipifix) then
            begin
               // формирование матрицы СЛАУ dA и вектора правой части dV
               dA[ipi-1][ipi-1]:= mp[ipi].dap; // центральная узловая точка
               dA[ipi-1][iei-1]:= - mp[ipi].dae;  // восток
               dA[ipi-1][iwi-1]:= - mp[ipi].daw;  // запад
               dA[ipi-1][ini-1]:= - mp[ipi].dan;  // север
               dA[ipi-1][isi-1]:= - mp[ipi].das;  // юг
              // ? dV[ipi-1]:= db[ipi]; // вектор правой части
            end
             else
            begin
               // фиксируем значение в центральной точке
               // расчётной области
               // это нужно сделать именно в этой секции,
               // т.к. если это сделать после то пришлось бы обнулять
               // дополнительные прежде заполненнные элементы матрицы A в одной из строк.
               dA[ipifix-1][ipifix-1]:= 1.0;
               // ? dV[ipifix-1]:= 0.0;
            end;

        end; // itype=1 внутренний узел
      end; // with
   end; // k1

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity...

   case ibasenorma of
       1 : // евклидова норма
          begin
             rescontinity:=myEvklidNorma(db,inx,iny);
          end;
       2 : // кубическая
          begin
             rescontinity:=mySupNorma(db,inx,iny);
          end;
       3 : // октаэдрическая
          begin
             rescontinity:=mySup2Norma(db,inx,iny);
          end;
   end;

   // Здесь на границе ставится условие Неймана
   // нормальная производная от поправки давления равна нулю.
   // По этому поводу см. 1. Патанкар ст. 108, 109.
   // 2. статья В.М. Ковеня Об одном алгоритме решения
   // уравнений Навье-Стокса вязкой несжимаемой жидкости.
   // 3. Лев Герасимович Лойцянский Механика жидкости и газа.

   (*
   // Условие Неймана на нижней
   // и верхней границах
   for i1:=2 to inx-1 do
   begin
      j1:=1; // низ
      ipi:=i1+(j1-1)*inx;  // текущая точка
      ini:=i1+j1*inx; // север
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][ini-1]:=-1.0;
      dV[ipi-1]:= 0.0;
      j1:=iny; // верх
      ipi:=i1+(j1-1)*inx;  // текущая точка
      isi:=i1+(j1-2)*inx; // юг
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][isi-1]:=-1.0;
      dV[ipi-1]:= 0.0;
   end;

   // Условие Неймана на левой
   // и правой границах
   for j1:=2 to iny-1 do
   begin
      i1:=1; // лево
      ipi:=i1+(j1-1)*inx;  // текущая точка
      iei:=(i1+1)+(j1-1)*inx; // восток
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][iei-1]:=-1.0;
      dV[ipi-1]:= 0.0;
      i1:=inx; // право
      ipi:=i1+(j1-1)*inx;  // текущая точка
      iwi:=(i1-1)+(j1-1)*inx; // запад
      dA[ipi-1][ipi-1]:=1.0;
      dA[ipi-1][iwi-1]:=-1.0;
      dV[ipi-1]:= 0.0;
   end;

   // Значение давления в 4
   // угловых точках.
   // Четыре угловые точки расчётной области
   // левый нижний угол
   i:=1;
   j:=1;
   ini:=i+j*inx; // север
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][ini-1]:= - 0.5;
   dA[ipi-1][iei-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   // правый нижний угол
   i:=inx;
   j:=1;
   ini:=i+j*inx; // север
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][ini-1]:= - 0.5;
   dA[ipi-1][iwi-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   // правый верхний угол
   i:=inx;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][isi-1]:= - 0.5;
   dA[ipi-1][iwi-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   // левый верхний угол
   i:=1;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   dA[ipi-1][ipi-1]:= 1.0;
   dA[ipi-1][isi-1]:= - 0.5;
   dA[ipi-1][iei-1]:= - 0.5;
   dV[ipi-1]:= 0.0;
   *)

   // трансформация Гаусса
   // обязательно т.к. задача с конвекцией
   // вопрос о необходимости применения в данном случае
   // трансформации Гаусса требует подробного рассмотрения.
   if (bGaussTransform) then GaussTransform(inx*iny, dA, dV);

   // Решение СЛАУ
   // методом Сопряжённых Градиентов
   // Хестенса и Штифеля
   if (bHestensenShtifiel) then
   begin
      // для этого метода по-моему обязательно требуется
      // трансформация Гаусса.
      // насчёт обязательности фиксации поправки давления в одной точке
      // для метода сопряжённых градиентов сказать пока сложно - это требует
      // подробного рассмотрения.
      // Здесь уровень поправки давления фиксируется.
      // Максимальное количество итераций увеличено в 10 раз, пороговое значение невязки
      // дополнительно уменьшено возведением в квадрат.
      SoprGrad(inx*iny, dA, dV, Pamendment, dx, false, 10*iterSimple.iterPamendment, rcs.Pamendment*rcs.Pamendment); // точность вычисления rcs.Pamendment
   end
   else // или прямой метод исключения Гаусса
   begin
      // для метода исключения Гаусса
      // необязательно проводить трансформацию Гаусса,
      // зато для него важно произвести фиксацию
      // поправки давления в одной точке с номером ipifix.
      GaussAlgorithm(inx*iny, dA, inx, iny, move, dV, dx, false);
   end;
   // копирование полученного решения обратно в Pamendment
   for i1:=0 to (inx*iny-1) do Pamendment[i1+1] := dx[i1]; // вектор с решением задачи;

end; // SolveUniversalPamendment

// находится на стадии тестирования
// Операции по определению поля давления самые ресурсоёмкие.
// Перед решением уравнения для поправки давления поле поправки давления
// надо инициализировать нулевым значением.
// решает линейное уравнение для поправки давления
// методом сопряжённых градиентов Хестенса и Штифеля.
// Здесь формируется матрица СЛАУ в формате CRS которая затем передаётся
// уточняющему солверу SoprGrad.
// этот метод эффективен по памяти т.к. здесь используется алгоритм хранеия доступа CRS.
procedure TForm1.SolveSoprGradCRSPamendment(bGaussTransform : Boolean;
                                            bipifix : Boolean;
                                            bSoloveichikAlg : Boolean; // применять ли алгоритм Ю.Г. Соловейчика 93 года
                                            var rescontinity :  Float);
// bGaussTransform - нужно ли использовать Трансформацию Гаусса: true - ДА, false - НЕТ.
// bipifix - нужно ли фиксировать поправку давления в центральной точке расчётной облсти: true - Да, false - Нет.
// rescontinity - нескомпенсированные источники массы

var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   m : MatrixCoef; // для компонент скорости
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для поправки давления
   db : array of  Float; // коэффициенты источникового члена
   iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   i,j : Integer; // Счётчики цикла for
   iNelem : Integer; // число ненулевых элементов матрицы СЛАУ
   k : Integer; // счётчик количества ненулевых элементов
   nze : array of TmyNonZeroElemMatrix; // ненулевые элементы матрицы СЛАУ
   val  : array of  Float; // ненулевые элементы матрицы СЛАУ
   col_ind : array of Integer; // соответствующие номера столбцов
   row_ptr : array of Integer; // для определения начала следующей строки.
   dV  : array of  Float; // вектор правой части
   dx  : array of  Float; // вектор с решением
   mf, attrsCR : Float;

begin
   // число ненулевых элементов матрицы СЛАУ
   // учтено, что одна точка расчётной области фиксирована
   if (bipifix) then
   begin
      // одна точка в центре расчётной области фиксирована
      iNelem:=5*(inx-2)*(iny-2)+(inx-2)*4+(iny-2)*4+4*3-5+1;
   end
   else
   begin
      // поправка давления сама ищет свой уровень
      iNelem:=5*(inx-2)*(iny-2)+(inx-2)*4+(iny-2)*4+4*3;
   end;
   // предположительно довольно много времени уходит
   // на выделение памяти
   // выделение памяти
   SetLength(mp,inx*iny+1); // массив коэффициентов
   SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
   // выделение памяти под ненулевые эементы матрицы СЛАУ.
   // Этот массив будет использоваться для сортировки
   // сортировка выполняется с целью упорядочить строки матицы и ключом
   // служит номер строки. При этом среди множества ключей есть ключи равные друг другу,
   // однако это не мешает выполнить сортировку.
   SetLength(nze,iNelem+1); // ненулевые элементы которые потом придётся сортировать по строкам
   SetLength(val,iNelem); // ненулевые элементы матрицы СЛАУ
   SetLength(col_ind,iNelem); // соответствующие ненулевым элементам номера столбцов
   SetLength(row_ptr,inx*iny+1); // информация о том где начинается следующая строка

   SetLength(dV,mzapas*inx*iny); // вектор правой части
   SetLength(dx,mzapas*inx*iny); // вектор с результатом

   // обнуление матрицы dА
   for i:=1 to (iNelem) do
   begin
      // инициализация
      // массива для хранения
      // ненулевых элементов
      nze[i].i:=0;
      nze[i].j:=0;
      nze[i].aij:=0.0;
      nze[i].key:=0;
   end;

   // обнуление матрицы dА
   for i:=0 to (iNelem-1) do
   begin
      // инициализация
      val[i]:=0.0;
      col_ind[i]:=0;
   end;

   // т.к. нумерация начинается с нуля, то и максимальное значение (iNelem+1)-1,
   // где -1 для учёта элемента с номером ноль, т.к. нумерация массива начинается с 0.
   for i:=0 to (inx*iny) do row_ptr[i]:=iNelem; // инициализация указателей на следующую строку

   // инициализация векторов dx и dV
   for i:=0 to (inx*iny-1) do
   begin
      dV[i]:=0.0;
      dx[i]:=0.0;
   end;

   // ipifix - фиксированная точка где-то в центре расчётной области
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;

   k:=1; // счётчик ненулевых элементов массива nze

   // вычисление коэффициентов
   // дискретного аналога во внутренних точках
   // расчётной области
   for i:=2 to inx-1 do
   begin
      for j:=2 to iny-1 do
      begin
         // координаты узлов для поправки давления
         // используется обыкновенная сетка
         ini:=i+j*inx; // север
         isi:=i+(j-2)*inx; // юг
         iwi:=(i-1)+(j-1)*inx; // запад
         iei:=(i+1)+(j-1)*inx; // восток
         ipi:=i+(j-1)*inx;  // текущая точка
         // для скоростей на гранях контрольного объёма
         iecvi:=i+(j-1)*(inx-1); // в массиве Vx
         iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
         incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
         iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
         // в уравнении для поправки давления
         // потребовались коэффициенты для компонент скорости
         // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
         // требуется покрайней мере в четыре раза больший объём вычислений
         // чем для уравнений для компонент скорости или температуры.

         if (i<>(inx-1)) then
         begin
            Vxcoef(i,j,m,mf,attrsCR); // m.dap=ae
            mp[ipi].dae:=densuty_in_surface(ipi,iei)*(0.5*(ypos[j+1]-ypos[j-1]))*(0.5*(ypos[j+1]-ypos[j-1]))/m.dap;
         end
         else
         begin
            mp[ipi].dae:=0; // нет влияния от давления на границе
         end;

         if (i<>2) then
         begin
            Vxcoef(i-1,j,m,mf,attrsCR); // m.dap=aw
            mp[ipi].daw:=densuty_in_surface(iwi,ipi)*(0.5*(ypos[j+1]-ypos[j-1]))*(0.5*(ypos[j+1]-ypos[j-1]))/m.dap;
         end
         else
         begin
            mp[ipi].daw:=0; // нет влияния от давления на границе
         end;

         if (j<>(iny-1)) then
         begin
            Vycoef(i,j,m,mf,attrsCR); // m.dap=an
            mp[ipi].dan:=densuty_in_surface(ipi,ini)*(0.5*(xpos[i+1]-xpos[i-1]))*(0.5*(xpos[i+1]-xpos[i-1]))/m.dap;
         end
         else
         begin
            mp[ipi].dan:=0; // нет влияния граничных условий
         end;

         if (j<>2) then
         begin
            Vycoef(i,j-1,m,mf,attrsCR); // m.dap=as
            mp[ipi].das:=densuty_in_surface(ipi,isi)*(0.5*(xpos[i+1]-xpos[i-1]))*(0.5*(xpos[i+1]-xpos[i-1]))/m.dap;
         end
         else
         begin
            mp[ipi].das:=0; // нет влияния граничных значений
         end;
         mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
         db[ipi]:=density(ipi)*(Vx[iwcvi]-Vx[iecvi])*(0.5*(ypos[j+1]-ypos[j-1]))+density(ipi)*(Vy[iscvi]-Vy[incvi])*(0.5*(xpos[i+1]-xpos[i-1]));

         if ((bipifix) and (ipi = ipifix)) then
         begin
            // фиксируем значение в центральной точке
            // расчётной области
            // это нужно сделать именно в этой секции,
            // т.к. если это сделать после то пришлось бы обнулять
            // дополнительные прежде заполненнные элементы матрицы A в одной из строк.
            // шаблон заполнения
            // dA[ipifix-1][ipifix-1]:= 1.0;
            nze[k].i:=ipifix-1; nze[k].j:=ipifix-1; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
            dV[ipifix-1]:= 0.0;
         end
         else
         begin
            // формирование матрицы СЛАУ dA и вектора правой части dV
           // шаблон заполнеиия
           // dA[ipi-1][ipi-1]:= mp[ipi].dap; // центральная узловая точка
           // dA[ipi-1][iei-1]:= - mp[ipi].dae;  // восток
           // dA[ipi-1][iwi-1]:= - mp[ipi].daw;  // запад
           // dA[ipi-1][ini-1]:= - mp[ipi].dan;  // север
           // dA[ipi-1][isi-1]:= - mp[ipi].das;  // юг
           nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=mp[ipi].dap; nze[k].key:=nze[k].i;  k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:= - mp[ipi].dae; nze[k].key:=nze[k].i; k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:= - mp[ipi].daw; nze[k].key:=nze[k].i; k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:= - mp[ipi].dan; nze[k].key:=nze[k].i; k:=k+1;
           nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:= - mp[ipi].das; nze[k].key:=nze[k].i; k:=k+1;

           dV[ipi-1]:= db[ipi]; // вектор правой части
         end;
      end; // j
   end; // i

   // С. Патанкар с. 104
   // матрица db представляет собой "источник массы", который должен быть
   // скомпенсирован поправками давления (через соответствующие поправки скорости).
   // Если норма db равна epsilon то решение  получено с точностью до epsilon.
   // вычисление невязки continity...
   case ibasenorma of
       1 : // евклидова норма
          begin
             rescontinity:=myEvklidNorma(db,inx,iny);
          end;
       2 : // кубическая
          begin
             rescontinity:=mySupNorma(db,inx,iny);
          end;
       3 : // октаэдрическая
          begin
             rescontinity:=mySup2Norma(db,inx,iny);
          end;
   end;


   // Здесь на границе ставится условие Неймана
   // нормальная производная от поправки давления равна нулю.
   // По этому поводу см. 1. Патанкар ст. 108, 109.
   // 2. статья В.М. Ковеня Об одном алгоритме решения
   // уравнений Навье-Стокса вязкой несжимаемой жидкости.
   // 3. Лев Герасимович Лойцянский Механика жидкости и газа.

   // Условие Неймана на нижней
   // и верхней границах
   for i:=2 to inx-1 do
   begin
      j:=1; // низ
      ipi:=i+(j-1)*inx;  // текущая точка
      ini:=i+j*inx; // север
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][ini-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:= -1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
      j:=iny; // верх
      ipi:=i+(j-1)*inx;  // текущая точка
      isi:=i+(j-2)*inx; // юг
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][isi-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:=-1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
   end;

   // Условие Неймана на левой
   // и правой границах
   for j:=2 to iny-1 do
   begin
      i:=1; // лево
      ipi:=i+(j-1)*inx;  // текущая точка
      iei:=(i+1)+(j-1)*inx; // восток
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][iei-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:= 1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:= -1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
      i:=inx; // право
      ipi:=i+(j-1)*inx;  // текущая точка
      iwi:=(i-1)+(j-1)*inx; // запад
      // шаблон заполнения
      // dA[ipi-1][ipi-1]:=1.0;
      // dA[ipi-1][iwi-1]:=-1.0;
      nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
      nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:=-1.0; nze[k].key:=nze[k].i;  k:=k+1;
      dV[ipi-1]:= 0.0;
   end;

   // Значение давления в 4
   // угловых точках.
   // Четыре угловые точки расчётной области
   // левый нижний угол
   i:=1;
   j:=1;
   ini:=i+j*inx; // север
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][ini-1]:= - 0.5;
   // dA[ipi-1][iei-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   dV[ipi-1]:= 0.0;
   // правый нижний угол
   i:=inx;
   j:=1;
   ini:=i+j*inx; // север
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][ini-1]:= - 0.5;
   // dA[ipi-1][iwi-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=ini-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   dV[ipi-1]:= 0.0;
   // правый верхний угол
   i:=inx;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iwi:=(i-1)+(j-1)*inx; // запад
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][isi-1]:= - 0.5;
   // dA[ipi-1][iwi-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iwi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   dV[ipi-1]:= 0.0;
   // левый верхний угол
   i:=1;
   j:=iny;
   isi:=i+(j-2)*inx; // юг
   iei:=(i+1)+(j-1)*inx; // восток
   ipi:=i+(j-1)*inx; // текущая точка
   // шаблон заполнения
   // dA[ipi-1][ipi-1]:= 1.0;
   // dA[ipi-1][isi-1]:= - 0.5;
   // dA[ipi-1][iei-1]:= - 0.5;
   nze[k].i:=ipi-1; nze[k].j:=ipi-1; nze[k].aij:=1.0; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=isi-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;  k:=k+1;
   nze[k].i:=ipi-1; nze[k].j:=iei-1; nze[k].aij:=-0.5; nze[k].key:=nze[k].i;
   dV[ipi-1]:= 0.0;


   if (itypesorter = 1) then
   begin
      QuickSort(nze,1,iNelem); // быстрая сортировка Хоара
   end
    else
   begin
      // itypesorter = 2
      HeapSort(nze,iNelem); // пирамидальная сортировка
   end;

   // формирование матрицы разреженной матрицы СЛАУ
   //  в формате CRS (сортировка нужна для упорядочивания элементов по строкам).
   for k:=0 to iNelem-1 do
   begin
      // для nze индекс k+1 т.к. нумерация этого массива начиналась с 1.
      // это требование алгоритма пирамидальной сортировки.
      val[k]:=nze[k+1].aij;
      col_ind[k]:=nze[k+1].j;
      row_ptr[nze[k+1].i]:=min(k, row_ptr[nze[k+1].i]);
   end;

   Finalize(nze); // освобождение памяти под массив nze
   //MainMemo.Lines.Add('матрица СЛАУ сформирована ');

   // трансформация Гаусса
   // обязательно т.к. задача с конвекцией, но вообще
   // вопрос о необходимости применения в данном случае
   // трансформации Гаусса требует подробного рассмотрения.
   // Матрица СЛАУ может быть также несимметрична из-за граничных условий первого рода.
   // А метод сопряжённых градиентов применим только для симметричных матриц.

   // Решение СЛАУ
   // методом Сопряжённых Градиентов
   // Хестенса и Штифеля
   // для этого метода по-моему обязательно требуется
   // трансформация Гаусса.
   // насчёт обязательности фиксации поправки давления в одной точке
   // для метода сопряжённых градиентов сказать пока сложно - это требует
   // подробного рассмотрения.
   // В зависимости от значения параметра bGaussTransform
   // применяется или не применяется трансформация Гаусса.
   // здесь передаётся квадрат значения невязки что уменьшаёт передаваемое значение и
   // заставляет сделать больше итераций.
   // максимальное количество итераций также увеличено в 10 раз.
   if (not(bSoloveichikAlg)) then
   begin
      // Алгоритм сопряжённых Градиентов Хестенса и Штифеля
      SoprGradCRS(inx*iny, val, col_ind, row_ptr, dV, Pamendment, dx, false, 10*iterSimple.iterPamendment,  bGaussTransform, rcs.Pamendment*rcs.Pamendment); // точность вычисления rcs.Pamendment
   end
    else
   begin
      // алгоритм Ю.Г. Соловейчика [1993]
      // Алгоритм Соловейчика не работает на уравнении для поправки давления.
      // нет сходимости.
      SoloveichikAlg(inx*iny, val, col_ind, row_ptr, dV, Pamendment, dx, false, 10*iterSimple.iterPamendment, rcs.Pamendment*rcs.Pamendment);
   end;


   // копирование полученного решения обратно в Pamendment
   for i:=0 to (inx*iny-1) do Pamendment[i+1]:= dx[i]; // вектор с решением задачи;

end; // SolveSoprGradCRSPamendment


// коррекция Давления
procedure TForm1.CorrectNewPressure;
var
   k : Integer; // Счётчик
   dgxeffective, dgyeffective : Float;
   //ipi : Integer; // координата текущего узла
   Volsigma, PVsigma : Float;

begin
      for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
         begin
            if (itype=1) then
            begin
               // внутренний и граничный узел.
               // 7 апреля испытывается новыый солвер для поправки давления
               // До этого стоял только внутреннний узел.

               // используется обыкновенная сетка
               ipi:=i+(j-1)*inx;  // текущая точка
               // Здесь реализуется четвёртый шаг алгоритма SIMPLE
               // Смысл которого состоит в коррекции давления,
               // так чтобы значения переменных Vx, Vy и P лучше удовлетворяли
               // уравнению неразрывности.
               // alphap=0.8;
               if (not bsimplec) then
               begin
                  // Алгоритм Патанкара и Сполдинга [1972] SIMPLE
                  P[ipi]:=P[ipi]+myrelaxfactors.PressureRelax*Pamendment[ipi];
               end
                else
               begin
                  // Алгоритм SIMPLEC [1984]
                  // нижней релаксации не нужно.
                  P[ipi]:=P[ipi] + Pamendment[ipi];
               end;
            end;
         end; // with
      end;

      for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
         begin
            if (itype=2) then
            begin
               ipi:=i+(j-1)*inx;  // текущая точка

               case iugol of
                 0 : begin
                        // Неугловая и нужно снести поправку на границу области.
                        case chnormal of
                           'N' : begin
                                    Pamendment[ipi]:=Pamendment[i+(j-1+1)*inx];
                           end;
                           'S' : begin
                                    Pamendment[ipi]:=Pamendment[i+(j-1-1)*inx];
                           end;
                           'W' : begin
                                    Pamendment[ipi]:=Pamendment[i-1+(j-1)*inx];
                           end;
                           'E' : begin
                                    Pamendment[ipi]:=Pamendment[i+1+(j-1)*inx];
                           end;
                        end;
                     end;
                 1 : begin
                        // левый нижний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i+1+(j-1)*inx]+Pamendment[i+(j-1+1)*inx]);
                     end;
                 2 : begin
                        // правый нижний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i-1+(j-1)*inx]+Pamendment[i+(j-1+1)*inx]);
                     end;
                 3 : begin
                        // левый верхний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i+1+(j-1)*inx]+Pamendment[i+(j-1-1)*inx]);
                     end;
                 4 : begin
                        // правый верхний угол.
                        Pamendment[ipi]:=0.5*(Pamendment[i-1+(j-1)*inx]+Pamendment[i+(j-1-1)*inx]);
                     end;
                 5 : begin
                        // узел пятиточечный крест.
                        Pamendment[ipi]:=0.25*(Pamendment[i-1+(j-1)*inx]+Pamendment[i+(j-1-1)*inx]+Pamendment[i+1+(j-1)*inx]+Pamendment[i+(j-1+1)*inx]);
                     end;
               end;
            end;
         end;
      end;

      for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
         begin
            if (itype=2) then
            begin
               ipi:=i+(j-1)*inx;  // текущая точка
               if (not bsimplec) then
               begin
                  // Алгоритм Патанкара и Сполдинга [1972] SIMPLE
                  P[ipi]:=P[ipi]+myrelaxfactors.PressureRelax*Pamendment[ipi];
               end
                else
               begin
                  // Алгоритм SIMPLEC [1984]
                  // нижней релаксации не нужно.
                  P[ipi]:=P[ipi] + Pamendment[ipi];
               end;
            end;
         end;
      end;

      //if (всюду условия Неймана для давления) then
      if (GridGenForm.bVabishevichPressureAvgZero()) then
      begin
         (*
         if (imodelEquation=5) then
         begin
            PVsigma:=0.0;
            Volsigma:=1.0;
         end
          else
         begin

         end;
         *)
            Volsigma:=0.0;
            PVsigma:=0.0;
            for k:=1 to imaxnumbernode do
            begin
               with (mapPT[k]) do
               begin
                  Volsigma:=Volsigma + dV;
                  PVsigma:=PVsigma + P[i+(j-1)*inx]*dV;
               end;
            end;

      end
      else
      begin
         // иначе
         // На какой-то из границ задано давление.
         PVsigma:=0.0;
         Volsigma:=1.0;
      end;

      // Вычисляем полное абсолютное давление:
      for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
            begin
               ipi:=i+(j-1)*inx;  // текущая точка

               dgyeffective:=dgy; // ускорение свободного падения
               dgxeffective:=dgx;

               // В случае силы тяжести меняющейся по гармоническому закону:
               if ((btimedepend) and (rgravVib.bOn)) then
               begin
                  // Только в том случае если процесс нестационарный и
                  // сила тяжести меняется по гармоническому закону.

                  dgyeffective:= dgyeffective + GetRealGravity('y');
                  dgxeffective:= dgxeffective + GetRealGravity('x');
               end;
               //Pressureabsolute[ipi]:=P[ipi]-PVsigma/Volsigma+OperatingPressure+matprop[0].drho*(dgyeffective*(ypos[j]-ypos[1])+dgxeffective*(xpos[i]-xpos[1]));
               if (bBussinesk) then
          begin
             Pressureabsolute[ipi]:=P[ipi]-PVsigma/Volsigma+OperatingPressure;
          end
          else
          begin
             Pressureabsolute[ipi]:=P[ipi]-PVsigma/Volsigma+OperatingPressure+density(ipi)*(dgyeffective*(ypos[j]-ypos[1])+dgxeffective*(xpos[i]-xpos[1]));
          end;

            end;
      end;

end; //  CorrectNewPressure

// организация нижней релаксации для компонент скорости.
procedure TForm1.Lower_relaxation_Velocity;
var
   k : Integer;
   //ipi : Integer;
begin
   // для горизонтальной скорости.
   for k:=1 to imaxnumbernodeVx do
      begin
         with (mapVx[k]) do
         begin
            // координата текущего узла на шахматной сетке
            // для горизонтальной компоненты скорости
            // для Vx на шахматной сетке по горизонтали на одну точку меньше.
            ipi:=i+(j-1)*(inx-1); // текущая точка для Vx
            // процедура нижней релаксации не влияющая на матрицу СЛАУ.
            // именно так рекомендует делать Гаврилов Андрей.
            Vx[ipi]:=myrelaxfactors.Momentum*Vx[ipi]+(1.0-myrelaxfactors.Momentum)*VxOld[ipi];
         end;
      end;
   // Для вертикальной скорости.
   for k:=1 to imaxnumbernodeVy do
      begin
         with (mapVy[k]) do
         begin
            // координата текущего узла на шахматной сетке
            // для горизонтальной компоненты скорости
            // для Vx на шахматной сетке по горизонтали на одну точку меньше.
            ipi:=i+(j-1)*(inx); // текущая точка для Vx
            // процедура нижней релаксации не влияющая на матрицу СЛАУ.
            // именно так рекомендует делать Гаврилов Андрей.
            Vy[ipi]:=myrelaxfactors.Momentum*Vy[ipi]+(1.0-myrelaxfactors.Momentum)*VyOld[ipi];
         end;
      end;
end;

// поправочная формула для горизонтальной скорости
procedure TForm1.CorrectVx;
var
   k : Integer; // Счётчик
   //ipi : Integer; // координата текущего узла для Vx
   je, jp : Integer; // координаты боковых узлов для давления
   m : MatrixCoef; // для компонент скорости
   //bnei : Boolean; // если граничное условие Неймана
   mf, attrsCR : Float;

begin

   for k:=1 to imaxnumbernodeVx do
      begin
         with (mapVx[k]) do
         begin
            if (itype =1) then
            begin
               // только для внутреннего узла

               // координата текущего узла на шахматной сетке
               // для горизонтальной компоненты скорости
               // для Vx на шахматной сетке по горизонтали на одну точку меньше.
               ipi:=i+(j-1)*(inx-1); // текущая точка для Vx
               jp:=i+(j-1)*inx;  // давление слева
               je:=(i+1)+(j-1)*inx; // давление справа
               VxCoef(i,j,m,mf,attrsCR); // вычисление коэффициента при скорости
               if (bsimplec) then
               begin
                  //Vx[ipi]:=Vx[ipi]+ myrelaxfactors.Momentum*dy*(Pamendment[jp]-Pamendment[je])/m.dap/(1.0-myrelaxfactors.Momentum);
                  Vx[ipi]:=Vx[ipi]+ myrelaxfactors.Momentum*dy*(Pamendment[jp]-Pamendment[je])/m.dap/(1.0-myrelaxfactors.Momentum)/densuty_in_surface(jp,je);
               end
               else if (bsimpler) then
               begin
                  //Vx[ipi]:=Vx[ipi]+ myrelaxfactors.Momentum*dy*(Pamendment[jp]-Pamendment[je])/m.dap;
                  //Vx[ipi]:=Vx[ipi]+ dy*(Pamendment[jp]-Pamendment[je])/m.dap;
                  Vx[ipi]:=Vx[ipi]+ dy*(Pamendment[jp]-Pamendment[je])/m.dap/densuty_in_surface(jp,je);
               end
                else
               begin
                 // Vx[ipi]:=Vx[ipi]+ myrelaxfactors.Momentum*dy*(Pamendment[jp]-Pamendment[je])/m.dap;
                  Vx[ipi]:=Vx[ipi]+ myrelaxfactors.Momentum*dy*(Pamendment[jp]-Pamendment[je])/m.dap/densuty_in_surface(jp,je);
               end;
            end;
         end; // with
   end;
end; // CorrectVx

// устраняет дефекты графической визуализации
procedure TForm1.VelXPachit;
var
   k : Integer;
   bnei : Boolean;
   //ipi, ini, isi, iei, iwi : Integer;
   
begin
   for k:=1 to imaxnumbernodeVx do
   begin
     with (mapVx[k]) do
       begin
         if (itype = 2) then
         begin  // граничный узел
            bnei:=GridGenForm.isneiman(iboundary, 'P',chnormal);
            if (not(bnei)) then
            begin
               ipi:=i+(j-1)*(inx-1);
               case chnormal of
                'N' : begin
                         ini:=i+j*(inx-1);
                         Vx[ipi]:=Vx[ini];
                      end;
                'S' : begin
                         isi:=i+(j-2)*(inx-1);
                         Vx[ipi]:=Vx[isi];
                      end;
                'E' : begin
                         iei:=(i+1)+(j-1)*(inx-1);
                         Vx[ipi]:=Vx[iei];
                      end;
                'W' : begin
                         iwi:=(i-1)+(j-1)*(inx-1);
                         Vx[ipi]:=Vx[iwi];
                      end;
                end; // case
            end;
         end;
       end;
   end;

end;// VelXPachit;

// поправочная формула для вертикальной скорости
procedure TForm1.CorrectVy;
var
   k : Integer; // Счётчик
   //ipi : Integer; // координата текущего узла для Vy
   jn, jp : Integer; // координаты боковых узлов для давления
   m : MatrixCoef; // для компонент скорости
   mf, attrsCR : Float;
   
begin
   // после этой коррекции
   // компоненты скорости удовлетворяют
   //уравнению неразрывности
   for k:=1 to imaxnumbernodeVy do
      begin
         with mapVy[k] do
         begin
            if (itype =1 ) then
            begin
               // только для внутреннего узла

               // координата текущего узла на шахматной сетке
               // для вертикальной компоненты скорости
               // для Vy на шахматной сетке по вертикали на одну точку меньше.
               ipi:=i+(j-1)*inx; // текущая точка для Vy
               jn:=i+j*inx; // давление сверху
               // здесь нестандартное обозначение для давления снизу
               // хорошо бы его обозвать jp вместо js
               jp:=i+(j-1)*inx; // давление снизу
               VyCoef(i,j,m,mf,attrsCR); // вычисление коэффициента при скорости
               if (bsimplec) then
               begin
                  //Vy[ipi]:=Vy[ipi]+myrelaxfactors.Momentum*dx*(Pamendment[jp]-Pamendment[jn])/m.dap/(1.0-myrelaxfactors.Momentum);
                  Vy[ipi]:=Vy[ipi]+myrelaxfactors.Momentum*dx*(Pamendment[jp]-Pamendment[jn])/m.dap/(1.0-myrelaxfactors.Momentum)/densuty_in_surface(jp,jn);
               end
               else if (bsimpler) then
               begin
                  // Vy[ipi]:=Vy[ipi]+myrelaxfactors.Momentum*dx*(Pamendment[jp]-Pamendment[jn])/m.dap;
                  //Vy[ipi]:=Vy[ipi]+dx*(Pamendment[jp]-Pamendment[jn])/m.dap;
                  Vy[ipi]:=Vy[ipi]+dx*(Pamendment[jp]-Pamendment[jn])/m.dap/densuty_in_surface(jp,jn);
               end
               else
               begin
                   //Vy[ipi]:=Vy[ipi]+myrelaxfactors.Momentum*dx*(Pamendment[jp]-Pamendment[jn])/m.dap;
                   Vy[ipi]:=Vy[ipi]+myrelaxfactors.Momentum*dx*(Pamendment[jp]-Pamendment[jn])/m.dap/densuty_in_surface(jp,jn);
               end;
            end;
         end; // with
   end;
end; // CorrectVy

// запуск на вычисление
procedure TForm1.RunTune;
var
  // локальные параметры для возобновления многопараметрического моделирования.
  inumbertimesteploc, itercountloc, inumberTimeStepDivisionPeriodloc, inumberPeriodloc : Integer;
  dTimeSteploc, realFlowTimeloc : Float;

  timestart, timefinish, timelength : Ttime; // замер времени выполнения.

// поддержание начальных настроек решающего алгоритма готовыми к старту.
procedure initparameters;
begin
   inumbertimestep:=inumbertimesteploc;
   itercount:=itercountloc;
   inumberTimeStepDivisionPeriod:=inumberTimeStepDivisionPeriodloc;
   inumberPeriod:=inumberPeriodloc;
   dTimeStep:=dTimeSteploc;
   realFlowTime:=realFlowTimeloc;
end;  // initparameters;

// запускает многопараметрический солвер
// с количеством переменных не более 9.
procedure runsweep;
var
   j1,j2,j3,j4,j5,j6,j7,j8,j9,i : Integer; // не более 9 переменных как в программе EasyMesh дополненой dynamic mesh.
   s : string; // формируемое тектовое сообщение для пользователя.
begin
   // многопараметрическое моделирование :
   // нужно пройтись по всем вариантам значений
   // определяющих переменных.
   if ((ivar_trial>=0) and (ivar_trial<=9)) then
   begin
      FormParametricTrialsOnlineReport.Show; // показываем онлайн диагностику.
      FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Clear; // очистка текстовой информации.

   case ivar_trial of
    0 : // нет переменных, значит запускаем один раз
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем.
           myVersionSIMPLEAlgorithm(false);
           FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

           // Пишем результат.
           s:='';
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);
        end;
    1 : // одна переменная, запускаем для всех значений одной переменной.
        begin
           // пишем заголовок.
           s:='';
           s:=s+base_value_trial[0].svar+'   ';
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);


           // Вычисляем.
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
              initparameters;
              myVersionSIMPLEAlgorithm(false);
              FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

              // Пишем результат.
              s:='';
              s:=s+base_value_trial[0].sval+'   ';
              for i:=0 to FormDefineTrials.imaxreport do
              begin
                 if (FormDefineTrials.mylistreport[i].bactive) then
                 begin
                    s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                 end;
              end;
              FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

              if (not(bweShouldContinue)) then
              begin
                 if (MessageBox(Handle,'We shold be continue ?','Question',35)=7) then
                 begin
                    // Нажата кнопка Нет и мы значит не хотим продолжать вычисление,
                    // выходим из цикла досрочно по break;
                    break;
                 end;
              end;

           end;
        end;
    2 : // две переменные, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                 base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                 initparameters;
                 myVersionSIMPLEAlgorithm(false);
                 FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                 // Пишем результат.
                 s:='';
                 s:=s+base_value_trial[0].sval+'   ';
                 s:=s+base_value_trial[1].sval+'   ';
                 for i:=0 to FormDefineTrials.imaxreport do
                 begin
                    if (FormDefineTrials.mylistreport[i].bactive) then
                    begin
                       s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                    end;
                 end;
                 FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

                 if (not(bweShouldContinue)) then
                 begin
                    if (MessageBox(Handle,'We shold be continue ?','Question',35)=7) then
                    begin
                       // Нажата кнопка Нет и мы значит не хотим продолжать вычисление,
                       // выходим из цикла досрочно по break;
                       break;
                    end;
                 end;

              end;
           end;
        end;
    3 : // три переменные, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                    base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                    base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                    initparameters;
                    myVersionSIMPLEAlgorithm(false);
                    FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                    // Пишем результат.
                    s:='';
                    for i:=0 to ivar_trial-1 do
                    begin
                       s:=s+base_value_trial[i].sval+'   ';
                    end;
                    for i:=0 to FormDefineTrials.imaxreport do
                    begin
                       if (FormDefineTrials.mylistreport[i].bactive) then
                       begin
                          s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                       end;
                    end;
                    FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);
                 end;
              end;
           end;
        end;
    4 : // 4 переменные, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    for j4:=0 to High(series_value_of_the_variable[3]) do
                    begin
                       base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                       base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                       base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                       base_value_trial[3].sval:=FloatTostr(series_value_of_the_variable[3][j4]);
                       initparameters;
                       myVersionSIMPLEAlgorithm(false);
                       FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.


                       // Пишем результат.
                       s:='';
                       for i:=0 to ivar_trial-1 do
                       begin
                          s:=s+base_value_trial[i].sval+'   ';
                       end;
                       for i:=0 to FormDefineTrials.imaxreport do
                       begin
                          if (FormDefineTrials.mylistreport[i].bactive) then
                          begin
                             s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                          end;
                       end;
                       FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);
                    end;
                 end;
              end;
           end;
        end;
    5 : // 5 переменных, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    for j4:=0 to High(series_value_of_the_variable[3]) do
                    begin
                       for j5:=0 to High(series_value_of_the_variable[4]) do
                       begin
                          base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                          base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                          base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                          base_value_trial[3].sval:=FloatTostr(series_value_of_the_variable[3][j4]);
                          base_value_trial[4].sval:=FloatTostr(series_value_of_the_variable[4][j5]);
                          initparameters;
                          myVersionSIMPLEAlgorithm(false);
                          FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                           // Пишем результат.
                           s:='';
                           for i:=0 to ivar_trial-1 do
                           begin
                              s:=s+base_value_trial[i].sval+'   ';
                           end;
                           for i:=0 to FormDefineTrials.imaxreport do
                           begin
                              if (FormDefineTrials.mylistreport[i].bactive) then
                              begin
                                 s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                              end;
                           end;
                           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

                       end;
                    end;
                 end;
              end;
           end;
        end;
    6 : // 6 переменных, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    for j4:=0 to High(series_value_of_the_variable[3]) do
                    begin
                       for j5:=0 to High(series_value_of_the_variable[4]) do
                       begin
                          for j6:=0 to High(series_value_of_the_variable[5]) do
                          begin
                             base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                             base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                             base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                             base_value_trial[3].sval:=FloatTostr(series_value_of_the_variable[3][j4]);
                             base_value_trial[4].sval:=FloatTostr(series_value_of_the_variable[4][j5]);
                             base_value_trial[5].sval:=FloatTostr(series_value_of_the_variable[5][j6]);
                             initparameters;
                             myVersionSIMPLEAlgorithm(false);
                             FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                             // Пишем результат.
                             s:='';
                             for i:=0 to ivar_trial-1 do
                             begin
                                s:=s+base_value_trial[i].sval+'   ';
                             end;
                             for i:=0 to FormDefineTrials.imaxreport do
                             begin
                                if (FormDefineTrials.mylistreport[i].bactive) then
                                begin
                                   s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                                end;
                             end;
                             FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

                          end;
                       end;
                    end;
                 end;
              end;
           end;
        end;
    7 : // 7 переменных, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    for j4:=0 to High(series_value_of_the_variable[3]) do
                    begin
                       for j5:=0 to High(series_value_of_the_variable[4]) do
                       begin
                          for j6:=0 to High(series_value_of_the_variable[5]) do
                          begin
                             for j7:=0 to High(series_value_of_the_variable[6]) do
                             begin
                                base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                                base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                                base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                                base_value_trial[3].sval:=FloatTostr(series_value_of_the_variable[3][j4]);
                                base_value_trial[4].sval:=FloatTostr(series_value_of_the_variable[4][j5]);
                                base_value_trial[5].sval:=FloatTostr(series_value_of_the_variable[5][j6]);
                                base_value_trial[6].sval:=FloatTostr(series_value_of_the_variable[6][j7]);
                                initparameters;
                                myVersionSIMPLEAlgorithm(false);
                                FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                                // Пишем результат.
                                s:='';
                                for i:=0 to ivar_trial-1 do
                                begin
                                   s:=s+base_value_trial[i].sval+'   ';
                                end;
                                for i:=0 to FormDefineTrials.imaxreport do
                                begin
                                   if (FormDefineTrials.mylistreport[i].bactive) then
                                   begin
                                      s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                                   end;
                                end;
                                FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);
                             end;
                          end;
                       end;
                    end;
                 end;
              end;
           end;
        end;
    8 : // 8 переменных, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    for j4:=0 to High(series_value_of_the_variable[3]) do
                    begin
                       for j5:=0 to High(series_value_of_the_variable[4]) do
                       begin
                          for j6:=0 to High(series_value_of_the_variable[5]) do
                          begin
                             for j7:=0 to High(series_value_of_the_variable[6]) do
                             begin
                                for j8:=0 to High(series_value_of_the_variable[7]) do
                                begin
                                   base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                                   base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                                   base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                                   base_value_trial[3].sval:=FloatTostr(series_value_of_the_variable[3][j4]);
                                   base_value_trial[4].sval:=FloatTostr(series_value_of_the_variable[4][j5]);
                                   base_value_trial[5].sval:=FloatTostr(series_value_of_the_variable[5][j6]);
                                   base_value_trial[6].sval:=FloatTostr(series_value_of_the_variable[6][j7]);
                                   base_value_trial[7].sval:=FloatTostr(series_value_of_the_variable[7][j8]);
                                   initparameters;
                                   myVersionSIMPLEAlgorithm(false);
                                   FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                                   // Пишем результат.
                                   s:='';
                                   for i:=0 to ivar_trial-1 do
                                   begin
                                      s:=s+base_value_trial[i].sval+'   ';
                                   end;
                                   for i:=0 to FormDefineTrials.imaxreport do
                                   begin
                                      if (FormDefineTrials.mylistreport[i].bactive) then
                                      begin
                                         s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                                      end;
                                   end;
                                   FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);
                                end;
                             end;
                          end;
                       end;
                    end;
                 end;
              end;
           end;
        end;
    9 : // 9 переменных, запускаем для всех возможных сочетаний.
        begin
           // пишем заголовок.
           s:='';
           for i:=0 to ivar_trial-1 do
           begin
              s:=s+base_value_trial[i].svar+'   ';
           end;
           for i:=0 to FormDefineTrials.imaxreport do
           begin
              if (FormDefineTrials.mylistreport[i].bactive) then
              begin
                 s:=s+FormDefineTrials.mylistreport[i].reportname + '   ';
              end;
           end;
           FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

           // Вычисляем :
           for j1:=0 to High(series_value_of_the_variable[0]) do
           begin
              for j2:=0 to High(series_value_of_the_variable[1]) do
              begin
                 for j3:=0 to High(series_value_of_the_variable[2]) do
                 begin
                    for j4:=0 to High(series_value_of_the_variable[3]) do
                    begin
                       for j5:=0 to High(series_value_of_the_variable[4]) do
                       begin
                          for j6:=0 to High(series_value_of_the_variable[5]) do
                          begin
                             for j7:=0 to High(series_value_of_the_variable[6]) do
                             begin
                                for j8:=0 to High(series_value_of_the_variable[7]) do
                                begin
                                   for j9:=0 to High(series_value_of_the_variable[8]) do
                                   begin
                                      base_value_trial[0].sval:=FloatTostr(series_value_of_the_variable[0][j1]);
                                      base_value_trial[1].sval:=FloatTostr(series_value_of_the_variable[1][j2]);
                                      base_value_trial[2].sval:=FloatTostr(series_value_of_the_variable[2][j3]);
                                      base_value_trial[3].sval:=FloatTostr(series_value_of_the_variable[3][j4]);
                                      base_value_trial[4].sval:=FloatTostr(series_value_of_the_variable[4][j5]);
                                      base_value_trial[5].sval:=FloatTostr(series_value_of_the_variable[5][j6]);
                                      base_value_trial[6].sval:=FloatTostr(series_value_of_the_variable[6][j7]);
                                      base_value_trial[7].sval:=FloatTostr(series_value_of_the_variable[7][j8]);
                                      base_value_trial[8].sval:=FloatTostr(series_value_of_the_variable[8][j9]);
                                      initparameters;
                                      myVersionSIMPLEAlgorithm(false);
                                      FormDefineTrials.calculationreports(); // формируем отчёт о вычислении.

                                      // Пишем результат.
                                      s:='';
                                      for i:=0 to ivar_trial-1 do
                                      begin
                                         s:=s+base_value_trial[i].sval+'   ';
                                      end;
                                      for i:=0 to FormDefineTrials.imaxreport do
                                      begin
                                         if (FormDefineTrials.mylistreport[i].bactive) then
                                         begin
                                            s:=s+FloatToStr(FormDefineTrials.mylistreport[i].resultreport) + '   ';
                                         end;
                                      end;
                                      FormParametricTrialsOnlineReport.mmoonlinetrialsreport.Lines.Add(s);

                                   end;
                                end;
                             end;
                          end;
                       end;
                    end;
                 end;
              end;
           end;
        end;
   end;
   end
    else
   begin
      // Ошибка. непредусмотренное количество переменных. Скорее всего больше 9 штук.
      mainMemo.Lines.Add('error ! number user variable must be >=0 and <=9.');
      Application.MessageBox('error ! number user variable must be >=0 and <=9.','error!',MB_OK);
   end;
end; // runsweep;

begin

   with myRun do
   begin
       // по умолчанию вычисления не были запущены на выполнение
       // Это нужно если форма была просто закрыта и пользователь не захотел начать вычисление.
       btheBeginingCalculation:=false;

       // если задача стационарная
       // то панель с нестационарными параметрами надо
       // сделать неактивной
       if (btimedepend) then
       begin
          ErealFlowTimeVal.Text:=FloatToStr(realFlowTime);
          Panel1.Visible:=true; // нестационарный
       end
        else
       begin
          Panel1.Visible:=false; // стационарный
       end;

       if (imodelEquation = 1) then
       begin
          // Чистая теплопроводность

          case itypesolver.itemperature of
             1 : // ГЗ
               begin // Солвер Гаусса-Зейделя
                  Panel3.Visible:=true;
                  // в соответствии с теорией из учебника
                  // Александра Андреевича Самарского,
                  // а также Ульян Гайковича Пирумова
                  // для метода простой итерации
                  // в случае линеной системы
                  // требуется выполнить до сходимости
                  // 2*N^2 итераций, где N - число неизвестных
                  // в уравнении.
                  // Для метода Зейделя, который здесь используется
                  // эта оценка составляет N^2.
                  Eitercount.Text:=IntToStr(Round(0.9*(inx+iny)));
               end;
             2 : // переменных направлений
               begin  // Метод переменных направлений
                  Panel3.Visible:=true;
                   // В теории метод переменных направлений полилинейный.
                   Eitercount.Text:=IntToStr((max(inx,iny)));
               end;
             3 : // прямой метод исключения Гаусса
               begin
                  // итераций нет это прямой метод
                  Panel3.Visible:=false;
               end;
             4 : // метод сопряжённых градиентов Хестенса и Штифеля
               begin
                  // метод является итерационным несмотря на то что
                  // для него в теории для полной сходимости требуется очень мало итераций.
                  Panel3.Visible:=true;
                  // задаём количество итераций по умолчанию.
                  Eitercount.Text:=IntToStr(max(inx,iny));
               end;
          end;
       end
        else
       begin
          // Навье - Стокс
          // возможно дополненный User-Defined Scalar`ом.

          Panel3.Visible:=true;
          if (actiVibr.bOn) then
          begin
             // dynamic mesh.

             Ltimestepnow.Caption:='number of steps for the period';
             Etimestep.Text:=IntToStr(number_of_steps_for_the_period); // 200 шагов по времени за период
             Lnumbertimestep.Caption:='number of periods of vibration';
             Enumbertimestep.Text:=IntToStr(number_of_periods_of_vibration); // 400 периодов
          end
           else
          begin
             Ltimestepnow.Caption:='time step size';
             Etimestep.Text:=FloatToStr(user_time_step_size);
             Lnumbertimestep.Caption:='number of time steps';
             Enumbertimestep.Text:=IntToStr(number_of_time_steps);
          end;
          // количество итераций для стационарного солвера
          Eitercount.Text:=IntToStr(number_of_iteration);
       end;
   end; // with

   // показывает форму запуска
   myRun.ShowModal; // временно передаёт управление модулю запуска.

   if (myRun.btheBeginingCalculation) then
   begin

      // теперь когда в необходимые участки кода вставлен вызов
      // Application.ProcessMessages; код реагирует на воздействия из вне и вычисление можно
      // приостановить.
      TerminateProcessForm.Show; // показывает меню в котором можно прервать процесс
      timestart:=Now;

      // Пользователь захотел запустить вычисление на выполнение.
      inumbertimesteploc:=inumbertimestep;
      itercountloc:=itercount;
      inumberTimeStepDivisionPeriodloc:=inumberTimeStepDivisionPeriod;
      inumberPeriodloc:=inumberPeriod;
      dTimeSteploc:=dTimeStep;
      realFlowTimeloc:=realFlowTime;


      // Как только работа модуля запуска закончится управление
      // передастся обратно в этот участок кода и выполнятся следующие процедуры.

      if (btimedepend = false) then // стационарный
      begin
         // В форме myRunModule уже задано
         // количество итераций itercount и
         // количество шагов по времени равное 1 -
         // это нужно из-за универсальности процедур расчёта.

         case imodelEquation of
            1 : // чистая теплопроводность без конвекции
              begin
                 RunCleanThermalConductionSteady;
              end;
            2 : // User-Defined Segregated Solver
                // на основе SIMPLE алгоритма.
              begin
                 if (FormDefineTrials.rgtrialtype.ItemIndex=0) then
                 begin
                    // только текущие значения!!!
                    myVersionSIMPLEAlgorithm(false);
                 end;
                 if (FormDefineTrials.rgtrialtype.ItemIndex=1) then
                 begin
                    // многопараметрическое моделирование :
                    // нужно пройтись по всем вариантам значений
                    // определяющих переменных.
                    runsweep();
                 end;
              end;
            3 : // чистая гидродинамика
              begin
                 // Здесь определяется только поле течения.
                 myVersionSIMPLEAlgorithm(false);
              end;
            4 : // гидродинамика плюс теплопроводность
              begin
                 // Здесь в добавок к уравнениям течения
                 // также будет решаться и уравнение теплопроводности.
                 myVersionSIMPLEAlgorithm(true);
              end;
            5 : // чистая гидродинамика  и VOF method
              begin
                 // Здесь определяется только поле течения и положение функции цвета.
                 // Внимание ! в стационарной постановке данную задачу решать нельзя, только в нестационарной.
                 //myVersionSIMPLEAlgorithm(false);
                 ShowMessage('Calculation can not start. Yuo mast be selected transient solver.');
              end;
         end; // case
      end
       else // нестационарный
      begin

         // В форме myRunModule уже задано
         // количество итераций itercount и
         // количество шагов по времени inumbertimestep.
         // Шаг по времени является постоянным с значением dTimeStep.
         // Начальное время расчёта задаётся равным dStartTime и
         // дальше больше нигде не используется.

         case imodelEquation of
           1 : // чистая теплопроводность без конвекции
              begin
                 RunCleanThermalConductionUnsteady;
              end;
           2 : // User-Defined Segregated Solver
               // на основе SIMPLE алгоритма в нестационарной постановке.
              begin
                 // например, это могут быть уравнения физики полупроводников !!!.
                 if (FormDefineTrials.rgtrialtype.ItemIndex=0) then
                 begin
                    // только текущие значения!!!
                    myVersionSIMPLEAlgorithm(false);
                 end;
                 if (FormDefineTrials.rgtrialtype.ItemIndex=1) then
                 begin
                    // многопараметрическое моделирование :
                    // нужно пройтись по всем вариантам значений
                    // определяющих переменных.
                    runsweep();
                 end;
              end;
           3 : //  чистая гидродинамика
              begin
                 // универсальная вычислительная процедура позволяющая находить
                 // поле течения в расчётной области.
                 myVersionSIMPLEAlgorithm(false);
              end;
           4 : // гидродинамика плюс теплопроводность
              begin
                 // универсальная вычислительная процедура.
                 // раздельный решатель. Позволяет находить
                 // поле течения совместно с полем температур.
                 myVersionSIMPLEAlgorithm(true);
              end;
           5 : //  чистая гидродинамика  плюс функция цвета (VOF method).
              begin
                 // универсальная SIMPLE процедура.
                 // раздельный решатель. Для гидродинамики и функции цвета.
                 myVersionSIMPLEAlgorithm(false);
              end;
         end; // case

      end;

      // Сообщение о том насколько продолжительным был данный расчёт.
      timefinish:=Now;
      timelength:=timefinish-timestart;
      mainMemo.Lines.Add('calculation time is='+TimeToStr(timelength));

      // В терминальной форме можно всегда прервать ход вычисления.
      TerminateProcessForm.Close; // закрывает окно терминальной формы.

      // необходимо сообщить что решение выпонено :
      MainMemo.Lines.Add('calculation complete');
      Application.MessageBox('calculation complete','',MB_OK);

   end;

end;

// вызывает солвер
procedure TForm1.Run1Click(Sender: TObject);
begin
   RunTune;
   //exportVx();
end; // вызывает солвер

// инициализация перед началом счёта
procedure TForm1.Initializationtune;
var
 tmin, tmax : Float;
 i : Integer;

// модуль вещественного числа.
function fabs(r : Float) : Float;
begin
   if (r<0.0) then fabs:=-r else fabs:=r;
end;

begin
   with myInitialize do
   begin
      case imodelEquation of
        1 : // чистая теплопроводность
          begin
             PTempreture.Visible:=true;
             PFlow.Visible:=false;
             PanelVof.Visible:=false;
             case imaxUDS of
                0 : begin
                       grpuds1.Visible:=False;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                1 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                2 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                3 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=False;
                    end;
                4 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=True;
                    end;
             end;
          end;
        2 : // User-Define Segregated Solver.
          begin
              PFlow.Visible:=false;
              PanelVof.Visible:=false;
              PTempreture.Visible:=false;
              case imaxUDS of
                0 : begin
                       grpuds1.Visible:=False;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                       Application.MessageBox('Заведите User-Defined Scalar','warning',MB_OK);
                    end;
                1 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                2 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                3 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=False;
                    end;
                4 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=True;
                    end;
             end;
          end;
         3 : // чистая гидродинамика
          begin
              PTempreture.Visible:=false;
              PFlow.Visible:=true;
              PanelVof.Visible:=false;
              case imaxUDS of
                0 : begin
                       grpuds1.Visible:=False;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                1 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                2 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                3 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=False;
                    end;
                4 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=True;
                    end;
             end;
          end;
         4 : // гидродинамика плюс теплопроводность
          begin
             PTempreture.Visible:=true;
             PFlow.Visible:=true;
             PanelVof.Visible:=false;
             case imaxUDS of
                0 : begin
                       grpuds1.Visible:=False;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                1 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                2 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                3 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=False;
                    end;
                4 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=True;
                    end;
             end;
          end;
         5 : // гидродинамика и VOF метод
         begin
            PanelVof.Visible:=true;
            PTempreture.Visible:=false;
            PFlow.Visible:=true;
            case imaxUDS of
                0 : begin
                       grpuds1.Visible:=False;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                1 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=False;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                2 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=False;
                       grpuds4.Visible:=False;
                    end;
                3 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=False;
                    end;
                4 : begin
                       grpuds1.Visible:=True;
                       grpuds2.Visible:=True;
                       grpuds3.Visible:=True;
                       grpuds4.Visible:=True;
                    end;
             end;
         end;
      end;

      // загружает запомненные параметры инициализации
      EinitXvel.Text:=FloatToStr(InitVal.XvelInit); // горизонтальная скорость
      EinitYvel.Text:=FloatToStr(InitVal.YvelInit); // вертикальная скорость
      tmin:=1.0e300;
      tmax:=-1.0e300;
   // характерная разность температур
   for i:=1 to GridGenForm.inumboundary do
   begin
   if ( GridGenForm.edgelist[i].temperatureclan=1) then
   begin
      if (GridGenForm.edgelist[i].temperaturecondition<tmin) then
         tmin:=GridGenForm.edgelist[i].temperaturecondition;
         if (GridGenForm.edgelist[i].temperaturecondition>tmax) then
         tmax:=GridGenForm.edgelist[i].temperaturecondition;
      end;
   end;


   if (StrToFloat(EinitTemp.Text)<tmin) then
   begin
      Form1.InitVal.TempInit:=tmin;
   end;

      EinitTemp.Text:=FloatToStr(InitVal.TempInit); // температура
      case imaxUDS of
       1 : begin
              edtuds1.Text:=InitVal.UDS1Init;
           end;
       2 : begin
              edtuds1.Text:=InitVal.UDS1Init;
              edtuds2.Text:=InitVal.UDS2Init;
           end;
       3 : begin
              edtuds1.Text:=InitVal.UDS1Init;
              edtuds2.Text:=InitVal.UDS2Init;
              edtuds3.Text:=InitVal.UDS3Init;
           end;
       4 : begin
              edtuds1.Text:=InitVal.UDS1Init;
              edtuds2.Text:=InitVal.UDS2Init;
              edtuds3.Text:=InitVal.UDS3Init;
              edtuds4.Text:=InitVal.UDS4Init;
           end;
      end;

      // функция цвета.
      if (fabs(InitVal.VofInit)<1.0e-20) then
      begin
         cbbvof.ItemIndex:=0;
      end
       else
      begin
         cbbvof.ItemIndex:=1;
      end;
   end; // with
   // вызывает модуль инициализации
   myInitialize.ShowModal;
end;


// параметры материалов
procedure TForm1.materialtune;
begin
   with MaterialForm do
   begin
      if (imaxUDS>0) then
      begin
         lbluds.Visible:=True;
         btnuds.Visible:=True;
      end
      else
      begin
         lbluds.Visible:=False;
         btnuds.Visible:=False;
      end;
      // инициализация формы материалов
      // параметрами выставленными при запуске
      materialComboBox.ItemIndex:=0;// air первая фаза.
      Erho.Text:=FloatToStr(matprop[0].drho); // плотность
      Emu.Text:=FloatToStr(matprop[0].dmu); // динамическая вязкость
      Ecp.Text:=FloatToStr(matprop[0].dcp); // теплоёмкость
      Elambda.Text:=FloatToStr(matprop[0].dlambda); // теплопроводность
      EbetaT.Text:=FloatToStr(matprop[0].beta); // коэффициент температурного расширения
      // динамическая вязкость
      if (Form1.imodelEquation>2) then
      begin
         Bapplymaterial.Visible:=True;
         
         PanelNusha.Visible:=true;
         GroupBoxDensity.Visible:=true;
         if ((Form1.imodelEquation=3) or (Form1.imodelEquation=5)) then
         begin
            // Чистая гидродинамика
            // чистая гидродинамика и VOF метод.
            Panellambda.Visible:=false;
            PanelCp.Visible:=false;
         end
          else
         begin
            Panellambda.Visible:=true;
            PanelCp.Visible:=true;
            if (bBussinesk) then
            begin
               PanelBeta.Visible:=true;
            end
             else
            begin
               PanelBeta.Visible:=false;
            end;
         end;
      end
       else if (Form1.imodelEquation=1) then
      begin
         Bapplymaterial.Visible:=True;
         // чистая теплопроводность.
         PanelNusha.Visible:=false;
         Panellambda.Visible:=true;
         // стационарный или нестационарный
         if (Form1.btimedepend) then
         begin
            // нестационарный
            PanelCp.Visible:=true;
            GroupBoxDensity.Visible:=true;
         end
          else
         begin
            // стационарный
            // плотность и теплоёмкость при постоянном давлении ненужны,
            // для случая где решается чистая теплопроводность.
            PanelCp.Visible:=false;
            if (Form1.imodelEquation < 3) then
            begin
               GroupBoxDensity.Visible:=false;
            end
             else
            begin
               GroupBoxDensity.Visible:=true;
            end
         end;

      end
       else
      begin
         // User-Defined Scalar.
         PanelNusha.Visible:=false;
         Panellambda.Visible:=false;
         PanelCp.Visible:=false;
         PanelBeta.Visible:=false;
         GroupBoxDensity.Visible:=false;
         Bapplymaterial.Visible:=False;
      end;

   end; // with
   // вызывает экранную форму задания параметров
   // материала
   MaterialForm.ShowModal;
   // всё придётся инициализировать заново: выделение памяти и присвоение значений.
   myInitializationRestart;
end;

// задаёт постоянные параметры материалов
procedure TForm1.Materials1Click(Sender: TObject);
begin
   // параметры материалов
   materialtune;
end; // задаёт параметры материалов

// передаёт картинку в программу tecplot
procedure TForm1.ecplot1Click(Sender: TObject);
begin
    if (Form1.actiVibr.bOn) then
    begin
       ExportTecplotForm.Panelmean.Visible:=true;
       if (imodelEquation=3) then
       begin
          ExportTecplotForm.LmeanT.Visible:=false;
          ExportTecplotForm.LT.Visible:=false;
       end
        else
       begin
          ExportTecplotForm.LmeanT.Visible:=true;
          ExportTecplotForm.LT.Visible:=true;
       end;
    end
     else
    begin
       ExportTecplotForm.Panelmean.Visible:=false;
       if ((imodelEquation=3) or (imodelEquation=5)) then
       begin
          ExportTecplotForm.LT.Visible:=false;
       end
        else
       begin
          ExportTecplotForm.LT.Visible:=true;
       end;
       if (imodelEquation=5) then
       begin
          ExportTecplotForm.lblVOF.Visible:=True;
       end
       else
       begin
          ExportTecplotForm.lblVOF.Visible:=False;
       end;
    end;
    // задание и запоминание масштабов длины.
    Formlengthscaleplot.edtlengthscalex.Text:=FloatToStr(lengthscaleplot.xscale);
    Formlengthscaleplot.edtlengthscaley.Text:=FloatToStr(lengthscaleplot.yscale);
    Formlengthscaleplot.ShowModal;
   // вызывает форму для выбора величины
   // которую надо визуализировать
   ExportTecplotForm.ShowModal;
end; // визуализация результатов вычислений в программе tecplot

// задание граничных условий
procedure TForm1.BoundaryConditionTune(Sender: TObject);
var
    i : Integer; // счётчик.

begin
   with BoundaryConditionForm do
   begin

     case Form1.imaxUDS of
       1 : begin
              cbbudsindex.Clear;
              cbbudsindex.AddItem('1',Sender);
              cbbudsindex.ItemIndex:=0;
           end;
       2 : begin
              cbbudsindex.Clear;
              cbbudsindex.AddItem('1',Sender);
              cbbudsindex.AddItem('2',Sender);
              cbbudsindex.ItemIndex:=0;
           end;
       3 : begin
              cbbudsindex.Clear;
              cbbudsindex.AddItem('1',Sender);
              cbbudsindex.AddItem('2',Sender);
              cbbudsindex.AddItem('3',Sender);
              cbbudsindex.ItemIndex:=0;
           end;
       4 : begin
              cbbudsindex.Clear;
              cbbudsindex.AddItem('1',Sender);
              cbbudsindex.AddItem('2',Sender);
              cbbudsindex.AddItem('3',Sender);
              cbbudsindex.AddItem('4',Sender);
              cbbudsindex.ItemIndex:=0;
           end;
     end;

     if ((imodelEquation = 3) or (imodelEquation = 5)) then
     begin
        // чистая гидродинамики или гидродинамика и vof method.

        // условия по температуре делаем невидимыми
        TabControl1.TabIndex:=1;
        PanelTemperature.Visible:=false;
        GroupBoxVelocity.Visible:=true;
        pnlvof.Visible:=False;
        pnluds.Visible:=False;
     end
     else if ((imodelEquation = 1) or (imodelEquation = 4)) then
     begin
         // Теплопередача или гидродинамика с теплопередачей.

        // Температура активна.
         TabControl1.TabIndex:=0;
        PanelTemperature.Visible:=true;
        GroupBoxVelocity.Visible:=false;
        pnlvof.Visible:=False;
        pnluds.Visible:=False;
     end
     else if (imodelEquation = 2) then
     begin
        // User-Defined Scalar`s
        TabControl1.TabIndex:=3;

        PanelTemperature.Visible:=False;
        GroupBoxVelocity.Visible:=false;
        pnlvof.Visible:=False;
        pnluds.Visible:=True;
     end;
      // вызывает форму задания граничных условий:
      // имена границ на которых задаются граничные условия, а также
      // значения граничных условий по умолчанию
      // сгенерированы в модуле GridGenUnit.
      // инициализация формы:
     EdgeComboBox.Clear; // очистка списка границ
     for i:=1 to GridGenForm.inumboundary do
     begin
        EdgeComboBox.Items.Add(GridGenForm.edgelist[i].boundaryname);
     end;
     if (GridGenForm.inumboundary>0) then
     begin
        EdgeComboBox.ItemIndex:=0; // первая граница выбрана.
        BoundaryConditionForm.EdgeComboBoxChange(Sender); // подготовительная инициализация.
     end;
   end;

    // показывает форму где задаются граничные условия
    BoundaryConditionForm.ShowModal;

    // всё придётся инициализировать заново: выделение памяти и присвоение значений.
    //myInitializationRestart;
end;

// задание граничных условий
procedure TForm1.BoundaryCondition1Click(Sender: TObject);
begin
   if (bcreateboundary) then
   begin
      if ((imodelEquation<>2) or ((imodelEquation=2)and(imaxUDS>0))) then
      begin
         BoundaryConditionTune(Sender);
      end
      else
      begin
         Application.MessageBox('сначала нужно создать user defined scalar','warning',MB_OK);
      end;
   end
    else
   begin
      Application.MessageBox('сначала Вы должны сгенерировать сетку','warning',MB_OK);
   end;
end; // задание граничных условий

// задаёт источниковый член в уравнениях
procedure TForm1.Source1Click(Sender: TObject);
begin
   // вызывает форму задания источникового члена
   SourceInEquationForm.EquationComboBox.Clear;
   if (imodelEquation=1) then
   begin
      // Температура.
      SourceInEquationForm.EquationComboBox.AddItem('Temperature',Sender);
      case imaxUDS of
        1 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
            end;
        2 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
            end;
        3 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
            end;
        4 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS4',Sender);
            end;
      end;
   end
   else if (imodelEquation=2) then
   begin
      // User-Defined Segregated Solver.
      case imaxUDS of
        1 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
            end;
        2 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
            end;
        3 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
            end;
        4 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS4',Sender);
            end;
      end;
   end
   else if (imodelEquation=3) then
   begin
      // Flow.
      SourceInEquationForm.EquationComboBox.AddItem('X-Vel',Sender); // горизонтальная скорость
      SourceInEquationForm.EquationComboBox.AddItem('Y-Vel',Sender); // вертикальная скорость.
      case imaxUDS of
        1 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
            end;
        2 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
            end;
        3 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
            end;
        4 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS4',Sender);
            end;
      end;
   end  else if (imodelEquation=4) then
   begin
      // Flow and Temperature.
      SourceInEquationForm.EquationComboBox.AddItem('Temperature',Sender);
      SourceInEquationForm.EquationComboBox.AddItem('X-Vel',Sender);
      SourceInEquationForm.EquationComboBox.AddItem('Y-Vel',Sender);
      case imaxUDS of
        1 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
            end;
        2 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
            end;
        3 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
            end;
        4 : begin
               SourceInEquationForm.EquationComboBox.AddItem('UDS1',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS2',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS3',Sender);
               SourceInEquationForm.EquationComboBox.AddItem('UDS4',Sender);
            end;
      end;
   end else if (imodelEquation=5) then
   begin
      // Flow and VOF
      SourceInEquationForm.EquationComboBox.AddItem('X-Vel',Sender);
      SourceInEquationForm.EquationComboBox.AddItem('Y-Vel',Sender);
   end;
    SourceInEquationForm.ESc.Text:='';
    SourceInEquationForm.ESp.Text:='';
    SourceInEquationForm.EquationComboBox.ItemIndex:=-1;

   SourceInEquationForm.ShowModal;
end; // задаёт источниковый член в уравнениях

// меню для реализованной визуализации
procedure TForm1.N2Dplot1Click(Sender: TObject);
begin
   Form2DPlot.Show; // вызывает меню визуализации
end;

// выбор способа интерполяции
procedure TForm1.UseInterpolate1Click(Sender: TObject);
begin
   // вызывает форму на которой можно выбрать
   InterpolateCaseForm.Show; // способ интерполяции
   // в этом же меню от интерполляции можно вообще отказаться
end;  // способ интерполяции

// решает уравнение для поправки давления
// с учётом выбранного солвера
procedure TForm1.SolvePamendment(var rescontinity : Float);
var
    i,k,k1 : Integer; // Счётчик
    mp : array of MatrixCoef;
    db : array of  Float;
    myrP : array of Float;
    deviation : Float; // невязка
    ipifix : Integer; // фиксируемая точка
    bpresflag : Boolean; // задано ли давление на одном из рёбер
    bconstruct : Boolean;
    Aseqx, Aseqy : TPeacemanRachford;
    QneiC : TQneiC;

begin
    for k:=1 to 20 do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false;
      end;
   end;

   bconstruct:=True;
   // параметр rescontinity - это значение невязки по нескомпенсированным
   // источникам массы которые должны быть скомпенсированы. По этому значению
   // можно судить о сходимости всей системы уравнений Навье-Стокса в целом.

   if (not(bPatankarPressure)) then
   begin
      // выделение памяти
      SetLength(mp,inx*iny+1); // массив коэффициентов
      SetLength(db,inx*iny+1); // коэффициенты связанные с наличием источникового члена
      SetLength(myrP,inx*iny+1);

      // вычисление коэффициентов дискретного аналога
      PamendmentCoef(rescontinity, mp, db);
   end;

   // решатель для поправки давления:
      case itypesolver.ipamendment of
      1 : // последовательный поточечный метод Гаусса-Зейделя.
          begin
             if (not(bPatankarPressure)) then
             begin
                // способ С.Патанкара фиксировать поправку давления
                // в одной точке если необходимо.


                if (bipifixpamendment) then
                begin
                   bpresflag:=false;
                   for i:=1 to GridGenForm.inumboundary do
                   begin
                      if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                   end;
                   if (not(bpresflag)) then
                   begin
                      ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                      while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                      mp[ipifix].dae:=0.0;
                      mp[ipifix].daw:=0.0;
                      mp[ipifix].dan:=0.0;
                      mp[ipifix].das:=0.0;
                      mp[ipifix].dap:=1.0;
                      db[ipifix]:=0.0; // давление в этой точке равно нулю.
                   end;
                end;

                i:=1;
                deviation:=1e300;
                while ((deviation > rcs.Pamendment) and (i <= iterSimple.iterPamendment)) do
                begin
                   GZUniversal(Pamendment,inx,iny, mapPT, 'P',  mp,db, QneiC);
                   if (((2*i) mod (inx+iny)) = 0 ) then
                   begin
                      deviation:=myResidual(Pamendment, myrP, inx, iny, mapPT, 'P', mp, db);
                   end;
                   inc(i); // переход к следующей итерации
                end;

              end
               else
              begin
                 // Здесь реализовано как у Патанкара - нет влияния от точки на границе.

                 // никакую сверрелаксацию применять по-моему не следует
                 SolveGZPamendment(bipifixpamendment,rescontinity); // на основе солвера Гаусса-Зейделя.
                 // передаваемое значение false означает,
                 // что фиксации поправки давления в центральной точке расчётной области не производится
                 // и поправка давления сама ищет свой уровень. Это гарантирует более быструю сходимость
                 // вычислительного процесса
              end;
          end;
      2 : // гибридный алгоритм метода прогонки и Гаусса-Зейделя.
          begin
             if (not(bPatankarPressure)) then
             begin

                if (bipifixpamendment) then
                begin
                   bpresflag:=false;
                   for i:=1 to GridGenForm.inumboundary do
                   begin
                      if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                   end;
                   if (not(bpresflag)) then
                   begin
                      ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                      while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                      mp[ipifix].dae:=0.0;
                      mp[ipifix].daw:=0.0;
                      mp[ipifix].dan:=0.0;
                      mp[ipifix].das:=0.0;
                      mp[ipifix].dap:=1.0;
                      db[ipifix]:=0.0; // давление в этой точке равно нулю.
                   end;
                end;

                i:=1;
                deviation:=1e300;
                while ((deviation > rcs.Pamendment) and (i <= iterSimple.iterPamendment)) do
                begin
                    // одна итерация методом переменных направлений
                    // для поля температур и граничных условий первого рода
                    TDMAGibridGZUniversal(Pamendment,inx,iny, mapPT, 'P',mp, db, Aseqx, Aseqy, bconstruct);
                    bconstruct:=False;
                   if (((2*i) mod (inx+iny)) = 0 ) then
                   begin
                      deviation:=myResidual(Pamendment, myrP, inx, iny, mapPT, 'P', mp, db);
                   end;
                   inc(i); // переход к следующей итерации
                end;

              end
               else
              begin
                 // Здесь реализовано как у Патанкара - нет влияния от точки на границе.

                 SolveGZPamendment(bipifixpamendment,rescontinity);

                 // метод не реализован
                 //Application.MessageBox('данная возможность не реализована','abort',MB_OK);
                 //MainMemo.Lines.Add('данная возможность не реализована');
                 //bweShouldContinue:=false; // прекращение вычислений
              end;
          end;

      // Универсальный решатель для поправки давления
      3 : // прямой метод исключения Гаусса
          begin


             if (not(bPatankarPressure)) then
             begin

                // проверка все ребер, т.к. на одном из них может быть задано давление
                bpresflag:=false;
                for i:=1 to GridGenForm.inumboundary do
                begin
                   if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                end;
                if (not(bpresflag)) then
                begin
                   // ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                   // while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                   ipifix:=Random(inx*iny+1);
                   if (ipifix=0) then inc(ipifix);
                   while (mapPT[ipifix].itype <> 1) do
                   begin
                      ipifix:=Random(inx*iny+1); // точка именно внутренняя
                      if (ipifix=0) then inc(ipifix);
                   end;
                   mp[ipifix].dae:=0.0;
                   mp[ipifix].daw:=0.0;
                   mp[ipifix].dan:=0.0;
                   mp[ipifix].das:=0.0;
                   mp[ipifix].dap:=1.0;
                   db[ipifix]:=0.0; // давление в этой точке равно нулю.
                end;

                GaussUniversal(Pamendment,inx,iny,mapPT,'P',mp, db, false);

             end
              else
             begin
                // первый параметр false - без использования трансформации Гаусса
                // второй параметр false - без применения метода сопряжённых градиентов, т.к.
                // используется прямой метод исключения Гаусса.
                //SolveUniversalPamendment(false,false,rescontinity);
                // нужно фиксировать одну точку если необходимо,
                //  иначе система будет линейно зависима.
                Application.MessageBox('данная возможность не реализована','abort',MB_OK);
                MainMemo.Lines.Add('данная возможность не реализована');
                bweShouldContinue:=false; // прекращение вычислений
             end;
          end;
      4 : // на основе метода Сопряжёных Градиентов.
          begin
             // Хестенс и Штифель [1952]
             if (not(bPatankarPressure)) then
             begin
                // на основе условий Неймана.
                // проверка все ребер, т.к. на одном из них может быть задано давление
                bpresflag:=false;
                for i:=1 to GridGenForm.inumboundary do
                begin
                   if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                end;
                if (not(bpresflag)) then
                begin
                   //ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                   //while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                   ipifix:=Random(inx*iny+1);
                   if (ipifix=0) then inc(ipifix);
                   while (mapPT[ipifix].itype <> 1) do
                   begin
                      ipifix:=Random(inx*iny+1); // точка именно внутренняя
                      if (ipifix=0) then inc(ipifix);
                   end;
                   mp[ipifix].dae:=0.0;
                   mp[ipifix].daw:=0.0;
                   mp[ipifix].dan:=0.0;
                   mp[ipifix].das:=0.0;
                   mp[ipifix].dap:=1.0;
                   db[ipifix]:=0.0; // давление в этой точке равно нулю.
                end;

                // bconve = false;
                // bmessage = false;
                SoprGradCRSUniversal( Pamendment, inx, iny, mapPT, 'P', mp, false, false, iterSimple.iterPamendment, rcs.temp, 0,db); // хранение разреженной матрицы в формате CRS
             end
              else
             begin

                // метод сопряжённых градиентов с применением трансформации Гаусса
                // в методе SolveSoprGradCRSPamendment(true,false) параметр true означает,
                // что выполняется трансформация К.Ф. Гаусса
                // проверено на примере течения в изотермической каверне при Re=400,
                // что отказ от трансформации Гаусса приводит к расходимости
                // вычислительного процесса.

                //SolveSoprGradCRSPamendment(true,true,false,rescontinity); // на основе технологии CRS
                // первый параметр равный true - означает что нужно применить трансформацию Гаусса
                // второй параметр равный false - говорит о том, что не нужно фиксировать уровня поправки давления,
                // а дать ей самой искать свой уровень. Если он равен true то поправка давления фиксирована в одной точке.
                // третий параметр равный false - говорит о том что нужно использовать метод сопаряжённых градиентов

                 if (ilanguage<>1) then
                 begin
                    // метод  реализован с учётом карты 20 июня 2013 года.
                    Application.MessageBox('язык реализации переведён на язык Си.','warning',MB_OK);
                    MainMemo.Lines.Add('язык реализации переведён на язык Си.');
                    ilanguage:=1; // Язык Си.
                 end;

                 // 20 июня 2013 года данный метод был реализован на языке С в виде dll.
                 // доступ к нему через метод Зейделя. Нужно только чтобы язык был Си.
                 // Здесь реализовано как у Патанкара - нет влияния от точки на границе.

                 // никакую сверрелаксацию применять по-моему не следует
                 SolveGZPamendment(bipifixpamendment,rescontinity); // на основе солвера Гаусса-Зейделя.
                 // передаваемое значение false означает,
                 // что фиксации поправки давления в центральной точке расчётной области не производится
                 // и поправка давления сама ищет свой уровень. Это гарантирует более быструю сходимость
                 // вычислительного процесса
             end;
          end;
      5 : // алгоритм BiCGStab Хенрика Ван дер Ворста [1990]
          begin
             if (not(bPatankarPressure)) then
             begin
                // на основе условий Неймана.
                // проверка все ребер, т.к. на одном из них может быть задано давление
                bpresflag:=false;
                for i:=1 to GridGenForm.inumboundary do
                begin
                   if (GridGenForm.edgelist[i].bpressure) then bpresflag:=true;
                end;
                if (not(bpresflag)) then
                begin
                   //ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
                   //while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя
                   ipifix:=Random(inx*iny+1);
                   if (ipifix=0) then inc(ipifix);
                   while (mapPT[ipifix].itype <> 1) do
                   begin
                      ipifix:=Random(inx*iny+1); // точка именно внутренняя
                      if (ipifix=0) then inc(ipifix);
                   end;
                   mp[ipifix].dae:=0.0;
                   mp[ipifix].daw:=0.0;
                   mp[ipifix].dan:=0.0;
                   mp[ipifix].das:=0.0;
                   mp[ipifix].dap:=1.0;
                   db[ipifix]:=0.0; // давление в этой точке равно нулю.
                end;
                 // bconve = true; данный параметр здесь не учитывается, алгоритм Соловейчика -
                 // локально оптимальная схема специально работает с несимметричными матрицами.
                // bmessage = false;
                // алгоритм Ю.Г.Соловейчика.
                SoprGradCRSUniversal( Pamendment, inx, iny, mapPT, 'P', mp, true, false, iterSimple.iterPamendment, rcs.temp*rcs.temp, 1,db); // используется формат хранения разреженной матрицы CRS
             end
              else
             begin

                // первый параметр true не используется.
                //SolveSoprGradCRSPamendment(true,true,true,rescontinity); // на основе технологии CRS

                 if (ilanguage<>1) then
                 begin
                    // метод  реализован с учётом карты 20 июня 2013 года.
                    Application.MessageBox('язык реализации переведён на язык Си.','warning',MB_OK);
                    MainMemo.Lines.Add('язык реализации переведён на язык Си.');
                    ilanguage:=1; // Язык Си.
                 end;


                 // 14 июля 2013 года данный метод был реализован на языке С в виде dll.
                 // доступ к нему через метод Зейделя. Нужно только чтобы язык был Си.
                 // Здесь реализовано как у Патанкара - нет влияния от точки на границе.

                 // алгоритм BiCGStab Хенрика Ван дер Ворста 1990.
                 SolveGZPamendment(bipifixpamendment,rescontinity);

                 // метод не реализован с учётом карты
                 //Application.MessageBox('abort','данная возможность не реализована',MB_OK);
                 //MainMemo.Lines.Add('данная возможность не реализована');
                 //bweShouldContinue:=false; // прекращение вычислений
             end;
          end;
      end;

end; // решает уравнение для поправки давления

// инициализация параметров в алгоритме SIMPLE
procedure TForm1.initparamSIMPLE(bposttemperature : Boolean);
var i : Integer;
begin
   // выделение оперативной памяти под исследуемые полевые величины
   // и присваивание им значения по умолчанию.
   initparam2;

   if (actiVibr.bOn) then
   begin
      kstreamdivision:=0;
      // перед началом гидродинамического вычисления с подвижными
      // сетками запоминаем начальную конфигурацию сетки.
      // запоминаем текущую сетку
      for i:=1 to Form1.iny do
      begin
         Form1.yposfix[i]:=Form1.ypos[i];
      end;
   end;

   if (btimedepend) then
   begin
      // инициализируем поле скорости на предыдущем временном слое
      // путём запоминания текущей скорости
      // примечание: данная реализация алгоритма SIMPLE стационарная
      // а массивы скорости просто фигурируют в дискретном аналоге из-за
      // общности алгоритма, т.к. один и тот же код с небольшими изменениями
      // используется как в нестационарном так и в стационарном случае.
      RememberXvel(VxOldTimeStep); // запоминаем горизонтальную компоненту скорости
      RememberYvel(VyOldTimeStep); // запоминаем вертикальную компоненту скорости
   end;
   // инициализация поля температур если требуется
   if (bposttemperature) then
   begin
      // решение уравнения теплопроводности
      // отдельное решение уравнения теплопроводности
      initparam; // инициализирует данные

      if ((not btimedepend) and (bBussinesk)) then
      begin
         SolveTempSteady(false,iterSimple.iterTemperature,false); // находит коэффициенты и решает
      end;
      // стационарное поле температур - это неплохое начальное приближение
      // к искомому полю температур, которое определяется также полем скорости

      // инициализация поля температур на предыдущем временном слое
      // память для хранения поля температур с предыдущего временного слоя
      // выделялась при необходимости в процедуре initparam.
      if (btimedepend) then RememberTOldTimeStep(true); // инициализация
   end;

end; //  initparamSIMPLE

// Вычисляет текущие невязки для компонент скорости
procedure TForm1.getrealresFlow(var resVx :  Float; var resVy :  Float);
var
   m : array of MatrixCoef; // все коэффициенты дискретного аналога
   db, myrU : array of  Float; // часть источникового члена
   bPressureSIMPLER : Boolean;
begin
   // выделение оперативной памяти  для горизонтальной скорости
   SetLength(m,mzapas*(inx-1)*iny+1); // основные коэффициенты дискретного аналога
   SetLength(db,mzapas*(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
   SetLength(myrU,mzapas*(inx-1)*iny+1); // невязка
   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
   // GlobalCoef вызывается не с целью вычислить псевдоскорости в алгоритме SIMPLER
   // поэтому мы передаём значение false.
   bPressureSIMPLER:=false;
   VxGlobalCoef(m,db,bPressureSIMPLER);
   resVx:=myResidual(Vx,myrU, inx-1,iny, mapVx, 'U', m,db); // значение невязки
   // выделение оперативной памяти  для вертикальной скорости
   SetLength(m,inx*(iny-1)+1); // основные коэффициенты дискретного аналога
   SetLength(db,inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам
    SetLength(myrU,inx*(iny-1)+1);
   // вычисление коэффициентов дискретного аналога
   // проход по всем внутренним точкам
   VyGlobalCoef(m,db,bPressureSIMPLER);
   resVy:=myResidual(Vy,myrU, inx,iny-1, mapVy, 'V', m,db); // значение невязки
   Finalize(m); Finalize(db); // освобождение оперативной памяти
end; // getrealresFlow

// вычисляет невязку для температуры
procedure TForm1.getrealResTemp(var restemp : Float);
var
   m : array of MatrixCoef; // все коэффициенты дискретного аналога
   db, myrU : array of  Float; // часть источникового члена
begin
   SetLength(m,inx*iny+1); // основные коэффициенты дискретного аналога
   SetLength(db,inx*iny+1);
   SetLength(myrU,inx*iny+1);
   TempConvCoef(m, db);
   restemp:=myResidual(T,myrU,inx,iny,mapPT, 'T', m,db);
   SetLength(m,0); // основные коэффициенты дискретного аналога
   SetLength(db,0);
   SetLength(myrU,0);
end; // getrealResTemp

// алгоритмы: SIMPLE, SIMPLEC и SIMPLER.
// стационарный алгоритм SIMPLE
// если bposttemperature = true, то с учётом теплопроводности,
// но без учёта приближения Буссинеска,
// т.е. гидродинамика не зависит от теплопроводности,
// а теплопроводность зависит от гидродинамики через поле скорости
// За приближение Обербека-Буссинеска отвечает параметр bBussinesk.
procedure TForm1.myVersionSIMPLEAlgorithm(bposttemperature : Boolean);
var
    i, iscan : Integer; // счётчик числа итераций.
    j : Integer; // счётчик числа шагов по времени
    rescontinity :  Float; // нескомпенсированные источники массы
    resVx, resVy, restemp :  Float; // невязка по горизонтальной и вертикальной компонентам скорости
    timestart, timefinish, timelength : Ttime; // для замера времени выполнения.
    p : Integer;
    resuds1, resuds2, resuds3, resuds4 : Float;
    mglobalVx1 : array of MatrixCoef; // все коэффициенты дискретного аналога
    dbglobalVx1 : array of  Float; // часть источникового члена
    mglobalVy1 : array of MatrixCoef; // все коэффициенты дискретного аналога
    dbglobalVy1 : array of  Float; // часть источникового члена
    bquickcalc1,  bquickcalc2,  bquickcalc3,  bquickcalc4 :  TmyDynArrayb;
    bquickcalcVx1,  bquickcalcVx2,  bquickcalcVx3,  bquickcalcVx4 :  TmyDynArrayb;
    bquickcalcVy1,  bquickcalcVy2,  bquickcalcVy3,  bquickcalcVy4 :  TmyDynArrayb;
    // Для проверки случая buds1coefconst=true;
    x1, x2 : Float;
    code1, code2 : Integer;
    value_of_equation : array of Float;
    fHorf : Float;

begin
   // Здесь реализована последовательность операций
   // алгоритма С. Патанкара SIMPLE, SIMPLEC и SIMPLER
   // на основе SIMPLE. (SIMPLER = SIMPLE Revised)

   (* SIMPLER  (SIMPLE Revised) *)
   (*
    *   Патанкар стр. 111.
    *  1. Ввести предположение о поле скорости.
    *  2. Рассчитать коэффициенты уравнения количества движения
    *     и затем рассчитать u~, v~ из уравнений, таких же, как (5.26).
    *  3. Рассчитать коэффициенты уравнения для давления (5.30) и
    *     решить его с целью получения поля давления.
    *  4. Обработать это поле давления в качестве p*, решить уравнение количества
    *      движения для получения u*, v*.
    *  5. Рассчитать массовый источник [уравнение (5.23)] и затем
    *     решить уравнение поля p`.
    *  6. Скорректировать поле скорости (но не поля давления) с помощью уравнений (5,17)-(5.19).
    *  7. Решить, если это надо, дискретные аналоги для других Ф.
    *  8. Вернуться к пункту 2 и повторить расчёты до тех пор пока не будет достигнута сходимость.
    *)



   if (bweShouldInitialize[imodelEquation]) then
   begin
      // окно терминальной формы закрывается в методе myRun.

      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin



       // Зададим граничные условия Дирихле для User-Defined Scalar
      case imaxUDS of
      // Учёт граничных условий Дирихле !!!
      1 : begin
             icurentuds:=1;
             initBoundaryConditionUDS;
          end;
      2 : begin
             icurentuds:=1;
             initBoundaryConditionUDS;
             icurentuds:=2;
             initBoundaryConditionUDS;

             // Проверка того можно ли очень быстро собрать СЛАУ для
             // уравнения потенциала в предположении, что шаблон
             // правой части для уравнения потенциала имеет предопределённую
             // заранее форму.
             val(dsp1str,x1,code1);
             val(gamma1str,x2,code2);
             if ((code1=0)and(code2=0)and((idsc1type=1)or(idsc1type=2))) then
             begin
                diffuds1const:=x2; // постоянный коэффициент диффузии.
                buds1coefconst:=True;
             end;
          end;
      3 : begin
             icurentuds:=1;
             initBoundaryConditionUDS;
             icurentuds:=2;
             initBoundaryConditionUDS;
             icurentuds:=3;
             initBoundaryConditionUDS;
          end;
      4 : begin
             icurentuds:=1;
             initBoundaryConditionUDS;
             icurentuds:=2;
             initBoundaryConditionUDS;
             icurentuds:=3;
             initBoundaryConditionUDS;
             icurentuds:=4;
             initBoundaryConditionUDS;
          end;
      end;

       SetLength(value_of_equation, inx*iny+1);


       // препроцессинг для SolveUDS.
       icurentuds:=1;
       preprocessing_quick_calc(bquickcalc1,bquickcalcVx1,bquickcalcVy1);
       icurentuds:=2;
       preprocessing_quick_calc(bquickcalc2,bquickcalcVx2,bquickcalcVy2);
       icurentuds:=3;
       preprocessing_quick_calc(bquickcalc3,bquickcalcVx3,bquickcalcVy3);
       icurentuds:=4;
       preprocessing_quick_calc(bquickcalc4,bquickcalcVx4,bquickcalcVy4);


       SetLength(mglobalVx1,mzapas*(inx-1)*iny+1); // основные коэффициенты дискретного аналога
       SetLength(dbglobalVx1,mzapas*(inx-1)*iny+1); // коэффициенты имеющие отношение к источниковым членам
       SetLength(mglobalVy1,mzapas*inx*(iny-1)+1); // основные коэффициенты дискретного аналога
       SetLength(dbglobalVy1,mzapas*inx*(iny-1)+1); // коэффициенты имеющие отношение к источниковым членам

       timestart:=Now;

       if (imodelEquation<>2) then
       begin
          SetLength(pointerlist_gl,mzapas*inx*iny);
          SetLength(pointerlistrevers_gl,mzapas*inx*iny);
          bconstr:=False; // признак показывающий что нужно заново рассчитать данные массивы.
       end;

      // вся необходимая инициализация параметров уже выполнена см. вкладку инициализации в меню.


         if (not(btimedepend)) then
         begin
            // будем показывать ход выполнения стационарного расчёта.
            myProgressBarForm.Show;
         end
         else
         begin
            myProgressBarUnsteadyForm.Show;
         end;


      // шаг 1: задание поля давления
      // смотри процедуру  initparamSIMPLE.

      j:=1; // инициализация
      while ((bweShouldContinue) and (j<=inumbertimestep)) do
      begin
         // в стационарном случае inumbertimestep равно 1. И это указывается явно при запуске в Run Module.
         // глобальная переменная realFlowTime
         // используется как параметр при различных вибрационных воздействиях.
         if (btimedepend) then
         begin
            realFlowTime:=realFlowTime + dTimeStep; // Текущее время при нестационарном расчёте
            // Запоминание плотности надо делать в конце шага по времени но перед вычислением нового положения
            // функции цвета !!!
         end;

         if (imodelEquation<>2) then
         begin
            if (actiVibr.bOn) then
            begin
               // передвигаем динамическую сетку
               // и задаёт скорость
               mymovingmesh;
               UpdateMap;
            end;
         end;

         i:=0; // инициализация
         rescontinity:=1.0e37; // очень большое число



         // обязательно не менее трёх обязательных итераций.
         // Не менее трёх итераций нужно например для задач с конвекцией когда continity на первой итерации
         // строго равна нулю, но решение ещё не получено так как возбуждающее течение поле температур ещё не успело найтись,
         // оно станет известным только к концу первой итерации.
         while (((bweShouldContinue) and (i<itercount) and (rescontinity>rcs.continity))or(i<3))  do
         begin

             if (imodelEquation=3) then
             begin
                // визуализация модуля скорости.
                DisplayUniversalInternal(9,true);
             end;

             if (imodelEquation=4) then
             begin
                // визуализация модуля скорости.
                DisplayUniversalInternal(9,true);
             end;

            // Так как теперь граничные условия зависят
            // от решения то надо регулярно updat`ить граничные условия Дирихле на каждой итерации.
            // Зададим граничные условия Дирихле для User-Defined Scalar

            case imaxUDS of
            // Учёт граничных условий Дирихле !!!
            1 : begin
                   icurentuds:=1;
                   initBoundaryConditionUDS;
                end;
            2 : begin
                   icurentuds:=1;
                   initBoundaryConditionUDS;
                   icurentuds:=2;
                   initBoundaryConditionUDS;
                end;
            3 : begin
                   icurentuds:=1;
                   initBoundaryConditionUDS;
                   icurentuds:=2;
                   initBoundaryConditionUDS;
                   icurentuds:=3;
                   initBoundaryConditionUDS;
                end;
            4 : begin
                   icurentuds:=1;
                   initBoundaryConditionUDS;
                   icurentuds:=2;
                   initBoundaryConditionUDS;
                   icurentuds:=3;
                   initBoundaryConditionUDS;
                   icurentuds:=4;
                   initBoundaryConditionUDS;
                end;
            end;




            if (i mod 10 = 0) then
            begin
               if ((imodelEquation=3)or (imodelEquation=5)) then
               begin
                  case imaxUDS of
                     0 : begin
                            MainMemo.Lines.Add('iter  continity   x-velocity   y-velocity');
                         end;
                     1 : begin
                            MainMemo.Lines.Add('iter continity   x-velocity   y-velocity  uds1');
                         end;
                     2 : begin
                            MainMemo.Lines.Add('iter continity x-vel y-vel uds1 uds2');
                         end;
                     3 : begin
                            MainMemo.Lines.Add('iter continity x-vel y-vel uds1 uds2 uds3');
                         end;
                     4 : begin
                            MainMemo.Lines.Add('iter continity x-vel y-vel uds1 uds2 uds3 uds4');
                         end;
                  end;
               end
                else if (imodelEquation=4) then
               begin
                  case imaxUDS of
                     0 : begin
                            MainMemo.Lines.Add('iter  continity   x-velocity   y-velocity  temperature');
                         end;
                     1 : begin
                            MainMemo.Lines.Add('iter  continity  x-vel   y-vel  temp uds1');
                         end;
                     2 : begin
                            MainMemo.Lines.Add('iter continity  x-vel   y-vel  temp  uds1  uds2');
                         end;
                     3 : begin
                            MainMemo.Lines.Add('iter continity  x-vel   y-vel  temp  uds1  uds2  uds3');
                         end;
                     4 : begin
                            MainMemo.Lines.Add('iter continity  x-vel   y-vel  temp  uds1  uds2  uds3 uds4');
                         end;
                  end;
               end
               else if (imodelEquation=2) then
               begin
                  case imaxUDS of
                     1 : begin
                            MainMemo.Lines.Add('iter  uds1');
                         end;
                     2 : begin
                            MainMemo.Lines.Add('iter  uds1  uds2');
                         end;
                     3 : begin
                            MainMemo.Lines.Add('iter  uds1  uds2  uds3');
                         end;
                     4 : begin
                            MainMemo.Lines.Add('iter  uds1  uds2  uds3  uds4');
                         end;
                  end;
               end;
            end;

            if (imodelEquation<>2) then
            begin
               if (bsimpler) then
               begin
                  // шаг 2 и 3 (SIMPLER). расчёт коэффициентов и
                  // решение уравнения для давления
                  CopyToVyActing(Vy);  // Сборку матрицы для давления нужно осуществлять на основе
                  CopyToVxActing(Vx);  // текущей скорости.
                  SolveGZPressure(false);
                  bconstr:=true;
               end;

               // шаг 2: решение нелинейных уравнений движения
               // требуется всеобъемлющее тестирование программного кода
               // решение нелинейного уравнения для горизонтальной скорости
               // содержит в себе и метод Зейделя и метод переменных направлений

               // На данном этапе вообще говоря VOld тождественно равно V.
               CopyToVyActing(Vy);
               CopyToVxActing(Vx);

               // раздельный солвер для компонент скорости
               SolveVx(mglobalVx1,dbglobalVx1); // для горизонтальной компоненты скорости
               fHorf:=0.25;
               if (btimedepend) then
               begin
                  fHorf:=0.75;
               end;
               // High order relaxation.
               for iscan := 1 to imaxnumbernodeVx do
               begin
                  //Vx[iscan]:=VxActing[iscan]+fHorf*(Vx[iscan]-VxActing[iscan]);
                  Vx[iscan]:=VxOld[iscan]+fHorf*(Vx[iscan]-VxOld[iscan]);
               end;

               SolveVy(mglobalVy1,dbglobalVy1); // для верикальной компоненты скорости
               fHorf:=0.25;
               if (btimedepend) then
               begin
                  fHorf:=0.75;
               end;
                // High order relaxation.
               for iscan := 1 to imaxnumbernodeVy do
               begin
                  //Vy[iscan]:=VyActing[iscan]+fHorf*(Vy[iscan]-VyActing[iscan]);
                  Vy[iscan]:=VyOld[iscan]+fHorf*(Vy[iscan]-VyOld[iscan]);
               end;

               // По видимому этой операции нижней релаксации явно недостаточно.
               // За время решения (итерирования СЛАУ) без какой либо нижней релаксации
               // компоненты скорости на столько удаляются от скоректированных, что мы
               // имеем в итоге расходимость всей SIMPLE процедуры.
               // из этого следует сделать вывод: Нужно вводить коэффициент нижней релаксации
               // к скоректированной скорости прямо в матрицу СЛАУ  и итерировать именну матрицу в которую уже встроена нижняя
               // релаксация  скоректированной скорости. Нижняя релаксация не позволит скорости стат очень большой
               // (сильно удалиться от скоректированной) к тому же наличие такой матрицы в которую уже всё встроено позволит
               // применять и другие более универсальные солверы.
               //Lower_relaxation_Velocity; // нижняя релаксация.

               //CopyToVyActing(Vy);  // Сборку матрицы для поправки давления нужно осуществлять на основе
               //CopyToVxActing(Vx);  // обновлённой скорости. со звёздочкой.

               getrealresFlow(resVx,resVy); // вычисление невязки для компонент скорости

               // шаг 3: решение линейного  уравнения для Pamendment
               initPamendmentZero; // инициализация нулём

               // решатель для поправки давления:
               SolvePamendment(rescontinity);
               bconstr:=true;


               // шаг 4: коррекция давления
               // замечание: нужно писать наверно вместе с граничными условиями
               if (not(bsimpler)) then CorrectNewPressure;
               //DisplayPressure; // визуализирует  давление
               // шаг 5: коррекция компонент скорости
               CorrectVx; // коррекция горизонтальной скорости
               //DisplayXvel; // отображаем горизонтальную скорость

               CorrectVy; // коррекция вертикальной скорости
               //DisplayYvel; // отображает вертикальную скорость

               // запоминаем поле скорости удовлетворяющее уравнению неразрывности
               RememberXvel(VxOld); // запоминаем горизонтальную компоненту скорости
               RememberYvel(VyOld); // запоминаем вертикальную компоненту скорости
               // шаг 6: решение других уравнений, например для поля температур, но
               // только в том случае если они влияют на течение жидкости
               // (см. например модель Обербека-Буссинеска).
               if (imodelEquation=4) then
               begin
                  // imodelEquation=4 совместное решение уравнений гидродинамики и теплопередачи.

                  // запоминаем поле температур с предыдущей итерации
                  RememberTOldTimeStep(false); // оно может использоваться для нижней релаксации
                  SolveTempSteady(false,iterSimple.iterTemperature, true); // находит коэффициенты и решает
                  fHorf:=0.25;
                  if (btimedepend) then
                  begin
                     fHorf:=0.75;
                  end;
                  // High order relaxation.
                  for iscan := 1 to imaxnumbernode do
                  begin
                     T[iscan]:=TOldIteration[iscan]+fHorf*(T[iscan]-TOldIteration[iscan]);
                  end;
                  getrealResTemp(restemp);
               end;


               (*if (imodelEquation=5) then
                begin
                   // Никогда не использовать данный код здесь, так как update
                   // функции цвета должен происходить только в конце временного шага.
                   SolveVOF(iterSimple.iterVof);
                   anti_diffusionVOF; // Антидиффузионная коррекция Н.Г. Бураго.
                end;
               *)

            end;

            // Решение уравнений для User-Defined Scalar`ов
            case imaxUDS of
               1 : // UDS1
                   begin
                       icurentuds:=1;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds1, resuds1, bquickcalc1, bquickcalcVx1, bquickcalcVy1, value_of_equation);
                   end;
               2 : // UDS1 and UDS2
                   begin
                       icurentuds:=1;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds1, resuds1, bquickcalc1, bquickcalcVx1, bquickcalcVy1, value_of_equation);

                       icurentuds:=2;
                       // Так как теперь граничные условия зависят
                       // от решения то надо регулярно updat`ить граничные условия Дирихле на каждой итерации.
                       // Зададим граничные условия Дирихле для User-Defined Scalar
                       // Будем задавать обновлённые граничные условия Дирихле.
                       //initBoundaryConditionUDS;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds2, resuds2, bquickcalc2, bquickcalcVx2, bquickcalcVy2, value_of_equation);
                   end;
               3 : // UDS1, UDS2, UDS3
                   begin
                       icurentuds:=1;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds1, resuds1, bquickcalc1, bquickcalcVx1, bquickcalcVy1, value_of_equation);
                       icurentuds:=2;
                       // Так как теперь граничные условия зависят
                       // от решения то надо регулярно updat`ить граничные условия Дирихле на каждой итерации.
                       // Зададим граничные условия Дирихле для User-Defined Scalar
                       // Будем задавать обновлённые граничные условия Дирихле.
                       //initBoundaryConditionUDS;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds2, resuds2,bquickcalc2, bquickcalcVx2, bquickcalcVy2, value_of_equation);
                       icurentuds:=3;
                       // Так как теперь граничные условия зависят
                       // от решения то надо регулярно updat`ить граничные условия Дирихле на каждой итерации.
                       // Зададим граничные условия Дирихле для User-Defined Scalar
                       // Будем задавать обновлённые граничные условия Дирихле.
                       //initBoundaryConditionUDS;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds3, resuds3,bquickcalc3, bquickcalcVx3, bquickcalcVy3, value_of_equation);
                   end;
               4 : // UDS1, UDS2, UDS3, UDS4
                   begin
                       icurentuds:=1;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds1, resuds1,bquickcalc1, bquickcalcVx1, bquickcalcVy1, value_of_equation);
                       icurentuds:=2;
                       // Так как теперь граничные условия зависят
                       // от решения то надо регулярно updat`ить граничные условия Дирихле на каждой итерации.
                       // Зададим граничные условия Дирихле для User-Defined Scalar
                       // Будем задавать обновлённые граничные условия Дирихле.
                       //initBoundaryConditionUDS;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds2, resuds2,bquickcalc2, bquickcalcVx2, bquickcalcVy2, value_of_equation);
                       icurentuds:=3;
                       // Так как теперь граничные условия зависят
                       // от решения то надо регулярно updat`ить граничные условия Дирихле на каждой итерации.
                       // Зададим граничные условия Дирихле для User-Defined Scalar
                       // Будем задавать обновлённые граничные условия Дирихле.
                       //initBoundaryConditionUDS;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds3, resuds3, bquickcalc3, bquickcalcVx3, bquickcalcVy3, value_of_equation);
                       icurentuds:=4;
                       // Первый параметр bmessage
                       SolveUDS(False, iterSimple.iteruds4, resuds4, bquickcalc4, bquickcalcVx4, bquickcalcVy4, value_of_equation);
                   end;
            end;

            // В противном случае решение подобных уравнений лучше произвести потом.
            // шаг 7: (зацикливающий) представление скоректированного давления как нового
            // и возвращение к шагу 2.
            // печать значения невязки на консоль
            if ((imodelEquation=3)or(imodelEquation=5)) then
            begin
               // imodelEquation=3 - чистая гидродинамика.
               // imodelEquation=5 - гидродинамика плюс VOF метод.
               inc(imarker);
               SetLength(myresplot,imarker);

               case imaxUDS of
                 0 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy));
                     end;
                 1 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',resuds1));
                        myresplot[imarker-1].uds1:=resuds1;
                     end;
                 2 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                     end;
                 3 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2)+ '  ' + FormatFloat('#.####e-0',resuds3));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                        myresplot[imarker-1].uds3:=resuds3;
                     end;
                 4 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2)+ '  ' + FormatFloat('#.####e-0',resuds3)+ '  ' + FormatFloat('#.####e-0',resuds4));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                        myresplot[imarker-1].uds3:=resuds3;
                        myresplot[imarker-1].uds4:=resuds4;
                     end;
               end;

               myresplot[imarker-1].continity:=rescontinity; // нумерация начинается от нуля
               myresplot[imarker-1].Vx:=resVx;
               myresplot[imarker-1].Vy:=resVy;
               myresplot[imarker-1].temperature:=1.0;
               if (imarker>1) then updatemainpaintbox; // графики невязок
            end
             else  if (imodelEquation=4) then
            begin
               inc(imarker);
               SetLength(myresplot,imarker);

               case imaxUDS of
                 0 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',restemp));
                     end;
                 1 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',restemp)+ '  ' + FormatFloat('#.####e-0',resuds1));
                        myresplot[imarker-1].uds1:=resuds1;
                     end;
                 2 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',restemp)+ '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                     end;
                 3 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',restemp)+ '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2)+ '  ' + FormatFloat('#.####e-0',resuds3));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                        myresplot[imarker-1].uds3:=resuds3;
                     end;
                 4 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',rescontinity) + '  ' + FormatFloat('#.####e-0',resVx) + '  ' + FormatFloat('#.####e-0',resVy)+ '  ' + FormatFloat('#.####e-0',restemp)+ '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2)+ '  ' + FormatFloat('#.####e-0',resuds3)+ '  ' + FormatFloat('#.####e-0',resuds4));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                        myresplot[imarker-1].uds3:=resuds3;
                        myresplot[imarker-1].uds4:=resuds4;
                     end;
               end;


               myresplot[imarker-1].continity:=rescontinity; // нумерация начинается от нуля
               myresplot[imarker-1].Vx:=resVx;
               myresplot[imarker-1].Vy:=resVy;
               myresplot[imarker-1].temperature:=restemp;

               if (imarker>1) then updatemainpaintbox; // графики невязок
            end
            else  if (imodelEquation=2) then
            begin
               inc(imarker);
               SetLength(myresplot,imarker);

               case imaxUDS of
                 0 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) );
                     end;
                 1 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) +'  ' + FormatFloat('#.####e-0',resuds1));
                        myresplot[imarker-1].uds1:=resuds1;
                     end;
                 2 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                     end;
                 3 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2)+ '  ' + FormatFloat('#.####e-0',resuds3));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                        myresplot[imarker-1].uds3:=resuds3;
                     end;
                 4 : begin
                        MainMemo.Lines.Add(IntToStr(iglobalnumberiteration) + '  ' + FormatFloat('#.####e-0',resuds1)+ '  ' + FormatFloat('#.####e-0',resuds2)+ '  ' + FormatFloat('#.####e-0',resuds3)+ '  ' + FormatFloat('#.####e-0',resuds4));
                        myresplot[imarker-1].uds1:=resuds1;
                        myresplot[imarker-1].uds2:=resuds2;
                        myresplot[imarker-1].uds3:=resuds3;
                        myresplot[imarker-1].uds4:=resuds4;
                     end;
               end;

               myresplot[imarker-1].continity:=rescontinity; // нумерация начинается от нуля
               myresplot[imarker-1].Vx:=resVx;
               myresplot[imarker-1].Vy:=resVy;
               myresplot[imarker-1].temperature:=restemp;


               if (imarker>1) then updatemainpaintbox; // графики невязок
            end;
            // печать значения невязки в файл
            // freport.Add(FloatToStr(rescontinity));

            if (not(btimedepend)) then
            begin
               if (itercount=0) then
               begin
                  itercount:=1;
               end;
               myProgressBarForm.ProgressBar1.Position:=Round(100*(i+1)/itercount);
            end
            else
            begin
               if (itercount=0) then
               begin
                  itercount:=1;
               end;
               myProgressBarUnsteadyForm.ProgressBar2.Position:=Round(100*(i+1)/itercount);
            end;

            i:=i+1; // увеличиваем счётчик и переходим к шагу 2.
            inc(iglobalnumberiteration); // увеличиваем глобальное количество итераций на 1
            // временное прерывание расчётов
            // для того чтобы программа смогла
            // среагировать на другие события от
            // пользователя или операционной системы.
            Application.ProcessMessages;
         end; // конец стационарных итераций.

         if (imodelEquation<>2) then
         begin
            // после внутренненего цикла но строго до вычисления функции цвета.
            rememberDensity; // запоминание плотности с предыдущего временного слоя
         end;

         if (not(btimedepend)) then
         begin
            myProgressBarForm.ProgressBar1.Position:=0;
            myProgressBarForm.Close;
         end;

         if (imodelEquation<>2) then
         begin
            if ((not bBussinesk) and (bposttemperature)) then
            begin
               // если требуется просто определить поле температур
               // в случае когда оно зависит от течения жидкости, а
               // течение жидкости от него не зависит.
               SolveTempSteady(false,iterSimple.iterTemperature, true); // находит коэффициенты и решает
            end;


            // Правка давления для нормальной графической визуализации
            // дополнение до граничных условий Неймана.
            PressurePathit; // устраняет дефекты графической визуализации
            VelXPachit; // устраняет дефекты графической визуализации для горизонтальной скорости

            // Вычисляет Вихрь
            CurlConstruct;
            // минус вихрь является правой частью в уравнении
            // Пуассона для нахождения функции тока.
            // Нахождение функции тока.
            // функция тока проинициализирована нулём внутри процедуры
            // initparam2 которая входит внутрь процедуры initparamSIMPLE.
            // При нестационарном расчёте с малым шагом можно предположить,
            // что функция тока меняется достаточно медленно поэтому значение
            // функции тока с предыдущей итерации по времени является хорошим начальным приближением.
            // необходимое количество итераций задаётся на вкладке контроля алгоритма SIMPLE.
            SolveStreamFunction(false, iterSimple.iterStreamFunction);
            if (actiVibr.bOn) then
            begin
               RememberStreamFunction; // функция тока
               RememberOmega1T; // вихрь
               RememberXVelDM; // горизонтальная скорость
               RememberYVelDM; // вертикальная скорость
               if (bposttemperature) then RememberTempDM; // температура
               if (inumbertimestep mod inumbertimestepDivisionPeriod = 0) then
               begin
                  // закончился один период пора собрать статистику
                  CalculateMeanStreamFunction; // функция тока
                  CalculateMeanOmega1T; // вихрь
                  CalculateMeanXVel; // горизонтальная скорость
                  CalculateMeanYVel; // вертикальная скорость
                  if (bposttemperature) then CalculateMeanTempreture;
                  inc(kstreamdivision);
                  initmeanSF('T'); // обнуление.
                  initmeanOmega('T');
                  initmeanXvel('T');
                  initmeanYvel('T');
                  if (bposttemperature) then initmeanTemp('T');
               end;
            end;

            if (btimedepend) then
            begin
               // В случае нестационарного солвера надо
               // запомнить распределения полевых величин
               // на данном временном слое
               // для использования их на следующем временном слое.


               // организация запоминания для аппроксимации по времени вторго порядка Пейре.
               if (bsecondorderflow) then
               begin
                  RememberXvelSO();
                  RememberYvelSO();
               end;
               // запоминание скорости на данном временном слое
               RememberXvel(VxOldTimeStep); // запоминаем горизонтальную компоненту скорости
               RememberYvel(VyOldTimeStep); // запоминаем вертикальную компоненту скорости

               // не забыть вычислить плотность с предыдущего шага по времени.
               //Плотность запоминается в начале каждого шага по времени. см. rememberdensity.
               if (bposttemperature) then
               begin
                  // Только в том случае если также рассчитывается поле температур:
                  // запоминаем поле температур в переменной ToldTimeStep
                  RememberTOldTimeStep(true);
               end;

               // решение уравнения для функции цвета.
               if (imodelEquation=5) then
               begin

                  // Мы должны запомнить распределение функции цвета до её обновления,
                  // т.е. до её вычисления на новом временном слое.
                  RememberVOF; // запоминаем функцию цвета при переходе на следующий шаг по времени.

                  if (bVOFExplicit) then
                  begin
                     // Явный метод.
                     // Hirt-Nichols`VOF
                     Hirt_NicholsVOF;
                  end
                   else
                  begin
                      // Неявный метод.
                      SolveVOF(iterSimple.iterVof);
                  end;
                  if (iantidiffusionBuragoevery<>High(Integer)) then
                  begin
                     if ((j mod iantidiffusionBuragoevery) = 0) then
                     begin
                        // Антидиффузионная коррекция Н.Г. Бураго.
                        anti_diffusionVOF;
                     end;
                  end;
                  // поддержка консервативности VOF.
                  // по мотивам диссертации Н.Г.Бураго.
                  // Так как консервативность ниоткуда не следует, особенно при включённой антидиффузионной
                  // коррекции, то её следует поддерживать искусственно.
                  //conservationVOF;

                  // Вычисляет силу поверхностного натяжения.
                  // CSF - continum surface force
                  if (bCSF) then
                  begin
                     calc_continuum_surface_force();
                  end;

                  // Графическое отображение функции цвета.
                  DisplayUniversalInternal(13,false);

                end;

                // вывод текущего времени и номера шага по времени на консоль
                MainMemo.Lines.Add('time    iter');
                MainMemo.Lines.Add(FormatFloat('#.####e-0', realFlowTime)+'   '+IntToStr(j));
            end;

         end;

         if (btimedepend) then
         begin
            case imaxUDS of
              1 : begin
                     if (itypeuds1unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds1oldTimeStep[ipi]:=UDS1[ipi];
                           end;
                        end;
                     end;
                     if (banimationnow) then
                     begin
                        // Графическое отображение UDS1.
                        DisplayUniversalInternal(14,false);  // графический показ UDS1 каждый шаг по времени
                     end;
                  end;
              2 : begin
                     if (itypeuds1unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds1oldTimeStep[ipi]:=UDS1[ipi];
                           end;
                        end;
                     end;
                     if (itypeuds2unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds2oldTimeStep[ipi]:=UDS2[ipi];
                           end;
                        end;
                     end;
                     if (banimationnow) then
                     begin
                        DisplayUniversalInternal(18,false); // графический вывод сразу двух UDS : UDS1 и UDS2.
                     end;
                  end;
              3 : begin
                     if (itypeuds1unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds1oldTimeStep[ipi]:=UDS1[ipi];
                           end;
                        end;
                     end;
                     if (itypeuds2unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds2oldTimeStep[ipi]:=UDS2[ipi];
                           end;
                        end;
                     end;
                     if (itypeuds3unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds3oldTimeStep[ipi]:=UDS3[ipi];
                           end;
                        end;
                     end;
                     if (banimationnow) then
                     begin
                        DisplayUniversalInternal(19,false); // графический вывод сразу трёх UDS : UDS1 и UDS2, UDS3.
                     end;
                  end;
              4 : begin
                     if (itypeuds1unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds1oldTimeStep[ipi]:=UDS1[ipi];
                           end;
                        end;
                     end;
                     if (itypeuds2unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds2oldTimeStep[ipi]:=UDS2[ipi];
                           end;
                        end;
                     end;
                     if (itypeuds3unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds3oldTimeStep[ipi]:=UDS3[ipi];
                           end;
                        end;
                     end;
                     if (itypeuds4unsteadyfunction=1) then
                     Begin
                        // нестационарный член присутствует
                        for p:=1 to imaxnumbernode do
                        begin
                           with mapPT[p] do
                           begin
                              ipi:=i+(j-1)*inx;
                              uds4oldTimeStep[ipi]:=UDS4[ipi];
                           end;
                        end;
                     end;
                  end;
            end;
         end;

         if (inumbertimestep=0) then
         begin
            inumbertimestep:=1;
         end;
         myProgressBarUnsteadyForm.ProgressBar1.Position:=Round(100*(j+1)/inumbertimestep);

         // нужно удалять не все строки а только начальный блок строк оставляя некоторый остаток.
         //if (mainMemo.Lines.Count > 1000) then
         //begin
            // Очистка MainMemo во избежание переполнения его буфера.
           // mainMemo.Lines.Clear;
            //mainMemo.Clear;
         //end;

         if ((j mod ianimateeverytimestep)=0) then
         begin
            // Сохранение анимационного кадра каждые
            // ianimateeverytimestep шагов по времени.
            if (imodelEquation<>2) then
            begin
               AnimationBody('time='+FloatToStr(realFlowTime));
            end;
         end;

         j:=j+1; // переход к следующему шагу по времени.
      end; // j временные шаги

      if (btimedepend) then
      begin
         myProgressBarUnsteadyForm.ProgressBar1.Position:=0; // обнуление
         myProgressBarUnsteadyForm.ProgressBar2.Position:=0; // индикаторов
         myProgressBarUnsteadyForm.Close; // закрыть индикатор хода выплнения
      end;

      if (imodelEquation<>2) then
      begin

         if (actiVibr.bOn) then
         begin
            if (kstreamdivision <> 0) then
            begin
               // передвигаем динамическую сетку
               // и задаёт скорость
               mymovingmesh;
               UpdateMap;
               CalculateMeanSF(kstreamdivision); // функция тока
               CalculateMeanOmega(kstreamdivision); // вихрь
               CalculateMeanVx(kstreamdivision); // горизонтальная скорость
               CalculateMeanVy(kstreamdivision); // вертикальная скорость
               if (bposttemperature) then CalculateMeanT(kstreamdivision);
             end;
          end;
      end;


      if (bweShouldContinue = false) then
      begin
         // если нижеследующего диагностического сообщения на консоль не поступает
         // значит переменная bweShouldContinue изменяется также внутри какого-то метода.
         // Нужно проследить за переменной bweShouldContinue
         MainMemo.Lines.Add('user terminate calculating process...');
         // восстанавливаем готовность к решению
         bweShouldContinue:=true;
      end;

      if (imodelEquation<>2) then
      begin
         // закрывает визуальную форму
         // в которой отображалась анимация
         //DisplayForm.Close;
         // сообщает о том что решение получено
         freport.SaveToFile('reportPamendment.txt');
         freport.Clear; // очистка содержимого
      end;

      MainMemo.Lines.Add('one task calculation complite...');
      timefinish:=Now;
      timelength:=timefinish-timestart;
      MainMemo.Lines.Add('calculation time is = '+TimeToStr(timelength));

      if (btimedepend) then
      begin
         if (imodelEquation<>2) then
         begin
            animationStart(); // запуск анимационных кадров.
         end;
      end;

      // Включается только на время вычислений.
      buds1coefconst:=False;

      SetLength(value_of_equation, 0);
   end;


end; // myVersionSIMPLEAlgorithm


// Выбор алгоритма солвера
procedure TForm1.SelectSolvertune;
begin
   // инициализация всех
   // панелей с учётом
   // выбранных типов солвера при
   // создании приложения или в процессе его работы

    // теплопроводность
    AlgoSolver.RadioGroup1.ItemIndex:=itypesolver.itemperature-1;
    // компоненты скорости
    AlgoSolver.RadioGroup2.ItemIndex:=itypesolver.ivelocity-1;
    // поправка давления
    AlgoSolver.RadioGroup3.ItemIndex:=itypesolver.ipamendment-1;
    case AlgoSolver.cbbuds.ItemIndex of
       0 : begin
              AlgoSolver.rguds.ItemIndex:=itypesolver.iuds1-1;
           end;
       1 : begin
              AlgoSolver.rguds.ItemIndex:=itypesolver.iuds2-1;
           end;
       2 : begin
              AlgoSolver.rguds.ItemIndex:=itypesolver.iuds3-1;
           end;
       3 : begin
              AlgoSolver.rguds.ItemIndex:=itypesolver.iuds4-1;
           end;
    end;

    AlgoSolver.ShowModal; // форма выбора алгоритма солвера
end;

// выбор алгоритма солвера: Гаусс-Зейдель или переменные направления
procedure TForm1.SelectSolver1Click(Sender: TObject);
begin
   SelectSolvertune;
end;

// контролирует одну итерацию алгоритма SIMPLE
procedure TForm1.controlSimpletune;
begin
   // передача параметров хранящихся в данный момент
   // или переданных при создании главной формы  MainUnit
   controlSIMPLEForm.EVOF.Text:=IntToStr(iterSIMPLE.iterVof); // для VOF метода неявная схема.
   controlSIMPLEForm.edtEVxlin.Text:=IntToStr(iterSIMPLE.iterVxLin); // линейная Vx
   controlSIMPLEForm.edtEVylin.Text:=IntToStr(iterSIMPLE.iterVyLin); // линейная Vy
   controlSIMPLEForm.edtEPamendment.Text:=IntToStr(iterSIMPLE.iterPamendment); // поправка давления
   controlSIMPLEForm.edtTemperature.Text:=IntToStr(iterSIMPLE.iterTemperature); // поле температур
   controlSIMPLEForm.edtStreamFunction.Text:=IntToStr(iterSIMPLE.iterStreamFunction); // для функции тока
   // давление в алгоритме SIMPLER 1979
   controlSIMPLEForm.edtPressure.Text:=IntToStr(iterSIMPLE.iterPressure);
   if (bsimpler) then
   begin
      controlSIMPLEForm.grppressure.Visible:=true;
   end
    else
   begin
      controlSIMPLEForm.grppressure.Visible:=false;
   end;
   if (imaxUDS > 0) then
   begin
       controlSIMPLEForm.grpuds.Visible:=True;

       case controlSIMPLEForm.cbbuds.ItemIndex of
         0 : begin
                controlSIMPLEForm.edtuds.Text:=IntToStr(iterSIMPLE.iteruds1);
             end;
         1 : begin
                controlSIMPLEForm.edtuds.Text:=IntToStr(iterSIMPLE.iteruds2);
             end;
         2 : begin
                controlSIMPLEForm.edtuds.Text:=IntToStr(iterSIMPLE.iteruds3);
             end;
         3 : begin
                controlSIMPLEForm.edtuds.Text:=IntToStr(iterSIMPLE.iteruds4);
             end;
       end;
   end
   else
   begin
      controlSIMPLEForm.grpuds.Visible:=False;
   end;
   controlSIMPLEForm.ShowModal; // отображает форму где можно изменить параметры
end;



// норма внутренности универсальной полевой величины U по аналогии с
// пространством C
// возвращает максимальное значение невязки.
// кубическая норма.
function TForm1.mySupNorma(const U : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   k : Integer; // Счётчики цикла for
   r :  Float; // возвращаемое значение
begin
   r:=0.0;
   
   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype <> 0) then
         begin
            r:=max(r,abs(U[i+(j-1)*icolx]));
         end;
      end; // with
   end;

   Result:=r;  // возвращает норму внутренности универсальной величины U
end; // норма внутренности универсальной полевой величины

// евклидова норма внутренности универсальной полевой величины U
// возвращает корень квадратный из суммы квадратов компонентов вектора невязки.
// для внутренней части расчётной области.
// евклидова норма.
function TForm1.myEvklidNorma(const U : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   k : Integer; // Счётчик цикла for
   r, rbuf :  Float; // возвращаемое значение
   dsum : Extended;

begin
   // инициализация
   dsum:=0.0;

   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype = 1) then
         begin
            // внутренний узел
            rbuf:=U[i+(j-1)*icolx]; // помещаем во временное хранилище
            // здесь возможно переполнение
            dsum:= dsum + rbuf*rbuf/imaxnumbernode;
         end;
      end; // with
   end;

   r:=sqrt(dsum);
   Result:=r;  // возвращает норму внутренности универсальной величины U
end; // норма внутренности универсальной полевой величины

// октаэдрическая норма внутренности универсальной полевой величины U
// возвращает сумму модулей компонент вектора невязки.
// октаэдрическая норма.
function TForm1.mySup2Norma(const U : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   k : Integer; // Счётчики цикла for
   r :  Float; // возвращаемое значение
begin
   r:=0.0;
   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype <> 0) then
         begin
            // сумма модулей компонент
            r:= r + abs(U[i+(j-1)*icolx]);
         end;
      end; // with
   end;

   Result:=r;  // возвращает норму внутренности универсальной величины U
end; // норма внутренности универсальной полевой величины

// норма разности внутренностей двух универсальных полевых
// величин U1 и U2 по аналогии с
// пространством C
function TForm1.mySupNorma2(const U1 : array of  Float;const U2 : array of  Float; icolx : Integer; icoly : Integer):  Float;
var
   i, j : Integer; // Счётчики
   r :  Float; // возвращаемое значение
begin
   r:=abs(U1[2+icolx]-U2[2+icolx]);
   for i:=2 to (icolx-1) do
   begin
      for j:=2 to (icoly-1) do
      begin
         r:=max(r,abs(U1[i+(j-1)*icolx]-U2[i+(j-1)*icolx]));
      end; // j
   end; // i

   Result:=r;  // возвращает норму разности внутренностей универсальных величин U1 и U2
end; // норма разности U1 и U2

// функция вычисляет невязку уравнения
function TForm1.myResidual( var U : array of  Float;
                            var myrU : array of  Float; // невязка
                            icolx : Integer;
                            icoly : Integer;
                            var map : TdynArraymyNode; // карта обхода
                            chvariable : Char; // для какой переменной решается
                            var m : array of MatrixCoef;
                            var db : array of  Float) :  Float;

var
    //myrU : array of  Float; // невязка
    //ini, isi, iwi, iei, ipi : Integer; // индексы коэффициентов на пятиточечном шаблоне
    k : Integer; // Счётчики
    r :  Float; // возвращаемый результат
    ilengthmap : Integer;

begin
   // выделение памяти  под невязки
   // НЕНАДО выделять, передаётся массив в котором память уже выделена заранее.
   //SetLength(myrU,icolx*icoly+1);
   // инициализация
   {
   for i1:=1 to icolx do
   begin
      for j1:=1 to icoly do
      begin
         myrU[i1+(j1-1)*icolx]:=0.0;
      end;
   end;
   }

   r:=0.0;

   ilengthmap:=imaxnumbernode; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
          end;
    'C' : begin
             // User-Defined Scalar
             ilengthmap:=imaxnumbernode;
          end;
    end;

   for k:=1 to (ilengthmap) do
   begin
      with map[k] do
      begin
         if (itype = 1) then
         begin
            {
            ini:= i + j*icolx;  // север
            isi:= i + (j-2)*icolx; // юг
            iwi:= (i-1)+(j-1)*icolx; // запад
            iei:= (i+1)+(j-1)*icolx; // восток
            ipi:= i+(j-1)*icolx; // текущая точка
            }

            ipi:=k;
            iei:=k+1;
            iwi:=k-1;
            ini:=k+icolx;
            isi:=k-icolx;
            myrU[ipi]:=m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi];
         end
         else
         begin
            myrU[ipi]:=0.0; // вместо инициализации
         end;
      end;
   end;


   case ibasenorma of
     1 : // евклидова норма
         begin
            r:=myEvklidNorma(myrU,icolx,icoly);
         end;
     2 : // кубическая норма
         begin
            r:=mySupNorma(myrU,icolx,icoly);
         end;
     3 : // октаэдрическая норма
         begin
            r:=mySup2Norma(myrU,icolx,icoly);
         end;
   end;

   // Память освобождать ненадо она освобождается в другом коде при выходе из данной функции.
  // SetLength(myrU,0); // Освобождение памяти.
   Result:=r;

end; // myResidual

// Вычисляет невязку включая граничные узлы :
// Используется в методе Ньютона.
procedure TForm1.myResidual_all(
                         var residual : array of Float; // вектор невязки.
                         var res : Float;  // норма невязки.
                         var U : array of Float; // универсальная искомая величина
                         icolx : Integer; // количество узлов по горизонтали
                         icoly : Integer; // количество узлов по вертикали
                         var map : TdynArraymyNode; // карта обхода
                         chvariable : Char; // для какой переменной решается
                         var m : array of MatrixCoef; // массив с коэффициентами дискретного аналога для U
                         var db : array of Float; // коэффициенты правой части, содержащие источниковый член
                         var QneiC : TQneiC);

// если передавать без var то происходит копирование массива и работа с этой копией.
// если передавать с var то копирования не происходит и работа происходит с оригиналом.

const
      epsilon = 1e-30;
      relaxfactorboncon = 0.01; // параметр релаксации для граничного условия на выходной границе
var
    ini, isi, iwi, iei, ipi : Integer; // индексы узлов на пятиточечном шаблон
    iwwi, ieei, inni, issi : Integer; // для мягких граничных условий
    bnei, bsim, boutflow, bfirstpointmetall : Boolean; // для условия Неймана
    k, k1 : Integer; // Счётчики
    ilengthmap : Integer;
    relaxfac : Float; // параметр релаксации
    ptilda : Float;
    rbuf1 : Float; // временный буфер

{
function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;
}

begin

    ilengthmap:=imaxnumbernode; // инициализация
    relaxfac:=1.0; // инициализация
    case chvariable of
    'T' : begin
             // температура
             ilengthmap:=imaxnumbernode;
             relaxfac:=myrelaxfactors.pSORTempreture;
           end;
    'U' : begin
             // горизонтальная скорость
             ilengthmap:=imaxnumbernodeVx;
             // Обязательно нужна нижняя релаксация.
             relaxfac:=1.0;
             //relaxfac:=myrelaxfactors.Momentum;
          end;
    'V' :  begin
              // вертикальная скорость
              ilengthmap:=imaxnumbernodeVy;
              // Обязательно нужна нижняя релаксация.
              relaxfac:=1.0;
              //relaxfac:=myrelaxfactors.Momentum;
           end;
    'O' :  begin
             // others все другие переменные
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0;
           end;
    'P' : begin
             // давление
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0;//myrelaxfactors.pSORPressure;
          end;
    'S' : begin
             // функция тока
             ilengthmap:=imaxnumbernode;
             relaxfac:=1.0; // нет релаксации
          end;
     'F' : begin
              // функция цвета
              ilengthmap:=imaxnumbernode;
              relaxfac:=1.0; // нет релаксации
           end;
     'C' : begin
              // User-Defined Scalar
              ilengthmap:=imaxnumbernode;
              relaxfac:=1.0; // нет релаксации
           end;
    end;


    for k:=1 to icolx do
    begin
       for k1:=1 to icoly do
       begin
          // обнуление невязки.
          residual[k+(k1-1)*icolx]:=0.0;
       end;
    end;

    //try
    bfirstpointmetall:=True;
   // цикл по всем узлам расчётной области
   for k:=1 to ilengthmap do
   begin
      //with map[k] do
      begin
         if (map[k].itype = 1) then
         begin
            { достаточно медленный код, ниже заменён более быстрым.
            // внутренний узел
            ini:=map[k].i + map[k].j*icolx; // север
            isi:=map[k].i + (map[k].j-2)*icolx; // юг
            iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
            iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
            ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
            if (fabs(m[ipi].dap) < epsilon ) then
            begin
               m[ipi].dap:=1.0;
            end;
            ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
            U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
            }
             // внутренний узел
             // ускоренное вычисление индексов.
            //ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
            ipi:=k;
            //ini:=map[k].i + map[k].j*icolx; // север
            ini:=k+icolx;
            //isi:=map[k].i + (map[k].j-2)*icolx; // юг
            isi:=k-icolx;
            //iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
            iwi:=k-1;
            //iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
            iei:=k+1;

            { // уберём проверку так как она очень медленная и ненужна.
            // её наверно надо выполнять до цикла сразу после сборки матрицы СЛАУ,
            // так сказать проверка на правильность сборки матрицы.
            if (fabs(m[ipi].dap) < epsilon ) then
            begin
               m[ipi].dap:=1.0;
            end;
            }
            residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
         end // внутренняя точка
          else
         begin
            // граничный узел с условием Неймана
            // задан тепловой поток
            if (map[k].itype = 2) then
            begin

               // такая граница найдена
               // и на ней поставлено условие Неймана.

               // на границе поставлено условие Неймана
               if (map[k].iugol=0) then
               begin
                  // граничная точка не является угловой


                  case chvariable of
                   'T' : begin
                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           bnei:= GridGenForm.isneiman(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi] - m[ipi].dap*U[ipi]);
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi] - m[ipi].dap*U[ipi]);
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                              end; // case  нормаль
                           end; // условие Неймана
                           boutflow:= GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                           if (boutflow) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        ini:=map[k].i+map[k].j*icolx; // север
                                        inni:=map[k].i+(map[k].j+1)*icolx; // удвоеннный север
                                        residual[ipi]:=(2*U[ini]-U[inni])-U[ipi];
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                        issi:= map[k].i+(map[k].j-3)*icolx; // удвоенный юг
                                        residual[ipi]:=(2*U[isi]-U[issi])-U[ipi];
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                        iwwi:=(map[k].i-2)+(map[k].j-1)*icolx; // удвоенный запад
                                        residual[ipi]:=(2*U[iwi]-U[iwwi])-U[ipi];
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                        ieei:= (map[k].i+2)+(map[k].j-1)*icolx; // удвоенный восток
                                        residual[ipi]:=(2*U[iei]-U[ieei])-U[ipi];
                                     end;
                              end; // case
                           end;
                           bsim:=GridGenForm.issimm(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bsim) then
                           begin
                              case map[k].chnormal of
                              'N' : // нижняя стенка
                                  // внутренняя нормаль
                                  begin
                                     ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                     ini:=map[k].i+map[k].j*icolx; // север
                                     residual[ipi]:=U[ini]-U[ipi];
                                  end;
                               'S' : // верхняя стенка
                                  // внутренняя нормаль
                                  begin
                                     ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                     isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                     residual[ipi]:=U[isi]-U[ipi];
                                  end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                        iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                        residual[ipi]:=U[iwi]-U[ipi];
                                     end;
                               'E' : // восток (левая стенка)
                                   // внутренняя нормаль
                                   begin
                                      ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                      iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                      residual[ipi]:=U[iei]-U[ipi];
                                   end;
                               end; //case
                           end; // граница симметрии
                  end; // T
                  'C' : begin
                           // User-Defined Scalar

                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           //bnei:= GridGenForm.isneiman(map[k].iboundary,chvariable,map[k].chnormal);
                           // предположительно ускоряющий фрагмент кода
                           // результат вычислений был запомнен!!!
                           bnei:=QneiC[map[k].iboundary][icurentuds];
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;

                                   { // проверка очень сильно замедляет вычисления избавимся от неё.
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                              end; // case  нормаль
                           end; // условие Неймана

                           // полный нормальный ток равен нулю или диффузионная нормальная составляющая тока равна нулю.
                           bnei:= (GridGenForm.isCzerocurent(map[k].iboundary) or (GridGenForm.isCzeroDiff(map[k].iboundary)));
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }

                                   //ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi])/m[ipi].dap;
                                   residual[ipi]:=(m[ipi].dan*U[ini]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }

                                   //ptilda:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   residual[ipi]:=(m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }

                                   //ptilda:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   residual[ipi]:=(m[ipi].daw*U[iwi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   iei:=k+1;
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   //ptilda:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi])/m[ipi].dap;
                                   residual[ipi]:=(m[ipi].dae*U[iei]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                              end; // case  нормаль
                           end; // условие ток равен нулю.

                           // свободный металл.
                           bnei:=GridGenForm.isFreeMetall(map[k].iboundary);
                           //обход против часовой стрелки
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iei:=k+1;
                                      ini:=k+icolx;
                                      //ptilda:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei])/m[ipi].dap;
                                      //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      residual[ipi]:=m[ipi].dan*U[ini]+m[ipi].dae*U[iei]-m[ipi].dap*U[ipi];
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                      //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                      ipi:=k;
                                      //ini:=map[k].i+map[k].j*icolx; // север
                                      //ini:=k+icolx;
                                      //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                      //iwi:=k-1;
                                      //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                      iei:=k+1;

                                      { // проверка очень сильно замедляет вычисления избавимся от неё.
                                      if (fabs(m[ipi].dap) < epsilon ) then
                                      begin
                                         m[ipi].dap:=1.0;
                                      end;
                                      }
                                      //ptilda:=(m[ipi].dae*U[iei])/m[ipi].dap;
                                     // U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      residual[ipi]:=m[ipi].dae*U[iei]-m[ipi].dap*U[ipi];
                                   end;

                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iwi:=k-1;
                                      isi:=k-icolx;
                                      //ptilda:=(m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      residual[ipi]:=m[ipi].das*U[isi]+m[ipi].daw*U[iwi]-m[ipi].dap*U[ipi];
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iwi:=k-1;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   //ptilda:=(m[ipi].daw*U[iwi])/m[ipi].dap;
                                   //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                    residual[ipi]:=m[ipi].daw*U[iwi]-m[ipi].dap*U[ipi];
                                   end;
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iwi:=k-1;
                                      ini:=k+icolx;
                                      //ptilda:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi])/m[ipi].dap;
                                      //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      residual[ipi]:=m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]-m[ipi].dap*U[ipi];
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   //isi:=k-icolx;
                                   //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   //iwi:=k-1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   //ptilda:=(m[ipi].dan*U[ini])/m[ipi].dap;
                                   //U[ipi]:=U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   residual[ipi]:=m[ipi].dan*U[ini]-m[ipi].dap*U[ipi];
                                   end;
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   if (bfirstpointmetall=true) then
                                   begin
                                      ipi:=k;
                                      iei:=k+1;
                                      isi:=k-icolx;
                                      //ptilda:=(m[ipi].das*U[isi]+m[ipi].dae*U[iei])/m[ipi].dap;
                                      //U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                      residual[ipi]:=m[ipi].das*U[isi]+m[ipi].dae*U[iei]-m[ipi].dap*U[ipi];
                                      bfirstpointmetall:=False;
                                   end
                                   else
                                   begin
                                   //ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ipi:=k;
                                   //ini:=map[k].i+map[k].j*icolx; // север
                                   //ini:=k+icolx;
                                   //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   isi:=k-icolx;
                                   //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   //iei:=k+1;

                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   //ptilda:=(m[ipi].das*U[isi])/m[ipi].dap;
                                  // U[ipi]:= U[ipi] + relaxfac*(ptilda-U[ipi]);
                                   residual[ipi]:=m[ipi].das*U[isi]-m[ipi].dap*U[ipi];
                                   end;
                                end;
                              end; // case  нормаль
                           end; // условие металлической пластины с нефиксированным потенциалом.



                        end;
                  'F' : begin       // Функция цвета.
                           // ищем границу по уникальному номеру
                           // на которой поставлено условие Неймана
                           bnei:= GridGenForm.isneimanVof(map[k].iboundary,rbuf1, map[k].chnormal);
                           if (bnei) then
                           begin
                              case map[k].chnormal of
                               'N' : // север (нижняя стенка)
                                begin
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'S' : // юг (верхняя стенка)
                                begin
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                               'W' : // запад (правая стенка)
                                begin
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                                'E' : // восток (левая стенка)
                                begin
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                   iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   {
                                   if (fabs(m[ipi].dap) < epsilon ) then
                                   begin
                                      m[ipi].dap:=1.0;
                                   end;
                                   }
                                   residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                end;
                              end; // case  нормаль
                           end; // условие Неймана
                  end;
                  'U' : begin
                           // горизонтальная скорость.
                           boutflow:= GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                           if (boutflow) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка

                                                 residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi]-m[ipi].dap*U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i+map[k].j*icolx; // север
                                                 inni:=map[k].i+(map[k].j+1)*icolx; // удвоеннный север

                                                 residual[ipi]:=(2*U[ini]-U[inni])-U[ipi];
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 //U[ipi]:=U[ini]; // равенство нормальной производной нулю.

                                                 residual[ipi]:=U[ini]-U[ipi];
                                              end;
                                        end; // case
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка

                                                 residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                                 issi:= map[k].i+(map[k].j-3)*icolx; // удвоенный юг

                                                 residual[ipi]:=(2*U[isi]-U[issi])-U[ipi];
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                  ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                  isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                  //U[ipi]:=U[isi]; // равенство нормальной производной нулю.
                                                  residual[ipi]:=(U[isi]-U[ipi]);
                                              end;
                                          end; // case
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                         case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 residual[ipi]:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]+m[isi].dan*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                                 (*if (j = (iny div 2)) then
                                                 begin
                                                    U[ipi]:=1; // скорости на входе в расчётную область
                                                 end
                                                  else
                                                 begin*)
                                                   // U[ipi]:=U[ipi] + relaxfactorboncon*(ptilda-U[ipi]);
                                                 //end;
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                                 iwwi:=(map[k].i-2)+(map[k].j-1)*icolx; // удвоенный запад
                                                 residual[ipi]:=(2.0*U[iwi]-U[iwwi])-U[ipi];
                                              end;
                                          2 : // из статьи в интернете
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 //U[ipi]:=U[iwi]; // равенство нормальной производной нулю.
                                                 residual[ipi]:=U[iwi]-U[ipi];
                                              end;
                                          end;
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка

                                                 residual[ipi]:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei]+m[isi].dan*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                               end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                                 ieei:= (map[k].i+2)+(map[k].j-1)*icolx; // удвоенный восток

                                                 residual[ipi]:=(2*U[iei]-U[ieei])-U[ipi];
                                              end;
                                           2 : // из статьи в интернете
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // запад
                                                 //U[ipi]:=U[iei]; // равенство нормальной производной нулю.
                                                 residual[ipi]:=U[iei]-U[ipi];
                                              end;
                                          end;
                                     end;
                              end; // case
                           end;
                           bsim:= GridGenForm.issimm(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bsim) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                begin
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   ini:=map[k].i+map[k].j*icolx; // север
                                   //U[ipi]:= U[ini];// + relaxfac*(U[ini]-U[ipi]);
                                   residual[ipi]:=U[ini]-U[ipi];
                                end;
                               'S' : // верхняя стенка
                               begin
                                   ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                   isi:=map[k].i+(map[k].j-2)*icolx; // юг j
                                   //U[ipi]:= U[isi];// + relaxfac*(U[isi]-U[ipi]);
                                   residual[ipi]:=U[isi]-U[ipi];
                                end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    residual[ipi]:=-U[ipi];
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    residual[ipi]:=-U[ipi];
                                 end;
                              end; // case нормаль
                           end;// bsimm
                        end; // U - горизонтальная скорость
                  'V' : // вертикальная скорость
                        begin
                           boutflow:= GridGenForm.isoutflow(map[k].iboundary,chvariable,map[k].chnormal);
                           if (boutflow) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка



                                                 residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].dan*U[ini]+db[ipi]-m[ipi].dap*U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i+map[k].j*icolx; // север
                                                 inni:=map[k].i+(map[k].j+1)*icolx; // удвоеннный север
                                                 residual[ipi]:=(2*U[ini]-U[inni])-U[ipi];
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 ini:=map[k].i + map[k].j*icolx; // север
                                                 //U[ipi]:=U[ini];
                                                 residual[ipi]:=U[ini]-U[ipi];
                                              end;
                                          end; // case
                                     end;
                               'S' : // верхняя стенка
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка

                                                 residual[ipi]:=(m[ipi].dae*U[iei]+m[ipi].daw*U[iwi]+m[ipi].das*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                                 issi:= map[k].i+(map[k].j-3)*icolx; // удвоенный юг

                                                 residual[ipi]:=(2*U[isi]-U[issi])-U[ipi];
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 isi:=map[k].i+(map[k].j-2)*icolx; // юг
                                                 //U[ipi]:=U[isi];

                                                 residual[ipi]:=U[isi]-U[ipi];
                                              end;
                                        end; // case
                                     end;
                               'W' : // запад (правая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iwi:=(map[k].i-1) + (map[k].j-1)*icolx; // запад
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка


                                                 residual[ipi]:=(m[ipi].dan*U[ini]+m[ipi].daw*U[iwi]+m[isi].dan*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                                 iwwi:=(map[k].i-2)+(map[k].j-1)*icolx; // удвоенный запад

                                                 residual[ipi]:=(2*U[iwi]-U[iwwi])-U[ipi];
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                                 //U[ipi]:=U[iwi];

                                                 residual[ipi]:=U[iwi]-U[ipi];
                                              end;
                                        end; // case
                                     end;
                               'E' : // восток (левая стенка)
                                     // внутренняя нормаль
                                     begin
                                        case ioutflow of
                                          0 : // условия Патанкара
                                              begin
                                                 isi:=map[k].i + (map[k].j-2)*icolx; // юг
                                                 iei:=(map[k].i+1) + (map[k].j-1)*icolx; // восток
                                                 ini:=(map[k].i) + (map[k].j)*icolx; // север
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка

                                                 residual[ipi]:=(m[ipi].dan*U[ini]+m[ipi].dae*U[iei]+m[isi].dan*U[isi]+db[ipi]-m[ipi].dap*U[ipi]);
                                              end;
                                          1 : // F[i]=2*F[i-1]-F[i-2]
                                              begin
                                                 ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                                 ieei:= (map[k].i+2)+(map[k].j-1)*icolx; // удвоенный восток

                                                 residual[ipi]:=(2*U[iei]-U[ieei])-U[ipi];
                                              end;
                                          2 : // на основе статьи из интернета
                                              begin
                                                 ipi:=map[k].i + (map[k].j-1)*icolx; // текущая точка
                                                 iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                                 //U[ipi]:=U[iei];

                                                 residual[ipi]:=U[iei]-U[ipi];
                                              end;
                                        end; // case
                                     end;
                              end; // case
                           end; // outflow
                           bsim:= GridGenForm.issimm(map[k].iboundary,chvariable,map[k].chnormal);
                           if (bsim) then
                           begin
                              case map[k].chnormal of
                               'N' : // нижняя стенка
                                   begin
                                      ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                      residual[ipi]:=-U[ipi]; // нет протекания через границу симметрии
                                   end;
                                'S' : // верхняя стенка
                                    begin
                                       ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                       residual[ipi]:=-U[ipi]; // нет протекания через границу симметрии
                                    end;
                               'W' : // правая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                                    //U[ipi]:= U[iwi];// + relaxfac*(U[iwi]-U[ipi]);
                                    residual[ipi]:=U[iwi]-U[ipi];
                                 end;
                               'E' : // левая стенка
                                 begin
                                    ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                                    iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                                    //U[ipi]:= U[iei];// + relaxfac*(U[iei]-U[ipi]);
                                    residual[ipi]:=U[iei]-U[ipi];
                                 end;
                              end; // case нормаль
                           end;// bsimm
                        end;
                        // Давления здесь нет, т.к. для него краевые точки не играют роли
                        // (не учитываются при расчёте).
                  end; // case chvariable
               end // граничная точка
                else
               begin  // угловая точка
                  ipi:=map[k].i+(map[k].j-1)*icolx; // текущая точка
                  // среднее арефметическое на значащих узлах
                  case map[k].iugol of
                     1 :  // левый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;

                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini])/m[ipi].dap;
                           residual[ipi]:=0.5*(U[iei]+U[ini])-U[ipi];
                        end;
                     2 : // правый нижний угол
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;
                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].dan*U[ini])/m[ipi].dap;
                           residual[ipi]:=0.5*(U[iwi]+U[ini])-U[ipi];
                        end;
                     3 : // верхний левый угол
                        begin
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].das*U[isi])/m[ipi].dap;
                           residual[ipi]:=0.5*(U[iei]+U[isi])-U[ipi];
                        end;
                     4 : // верхний правый угол
                        begin
                            //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                            isi:=k-icolx;
                            //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                            iwi:=k-1;
                            {
                            if (fabs(m[ipi].dap) < epsilon ) then
                            begin
                                m[ipi].dap:=1.0;
                            end;
                            }
                             //U[ipi]:=(m[ipi].daw*U[iwi]+m[ipi].das*U[isi])/m[ipi].dap;
                             residual[ipi]:=0.5*(U[iwi]+U[isi])-U[ipi];
                        end;
                     5 : // пятиточечная звезда
                        begin
                           //ini:=map[k].i+map[k].j*icolx; // север
                           ini:=k+icolx;
                           //isi:=map[k].i+(map[k].j-2)*icolx; // юг
                           isi:=k-icolx;
                           //iei:=(map[k].i+1)+(map[k].j-1)*icolx; // восток
                           iei:=k+1;
                           //iwi:=(map[k].i-1)+(map[k].j-1)*icolx; // запад
                           iwi:=k-1;
                           {
                           if (fabs(m[ipi].dap) < epsilon ) then
                           begin
                              m[ipi].dap:=1.0;
                           end;
                           }
                           //U[ipi]:=(m[ipi].dae*U[iei]+m[ipi].dan*U[ini]+m[ipi].das*U[isi]+m[ipi].daw*U[iwi])/m[ipi].dap;
                           residual[ipi]:=0.25*(U[iei]+U[ini]+U[isi]+U[iwi])-U[ipi];
                        end;
                  end; // case
               end; // угловая точка

            end;
         end;
      end;
   end;

   //except
     // MainMemo.Lines.Add('exception GZ : division by zero');
   //end;

   case ibasenorma of
     1 : // евклидова норма
         begin
            res:=myEvklidNorma(residual,icolx,icoly);
         end;
     2 : // кубическая норма
         begin
            res:=mySupNorma(residual,icolx,icoly);
         end;
     3 : // октаэдрическая норма
         begin
            res:=mySup2Norma(residual,icolx,icoly);
         end;
   end;

end; // myResidual_all

// вызывает форму где можно задать параметры релаксации
procedure TForm1.RelaxationFactorstune;
begin
    // передача в форму текущих параметров релаксации
    // для алгоритма SIMPLE
    RelaxFactorsForm.edtEMomentum.Text:=FloatToStr(myrelaxfactors.Momentum); // Momentum

    if (bsimplec) then
    begin
       RelaxFactorsForm.GroupBoxPressure.Visible:=false;
    end
     else
    begin
       RelaxFactorsForm.GroupBoxPressure.Visible:=true;
       RelaxFactorsForm.EPressure.Text:=FloatToStr(myrelaxfactors.PressureRelax); // Pressure
    end;
    // SOR для уравнения поправки давления.
    RelaxFactorsForm.ESORPamendment.Text:=FloatToStr(myrelaxfactors.pSORPressure); // SOR для поправки давления
    RelaxFactorsForm.ESORTempretrure.Text:=FloatToStr(myrelaxfactors.pSORTempreture); // температура
    if (bBussinesk) then
    begin
       RelaxFactorsForm.GroupBoxBussinesk.Visible:=true;
       // При моделировании естественной конвекции при больших
       // числах Релея желательно замедлить измение источникового члена от итерации к итерации.
       RelaxFactorsForm.EBodyForce.Text:=FloatToStr(myrelaxfactors.prelaxBodyForce); // нижняя релаксация
    end
     else
    begin
       RelaxFactorsForm.GroupBoxBussinesk.Visible:=false;
    end;
    case RelaxFactorsForm.CBUDS.ItemIndex of
      0 : begin
             RelaxFactorsForm.EditUDS.Text:=FloatToStr(myrelaxfactors.uds1);
          end;
      1 : begin
             RelaxFactorsForm.EditUDS.Text:=FloatToStr(myrelaxfactors.uds2);
          end;
      2 : begin
             RelaxFactorsForm.EditUDS.Text:=FloatToStr(myrelaxfactors.uds3);
          end;
      3 : begin
             RelaxFactorsForm.EditUDS.Text:=FloatToStr(myrelaxfactors.uds4);
          end;
    end;
    // вызывает меню, где можно задать параметры релаксации
    RelaxFactorsForm.ShowModal;
end;

// вызывает форму где можно задать параметры релаксации
procedure TForm1.RelaxationFactors1Click(Sender: TObject);
begin
   RelaxationFactorstune;
end;

// аппроксимация конвективного члена и алгоритм решения
procedure TForm1.Methodstune;
begin
   case ApproxConvectionForm.ComboBoxudsindex.ItemIndex of
     0 : begin
            if ((ishconv1>=1) and (ishconv1<=7)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv1-1;
            end
            else  if ((ishconv1>=1000) and (ishconv1<=1015)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv1-1000+7;
            end;
         end;
     1 : begin
             if ((ishconv2>=1) and (ishconv2<=7)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv2-1;
            end
             else  if ((ishconv2>=1000) and (ishconv2<=1015)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv2-1000+7;
            end;
         end;
     2 : begin
             if ((ishconv3>=1) and (ishconv3<=7)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv3-1;
            end
             else  if ((ishconv3>=1000) and (ishconv3<=1015)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv3-1000+7;
            end;
         end;
     3 : begin
             if ((ishconv4>=1) and (ishconv4<=7)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv4-1;
            end
             else  if ((ishconv4>=1000) and (ishconv4<=1015)) then
            begin
               ApproxConvectionForm.ComboBoxSchemeuds.ItemIndex:=ishconv4-1000+7;
            end;
         end;
   end;
   if (btimedepend and (bVOFExplicit=False)) then
   begin
       ApproxConvectionForm.GBVOFtransientformulation.Visible:=true;
       if (bVOFsecondorder) then
       begin
          // Пейре.
          ApproxConvectionForm.CBVOFtransientFormulation.ItemIndex:=1;
       end
        else
       begin
          // Эйлер.
          ApproxConvectionForm.CBVOFtransientFormulation.ItemIndex:=0;
       end;
   end
    else
   begin
      ApproxConvectionForm.GBVOFtransientformulation.Visible:=false;
   end;
   if (btimedepend) then
   begin
      ApproxConvectionForm.GBFlowTransForm.Visible:=true;
      if (bsecondorderflow) then
      begin
         ApproxConvectionForm.CBFlowTransientFormulation.ItemIndex:=1;
      end
      else
      begin
         ApproxConvectionForm.CBFlowTransientFormulation.ItemIndex:=0;
      end;
   end
   else
   begin
      ApproxConvectionForm.GBFlowTransForm.Visible:=false;
   end;

   if (btimedepend) then
   begin
      ApproxConvectionForm.GBTemperatureTransientFormulation.Visible:=true;
      if (bsecondordertemp) then
      begin
         // Схема Пейре.
         ApproxConvectionForm.CBTemperatureunsteadyformulation.ItemIndex:=1;
      end
      else
      begin
         // Схема Эйлера.
         ApproxConvectionForm.CBTemperatureunsteadyformulation.ItemIndex:=0;
      end;
   end
   else
   begin
      ApproxConvectionForm.GBTemperatureTransientFormulation.Visible:=false;
   end;

   // усиление диагонального преобладания см. I.Sezai and
   // Гаврилов Андрей.
   ApproxConvectionForm.CBISezai.Checked:=bISezai;
   // устанавливет текущую выбранную
   // схему аппроксимации конвективного члена
   if ((ishconv>=1)and(ishconv<=7)) then
   begin
      if (brealisticflow) then
      begin
         ApproxConvectionForm.CBFlow.ItemIndex:=6+ishconv;
      end
       else
      begin
         ApproxConvectionForm.CBFlow.ItemIndex:=ishconv-1;
      end;
   end
    else
   begin
      if (ishconv>=1000) then
      begin
         // High Resolution Scheme.
         ApproxConvectionForm.CBFlow.ItemIndex:=ishconv-1000+8;
      end;
   end;
   if ((ishconvtemp>=1)and(ishconvtemp<=7)) then
   begin
      if (brealistictemperature) then
      begin
         ApproxConvectionForm.CBTemperature.ItemIndex:=6+ishconvtemp;
      end
       else
      begin
         ApproxConvectionForm.CBTemperature.ItemIndex:=ishconvtemp-1;
      end;
   end
    else
   begin
      if (ishconvtemp>=1000) then
      begin
         // High Resolution Scheme.
         ApproxConvectionForm.CBTemperature.ItemIndex:=ishconvtemp-1000+8;
      end;
   end;
   ApproxConvectionForm.chkonGarber.Checked:=bGarberArtDiffusion;
   // Устанавливает выбранный алгоритм решения:
   // Pressure-Velocity Coupling
   if (not bsimplec) then
   begin
      if (bsimpler) then
      begin
         // Алгоритм SimpleR
         ApproxConvectionForm.RadioGroup2.ItemIndex:=2;
      end
       else
      begin
         // Алгоритм SIMPLE
         ApproxConvectionForm.RadioGroup2.ItemIndex:=0;
      end;
   end
   else
   begin
      // Алгоритм SIMPLEC
      ApproxConvectionForm.RadioGroup2.ItemIndex:=1;
   end;
   // вызывает меню где можно выбрать аппроксимацию
   // конвективного члена
   ApproxConvectionForm.ShowModal;
end;

// выбор схемы аппроксимации конвективного члена
procedure TForm1.ApproxConvection1Click(Sender: TObject);
begin
   Methodstune;
end;

// решает стационарную задачу чистой теплопроводности
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций !
procedure TForm1.RunCleanThermalConductionSteady;
begin

   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // универсальная процедура решения,
      // содержащая вычисление коэффициентов дискретного аналога
      // а также два решателя: ГЗ и гибрид: ГЗ-Томас - метод продольно поперечной прогонки
      // Третий параметр false означает что конвективный член не учитывается.
      SolveTempSteady(true, itercount, false);

      // сообщает о том что решение получено в функции RunTune.
   end;
end; // RunCleanThermalConductionSteady

// решает стационарную задачу теплопроводности с учётом конвекции
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций !
procedure TForm1.RunConvectiveThermalConductionSteady;
begin
   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // универсальный решатель,
      // включающий в себя процедуру
      // нахождкения коэффициентов дискретного аналога,
      // а также содержащий два решателя:
      // 1 - ГЗ и 2 - гибридный ГЗ-Томас.
      // 3 - прямой метод Гаусса,
      // 4 - метод сопряжённых градиентов Хестенса и Штифеля
      SolveTempSteady(true, itercount, true);  // решает

      // сообщает о том что решение получено в функции RunTune.

   end;
end; // RunConvectiveThermalConductionSteady

// вызывает меню, где можно выбрать
// уравнения подлежащие решению
procedure TForm1.EquationTune(Sender: TObject);
begin
   // инициализирует форму выбора
    ModelEquationForm.RadioGroup1.ItemIndex:=imodelEquation - 1;
    ModelEquationForm.oldeq:=imodelEquation-1;
    // показывает форму выбора
    ModelEquationForm.ShowModal; // вызывает форму выбора
    myInitializationRestart; // всё придётся инициализировать заново: выделение памяти и присвоение значений.
    FormPaint(Sender);
end;

// вызывает меню, где можно выбрать
// уравнения подлежащие решению
procedure TForm1.Equation1Click(Sender: TObject);
begin
   EquationTune(Sender);
end; // Equation1Click

// решает нестационарную задачу чистой теплопроводности
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций,
// шаг по времени, количество шагов по времени, начальное время.
procedure TForm1.RunCleanThermalConductionUnsteady;
begin
   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // универсальная процедура,
      // включающая в себя нахождение коэффициентов
      // дискретного аналога и четыре солвера
      // 1 - Гаусс-Зейдель и 2 - метод переменных направлений.
      // 3 - прямой метод Гаусса, 4 - метод сопряжённых градиентов.
      // параметр false - означает что решается чистая теплопроводность.
      SolveTempUnsteady(false); // решает

      // сообщает о том что решение получено в функции RunTune.
   end;
end; // RunCleanThermalConductionUnsteady

// решает нестационарную задачу теплопроводности с учётом конвекции
// Здесь прописан сценарий решения, включающий
// инициализации (полевых величин и параметров материалов),
// задание граничных условий и запуск процедуры решения.
// Перед вызовом данного сценария, в модуле myRunModule
// обязательно должно быть задано количество итераций на временном слое
// начальное время, шаг по времени и количество шагов по времени.
procedure TForm1.RunConvectiveThermalConductionUnsteady;
begin
   if (bweShouldInitialize[imodelEquation]) then
   begin
      TerminateProcessForm.Close; // закрывает окно терминальной формы.
      // Показать предупреждение:
      // Вы должны инициализировать переменные, задать начальное приближение
      // и выделить оперативную память.
      MainMemo.Lines.Add('you must be Initialize the solution variables...');
      Application.MessageBox('you must be Initialize the solution variables...','',MB_OK);
   end
    else
   begin
      // улучшенный универсальный солвер:
      // содержит код вычисляющий коэффициенты плюс
      // два солвера:
      // 1 - на основе Гаусса-Зейделя, а также
      // 2 - на основе алгоритма трёхдиагональной матрицы
      // 3 - прямой метод Гаусса, 4 - метод сопряжённых градиентов.
      // Параметр true - означает, что решается теплопроводность
      // с учётом конвективного члена
      SolveTempUnsteady(true);

      // сообщает о том что решение получено в функции RunTune.
   end;
end; // RunConvectiveThermalConductionUnsteady

// Реализация прямого метода исключения Гаусса.
// задача решить СЛАУ Ax = b
// Дано A и b. Найти x.
// Критика:
// 1. Данная реализация прямого метода исключения Гаусса
// не делает выбор главного разршающего элемента (это никчему т.к.
// консервативный метод дискретизации С. Патанкара МКО обеспечивает диагональное
// преобладание матрицы СЛАУ).
// 2.  Главный недостаток данной реализации использование огромного
// количества оперативной памяти для хранения нулевых элементов матрицы.
// Т.е. данный алгоритм никаким образом не использует 5-диагональную структуру матрицы СЛАУ.
// В этом плане реализация поточечного последовательного метода Гаусса-Зейделя гораздо более
// экономична по памяти. Более того учёт разреженности матрицы в алгоритме Гаусса чрезвычайно затруднителен
// и не имеет эффективного решения. См. Тьюарсон.
// Тем не менее сейчас хранится только лента для ленточной матрицы А размером
// 2*icolx+1 на isize. Это существенно ускоряет метод Гаусса и сокращает расходы по памяти.
// 3. Характер данного метода не уточняющий. Уточняющий метод берёт начальное приближение
// и в результате своей работы улучшает это начальное приближение до заданного значения невязки.
// Методу Гаусса неважно скакого начального приближения он стартует. Более того после окончания его работы
// мы имеем полностью сошедшееся решение (т.е. абсолютно точное в идеале, что не всегда нужно.)
// Достоинства.
// Если добавить в алгоритм выбор главного элемента, то получится
// робастый алгоритм работающий даже с очень плохими матрицами
// (под тем что матрица плоха понимается её плохая обусловленность.)
// Данный алгоритм запрограммирован при помощи книжки У.Г.Пирумова.
// Замечание: обрабатываемые матрицы достаточно велики, и передаются по ссылке,
// чтобы избежать потерь времени на выделение памяти. Данный алгоритм портит матрицу
// изменяя её элементы.
// Теперь в реализации данного метода учтено что ненулевые элементы
// матрицы содержатся только внутри ленты ширины 2*icolx+1. это учитывается
// и влияет на скорость работы алгоритма - теперь алгоритм действительно быстр
// и относительно немного времени уходит только на выделение оперативной памяти для хранения ленты.
// Гаусс Карл Фридрих 1777-1855.
procedure TForm1.GaussAlgorithm(isize : Integer; // размер квадратной матрицы
                                var dA : array of TmyDynArray; // матрица СЛАУ
                                icolx : Integer; // количество узлов по горизонтали
                                icoly : Integer; // количество узлов по вертикали
                                const move : array of Integer; // для ленточной матрицы
                                var dV : array of  Float; // вектор правой части
                                var dx : array of  Float; // результат вычисления
                                bmessage : Boolean);
const
    epsilon = 1e-30;

var
   i,j,k : Integer; // Счётчики циклов
   dCik, dSum :  Float;
   //str : string; // для распечатки матрицы

begin
   // ненулевые элменты матрицы содержатся только внутри полосы
   // шириной 2*icolx+1. В алгоритме это учитывается.
   // Есть задачи для которых inx мало для них ширина полосы мала
   // и эффективность алгоритма на таких задачах особенно высока


   (*
   // распечатка матрицы СЛАУ для анализа
   for i:=0 to (2*icolx) do
   begin
      for j:=0 to (isize-1) do
      begin
         str:=str+FloatToStr(dA[i][j]) + ' ';
      end;
      freport.Add(str);
      str:='';
   end;
   freport.SaveToFile('Gauss matrix.txt');
   freport.Clear; // очистка содержимого
   *)


   // массивы dA и dV передаются в данную
   // процедуру по ссылке, это означает что
   // на время работы данной процедуры
   // все операции производятся над самими данными
   // и массивы портятся.

   try

   for i:=0 to (isize-1) do dx[i]:=0.0; // инициализация вектора dx

   // прямой ход метода Гаусса
   // приведение к верхнетреуголному виду

   // по всем столбцам слева направо, т.е.
   // для k:= 0.. (isize-1)
   for k:=0 to (isize-1) do
   begin
      // цикл по всем строкам ниже строки с номером k
      for i:=k+1 to min((k+icolx),(isize-1)) do
      begin
         // применяется только в случае
         // если элемент ненулевой
         // это должно несколько ускорить счёт.
         if (abs(dA[i][k+move[i]])>1e-30) then
         begin
            if (dA[k][k+move[k]] < epsilon) then dA[k][k+move[k]]:=1.0;
            // обработка фиксированной строки с номером i
            dCik := (dA[i][k+move[i]]/dA[k][k+move[k]]);
            // здесь предполагается
            // что двумерные массивы
            // отображаются на одномерные
            // с учётом отображения i+(j-1)*inx.
            for j:=k to min((k+icolx),(isize-1)) do
            begin
               // преобразование матрицы к верхнетреугольному виду
               dA[i][j+move[i]] := dA[i][j+move[i]] - dCik*dA[k][j+move[k]];
            end;
            // преобразование правой части
            dV[i] := dV[i] - dCik*dV[k];
         end;
      end;
   end;

   // печать диагностического сообщения
   if (bmessage) then
   begin
      MainMemo.Lines.Add('матрица СЛАУ приведена к верхнетреугольному виду ');
   end;

   // Теперь, когда матрица СЛАУ приведена к верхнетреугольному виду
   // можно совершить обратный ход метода Гаусса.
   for k:=(isize-1) downto 0 do
   begin
      dSum:=0.0; // обнуление сумматора
      for i:= k+1 to min((k+icolx),(isize-1)) do
      begin
         dSum := dSum + dA[k][i+move[k]]*dx[i];
      end;
      if (dA[k][k+move[k]] < epsilon) then dA[k][k+move[k]]:=1.0;
      dx[k] := (dV[k] - dSum)/dA[k][k+move[k]];
   end;

   except
      MainMemo.Lines.Add('exception Gauss: division by zero');
   end;

end; // GaussAlgorithm()

// LU разложение
procedure TForm1.LUdecomposition(isize : Integer; // размер квадратной матрицы
                                var dA : array of TmyDynArray; // матрица СЛАУ
                                icolx : Integer; // количество узлов по горизонтали
                                icoly : Integer; // количество узлов по вертикали
                                const move : array of Integer; // для ленточной матрицы
                                var dV : array of  Float; // вектор правой части
                                var dx : array of  Float; // результат вычисления
                                bmessage : Boolean);
var
     i,j,k : Integer; // Счётчики циклов
     dy : array of Float;
     dsum : Float;
begin
    (*  сначала запишем алгоритм для полностью заполненой матрицы
     *  for k:=0 to isize-2 do
     *  begin
     *     for j:=k+1 to isize-1 do
     *     begin
     *        dA[k][j]:=dA[k][j]/dA[k][k];
     *        for i:=k+1 to isize-1 do
     *        begin
     *            dA[i][j]:=dA[i][j]-dA[i][k]*dA[k][j];
     *        end;
     *     end;
     *  end;
     *  Теперь для ленточной матрицы:
    *)
       // LU разложение:
       for k:=0 to (isize-2) do
       begin
          for j:=k+1 to min((k+icolx),(isize-1)) do
          begin
             dA[k][j+move[k]]:=dA[k][j+move[k]]/dA[k][k+move[k]];
             dV[k]:=dV[k]/dA[k][k+move[k]]; // преобразование правой части
             for i:=k+1 to min((k+icolx),(isize-1)) do
             begin
                 dA[i][j+move[i]]:=dA[i][j+move[i]]-dA[i][k+move[i]]*dA[k][j+move[k]];
             end;
          end;
       end;

       SetLength(dy,isize);
       for i:=0 to isize-1 do dy[i]:=0.0;
       // замена вперёд.
       (*  dy[0]:=dV[0]/L[1][1];
        *  dy[i]:=(1/L[i][i])*(dV[i]-Sum(j,i-1,L[i][j]*dy[j]));
        *  в матрице L на главной диагонали стоят единицы.
       *)
       dy[0]:=dV[0];
       for i:=1 to isize-1 do
       begin
          dsum:=0.0;
          for j:=max(0,i-icolx) to (i-1) do dsum:=dsum+dA[i][j+move[i]]*dy[j];
          dy[i]:=1.0*(dV[i]-dsum);
       end;

       for i:=0 to (isize-1) do dx[i]:=0.0;
       // обратная замена
       (*  dx[isize-1]:=dy[isize-1]/U[isize-1][isize-1];
        *  dx[i]:=(1/U[i][i])*(dy[i]-Sum(i+1,isize-1,U[i][j]*dx[j]));
        *                            j
        *)
        dx[isize-1]:=dy[isize-1]/dA[isize-1][isize-1+move[isize-1]];
        for i:=(isize-2) downto 0 do
        begin
           dsum:=0.0;
           for j:=(i+1) to min((i+icolx),(isize-1)) do dsum:=dsum + dA[i][j+move[i]]*dx[j];
           dx[i]:=(1/dA[i][i+move[i]])*(dy[i]-dsum);
        end;

end; // LUdecomposition

// Метод Сопряжённых Градиентов и всё что с ним связано

// скалярное произведение двух векторов
function TForm1.Scal(isize : Integer;
                     const dV1 : array of  Float;
                     const dV2 : array of  Float) :  Float;
var
    ds :  Float;
    i : Integer;
begin
   ds:=0.0; // инициализация
   for i:=0 to (isize-1) do
   begin
      ds:= ds + dV1[i]*dV2[i];
   end;
   Result:=ds;
end; // Scal

// умножение матрицы на вектор
procedure TForm1.MatrixByVector(isize : Integer;
                                const dH : array of TmyDynArray;
                                const dV : array of  Float;
                                var dx : array of  Float);
var i,j : Integer;
    dsum :  Float;
begin
   dsum:=0.0; // инициализация
   for i:=0 to (isize-1) do dx[i]:=0.0; // обнуление
   for i:=0 to (isize-1) do
   begin
      for j:=0 to (isize-1) do
      begin
         dsum:= dsum + dV[j]*dH[i][j];
      end;
      dx[i]:=dsum;
      dsum:=0.0; // обнуление сумматора
   end;
end;  // MatrixByVector

// норма вектора
// как корень квадратный из суммы квадратов
function TForm1.NormaV(isize : Integer;
                       const dV : array of  Float) :  Float;
var
    i : Integer; // счётчик цикла
    dnorma, dsum :  Float;
begin
   // инициализация переменных
   dsum:=0.0;
   for i:=0 to (isize-1) do
   begin
      dsum:= dsum + dV[i]*dV[i];
   end;
   dnorma:=sqrt(dsum); // норма вектора
   Result:=dnorma;
end; // NormaV

// норма вектора
// как максимальное значение среди модулей компонент вектора
// кубическая норма.
function TForm1.NormaSupV(isize : Integer;
                       const dV : array of  Float) :  Float;
var
    i : Integer; // счётчик цикла
    dmax :  Float; // будущее значение нормы вектора
begin
   // инициализация переменных
   dmax:=-1.0; // отрицательное число
   for i:=0 to (isize-1) do
   begin
      dmax:= max(dmax, abs(dV[i]));
   end;
    // норма вектора
   Result:=dmax;
end; // NormaSupV

// норма вектора
// сумма модулей компонент вектора
// октаэдрическая норма.
function TForm1.NormaSup2V(isize : Integer;
                       const dV : array of  Float) :  Float;
var
    i : Integer; // счётчик цикла
    dsum :  Float; // будущее значение нормы вектора
begin
   // инициализация переменных
   dsum:=0.0; // обнуление сумматора
   for i:=0 to (isize-1) do
   begin
      dsum:= dsum + abs(dV[i]);
   end;
    // норма вектора
   Result:=dsum;
end; // NormaSup2V

// Для применения метода сопряжённых градиентов
// с использованием технологии
// хранения разреженной матрицы CRS
// потребуется реализация алгоритма быстрой сортировки

// Запрограммировано с использованием
// Брайан Керниган и Дени Ритчи "The C Programming Language".
// Swap : Обмен местами list[i] и list[j]
procedure TForm1.Swap(var list : array of TmyNonZeroElemMatrix;
                          i : Integer;
                          j : Integer);
var
    temp :  TmyNonZeroElemMatrix;

begin
   // Если стек переполнен и отладчик остановился здесь на
   // строке begin, значит скрее всего быстрая сортировка Хоара
   // вызвала переполнение стека вложеннных вызовов.
   // Выход заменить её пирамидальной сортировкой.

   // cgange list[i] <-> list [j]

   // temp = list[i];
   temp.i:=list[i].i;
   temp.j:=list[i].j;
   temp.aij:=list[i].aij;
   temp.key:=list[i].key;
   // list[i] = list[j];
   list[i].i:=list[j].i;
   list[i].j:=list[j].j;
   list[i].aij:=list[j].aij;
   list[i].key:=list[j].key;
   // list[j] = temp;
   list[j].i:=temp.i;
   list[j].j:=temp.j;
   list[j].aij:=temp.aij;
   list[j].key:=temp.key;

end; // Swap

// Вот алгоритм PivotList
// он возвращает точку деления элементов массива на две части.
// Запрограммировано с использованием книжки ДЖ. Макконел
// Анализ алгоритмов стр. 106.
function TForm1.PivotList(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer) : Integer;
var
   PivotValue : Integer;
   PivotPoint : Integer; // возвращаемая позиция точки разделения
   index : Integer; // счётчик цикла for

begin
   // list обрабатываемый список
   // first номер первого элемента
   // last номер последнего элемента

   PivotValue := list[first].key;
   PivotPoint := first;

   for index:=(first+1) to last do
   begin
      if (list[index].key < PivotValue) then
      begin
         PivotPoint := PivotPoint + 1;
         Swap(list, PivotPoint, index);
      end;
   end;

   Swap(list, first, PivotPoint);

   Result := PivotPoint;

end; // PivotList

// Быстрая сортировка Хоара.
// Это рекурсивный алгоритм который эффективен по быстродействию
// но возможно не эффективен по памяти.
// Быстрая сортировка применяется здесь для упорядочивания достаточно больших
// массивов данных.
// Запрограммировано с использованием Дж. Макконел Анализ алгоритмов стр. 106.
procedure TForm1.QuickSort(var list : array of TmyNonZeroElemMatrix;
                              first : Integer;
                              last : Integer);
var
    Pivot : Integer;

begin
   // list упорядочиваемый список элементов
   // first номер первого элемента в сортируемой части списка
   // last номер последнего элемента в сортируемой части списка

   if (first < last) then
   begin
      Pivot := PivotList(list, first, last);
      QuickSort(list, first, Pivot-1);
      QuickSort(list, Pivot+1, last);
   end;

end; // QuickSort

// Пирамидальная сортировка

// Переформировать пирамиду
procedure TForm1.FixHeap(var list : array of TmyNonZeroElemMatrix;
                          root : Integer;
                          m : TmyNonZeroElemMatrix;
                          bound : Integer);
var
    vacant : Integer;
    largerChild : Integer;

begin
   // list сортируемый список пирамида
   // root номер корня пирамиды
   // m ключевое значение вставляемое в пирамиду
   // bound правая граница (номер) в пирамиде
   vacant:=root;
   while (2*vacant <= bound) do
   begin
      largerChild:=2*vacant;

      // поиск наибольшего из двух непосредственных потомков
      if ((largerChild<bound) and (list[largerChild+1].key>list[largerChild].key)) then
      begin
         largerChild:=largerChild + 1;
      end;

      // находится ли ключ выше текущего потомка ?
      if (m.key > list[largerChild].key) then
      begin
         // да, цикл завершается
         break;
      end
      else
      begin
         // нет, большего непосредственного потомка
         // следует поднять
         list[vacant].i:=list[largerChild].i;
         list[vacant].j:=list[largerChild].j;
         list[vacant].aij:=list[largerChild].aij;
         list[vacant].key:=list[largerChild].key;
         vacant:=largerChild;
      end;
   end;
   list[vacant].i:=m.i;
   list[vacant].j:=m.j;
   list[vacant].aij:=m.aij;
   list[vacant].key:=m.key;
end; // FixHeap

// Пирамидальная сортировка оптимальна как
// по памяти, так и по быстродействию, к тому же её алгоритм
// очень интересен.
// Ограничение состоит в том, что нумерация массива должна начинаться с 1.
procedure TForm1.HeapSort(var list : array of TmyNonZeroElemMatrix;
                              n : Integer);
var
   i : Integer; // счётчик
   max : TmyNonZeroElemMatrix; // элемент с наибольшим значением ключа

begin
    // конструирование пирамиды
    for i:=(n div 2) downto 1 do
    begin
       FixHeap(list, i, list[i], n);
    end;
    for i:=n downto 2 do
    begin
       // скопировать корень пирамиды в список
       // переформировать пирамиду
       max.i:=list[1].i;
       max.j:=list[1].j;
       max.aij:=list[1].aij;
       max.key:=list[1].key;
       FixHeap(list, 1, list[i], i-1);
       list[i].i:=max.i;
       list[i].j:=max.j;
       list[i].aij:=max.aij;
       list[i].key:=max.key;
    end;
end; // HeapSort

// умножение матрицы на вектор
// используя формат хранения CRS
// Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
// Запрограммировано с использованием
// 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
// 2. Р. Тьюарсон "Разреженные матрицы".
// Массивы передаются по ссылке дабы избежать переполнения стека.
procedure TForm1.MatrixCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of  Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of  Float; // заданный вектор на который производится умножение
                                var dx : array of  Float);  // результат умножения заносится в dx.
var
     i,j : Integer; // счётчики цикла for
begin

   for i:=0 to (isize-1) do
   begin
      dx[i]:=0.0;

      for j:=row_ptr[i] to (row_ptr[i+1]-1) do
      begin
         dx[i] := dx[i] + val[j]*dV[col_ind[j]];
      end;

   end;

end;  // MatrixCRSByVector

// умножение транспонированной матрицы на вектор
// используя формат хранения CRS
// Это эффективная процедура учитывающая разреженность матрицы СЛАУ.
// Запрограммировано с использованием
// 1. http://www.netlib.org/linalg/html_templates  "Survey of Sparse Matrix Storage Formats"
// 2. Р. Тьюарсон "Разреженные матрицы".
procedure TForm1.MatrixTransposeCRSByVector(isize : Integer; // размерность вектора или квадратной матрицы
                                const val : array of  Float;  // ненулевые элементы матрицы
                                const col_ind : array of Integer; // соответствующие им номера столбцов
                                const row_ptr : array of Integer; // для определения начала следующей строки
                                const dV : array of  Float; // заданный вектор на который производится умножение
                                var dx : array of  Float);  // результат умножения заносится в dx.
var i,j : Integer; // счётчики цикла for
begin

   for i:=0 to (isize-1) do dx[i]:=0.0; // обнуление

   for j:=0 to (isize-1) do
   begin

      for i:=row_ptr[j] to (row_ptr[j+1]-1) do
      begin
         dx[col_ind[i]] := dx[col_ind[i]] + val[i]*dV[j];
      end;

   end;

end;  // MatrixTransposeCRSByVector

// Метод Сопряжённых градиентов
// Хестенса Штифеля
// см. например, дисер Н.Г. Бураго
// или Г.И. Марчук методы вычислительной математики
// Метод сопряжённых градиентов также описан в книжке
// С.М. Устинов, В.А. Зимницкий Вычислительная математика на стр. 86-90.
// Есть некоторые отличия, требуется исследование.
procedure TForm1.SoprGrad(isize : Integer; // размер квадратной матрицы
                          const dA : array of TmyDynArray; // матрица СЛАУ
                          const dV : array of  Float;  // вектор правой части
                          const dX0 : array of  Float; // вектор начального приближения
                          var dres : array of  Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение сверху на количество итераций
                          epsilon :  Float); // точность вычисления
var
    i,k : Integer; // счётчики
    dy, dx, dax, dap, dz, dz1, dp : array of  Float;  // динамические массивы
    dar, dbr, dnz :  Float;

begin

   // выделение памяти
   // под динамические массивы
   SetLength(dy,isize);
   SetLength(dx,isize);
   SetLength(dax,isize);
   SetLength(dap,isize);
   SetLength(dz,isize);
   SetLength(dz1,isize);
   SetLength(dp,isize);

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for i:=0 to (isize-1) do dx[i]:=dX0[i+1];

   MatrixByVector(isize, dA, dx, dax); // результат dA*dx занесён в dax
   // вычисление вектора невязки начального приближения
   for i:=0 to (isize-1) do dz[i]:= dV[i] - dax[i];

   if (Scal(isize, dz, dz) <> 0.0) then
   begin
      for i:=0 to (isize-1) do dp[i]:=dz[i];
      k:=0; // номер итерации
      dnz:=1e300; // начальное значение невязки (инициализация)
      while ((k < kend) and (dnz > epsilon)) do
      begin
         MatrixByVector(isize, dA, dp, dap); // результат dA*dp занесён в dap
         dar := Scal(isize, dz, dp) / Scal( isize, dz, dap);
         for i:=0 to (isize-1) do
         begin
            dy[i] := dx[i] + dar*dp[i];
            dz1[i] := dz[i] - dar*dap[i];
         end;
         // здесь реализованы все три нормы
         // вообще говоря они все эквивалентны
         case ibasenorma of
            1 : dnz := NormaV(isize, dz1); // евклидова
            2 : dnz := NormaSupV(isize, dz1); // кубическая норма
            3 : dnz := NormaSup2V(isize, dz1);// октаэдрическая норма
         end;
         if (bconsole_message) then
         begin
            // печать значения невязки на консоль
            if (k mod 10 = 0) then MainMemo.Lines.Add('residual ');
            MainMemo.Lines.Add(FloatToStr(dnz));
         end;
         dbr := Scal(isize, dz1, dap) / Scal(isize, dp, dap);
         for i:=0 to (isize-1) do
         begin
            dp[i] := dz1[i] - dbr*dp[i];
            dz[i] := dz1[i];
            dx[i] := dy[i];
         end;
         k:= k+1; // переход к следующей итерации
         // если процесс расходится его надо остановить
         if (dnz > 1e7) then
         begin
            // восстановление начального приближения
            for i:=0 to (isize-1) do dy[i]:=dX0[i+1];
            MainMemo.Lines.Add('вычислительный процесс расходится ');
            Application.MessageBox('divergence SoprGrad solver ','',MB_OK);
            break; // и останов процесса
         end;
      end;
      // возвращение результата
      for i:=0 to (isize-1) do dres[i]:=dy[i];
   end
   else
   begin
      // возвращает начальное приближение
      for i:=0 to (isize-1) do dres[i]:=dx[i];
   end;

   // освобождение памяти выделенной под динамические массивы
   Finalize(dy);  Finalize(dx);
   Finalize(dax); Finalize(dap);
   Finalize(dz); Finalize(dz1);
   Finalize(dp);

end;  // SoprGrad


// Метод Сопряжённых градиентов
// Хестенса и Штифеля 1952 год.
// см. например, диссертацию Н.Г. Бураго  стр. 88.
// или Г.И. Марчук методы вычислительной математики
// здесь применена технология CRS хранения и обработки разреженной матрицы.
// Этот алгоритм подходит не только для SPD - Symmetric and Positively Defined матриц.
// SPD - Самосопряжённые и положительно определённые матрицы.
// В зависимости от значения передаваемого параметра bGaussTransform
// в нём примененяется или не применяется трансформация Гаусса.
// Трансформация Гаусса состоит в домножении СЛАУ на транспонированную матрицу слева,
// что позволяет из любой СЛАУ получить СЛАУ с положительно определённой самосопряжённой матрицей.
// Однако трансформация Гаусса сильно портит число обусловленности матрицы (спектр матрицы) возводя его в квадрат.
procedure TForm1.SoprGradCRS(isize : Integer; // размер квадратной матрицы
                          const val : array of  Float; // матрица СЛАУ
                          const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                          const row_ptr : array of Integer; // информация о началах строк
                          const dV : array of  Float;  // вектор правой части
                          const dX0 : array of  Float; // вектор начального приближения
                          var dres : array of  Float; // вектор результата
                          bconsole_message : Boolean; // выводить ли значения невязки на консоль
                          kend : Integer; // ограничение на максимальное количество итераций
                          bGaussTransform : Boolean; // выполнять ли трансформацию Гаусса
                          epsilon :  Float); // точность вычисления
var
    i,k : Integer; // счётчики
    dx, dax, dap, dg, dp : array of  Float;  // динамические массивы
    dbuf : array of  Float; // временное хранилище необходимое при трансформации Гаусса
    dar, dbr, dnz, dscalgg :  Float;

begin

   // выделение памяти
   // под динамические массивы
   SetLength(dx,isize);  // искомое решение системы
   SetLength(dax,isize); // результаты умножения
   SetLength(dap,isize); // матрицы на вектор
   SetLength(dg,isize); // вектор градиента
   SetLength(dp,isize); // вектор сопряжённого направления поиска
   // для трансформации Гаусса
   SetLength(dbuf,isize); // временное хранилище при выполнении трансформации Гаусса

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for i:=0 to (isize-1) do dx[i]:=dX0[i+1];

   // Первоначально без применения трансформации Гаусса.
   MatrixCRSByVector(isize, val, col_ind, row_ptr, dx, dax); // результат занесён в dax
   for i:=0 to (isize-1) do dg[i]:= dV[i] - dax[i];  // начальная невязка

   if ( bGaussTransform) then
   begin
      // Если трансформация Гаусса всё-же требуется.
      for i:=0 to (isize-1) do dbuf[i]:= dg[i];  // временная копия начальной невязки
      MatrixTransposeCRSByVector(isize, val, col_ind, row_ptr, dbuf, dg); // результат занесён в dg:=At*dbuf;
   end;

   if (Scal(isize, dg, dg) <> 0.0) then
   begin
      for i:=0 to (isize-1) do dp[i]:=dg[i]; // p0:=g0;
      k:=0; // номер итерации
      dnz:=1e300; // начальное значение невязки (инициализация)
      while ((k < kend) and (dnz > epsilon)) do
      begin
         if ( bGaussTransform) then
         begin
            // выполняется трансформация Гаусса.
            MatrixCRSByVector(isize, val, col_ind, row_ptr, dp, dbuf); // результат занесён в dbuft1
            MatrixTransposeCRSByVector(isize, val, col_ind, row_ptr, dbuf, dap); // результат At*A*dp занесён в dap
         end
         else
         begin
            // Трансформация Гаусса не выполняется.
            MatrixCRSByVector(isize, val, col_ind, row_ptr, dp, dap); // результат A*dp занесён в dap
         end;
         dscalgg:= Scal(isize, dg, dg);
         dar :=  dscalgg / Scal( isize, dap, dp);
         for i:=0 to (isize-1) do
         begin
            dx[i] := dx[i] + dar*dp[i];
            dg[i] := dg[i] - dar*dap[i];
         end;
         // здесь реализованы все три нормы
         // вообще говоря они все эквивалентны
         case ibasenorma of
            1 : dnz:=NormaV(isize, dg); // евклидова
            2 : dnz:=NormaSupV(isize, dg); // кубическая норма
            3 : dnz:=NormaSup2V(isize, dg);// октаэдрическая норма
         end;
         if (imodelEquation < 3) then
         begin
            // график невязки
            inc(imarker);
            SetLength(myresplot,imarker);
            myresplot[imarker-1].temperature:=dnz; // нумерация начинается от нуля
            if (imarker>1) then updatemainpaintbox; // графики невязок
         end;
         if (bconsole_message) then
         begin
            // печать значения невязки на консоль
            if (k mod 10 = 0) then MainMemo.Lines.Add('iter  residual');
            MainMemo.Lines.Add(IntToStr(k)+'  '+FormatFloat('#.####e-0',dnz));
         end;
         dbr := Scal(isize, dg, dg) / dscalgg;
         for i:=0 to (isize-1) do
         begin
            dp[i] := dg[i] + dbr*dp[i];
         end;
         k:= k+1; // переход к следующей итерации
         // если процесс расходится его надо остановить
         if (dnz > 1e7) then
         begin
            // восстановление начального приближения
            for i:=0 to (isize-1) do dx[i]:=dX0[i+1];
            MainMemo.Lines.Add('вычислительный процесс расходится ');
            Application.MessageBox('divergence SoprGrad solver ','',MB_OK);
            break; // и останов процесса
         end;
      end;
      // возвращение результата
      for i:=0 to (isize-1) do dres[i]:=dx[i];
   end
    else
   begin
      // возвращает начальное приближение
      for i:=0 to (isize-1) do dres[i]:=dX0[i+1];
   end;

   // освобождение памяти выделенной под динамические массивы
   Finalize(dx); // уточняемая величина в результате итерационного процесса
   Finalize(dax); Finalize(dap); // результаты умножения матрицы на вектор
   Finalize(dg); Finalize(dp); // векторы градиента и сопряжённого направления поиска.
   Finalize(dbuf);

end;  // SoprGradCRS

// алгоритм Ю.Г.Соловейчика [1993]
// для возможно несимметричных матриц.
// Запрограммировано по практикуму
// "Численные методы решения систем уравнений" [2004]
// Новосибирского Государственного Технического Университета.
procedure TForm1.SoloveichikAlg(isize : Integer; // размер квадратной матрицы
                         const val : array of  Float; // матрица СЛАУ
                         const col_ind : array of Integer; // соответствующие ненулевым элементам номера столбцов
                         const row_ptr : array of Integer; // информация о началах строк
                         const dV : array of  Float;  // вектор правой части
                         const dX0 : array of  Float; // вектор начального приближения
                         var dres : array of  Float; // вектор результата
                         bconsole_message : Boolean; // выводить ли значения невязки на консоль
                         kend : Integer; // ограничение на максимальное количество итераций
                         epsilon :  Float); // точность вычисления
var
     i,k : Integer; // счётчики
     dx, dax, dr, dz, dp, dar1 : array of  Float;
     dar, dbr, dnz, dscalp :  Float;

begin
   // Выделение памяти под динамические массивы
   SetLength(dx,isize);  SetLength(dax,isize); SetLength(dr,isize);
   SetLength(dz,isize);  SetLength(dp,isize);  SetLength(dar1,isize);

   // начальное приближение
   // X0 ==
   // под вектором dX0 понимается вектор поля температур к примеру.
   for i:=0 to (isize-1) do dx[i]:=dX0[i+1];

   MatrixCRSByVector(isize, val, col_ind, row_ptr, dx, dax); // результат занесён в dax
   for i:=0 to (isize-1) do dr[i]:= dV[i] - dax[i];  // начальная невязка
   dnz:=Scal(isize,dr,dr); // начальное значение невязки
   for i:=0 to (isize-1) do dz[i]:=dr[i];  // вектор спуска (сопряжённое направление поиска).
   MatrixCRSByVector(isize, val, col_ind, row_ptr, dz, dp); // результат занесён в dp

   if (abs(Scal(isize, dp, dp))>1e-270) then
   begin
      k:=1; // нумерация начинается именно с 1
      // начальное значение невязки вычислено выше
      while ((bweShouldContinue) and (k <= kend) and (dnz > epsilon)) do
      begin
         dscalp:=1/Scal(isize, dp, dp);
         dar:=Scal(isize, dp, dr)*dscalp;
         for i:=0 to (isize-1) do
         begin
            dx[i]:=dx[i]+dar*dz[i];
            dr[i]:=dr[i]-dar*dp[i];
         end;
         dnz:=dnz-dar*dar/dscalp; // норма невязки
         if (imodelEquation < 3) then
         begin
            // график невязки
            inc(imarker);
            SetLength(myresplot,imarker);
            myresplot[imarker-1].temperature:=dnz; // нумерация начинается от нуля
            if (imarker>1) then updatemainpaintbox; // графики невязок
         end;
         if (bconsole_message) then
         begin
            // печать значения невязки на консоль
            if (k mod 10 = 0) then MainMemo.Lines.Add('residual');
            MainMemo.Lines.Add(FormatFloat('#.####e-0',dnz));
         end;
         MatrixCRSByVector(isize, val, col_ind, row_ptr, dr, dar1); // результат занесён в dar1
         dbr:=-Scal(isize,dp,dar1)*dscalp;
         for i:=0 to (isize-1) do
         begin
            dz[i]:=dr[i]+dbr*dz[i];
            dp[i]:=dar1[i]+dbr*dp[i];
         end;
         k:=k+1;
         // если процесс расходится его надо остановить
         if (dnz > 1e7) then
         begin
            // восстановление начального приближения
            for i:=0 to (isize-1) do dx[i]:=dX0[i+1];
            MainMemo.Lines.Add('вычислительный процесс Ю.Г. Соловейчика  расходится ');
            Application.MessageBox('divergence Soloveichik solver ','',MB_OK);
            bweShouldContinue:=false;
            break; // выход из цикла while
         end;
         Application.ProcessMessages; // микропауза пауза
      end; // while
      // возвращение результата
      for i:=0 to (isize-1) do dres[i]:=dx[i];
   end
   else
   begin
      // возвращает начальное приближение
      for i:=0 to (isize-1) do dres[i]:=dX0[i+1];
   end;

   if (imodelEquation < 3) then bweShouldContinue:=true; // восстанавливаем готовность к решению.
   // освобождение памяти выделенной под динамические массивы
   Finalize(dx); Finalize(dax); Finalize(dr);
   Finalize(dz); Finalize(dp); Finalize(dar1);

end; // SoloveichikAlg


// Вызывает меню где можно определить
// невязки.
procedure TForm1.Solution1Click(Sender: TObject);
begin
   // инициализация
   // задаёт текущие значения невязок
   MyResControlForm.EditTemperature.Text:=FloatToStr(rcs.temp); // температура
   MyResControlForm.EditXVel.Text:=FloatToStr(rcs.Vx); // горизонтальная скорость
   MyResControlForm.EditYVel.Text:=FloatToStr(rcs.Vy); // вертикальная скорость
   MyResControlForm.EditPamendment.Text:=FloatToStr(rcs.Pamendment); // поправка давления
   MyResControlForm.Editcontinity.Text:=FloatToStr(rcs.continity); // нескомпенсированные источники массы
   MyResControlForm.Estreamfunc.Text:=FloatToStr(rcs.streamfunction); // функция тока
   MyResControlForm.EditPressure.Text:=FloatToStr(rcs.Pressure); // Давление
   case MyResControlForm.cbbuds.ItemIndex of
     0 : begin
            MyResControlForm.edtuds.Text:=FloatToStr(rcs.uds1);
         end;
     1 : begin
            MyResControlForm.edtuds.Text:=FloatToStr(rcs.uds2);
         end;
     2  : begin
             MyResControlForm.edtuds.Text:=FloatToStr(rcs.uds3);
         end;
     3  : begin
             MyResControlForm.edtuds.Text:=FloatToStr(rcs.uds4);
         end;
   end;
   if (bsimpler) then
   begin
      // алгоритм SIMPLER
      // вкладки для давления сделаны видимыми.
      MyResControlForm.EditPressure.Visible:=true;
      MyResControlForm.LabelPressure.Visible:=true;
   end
    else
   begin
       // иначе вкладки для давления сделаны невидимыми.
      MyResControlForm.EditPressure.Visible:=false;
      MyResControlForm.LabelPressure.Visible:=false;
   end;
   // Показывает форму где можно
   // определить значения невязок
   // по достижению которых
   // наступит сходимость.
   MyResControlForm.Show;
end;  

// здесь можно настроить решатель на снове
// солвера сопряжённых градиентов
procedure TForm1.SoprGrad1Click(Sender: TObject);
begin
   // учёт разреженности матрицы на основе CRS
   // выбор используемого алгоритма сортировки.
   SoprGradForm.RadioGroup2.ItemIndex:=itypesorter-1;
   // вызывает меню настроек SoprGrad
   SoprGradForm.ShowModal;
end;

// для задания ускорения свободного падения
procedure TForm1.Gravity1Click(Sender: TObject);
begin
   if (imodelEquation>2) then
   begin
      // вызывает меню где можно задать силу тяжести
      // инициализация формы
      GravityForm.Egx.Text:=FloatToStr(dgx);
      GravityForm.Egy.Text:=FloatToStr(dgy);
      GravityForm.ShowModal; // вызывает форму
   end
   else
   begin
      Application.MessageBox('Define->Equation должно быть: Flow или Flow and Temperature или Flow and VOF.','gravity',MB_OK);
   end;
end;

// Этот участок кода находится на стадии тестирования
// Вычисление функции тока.
// 1: реализовано вычисление коэффициентов дискретного аналога.
// 2: Содержит четыре решателя: ГЗ, гибрид ГЗ-Томас, а также
// прямой метод исключения Гаусса и метод сопряжённых градиентов Хестенса и Штифеля.
// ГЗ - стационарный поточечный последовательный
// метод Гауса-Зейделя сходимость
// которого гарантируется критерием
// Скарбороу.
// Недостатки:
// Очень медленная сходимость.
// Но здесь представлена его более быстрая модификация
// которая, к сожалению,  требует несколько больше оперативной памяти.
// гибрид ГЗ-Томас - на основе гибридного метода: итерационный плюс прямой
// с использованием алгоритма Томаса
// (алгоритма трёхдиагональной матрицы или
// метода прогонки)
// сходимость
// которого гарантируется критерием
// Скарбороу.
// Недостатки:
// несколько более сложен для программирования чем Гаусс-Зейдель.
procedure TForm1.SolveStreamFunction(bmessage : Boolean; kend : Integer);
var
   k : Integer; // счётчик количества итераций
   m : array of MatrixCoef; // матрица коэффициетов
   db, myrU : array of  Float;  // коэффициент который зависит от x и y
   //ipi : Integer; // номера узлов на пятиточечном шаблоне
   k1 : Integer; // счётчики
   resudualstreamfunc :  Float; // текущее значение невязки по функции тока
   bneiman : Boolean; // поставлено ли условие Неймана
   qb : Float; // значение "теплового потока" в терминах функции тока.
   bconstruct : Boolean;
   Aseqx, Aseqy : TPeacemanRachford;
   QneiC : TQneiC;

begin
    for k:=1 to 20 do
   begin
      for k1:=1 to 4 do
      begin
         QneiC[k][k1]:=false;
      end;
   end;

   bconstruct:=True;

   // коэффициенты дискретного аналога постоянны
   // их нужно вычислить один раз и дальше только использовать.
   // Коэффициенты зависят от x и y, но геометрия неизменна (нету dynamicmesh).
   SetLength(m,inx*iny+1); // выделение памяти под коэффициенты
   SetLength(db,inx*iny+1); // выделение памяти под коэффициент
   SetLength(myrU,inx*iny+1);

   // проход по всем внутренним точкам
   // для вычисления значений коэффициентов

   for k1:=1 to imaxnumbernode do
   begin
       with mapPT[k1] do
       begin
          ipi:=i+(j-1)*inx; // текущая точка
          if (itype=1) then
          begin
             // внутренний узел
             m[ipi].dae:=dy/dxe;  // коэффициенты
             m[ipi].daw:=dy/dxw;  // дискретного
             m[ipi].dan:=dx/dyn;  // аналога
             m[ipi].das:=dx/dys;
             db[ipi]:=-Omega[ipi]*dV; // постоянная составляющая источникового члена
             m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan+m[ipi].das-dSp*dV;
          end;
          if (itype=2) then
          begin
             if (iugol=0) then
             begin
                // iboundary - уникальный номер границы
                bneiman:=GridGenForm.isneimanqb(iboundary, 'S', qb);
                if (bneiman) then
                begin
                   // точка не является угловой
                   case chnormal of
                     'N' : begin
                              // нижняя граница
                              m[ipi].dae:=dy/dxe;  // коэффициенты
                              m[ipi].daw:=dy/dxw;  // дискретного
                              m[ipi].dan:=dx/dyn;  // аналога
                              m[ipi].das:=0.0;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].dan-dSp*dV;
                           end;
                     'S' : begin
                              // верхняя граница
                              m[ipi].dae:=dy/dxe;  // коэффициенты
                              m[ipi].daw:=dy/dxw;  // дискретного
                              m[ipi].dan:=0.0;  // аналога
                              m[ipi].das:=dx/dys;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].dae+m[ipi].daw+m[ipi].das-dSp*dV;
                           end;
                     'W' : begin
                              // правая стенка
                              m[ipi].dae:=0.0;  // коэффициенты
                              m[ipi].daw:=dy/dxw;  // дискретного
                              m[ipi].dan:=dx/dyn;  // аналога
                              m[ipi].das:=dx/dys;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].daw+m[ipi].dan+m[ipi].das-dSp*dV;
                           end;
                     'E' : begin
                              // левая стенка
                              m[ipi].dae:=dy/dxe;  // коэффициенты
                              m[ipi].daw:=0.0;  // дискретного
                              m[ipi].dan:=dx/dyn;  // аналога
                              m[ipi].das:=dx/dys;
                              db[ipi]:=-Omega[ipi]*dV + qb; // постоянная составляющая источникового члена
                              m[ipi].dap:=m[ipi].dae+m[ipi].dan+m[ipi].das-dSp*dV;
                           end;
                   end; // case
                end; // Нейман
             end;
          end;
       end; // with
   end;

   // теперь когда коэффициенты вычислены можно запускать
   // основной тройной цикл.

   if (itypesolver.istreamfunction < 3 ) then
   begin
      resudualstreamfunc:=1e300; // очень большое число
      k:=0; // инициализация
      // здесь должен быть предусмотрен выход из цикла по
      // достижению заданной невязки
      while ((resudualstreamfunc > rcs.streamfunction) and (k < kend)) do
      begin

         case itypesolver.istreamfunction of
           1: // последовательный поточечный метод Гаусса - Зейделя
              begin
                 // ниже представлен более быстрый солвер,
                 // но он ограничен только случаями
                 // статической сетки
                 // данный метод предназначен для небольших сеток
                 //  иначе время счёта будет весьма существенным.
                 GZUniversal(SF,inx,iny, mapPT, 'S',  m,db,QneiC);
              end;
           2: // метод переменных направлений
              // (гибридный метод Гаусс-Зейдель плюс алгоритм ТОМАСА для 3 диагональной СЛАУ).
              begin
                // одна итерация методом переменных направлений
                // для поля функции тока и граничных условий первого рода (нулевых)
                // солвер основанный на гибридном алгоритме,
                // сочетающем в себе как итерационный метод Гаусса-Зейделя
                // так и прямой алгоритм Томаса для трёхдиагональной матрицы.
                TDMAGibridGZUniversal(SF,inx,iny, mapPT, 'S', m,db, Aseqx, Aseqy, bconstruct);
                bconstruct:=False;
              end;
         end; // case

         resudualstreamfunc:=myResidual(SF,myrU,inx,iny,mapPT, 'S', m,db);

         if (bmessage) then
         begin
            if (k mod 10 = 0) then MainMemo.Lines.Add('stream function ');
            MainMemo.Lines.Add(FloatToStr(resudualstreamfunc));
         end;

         k:=k+1; // увеличение счётчика: переход к следующей итерации.
      end;  // while
   end
   else
   begin
      case itypesolver.istreamfunction of
        3 :  // решение задачи прямым методом Гаусса
           begin
              GaussUniversal(SF,inx,iny, mapPT, 'S' ,m,db,false);
           end;
        4 : // метод Сопряжённых Градиентов
           begin
              SoprGradCRSUniversal( SF, inx, iny, mapPT, 'S', m, false, bmessage, kend, rcs.streamfunction, 0, db); //на основе технологии хранения CRS
           end;
        end; // case
   end;

   SetLength(m,0); // выделение памяти под коэффициенты
   SetLength(db,0); // выделение памяти под коэффициент
   SetLength(myrU,0);

end; // SolveStreamFunction

// Это исправление граничных условий для давления
// до граничных условий Неймана для корректного
// отображения при визуализации.
procedure TForm1.PressurePathit;
var
    k : Integer;
begin
   for k:=1 to imaxnumbernode do
   begin
      with (mapPT[k]) do
      begin
         if (itype=2) then
         begin
            if (iugol=0) then
            begin
               case chnormal of
               'N' : begin
                        P[i+(j-1)*inx]:=P[i+j*inx];
                     end;
               'S' : begin
                        P[i+(j-1)*inx]:=P[i+(j-2)*inx];
                     end;
               'W' : begin
                        P[i+(j-1)*inx]:=P[(i-1)+(j-1)*inx];
                     end;
               'E' : begin
                        P[i+(j-1)*inx]:=P[(i+1)+(j-1)*inx];
                     end;
               end; // case
            end
             else
            begin
               // обработка угловых точек
               case iugol of
                1 :  // левый нижний угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i+1)+(j-1)*inx]+ P[i+j*inx]);
                  end;
                2 : // правый нижний угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i-1)+(j-1)*inx]+ P[i+j*inx]);
                  end;
                3 : // верхний левый угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i+1)+(j-1)*inx]+ P[i+(j-2)*inx]);
                  end;
                4 : // верхний правый угол
                  begin
                     P[i+(j-1)*inx]:=0.5*(P[(i-1)+(j-1)*inx]+ P[i+(j-2)*inx]);
                  end;
                5 : // пятиточечная звезда
                  begin
                     P[i+(j-1)*inx]:=0.25*(P[(i+1)+(j-1)*inx]+ P[i+j*inx]);
                     P[i+(j-1)*inx]:=P[i+(j-1)*inx]+ 0.25*(P[(i-1)+(j-1)*inx]+ P[i+(j-2)*inx]);
                  end;
               end; // case
            end;
         end;
      end;
   end;

end; // PressurePathit

// Для исследования вибрационного воздействия
// Возвращает текущее значение силы тяжести
// в зависимости от текущего момента времени.
function TForm1.GetRealGravity(chDirect : Char) :  Float;
var
    r :  Float; // возвращаемое значение
begin
   // rgravVib - глобальная переменная содержащая вибрационные параметры:
   // амплитуду и частоту вибраций.
   // realFlowTime - глобальная переменная содержащая текущее время.
   if (rgravVib.chDirect = chDirect) then
   begin
      // направление вибрационного воздействия
      // совпадает с заданным.
      r:=-4*Pi*Pi;
      r:=r*rgravVib.Amplitude*rgravVib.Frequency*rgravVib.Frequency;
      r:=r*Sin(2*Pi*rgravVib.Frequency*realFlowTime);
   end
    else
   begin
      // направление вибрационного воздействия лежит в другой плоскости.
      r:=0.0;
   end;

   Result:=r;
end; // GetRealGravity

// вызывает форму создания геометрии
// и генерации расчётной сетки
procedure TForm1.CreateGeom1Click(Sender: TObject);
begin
    // Изменение размерности сетки может привести к неадекватному
    // отображению анимации поэтому окно анимации необходимо закрыть
    // перед регенерацией сетки.
    DisplayForm.Close;
    
     // все необходимые инициализирующие
     // действия производятся при создании формы.
    // вызывает форму создания геометрии
    GridGenForm.ShowModal;
end; // вызывает форму создания геометрии


// определение угловых точек и их типов
// для карт горизонтальной и вертикальной скорости
// вызывается внутри модуля GridGenUnit.
procedure TForm1.ugoldetect(var map : TdynArraymyNode; icolx, icoly : Integer);
var
    i,k : Integer; // счётчики
begin
   // определение угловых точек
   // Все угловые точки определяются,
   // классифицируются и отмечаются специальной пометкой (особым номером).
   for i:=1 to icolx do
   begin
      for k:=1 to icoly do
      begin
         map[i + (k-1)*icolx].iugol:=8; // инициализация
         if  (map[i + (k-1)*icolx].itype=2) then
         begin
            // граничный узел
            map[i + (k-1)*icolx].iugol:=0; // инициализация
            // для гарантированно внутренней точки
            if ((i<icolx) and (i>1) and (k<icoly) and (k>1)) then
            begin
               // левый нижний угол
               if ((map[i + (k)*icolx].itype=2) and (map[(i+1) + (k-1)*icolx].itype=2) and
               (map[(i-1) + (k-1)*icolx].itype<>2) and (map[i + (k-2)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=1; // левый нижний угол
                end;
                // правый нижний угол
                if ((map[i + (k)*icolx].itype=2) and (map[(i-1) + (k-1)*icolx].itype=2) and
               (map[(i+1) + (k-1)*icolx].itype<>2) and (map[i + (k-2)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=2; // правый нижний угол
                end;
                // верхний левый угол
                if ((map[i + (k-2)*icolx].itype=2) and (map[(i+1) + (k-1)*icolx].itype=2) and
                (map[(i-1) + (k-1)*icolx].itype<>2) and (map[i + (k)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=3; // левый нижний угол
                end;
                // правый верхний угол
                if ((map[i + (k-2)*icolx].itype=2) and (map[(i-1) + (k-1)*icolx].itype=2) and
               (map[(i+1) + (k-1)*icolx].itype<>2) and (map[i + (k)*icolx].itype<>2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=4; // правый верхний угол
                end;
                // пятиточечная звезда как особая угловая точка
                if ((map[i + (k-2)*icolx].itype=2) and (map[(i-1) + (k-1)*icolx].itype=2) and
               (map[(i+1) + (k-1)*icolx].itype=2) and (map[i + (k)*icolx].itype=2)) then
                begin
                   map[i + (k-1)*icolx].iugol:=5; // пятиточечная звезда
                end;
            end
             else
            begin
                if (i=icolx) then
               begin
                  // поиск углов вдоль правой стенки
                  if ( map[(i-1) + (k-1)*icolx].itype=2) then
                  begin
                      if ((k<icoly) and (map[i + (k)*icolx].itype=2)) then
                      begin
                         // правый нижний угол
                         map[i + (k-1)*icolx].iugol:=2;
                      end;
                      if ((k>1) and (map[i + (k-2)*icolx].itype=2)) then
                      begin
                         // правый верхний угол
                         map[i + (k-1)*icolx].iugol:=4;
                      end;
                  end;
               end;
                if (i=1) then
               begin
                  // поиск углов вдоль левой стенки
                  if ( map[(i+1) + (k-1)*icolx].itype=2) then
                  begin
                      if ((k<icoly) and (map[i + (k)*icolx].itype=2)) then
                      begin
                         map[i + (k-1)*icolx].iugol:=1;
                      end;
                      if ((k>1) and (map[i + (k-2)*icolx].itype=2)) then
                      begin
                         map[i + (k-1)*icolx].iugol:=3;
                      end;
                  end;
               end;
               if (k=icoly) then
               begin
                  // поиск углов вдоль верхней стенки
                  if (map[i + (k-2)*icolx].itype=2) then
                  begin
                     if ((i>1) and (map[(i-1) + (k-1)*icolx].itype=2)) then
                     begin
                        // правый верхний угол
                        map[i + (k-1)*icolx].iugol:=4;
                     end;
                     if ((i<icolx) and (map[(i+1) + (k-1)*icolx].itype=2)) then
                     begin
                        // левый верхний угол
                        map[i + (k-1)*icolx].iugol:=3;
                     end;
                  end;
               end;
               if (k=1) then
               begin
                  // поиск углов вдоль нижней стенки
                  if (map[i + k*icolx].itype=2) then
                  begin
                     if ((i>1) and (map[(i-1) + (k-1)*icolx].itype=2)) then
                     begin
                        // правый нижний угол угол
                        map[i + (k-1)*icolx].iugol:=2;
                     end;
                     if ((i<icolx) and (map[(i+1) + (k-1)*icolx].itype=2)) then
                     begin
                        // левый нижний угол
                        map[i + (k-1)*icolx].iugol:=1;
                     end;
                  end;
               end;

            end;
         end;
       end;
   end;
end;

// вызов менюшки по двойному щелчку
procedure TForm1.TreeView1DblClick(Sender: TObject);
var
    str : String;
begin
   // TODO   19 марта и 29 марта
   str:=TreeView1.Selected.Text;
   case str[1] of
     'C' : begin
              case str[2] of
              'r' : begin
                       // все необходимые инициализирующие
                       // действия производятся при создании формы.
                       // вызывает форму создания геометрии
                       GridGenForm.ShowModal;
                    end;
              'o' : begin
                      // контролирует одну итерацию алгоритма
                      // SIMPLE
                      controlSimpletune;
                    end;
              end;
           end;
     'D' : begin
              // динамические сетки
              DynamMeshtune;
           end;
     'G' : begin
              // главные параметры солвера:
              // стационарный и нестационарный
              myGeneraltune;
           end;
     'E' : begin
              // выбор набора уравнений для решения
              EquationTune(Sender);
           end;
     'M' : begin
              case str[2] of
                'a' : begin
                         // параметры материалов
                         materialtune;
                      end;
                'e' : begin
                         // аппроксимация конвективного члена
                         // и выбор алгоритма солвера
                         Methodstune;
                      end; 
                end;
           end;
     'B' : begin
              // задание граничных условий
              BoundaryConditionTune(Sender);
           end;
     'S' : begin
              // Выбор алгоритма солвера
              SelectSolvertune;
           end;
       'I' : begin
                // инициализация перед началом вычисления 
                Initializationtune;
             end;
       'R' : begin
                case str[2] of
                  'e' : begin
                           // настройка параметров релаксации.
                           RelaxationFactorstune;
                        end;
                  'u' : begin
                          // вызывает солвер
                          RunTune;
                        end;
                  end;
             end;
       'P' : begin
                // дополнительная инициализация
                // используется, например, в VOF методе.
                patchtune;
             end;
   end; // case

end;

// управление простейшей динамической сеткой
procedure TForm1.DynamMeshtune;
var i : Integer;
begin
   // очистка списка границ расчётной области
    DynMeshForm.ComboBox1.Clear;
    // загрузка списка границ
    for i:=1 to GridGenForm.inumboundary do
    begin
       DynMeshForm.ComboBox1.Items.Add(GridGenForm.edgelist[i].boundaryname);
    end;

    DynMeshForm.ShowModal;
end;

// управление простейшей динамической сеткой
procedure TForm1.DynamicMesh1Click(Sender: TObject);
begin
   DynamMeshtune;
end; // динамические сетки

// передвигает координаты сетки
procedure TForm1.mymovingmesh;
var
    dy, dH1, dH2 : Float; // приращение при вибрации
    k, k1 : Integer; // счётчик
    rVy : Float; // скорость на подвижной границе
begin

   dy:=actiVibr.Amplitude*(Sin(2*Pi*actiVibr.Frequency*realFlowTime));
   rVy:=2*Pi*actiVibr.Amplitude*actiVibr.Frequency*(Cos(2*Pi*actiVibr.Frequency*realFlowTime));
   for k:=actiVibr.jdend to actiVibr.jupstart do
   begin
      ypos[k]:=yposfix[k] + dy;
   end;
   dH1:= (yposfix[actiVibr.jdend] - yposfix[actiVibr.jdstart]+dy)/(actiVibr.jdend-actiVibr.jdstart);
   k1:=0;
   for k:=(actiVibr.jdstart+1) to  (actiVibr.jdend-1) do
   begin
      inc(k1);
      ypos[k]:=yposfix[actiVibr.jdstart] + (k1)*dH1;
   end;
   dH2:=(yposfix[actiVibr.jupend] - yposfix[actiVibr.jupstart]-dy)/(actiVibr.jupend - actiVibr.jupstart);
   k1:=0;
   for k:= (actiVibr.jupend - 1) downto (actiVibr.jupstart+1) do
   begin
      inc(k1);
      ypos[k]:=yposfix[actiVibr.jupend] - (k1)*dH2;
   end;
   GridGenForm.bricklist[actiVibr.unickbricknum].yS:=DynMeshForm.rblockpos+dy;
   if (actiVibr.bBridshmen) then
   begin
      GridGenForm.bricklist[actiVibr.uniccontacktupbricknum].yS:=DynMeshForm.rblockpositionBridgmen+dy;
      GridGenForm.bricklist[actiVibr.uniccontacktupbricknum].yL:=dLy-GridGenForm.bricklist[actiVibr.uniccontacktupbricknum].yS;
   end;
   // Внимание !!! в модуле TDynMeshForm.BAnimateClick обязательно должна быть выделена память
   // для массива вертикальной скорости Vy так как здесь производится её обновление.
   // Внимание. При выходе за границы динамического массива компилятор не сообщит об ошибке и приложение будет
   // неожиданным образом падать. Чтобы этого избежать память должна быть выделена заранее.

   // задание модуля скорости на границе подвижного объекта
   for k:=1 to  imaxnumbernodeVy do
   begin
      if (mapVy[k].itype=2) then
      begin
         if (mapVy[k].iboundary = actiVibr.unicalidentifire) then
         begin
            if ((mapVy[k].i+(mapVy[k].j-1)*inx)<High(Vy)) then
            begin
               Vy[mapVy[k].i+(mapVy[k].j-1)*inx]:=rVy;
            end
              else
            begin
               MessageBox(0,PChar('error ! diapazon Vy moving mesh'),PChar('error'),MB_OK);
            end;
         end;
      end;
   end;

end; // осуществляет движение динамической сетки

//при динамической сетке надо обновлять карты.
// процедура обновления карты только для основных переменных.
procedure TForm1.UpdateMap;
var
    i,k : Integer;
begin
   // сначала обычная карта
   for i:=1 to inx do
   begin
      for k:=1 to iny do
      begin
         with  (mapPT[i + (k-1)*inx]) do
         begin
         if (itype=1) then
         begin
            // внутренний узел
            dx:=0.5*(xpos[i+1]-xpos[i-1]);
            dy:=0.5*(ypos[k+1]-ypos[k-1]);
            dV:=dx*dy;
            dxe:=(xpos[i+1]-xpos[i]);
            dxw:=(xpos[i]-xpos[i-1]);
            dyn:=(ypos[k+1]-ypos[k]);
            dys:=(ypos[k]-ypos[k-1]);
         end;
         if (itype=2) then
         begin
            // граничный узел
            if (iugol=0) then
            begin
               case chnormal of
                  'N' : // нижняя стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i-1]);
                          dy:=0.5*(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dxw:=(xpos[i]-xpos[i-1]);
                          dyn:=(ypos[k+1]-ypos[k]);
                       end;
                  'S' : // верхняя стенка
                        begin
                           dx:=0.5*(xpos[i+1]-xpos[i-1]);
                           dy:=0.5*(ypos[k]-ypos[k-1]);
                           dV:=dx*dy;
                           dxw:=(xpos[i]-xpos[i-1]);
                           dxe:=(xpos[i+1]-xpos[i]);
                           dys:=(ypos[k]-ypos[k-1]);
                        end;
                  'W' : // правая стенка
                        begin
                           dx:=0.5*(xpos[i]-xpos[i-1]);
                           dy:=0.5*(ypos[k+1]-ypos[k-1]);
                           dV:=dx*dy;
                           dxw:=(xpos[i]-xpos[i-1]);
                           dyn:=(ypos[k+1]-ypos[k]);
                           dys:=(ypos[k]-ypos[k-1]);
                        end;
                  'E' : // левая стенка
                        begin
                           dx:=0.5*(xpos[i+1]-xpos[i]);
                           dy:=0.5*(ypos[k+1]-ypos[k-1]);
                           dV:=dx*dy;
                           dxe:=(xpos[i+1]-xpos[i]);
                           dyn:=(ypos[k+1]-ypos[k]);
                           dys:=(ypos[k]-ypos[k-1]);
                        end;
               end; // case
            end
             else
            begin
               // угловая точка
               case iugol of
                1 : // левый нижний угол
                  begin
                     dx:=0.5*(xpos[i+1]-xpos[i]);
                     dy:=0.5*(ypos[k+1]-ypos[k]);
                     dV:=dx*dy;
                     dxe:=(xpos[i+1]-xpos[i]);
                     dyn:=(ypos[k+1]-ypos[k]);
                  end;
                2 : // правый нижний угол
                  begin
                     dx:=0.5*(xpos[i]-xpos[i-1]);
                     dy:=0.5*(ypos[k+1]-ypos[k]);
                     dV:=dx*dy;
                     dxw:=(xpos[i]-xpos[i-1]);
                     dyn:=(ypos[k+1]-ypos[k]);
                  end;
                3 : // верхний левый угол
                  begin
                     dx:=0.5*(xpos[i+1]-xpos[i]);
                     dy:=0.5*(ypos[k]-ypos[k-1]);
                     dV:=dx*dy;
                     dxe:=(xpos[i+1]-xpos[i]);
                     dys:=(ypos[k]-ypos[k-1]);
                  end;
                4 : // верхний правый угол
                  begin
                     dx:=0.5*(xpos[i]-xpos[i-1]);
                     dy:=0.5*(ypos[k]-ypos[k-1]);
                     dV:=dx*dy;
                     dxw:=(xpos[i]-xpos[i-1]);
                     dys:=(ypos[k]-ypos[k-1]);
                  end;
                5 : // пятиточечная звезда
                  begin
                     dx:=0.5*(xpos[i+1]-xpos[i-1]);
                     dy:=0.5*(ypos[k+1]-ypos[k-1]);
                     dV:=3*dx*dy/4; // объём
                     dxe:=(xpos[i+1]-xpos[i]);
                     dxw:=(xpos[i]-xpos[i-1]);
                     dyn:=(ypos[k+1]-ypos[k]);
                     dys:=(ypos[k]-ypos[k-1]);
                  end;
                end; // case
            end;
         end;
         end; // with mapPT

         // наверно нужно сделать обновления ещё и для
         // горизонтальной и вертикальной компонент скорости.

      end;
   end;
   for i:=1 to (inx-1) do
   begin
      for k:=1 to iny do
      begin
         with  (mapVx[i + (k-1)*(inx-1)]) do
         begin
            if (itype=1) then
            begin
               // внутренний узел
               dx:=(xpos[i+1]-xpos[i]);
               dy:=0.5*(ypos[k+1]-ypos[k-1]);
               dV:=dx*dy;
               dxe:=0.5*(xpos[i+2]-xpos[i]);
               dxw:=0.5*(xpos[i+1]-xpos[i-1]);
               dyn:=(ypos[k+1]-ypos[k]);
               dys:=(ypos[k]-ypos[k-1]);
            end;
            if (itype=2) then
            begin
               // граничный узел
               if (iugol=0) then
               begin
                  case chnormal of
                   'N' : // нижняя стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=0.5*(xpos[i+2]-xpos[i]);
                          dxw:=0.5*(xpos[i+1]-xpos[i-1]);
                          dyn:=(ypos[k+1]-ypos[k]);
                       end;
                   'S' : // верхняя стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k]-ypos[k-1]);
                          dV:=dx*dy;
                          dxe:=0.5*(xpos[i+2]-xpos[i]);
                          dxw:=0.5*(xpos[i+1]-xpos[i-1]);
                          dys:=(ypos[k]-ypos[k-1]);
                       end;
                   'W' : // правая стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k+1]-ypos[k-1]);
                          dV:=dx*dy;
                          dxw:=0.5*(xpos[i+1]-xpos[i-1]);
                          dyn:=(ypos[k+1]-ypos[k]);
                          dys:=(ypos[k]-ypos[k-1]);
                       end;
                   'E' : // левая стенка
                       begin
                          dx:=(xpos[i+1]-xpos[i]);
                          dy:=0.5*(ypos[k+1]-ypos[k-1]);
                          dV:=dx*dy;
                          dxe:=0.5*(xpos[i+2]-xpos[i]);
                          dyn:=(ypos[k+1]-ypos[k]);
                          dys:=(ypos[k]-ypos[k-1]);
                       end;
                   end; // case
               end; // iugol 0
            end;
         end;
      end;
   end;
   for i:=1 to inx do
   begin
      for k:=1 to (iny-1) do
      begin
         with  (mapVy[i + (k-1)*inx]) do
         begin
            if (itype=1) then
            begin
               // внутренний узел
               dx:=0.5*(xpos[i+1]-xpos[i-1]);
               dy:=(ypos[k+1]-ypos[k]);
               dV:=dx*dy;
               dxe:=(xpos[i+1]-xpos[i]);
               dxw:=(xpos[i]-xpos[i-1]);
               dyn:=0.5*(ypos[k+2]-ypos[k]);
               dys:=0.5*(ypos[k+1]-ypos[k-1]);
            end;
            if (itype=2) then
            begin
               // граничный узел
               if (iugol=0) then
               begin
                  case chnormal of
                   'N' : // нижняя стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i-1]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dxw:=(xpos[i]-xpos[i-1]);
                          dyn:=0.5*(ypos[k+2]-ypos[k]);
                       end;
                   'S' : // верхняя стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i-1]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dxw:=(xpos[i]-xpos[i-1]);
                          dys:=0.5*(ypos[k+1]-ypos[k-1]);
                       end;
                   'W' : // правая стенка
                       begin
                          dx:=0.5*(xpos[i]-xpos[i-1]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxw:=(xpos[i]-xpos[i-1]);
                          dyn:=0.5*(ypos[k+2]-ypos[k]);
                          dys:=0.5*(ypos[k+1]-ypos[k-1]);
                       end;
                   'E' : // левая стенка
                       begin
                          dx:=0.5*(xpos[i+1]-xpos[i]);
                          dy:=(ypos[k+1]-ypos[k]);
                          dV:=dx*dy;
                          dxe:=(xpos[i+1]-xpos[i]);
                          dyn:=0.5*(ypos[k+2]-ypos[k]);
                          dys:=0.5*(ypos[k+1]-ypos[k-1]);
                       end;
                   end; // case
               end;
            end;
         end;
      end;
   end;
   // TODO
end;

// графики невязок
procedure TForm1.updatemainpaintbox;
const   // импирические значения константы: 60, 104, 208
    imaxline = 208; // константа отвечающая за подробность визуализации
    imaxline2 = 500;
    beginfreeline = 5;
    epsilon = 1e-23; // точность с которой определяется вещественный ноль
    rzero_level = 1e-23; // для проверки равенства невязки на ноль.
    izero_level = -23; // степень

var
   w,h,i : Integer;
   rmin, rmax : Float;
   ix,iy, istep : Integer;
   myresplotcopy : array of TResidualPlot;
   imarkercopy : Integer;
   istart : Integer;

function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;


begin

   if (cbbdisplay.ItemIndex=0) then
   begin
    // очистка фона белым
   with MainPaintBox do
   begin
      w:=Width; // ширина в пикселах
      h:=Height div 25;  // высота в пикселах

      // Градиентная заливка.
      Canvas.Brush.Color:=RGB(250,255,255);
      Canvas.Pen.Color:=RGB(250,255,255);
      Canvas.Rectangle(0,24*h,w,Height);
      for i:=24 downto 1 do
      begin
         if (i<>1) then
         begin
            Canvas.Brush.Color:=RGB(130+i*5,255,255);
            Canvas.Pen.Color:=RGB(130+i*5,255,255);
         end
          else
         begin
            Canvas.Brush.Color:=RGB(135,250,255);
            Canvas.Pen.Color:=RGB(135,250,255);
         end;
         Canvas.Rectangle(0,(i-1)*h,w,i*h);
      end;
      // сейчас установлен голубой цвет фона

      Canvas.Brush.Style:=bsClear;
      Canvas.Font.Color:=clBlack; // цвет шрифта
      //Canvas.TextOut(w-130,20,'DAVIS test v.14.06.2010');
      //Canvas.TextOut(w-130,20,'DAVIS test v.17.06.2014');
      Canvas.TextOut(w-130,20,'DAVIS test v.10.12.2014');
      if (imarker>1) then Canvas.TextOut(20,20,'residual');
      Canvas.Brush.Style:=bsSolid;

       // выбор мат модели (набора уравнений и граничных, начальных условий)
    // значения переменной imodelEquation:
    // 1 - чистая теплопроводность,
    // 2 - User Defined Segregated Solver,
    // 3 - чистая гидродинамика,
    // 4 - гидродинамика с учётом теплопроводности.
    // 5 - гидродинамика и VOF метод.
      if (imodelEquation=1) then
      begin
         Canvas.Brush.Style:=bsClear;
         Canvas.Pen.Color:=clRed; // цвет графика
         Canvas.Font.Color:=clRed; // цвет шрифта
         Canvas.TextOut(20,35,'temperature');
         Canvas.Brush.Style:=bsSolid;


         if (imarker > imaxline) then
         begin
            // отсев половины значений
            imarkercopy:=1; // инициализация

            for i:=1 to imarker do
            begin
               if (i=1) then
               begin
                  imarkercopy:=1;
                  SetLength(myresplotcopy,imarkercopy);
                  myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
               end
                else
               begin
                  if ((i mod 2) =0) then
                  begin
                     inc(imarkercopy);
                     SetLength(myresplotcopy,imarkercopy);
                     myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
                  end;
               end;
            end;
            imarker:=imarkercopy;
            SetLength(myresplot,imarker);
            for i:=0 to imarker-1 do
            begin
               // копирование данных.
               myresplot[i]:=myresplotcopy[i];
            end;

            SetLength(myresplotcopy,imarker);
            for i:=0 to imarker-1 do
            begin
               // копирование данных.
               myresplotcopy[i]:=myresplot[i];
            end;
            if (imarker >  imaxline2) then
            begin
               imarkercopy:=imarker;
               imarker:=imarker-beginfreeline;
               istart:=beginfreeline;
            end
            else
            begin
               istart:=1;
            end;
            SetLength(myresplot,imarker); // уменьшаем размер массива.

            // обратное копирование просеянного вдвое массива
            for i:=istart to imarkercopy-1 do myresplot[i-istart].temperature:= myresplotcopy[i].temperature;
            SetLength(myresplotcopy,1);
         end;


         // табулирование функции -
         // определение максимумов и минимумов.
         rmin:=1e30;
         rmax:=-1e30;
         for i:=0 to imarker-1 do
         begin
             if (fabs(myresplot[i].temperature)<rzero_level) then
             begin
                rmin:=izero_level;
             end
             else
             begin
                if (rmin > log10(fabs(myresplot[i].temperature))) then
                rmin:=log10(fabs(myresplot[i].temperature));
                if (rmax < log10(fabs(myresplot[i].temperature))) then
                rmax:=log10(fabs(myresplot[i].temperature));
             end;
         end;

         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            if (Abs(rmax-rmin)>epsilon) then
            begin
               // чтобы избежать деления на ноль.
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].temperature))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if (Abs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].temperature)) - rmin)/(rmax-rmin));
            end
             else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
      end
      else if (imodelEquation=2) then
      begin
         Canvas.Brush.Style:=bsClear;
         case imaxUDS of
            1 : begin
                   Canvas.Pen.Color:=clRed; // цвет графика
                   Canvas.Font.Color:=clRed; // цвет шрифта
                   Canvas.TextOut(20,35,'uds1');
                end;
            2 : begin
                   Canvas.Pen.Color:=clRed; // цвет графика
                   Canvas.Font.Color:=clRed; // цвет шрифта
                   Canvas.TextOut(20,35,'uds1');
                   Canvas.Pen.Color:=clGreen; // цвет графика
                   Canvas.Font.Color:=clGreen; // цвет шрифта
                   Canvas.TextOut(20,45,'uds2');
                end;
            3 : begin
                   Canvas.Pen.Color:=clRed; // цвет графика
                   Canvas.Font.Color:=clRed; // цвет шрифта
                   Canvas.TextOut(20,35,'uds1');
                   Canvas.Pen.Color:=clGreen; // цвет графика
                   Canvas.Font.Color:=clGreen; // цвет шрифта
                   Canvas.TextOut(20,45,'uds2');
                   Canvas.Pen.Color:=clYellow; // цвет графика
                   Canvas.Font.Color:=clYellow; // цвет шрифта
                   Canvas.TextOut(20,55,'uds3');
                end;
            4 : begin
                   Canvas.Pen.Color:=clRed; // цвет графика
                   Canvas.Font.Color:=clRed; // цвет шрифта
                   Canvas.TextOut(20,35,'uds1');
                   Canvas.Pen.Color:=clGreen; // цвет графика
                   Canvas.Font.Color:=clGreen; // цвет шрифта
                   Canvas.TextOut(20,45,'uds2');
                   Canvas.Pen.Color:=clYellow; // цвет графика
                   Canvas.Font.Color:=clYellow; // цвет шрифта
                   Canvas.TextOut(20,55,'uds3');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,65,'uds4');
                end;
         end;

         Canvas.Brush.Style:=bsSolid;


         if (imarker > imaxline) then
         begin
            // отсев половины значений
            imarkercopy:=1; // инициализация

            for i:=1 to imarker do
            begin
               if (i=1) then
               begin
                  imarkercopy:=1;
                  SetLength(myresplotcopy,imarkercopy);
                  case imaxUDS of
                    1 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                        end;
                    2 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                           myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                        end;
                    3 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                           myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                           myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                        end;
                    4 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                           myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                           myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                           myresplotcopy[imarkercopy-1].uds4:=myresplot[i-1].uds4;
                        end;
                  end;


               end
                else
               begin
                  if ((i mod 2) =0) then
                  begin
                     inc(imarkercopy);
                     SetLength(myresplotcopy,imarkercopy);
                     case imaxUDS of
                        1 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                            end;
                        2 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                               myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                            end;
                        3 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                               myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                               myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                            end;
                        4 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                               myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                               myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                               myresplotcopy[imarkercopy-1].uds4:=myresplot[i-1].uds4;
                            end;
                     end;

                  end;
               end;
            end;
            imarker:=imarkercopy;
            SetLength(myresplot,imarker);
            for i:=0 to imarker-1 do
            begin
               // копирование данных.
               myresplot[i]:=myresplotcopy[i];
            end;

            SetLength(myresplotcopy,imarker);
            for i:=0 to imarker-1 do
            begin
               // копирование данных.
               myresplotcopy[i]:=myresplot[i];
            end;
            if (imarker >  imaxline2) then
            begin
               imarkercopy:=imarker;
               imarker:=imarker-beginfreeline;
               istart:=beginfreeline;
            end
            else
            begin
               istart:=1;
            end;
            SetLength(myresplot,imarker); // уменьшаем размер массива.

            // обратное копирование просеянного вдвое массива
            for i:=istart to imarkercopy-1 do
            begin

               case imaxUDS of
                 1 : begin
                        myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                     end;
                 2 : begin
                         myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                         myresplot[i-istart].uds2:= myresplotcopy[i].uds2;
                     end;
                 3 : begin
                         myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                         myresplot[i-istart].uds2:= myresplotcopy[i].uds2;
                         myresplot[i-istart].uds3:= myresplotcopy[i].uds3;
                     end;
                 4 : begin
                         myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                         myresplot[i-istart].uds2:= myresplotcopy[i].uds2;
                         myresplot[i-istart].uds3:= myresplotcopy[i].uds3;
                         myresplot[i-istart].uds4:= myresplotcopy[i].uds4;
                     end;
               end;
            end;
            SetLength(myresplotcopy,1);
         end;


         // табулирование функции -
         // определение максимумов и минимумов.
         rmin:=1e30;
         rmax:=-1e30;
         for i:=0 to imarker-1 do
         begin
             case imaxUDS of
             1 : begin
                    if (fabs(myresplot[i].uds1)<rzero_level) then
                    begin
                       rmin:=izero_level;
                    end
                     else
                    begin
                       if (rmin > log10(fabs(myresplot[i].uds1))) then
                       rmin:=log10(fabs(myresplot[i].uds1));
                       if (rmax < log10(fabs(myresplot[i].uds1))) then
                       rmax:=log10(fabs(myresplot[i].uds1));
                    end;
             end;
             2 : begin
                    if (fabs(myresplot[i].uds1)<rzero_level) then
                    begin
                       rmin:=izero_level;
                    end
                     else
                    begin
                       if (rmin > log10(fabs(myresplot[i].uds1))) then
                       rmin:=log10(fabs(myresplot[i].uds1));
                       if (rmax < log10(fabs(myresplot[i].uds1))) then
                       rmax:=log10(fabs(myresplot[i].uds1));
                    end;
                    if (fabs(myresplot[i].uds2)<rzero_level) then
                    begin
                       rmin:=izero_level;
                    end
                     else
                    begin
                       if (rmin > log10(fabs(myresplot[i].uds2))) then
                       rmin:=log10(fabs(myresplot[i].uds2));
                       if (rmax < log10(fabs(myresplot[i].uds2))) then
                       rmax:=log10(fabs(myresplot[i].uds2));
                    end;
             end;
             3 : begin
                    if (fabs(myresplot[i].uds1)<rzero_level) then
                    begin
                       rmin:=izero_level;
                    end
                     else
                    begin
                       if (rmin > log10(fabs(myresplot[i].uds1))) then
                       rmin:=log10(fabs(myresplot[i].uds1));
                       if (rmax < log10(fabs(myresplot[i].uds1))) then
                       rmax:=log10(fabs(myresplot[i].uds1));
                    end;
                    if (fabs(myresplot[i].uds2)<rzero_level) then
                    begin
                       rmin:=izero_level;
                    end
                     else
                    begin
                       if (rmin > log10(fabs(myresplot[i].uds2))) then
                       rmin:=log10(fabs(myresplot[i].uds2));
                       if (rmax < log10(fabs(myresplot[i].uds2))) then
                       rmax:=log10(fabs(myresplot[i].uds2));
                    end;
                    if (fabs(myresplot[i].uds3)<rzero_level) then
                    begin
                       rmin:=izero_level;
                    end
                     else
                    begin
                       if (rmin > log10(fabs(myresplot[i].uds3))) then
                       rmin:=log10(fabs(myresplot[i].uds3));
                       if (rmax < log10(fabs(myresplot[i].uds3))) then
                       rmax:=log10(fabs(myresplot[i].uds3));
                    end;
             end;
             4 : begin
                 if (fabs(myresplot[i].uds1)<rzero_level) then
             begin
                rmin:=izero_level;
             end
             else
             begin
                if (rmin > log10(fabs(myresplot[i].uds1))) then
                rmin:=log10(fabs(myresplot[i].uds1));
                if (rmax < log10(fabs(myresplot[i].uds1))) then
                rmax:=log10(fabs(myresplot[i].uds1));
             end;
             if (fabs(myresplot[i].uds2)<rzero_level) then
             begin
                rmin:=izero_level;
             end
             else
             begin
                if (rmin > log10(fabs(myresplot[i].uds2))) then
                rmin:=log10(fabs(myresplot[i].uds2));
                if (rmax < log10(fabs(myresplot[i].uds2))) then
                rmax:=log10(fabs(myresplot[i].uds2));
             end;
             if (fabs(myresplot[i].uds3)<rzero_level) then
             begin
                rmin:=izero_level;
             end
             else
             begin
                if (rmin > log10(fabs(myresplot[i].uds3))) then
                rmin:=log10(fabs(myresplot[i].uds3));
                if (rmax < log10(fabs(myresplot[i].uds3))) then
                rmax:=log10(fabs(myresplot[i].uds3));
             end;
             if (fabs(myresplot[i].uds4)<rzero_level) then
             begin
                rmin:=izero_level;
             end
             else
             begin
                if (rmin > log10(fabs(myresplot[i].uds4))) then
                rmin:=log10(fabs(myresplot[i].uds4));
                if (rmax < log10(fabs(myresplot[i].uds4))) then
                rmax:=log10(fabs(myresplot[i].uds4));
             end;
             end;
             end;
         end;
         case imaxUDS of
         1 : begin
         // прорисовка графика:
          Canvas.Pen.Color:=clRed; // цвет графика
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon))  then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon)  and (fabs(myresplot[i-1].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
         end;
         2 : begin
         // прорисовка графика:
          Canvas.Pen.Color:=clRed; // цвет графика
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
         // прорисовка графика:
          Canvas.Pen.Color:=clGreen; // цвет графика
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds2))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds2)) - rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
             end;
         3 : begin
                 Canvas.Pen.Color:=clRed; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
                 Canvas.Pen.Color:=clGreen; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds2))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds2)) - rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
                 Canvas.Pen.Color:=clYellow; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds3)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds3))-rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds3)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds3)) - rmin)/(rmax-rmin));
            end
            else
            begin
               iy:=Height-20;
            end;
            Canvas.LineTo(ix,iy);
         end;
         end;
         4 : begin
                 Canvas.Pen.Color:=clRed; // цвет графика
                 ix:=25; iy:=0;
                 if (imarker > 1) then
                 begin
                    // чтобы избежать деления на ноль.
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                 end;
                 Canvas.MoveTo(ix,iy);
                 istep:=round(Width/(imarker+1));
                 for i:=2 to imarker do
                 begin
                    ix:=25+(i)*istep;
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds1)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                    Canvas.LineTo(ix,iy);
                 end;
                 Canvas.Pen.Color:=clGreen; // цвет графика
                 ix:=25; iy:=0;
                 if (imarker > 1) then
                 begin
                    // чтобы избежать деления на ноль.
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds2)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds2))-rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                 end;
                 Canvas.MoveTo(ix,iy);
                 istep:=round(Width/(imarker+1));
                 for i:=2 to imarker do
                 begin
                    ix:=25+(i)*istep;
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds2)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds2)) - rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                    Canvas.LineTo(ix,iy);
                 end;
                 Canvas.Pen.Color:=clYellow; // цвет графика
                 ix:=25; iy:=0;
                 if (imarker > 1) then
                 begin
                    // чтобы избежать деления на ноль.
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds3)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds3))-rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                 end;
                 Canvas.MoveTo(ix,iy);
                 istep:=round(Width/(imarker+1));
                 for i:=2 to imarker do
                 begin
                    ix:=25+(i)*istep;
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds3)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds3)) - rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                    Canvas.LineTo(ix,iy);
                 end;
                 Canvas.Pen.Color:=clOlive; // цвет графика
                 ix:=25; iy:=0;
                 if (imarker > 1) then
                 begin
                    // чтобы избежать деления на ноль.
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds4)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds4))-rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                 end;
                 Canvas.MoveTo(ix,iy);
                 istep:=round(Width/(imarker+1));
                 for i:=2 to imarker do
                 begin
                    ix:=25+(i)*istep;
                    if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds4)>epsilon)) then
                    begin
                       iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds4)) - rmin)/(rmax-rmin));
                    end
                     else
                    begin
                       iy:=Height-20;
                    end;
                    Canvas.LineTo(ix,iy);
                 end;
             end;
         end;
      end
       else if (imodelEquation>=3) then
      begin
         // Навье-Стокс
         // TODO

         Canvas.Brush.Style:=bsClear;
         Canvas.Font.Color:=clBlack; // чёрный
         Canvas.TextOut(20,35,'continity');
         Canvas.Font.Color:=RGB(0,0,255); // синий
         Canvas.TextOut(20,45,'x-velocity');
         Canvas.Font.Color:=clGreen; // зелёный
         Canvas.TextOut(20,55,'y-velocity');
         if (imodelEquation=4) then
         begin
            Canvas.Font.Color:=clRed; // красный
            Canvas.TextOut(20,65,'temperature');
            case imaxUDS of
            1 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,75,'uds1');
                end;
            2 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,75,'uds1');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,85,'uds2');
                end;
            3 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,75,'uds1');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,85,'uds2');
                   Canvas.Pen.Color:=clNavy; // цвет графика
                   Canvas.Font.Color:=clNavy; // цвет шрифта
                   Canvas.TextOut(20,95,'uds3');
                end;
            4 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,75,'uds1');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,85,'uds2');
                   Canvas.Pen.Color:=clNavy; // цвет графика
                   Canvas.Font.Color:=clNavy; // цвет шрифта
                   Canvas.TextOut(20,95,'uds3');
                   Canvas.Pen.Color:=clPurple; // цвет графика
                   Canvas.Font.Color:=clPurple; // цвет шрифта
                   Canvas.TextOut(20,105,'uds4');
                end;
            end;
         end
          else
         begin
            case imaxUDS of
            1 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,65,'uds1');
                end;
            2 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,65,'uds1');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,75,'uds2');
                end;
            3 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,65,'uds1');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,75,'uds2');
                   Canvas.Pen.Color:=clNavy; // цвет графика
                   Canvas.Font.Color:=clNavy; // цвет шрифта
                   Canvas.TextOut(20,85,'uds3');
                end;
            4 : begin
                   Canvas.Pen.Color:=clMaroon; // цвет графика
                   Canvas.Font.Color:=clMaroon; // цвет шрифта
                   Canvas.TextOut(20,65,'uds1');
                   Canvas.Pen.Color:=clOlive; // цвет графика
                   Canvas.Font.Color:=clOlive; // цвет шрифта
                   Canvas.TextOut(20,75,'uds2');
                   Canvas.Pen.Color:=clNavy; // цвет графика
                   Canvas.Font.Color:=clNavy; // цвет шрифта
                   Canvas.TextOut(20,85,'uds3');
                   Canvas.Pen.Color:=clPurple; // цвет графика
                   Canvas.Font.Color:=clPurple; // цвет шрифта
                   Canvas.TextOut(20,95,'uds4');
                end;
            end;
         end;
         Canvas.Brush.Style:=bsSolid;

         if (imarker > imaxline) then
         begin
            // отсев половины значений
            imarkercopy:=1; // инициализация
            for i:=1 to imarker do
            begin
               if (i=1) then
               begin
                  imarkercopy:=1;
                  SetLength(myresplotcopy,imarkercopy);
                  myresplotcopy[imarkercopy-1].continity:=myresplot[i-1].continity;
                  myresplotcopy[imarkercopy-1].Vx:=myresplot[i-1].Vx;
                  myresplotcopy[imarkercopy-1].Vy:=myresplot[i-1].Vy;
                  if (imodelEquation=4) then
                  begin
                     myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
                  end;
                  case imaxUDS of
                    1 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                        end;
                    2 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                           myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                        end;
                    3 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                           myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                           myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                        end;
                    4 : begin
                           myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                           myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                           myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                           myresplotcopy[imarkercopy-1].uds4:=myresplot[i-1].uds4;
                        end;
                  end;
               end
                else
               begin
                  if ((i mod 2) = 0) then
                  begin
                     inc(imarkercopy);
                     SetLength(myresplotcopy,imarkercopy);
                     myresplotcopy[imarkercopy-1].continity:=myresplot[i-1].continity;
                     myresplotcopy[imarkercopy-1].Vx:=myresplot[i-1].Vx;
                     myresplotcopy[imarkercopy-1].Vy:=myresplot[i-1].Vy;
                     if (imodelEquation=4) then
                     begin
                        myresplotcopy[imarkercopy-1].temperature:=myresplot[i-1].temperature;
                     end;
                     case imaxUDS of
                        1 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                            end;
                        2 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                               myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                            end;
                        3 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                               myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                               myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                            end;
                        4 : begin
                               myresplotcopy[imarkercopy-1].uds1:=myresplot[i-1].uds1;
                               myresplotcopy[imarkercopy-1].uds2:=myresplot[i-1].uds2;
                               myresplotcopy[imarkercopy-1].uds3:=myresplot[i-1].uds3;
                               myresplotcopy[imarkercopy-1].uds4:=myresplot[i-1].uds4;
                            end;
                     end;
                  end;
               end;
            end;
            // обратное копирование просеянного вдвое массива
            imarker:=imarkercopy;
            SetLength(myresplot,imarker);
            for i:=0 to imarker-1 do
            begin
               // копирование данных.
               myresplot[i]:=myresplotcopy[i];
            end;

            SetLength(myresplotcopy,imarker);
            for i:=0 to imarker-1 do
            begin
               // копирование данных.
               myresplotcopy[i]:=myresplot[i];
            end;

            if (imarker >  imaxline2) then
            begin
               imarkercopy:=imarker;
               imarker:=imarker-beginfreeline;
               istart:=beginfreeline;
            end
            else
            begin
               istart:=1;
            end;
            SetLength(myresplot,imarker); // уменьшаем размер массива.

            // обратное копирование просеянного вдвое массива.
            for i:=istart to imarkercopy-1 do
            begin
                myresplot[i-istart].continity:= myresplotcopy[i].continity;
                myresplot[i-istart].Vx:= myresplotcopy[i].Vx;
                myresplot[i-istart].Vy:= myresplotcopy[i].Vy;
                if (imodelEquation=4) then
                begin
                    myresplot[i-istart].temperature:=myresplotcopy[i].temperature;
                end;
                case imaxUDS of
                 1 : begin
                        myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                     end;
                 2 : begin
                         myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                         myresplot[i-istart].uds2:= myresplotcopy[i].uds2;
                     end;
                 3 : begin
                         myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                         myresplot[i-istart].uds2:= myresplotcopy[i].uds2;
                         myresplot[i-istart].uds3:= myresplotcopy[i].uds3;
                     end;
                 4 : begin
                         myresplot[i-istart].uds1:= myresplotcopy[i].uds1;
                         myresplot[i-istart].uds2:= myresplotcopy[i].uds2;
                         myresplot[i-istart].uds3:= myresplotcopy[i].uds3;
                         myresplot[i-istart].uds4:= myresplotcopy[i].uds4;
                     end;
               end;
            end;
            SetLength(myresplotcopy,1);
         end;


         // табулирование функции -
         // определение максимумов и минимумов.
         rmin:=1e30;
         rmax:=-1e30;
         for i:=0 to imarker-1 do
         begin
             // предотвращение деления на ноль
             if (fabs(myresplot[i].continity)<rzero_level) then
             begin
                myresplot[i].continity:=1.2*rzero_level;
             end;
             if (fabs(myresplot[i].Vx)<rzero_level) then
                   myresplot[i].Vx:=1.2*rzero_level;
             if (fabs(myresplot[i].Vy)<rzero_level) then
                   myresplot[i].Vy:=1.2*rzero_level;
             if (imodelEquation=4) then
             begin
                if (fabs(myresplot[i].temperature)<rzero_level) then
                   myresplot[i].temperature:=1.2*rzero_level;
             end;
             // поиск экстремумов
             if (rmin > log10(fabs(myresplot[i].continity))) then
             rmin:=log10(fabs(myresplot[i].continity));
             if (rmin > log10(fabs(myresplot[i].Vx))) then
             rmin:=log10(fabs(myresplot[i].Vx));
             if (rmin > log10(fabs(myresplot[i].Vy))) then
             rmin:=log10(fabs(myresplot[i].Vy));
             if (imodelEquation=4) then
             begin
                if (rmin > log10(fabs(myresplot[i].temperature))) then
                   rmin:=log10(fabs(myresplot[i].temperature));
             end;
             if (rmax < log10(fabs(myresplot[i].continity))) then
             rmax:=log10(fabs(myresplot[i].continity));
             if (rmax < log10(fabs(myresplot[i].Vx))) then
             rmax:=log10(fabs(myresplot[i].Vx));
             if (rmax < log10(fabs(myresplot[i].Vy))) then
             rmax:=log10(fabs(myresplot[i].Vy));
             if (imodelEquation=4) then
             begin
                if (rmax < log10(fabs(myresplot[i].temperature))) then
                    rmax:=log10(fabs(myresplot[i].temperature));
             end;
             case imaxUDS of
             1 : begin
                 if (fabs(myresplot[i].uds1)<rzero_level) then
                 begin
                    myresplot[i].uds1:=1.2*rzero_level;
                 end;


                 if (rmin > log10(fabs(myresplot[i].uds1))) then
                 rmin:=log10(fabs(myresplot[i].uds1));
                 if (rmax < log10(fabs(myresplot[i].uds1))) then
                 rmax:=log10(fabs(myresplot[i].uds1));

             end;
             2 : begin
                if (fabs(myresplot[i].uds1)<rzero_level) then
                begin
                   myresplot[i].uds1:=1.2*rzero_level;
                end;


                if (rmin > log10(fabs(myresplot[i].uds1))) then
                rmin:=log10(fabs(myresplot[i].uds1));
                if (rmax < log10(fabs(myresplot[i].uds1))) then
                rmax:=log10(fabs(myresplot[i].uds1));

                if (fabs(myresplot[i].uds2)<rzero_level) then
                begin
                   myresplot[i].uds2:=1.2*rzero_level;
                end;


                if (rmin > log10(fabs(myresplot[i].uds2))) then
                rmin:=log10(fabs(myresplot[i].uds2));
                if (rmax < log10(fabs(myresplot[i].uds2))) then
                rmax:=log10(fabs(myresplot[i].uds2));

             end;
             3 : begin
                 if (fabs(myresplot[i].uds1)<rzero_level) then
                 begin
                    myresplot[i].uds1:=1.2*rzero_level;
                 end;


                 if (rmin > log10(fabs(myresplot[i].uds1))) then
                 rmin:=log10(fabs(myresplot[i].uds1));
                 if (rmax < log10(fabs(myresplot[i].uds1))) then
                 rmax:=log10(fabs(myresplot[i].uds1));

                 if (fabs(myresplot[i].uds2)<rzero_level) then
                 begin
                    myresplot[i].uds2:=1.2*rzero_level;
                 end;


                 if (rmin > log10(fabs(myresplot[i].uds2))) then
                 rmin:=log10(fabs(myresplot[i].uds2));
                 if (rmax < log10(fabs(myresplot[i].uds2))) then
                 rmax:=log10(fabs(myresplot[i].uds2));

                 if (fabs(myresplot[i].uds3)<rzero_level) then
                 begin
                    myresplot[i].uds3:=1.2*rzero_level;
                 end;

                 if (rmin > log10(fabs(myresplot[i].uds3))) then
                 rmin:=log10(fabs(myresplot[i].uds3));
                 if (rmax < log10(fabs(myresplot[i].uds3))) then
                 rmax:=log10(fabs(myresplot[i].uds3));


             end;
             4 : begin
                 if (fabs(myresplot[i].uds1)<rzero_level) then
                 begin
                    myresplot[i].uds1:=1.2*rzero_level;
                 end;


                 if (rmin > log10(fabs(myresplot[i].uds1))) then
                 rmin:=log10(fabs(myresplot[i].uds1));
                 if (rmax < log10(fabs(myresplot[i].uds1))) then
                 rmax:=log10(fabs(myresplot[i].uds1));

                 if (fabs(myresplot[i].uds2)<rzero_level) then
                 begin
                    myresplot[i].uds2:=1.2*rzero_level;
                 end;


                 if (rmin > log10(fabs(myresplot[i].uds2))) then
                 rmin:=log10(fabs(myresplot[i].uds2));
                 if (rmax < log10(fabs(myresplot[i].uds2))) then
                 rmax:=log10(fabs(myresplot[i].uds2));

                 if (fabs(myresplot[i].uds3)<rzero_level) then
                 begin
                    myresplot[i].uds3:=1.2*rzero_level;
                 end;


                 if (rmin > log10(fabs(myresplot[i].uds3))) then
                 rmin:=log10(fabs(myresplot[i].uds3));
                 if (rmax < log10(fabs(myresplot[i].uds3))) then
                 rmax:=log10(fabs(myresplot[i].uds3));


                 if (fabs(myresplot[i].uds4)<rzero_level) then
                 begin
                    myresplot[i].uds4:=1.2*rzero_level;
                 end;

                 if (rmin > log10(fabs(myresplot[i].uds4))) then
                 rmin:=log10(fabs(myresplot[i].uds4));
                 if (rmax < log10(fabs(myresplot[i].uds4))) then
                 rmax:=log10(fabs(myresplot[i].uds4));

                end;
             end;
         end;



         // несбалансированные источники массы
         Canvas.Pen.Color:=clBlack;
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if (fabs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[0].continity))-rmin))/(rmax-rmin));
            end
            else
            begin
               iy:=40;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if (fabs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[i-1].continity)) - rmin))/(rmax-rmin));
            end
             else
            begin
               iy:=40;
            end;
            Canvas.LineTo(ix,iy);
         end;

         // горизонтальная скорость
         Canvas.Pen.Color:=RGB(0,0,255); // синий
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if (fabs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[0].Vx))-rmin))/(rmax-rmin));
            end
             else
            begin
               iy:=40;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if (fabs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[i-1].Vx)) - rmin))/(rmax-rmin));
            end
            else
            begin
               iy:=40;
            end;
            Canvas.LineTo(ix,iy);
         end;

          // вертикальная скорость
         Canvas.Pen.Color:=clGreen; // зелёный
         // прорисовка графика:
         ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if (fabs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[0].Vy))-rmin))/(rmax-rmin));
            end
              else
            begin
               iy:=40;
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if (fabs(rmax-rmin)>epsilon) then
            begin
               iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[i-1].Vy)) - rmin))/(rmax-rmin));
            end
              else
            begin
               iy:=40;
            end;
            Canvas.LineTo(ix,iy);
         end;

         if (imodelEquation=4) then
         begin
            // температура
            Canvas.Pen.Color:=clRed;
            // прорисовка графика:
            ix:=25; iy:=0;
            if (imarker > 1) then
            begin
               // чтобы избежать деления на ноль.
               if (fabs(rmax-rmin)>epsilon) then
               begin
               iy:=Height-round(((Height-40)*fabs(log10(fabs(myresplot[0].temperature))-rmin))/(rmax-rmin));
               end
                else
               begin
                 iy:=40;
               end;
            end;
            Canvas.MoveTo(ix,iy);
            istep:=round(Width/(imarker+1));
            for i:=2 to imarker do
            begin
               ix:=25+(i)*istep;
               if (fabs(rmax-rmin)>epsilon) then
               begin
                  iy:=Height-round((Height-40)*fabs((log10(fabs(myresplot[i-1].temperature)) - rmin))/(rmax-rmin));
               end
                else
               begin
                  iy:=40;
               end;
               Canvas.LineTo(ix,iy);
            end;
         end;

         // UDS
         case imaxUDS of
         1 : begin
                // прорисовка графика:
                Canvas.Pen.Color:=clMaroon; // цвет графика
                ix:=25; iy:=0;
                if (imarker > 1) then
                begin
                   // чтобы избежать деления на ноль.
                   if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon))  then
                   begin
                      iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
                   end;
                end;
                Canvas.MoveTo(ix,iy);
                istep:=round(Width/(imarker+1));
                for i:=2 to imarker do
                begin
                   ix:=25+(i)*istep;
                   if ((fabs(rmax-rmin)>epsilon)  and (fabs(myresplot[i-1].uds1)>epsilon)) then
                   begin
                      iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
                   end;
                   Canvas.LineTo(ix,iy);
                end;
             end;
         2 : begin
                // прорисовка графика:
                Canvas.Pen.Color:=clMaroon; // цвет графика
                ix:=25; iy:=0;
                if (imarker > 1) then
                begin
                   // чтобы избежать деления на ноль.
                   if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon)) then
                   begin
                      iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
                   end;
                end;
                Canvas.MoveTo(ix,iy);
                istep:=round(Width/(imarker+1));
                for i:=2 to imarker do
                begin
                   ix:=25+(i)*istep;
                   if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds1)>epsilon)) then
                   begin
                      iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
                   end;
                   Canvas.LineTo(ix,iy);
                end;
                // прорисовка графика:
                Canvas.Pen.Color:=clOlive; // цвет графика
                ix:=25; iy:=0;
                if (imarker > 1) then
                begin
                   // чтобы избежать деления на ноль.
                   if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds2)>epsilon)) then
                   begin
                      iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds2))-rmin)/(rmax-rmin));
                   end;
                end;
                Canvas.MoveTo(ix,iy);
                istep:=round(Width/(imarker+1));
                for i:=2 to imarker do
                begin
                   ix:=25+(i)*istep;
                   if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds2)>epsilon)) then
                   begin
                      iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds2)) - rmin)/(rmax-rmin));
                   end;
                   Canvas.LineTo(ix,iy);
                end;
             end;
         3 : begin
                 Canvas.Pen.Color:=clMaroon; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
                 Canvas.Pen.Color:=clOlive; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds2))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds2)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
                 Canvas.Pen.Color:=clNavy; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds3)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds3))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds3)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds3)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
         end;
         4 : begin
                 Canvas.Pen.Color:=clMaroon; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds1))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds1)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds1)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
                 Canvas.Pen.Color:=clOlive; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds2))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds2)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds2)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
                 Canvas.Pen.Color:=clNavy; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds3)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds3))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds3)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds3)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
         Canvas.Pen.Color:=clPurple; // цвет графика
                 ix:=25; iy:=0;
         if (imarker > 1) then
         begin
            // чтобы избежать деления на ноль.
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[0].uds4)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[0].uds4))-rmin)/(rmax-rmin));
            end;
         end;
         Canvas.MoveTo(ix,iy);
         istep:=round(Width/(imarker+1));
         for i:=2 to imarker do
         begin
            ix:=25+(i)*istep;
            if ((fabs(rmax-rmin)>epsilon) and (fabs(myresplot[i-1].uds4)>epsilon)) then
            begin
               iy:=Height-round((Height-40)*(log10(fabs(myresplot[i-1].uds4)) - rmin)/(rmax-rmin));
            end;
            Canvas.LineTo(ix,iy);
         end;
             end;
         end;

      end;

    end;
    end // end Residual.
     else
    begin
       // очистка фона белым
       with MainPaintBox do
       begin
          w:=Width; // ширина в пикселах
          h:=Height div 25;  // высота в пикселах

          // Градиентная заливка.
          Canvas.Brush.Color:=RGB(250,255,255);
          Canvas.Pen.Color:=RGB(250,255,255);
          Canvas.Rectangle(0,24*h,w,Height);
          for i:=24 downto 1 do
          begin
             if (i<>1) then
             begin
                Canvas.Brush.Color:=RGB(130+i*5,255,255);
                Canvas.Pen.Color:=RGB(130+i*5,255,255);
             end
              else
             begin
                Canvas.Brush.Color:=RGB(135,250,255);
                Canvas.Pen.Color:=RGB(135,250,255);
             end;
             Canvas.Rectangle(0,(i-1)*h,w,i*h);
          end;
          // сейчас установлен голубой цвет фона
       end;
    end;
end;

// Второй способ мониторинга сходимости отслеживать
// эволюцию рассчитываемых величин.
// index :
// 0 - вернуть объём расчётной области,
// 1 - вернуть максимум UDS1,
// 2 - вернуть максимум UDS2,
// 3 - вернуть максимум UDS3,
// 4 - вернуть максимум UDS4,
// 5 - вернуть минимум UDS1,
// 6 - вернуть минимум UDS2,
// 7 - вернуть минимум UDS3,
// 8 - вернуть минимум UDS4,
// 9 - вернуть Volume Integral UDS1,
// 10 - вернуть Volume Integral UDS2,
// 11 - вернуть Volume Integral UDS3,
// 12 - вернуть Volume Integral UDS4,
// 13 - вернуть сумму UDS1,
// 14 - вернуть сумму UDS2,
// 15 - вернуть сумму UDS3,
// 16 - вернуть сумму UDS4,
// 17 - вернуть Volume Average UDS1,
// 18 - вернуть Volume Average UDS2,
// 19 - вернуть Volume Average UDS3,
// 20 - вернуть Volume Average UDS4,
// 21 - 30 MAX Custom Field Functions,
// 31 - 40 MIN Custom Field Functions,
// 41 - 50 Volume Integral Custom Field Functions,
// 51 - 60 Sum Custom Field Functions,
// 61 - 70 Volume-Average Custom Field Functions.
function TForm1.getVolumeMonitor(index : Integer) : Float;
var
   r, max, min, r1 : Float;
   k : Integer;
   fex : T2myDynArray;
begin
   if (index>20) then
   begin
       // Custom Field Functions
       SetLength(fex,10);
       for k:=0 to 9 do
       begin
          SetLength(fex[k],inx*iny+1);
       end;

       // Вычисляет всё необходимое.
       getreadycalc(fex);
   end;



   r:=0.0;
   r1:=0.0;
   max:=-1.0e+30;
   min:=1.0e+30;
   case index of
     0 : begin
            // Объём расчётной области.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+mapPT[k].dV;
               end;
            end;
         end;
    1 : begin
            // максимум UDS1.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  max:=maxoper(max,UDS1[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=max;
         end;
    2 : begin
            // максимум UDS2.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  max:=maxoper(max,UDS2[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=max;
         end;
    3 : begin
            // Максимум UDS3.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  max:=maxoper(max,UDS3[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=max;
        end;
    4 : begin
            // Максимум UDS4.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  max:=maxoper(max,UDS4[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=max;
        end;
    5 : begin
            // минимум UDS1.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  min:=fmin(min,UDS1[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=min;
         end;
    6 : begin
            // минимум UDS2.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  min:=fmin(min,UDS2[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=min;
         end;
    7 : begin
            // минимум UDS3.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  min:=fmin(min,UDS3[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=min;
        end;
    8 : begin
            // минимум UDS4.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  min:=fmin(min,UDS4[mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=min;
        end;
    9 : begin
            // Volume Integral UDS1.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS1[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
               end;
            end;
        end;
    10 : begin
            // Volume Integral UDS2.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS2[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
               end;
            end;
        end;
    11 : begin
            // Volume Integral UDS3.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS3[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
               end;
            end;
        end;
    12 : begin
            // Volume Integral UDS4.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS4[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
               end;
            end;
        end;
     13 : begin
            // Sum UDS1.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS1[mapPT[k].i+(mapPT[k].j-1)*inx];
               end;
            end;
        end;
     14 : begin
            // Sum UDS2.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS2[mapPT[k].i+(mapPT[k].j-1)*inx];
               end;
            end;
        end;
     15 : begin
            // Sum UDS3.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS3[mapPT[k].i+(mapPT[k].j-1)*inx];
               end;
            end;
        end;
     16 : begin
            // Sum UDS4.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS4[mapPT[k].i+(mapPT[k].j-1)*inx];
               end;
            end;
        end;
     17 : begin
            // Volume Average UDS1.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS1[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
                  r1:=r1+mapPT[k].dV;
               end;
            end;
            r:=r/r1;
        end;
     18 : begin
            // Volume Average UDS2.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS2[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
                  r1:=r1+mapPT[k].dV;
               end;
            end;
            r:=r/r1;
        end;
     19 : begin
            // Volume Average UDS3.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS3[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
                  r1:=r1+mapPT[k].dV;
               end;
            end;
            r:=r/r1;
        end;
     20 : begin
            // Volume Average UDS4.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+UDS4[mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
                  r1:=r1+mapPT[k].dV;
               end;
            end;
            r:=r/r1;
        end;
     21, 22, 23, 24, 25, 26, 27, 28, 29, 30 :
         begin
            // максимум fex.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  max:=maxoper(max,fex[index-21][mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=max;
         end;
      31, 32, 33, 34, 35, 36, 37, 38, 39, 40 :
         begin
            // минимум fex.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  min:=fmin(min,fex[index-31][mapPT[k].i+(mapPT[k].j-1)*inx]);
               end;
            end;
            r:=min;
         end;
      41, 42, 43, 44, 45, 46, 47, 48, 49, 50 :
       begin
            // Volume Integral fex.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+fex[index-41][mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
               end;
            end;
        end;
       51, 52, 53, 54, 55, 56, 57, 58, 59, 60 :
       begin
            // Sum fex.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+fex[index-51][mapPT[k].i+(mapPT[k].j-1)*inx];
               end;
            end;
        end;
        61, 62, 63, 64, 65, 66, 67, 68, 69, 70 :
         begin
            // Volume Average fex.
            for k:=1 to imaxnumbernode do
            begin
               if (mapPT[k].itype<>0) then
               begin
                  r:=r+fex[index-61][mapPT[k].i+(mapPT[k].j-1)*inx]*mapPT[k].dV;
                  r1:=r1+mapPT[k].dV;
               end;
            end;
            r:=r/r1;
        end;
   end;


   getVolumeMonitor:=r;
end;

// графики невязок
procedure TForm1.FormPaint(Sender: TObject);
begin
   updatemainpaintbox; // прорисовка графиков невязок
end;

// вызывает меню, где можно задать структуру одной итерации
// алгоритма SIMPLE
procedure TForm1.SIMPLE1Click(Sender: TObject);
begin
   controlSimpletune;
end;  // структура одной итерации алгоритма SIMPLE

// настройка параметров с которыми решается
// уравнение для поправки давления
procedure TForm1.Pressure1Click(Sender: TObject);
begin
   // инициализация:
   if (bPatankarPressure) then
     PamendmendcontrolForm.RadioGroup1.ItemIndex:=0
    else
     PamendmendcontrolForm.RadioGroup1.ItemIndex:=1;

    if (bipifixpamendment) then
        PamendmendcontrolForm.CheckBoxipifixpamendment.Checked:=true
      else
        PamendmendcontrolForm.CheckBoxipifixpamendment.Checked:=false;
        
   // задание параметров решения уравнения
   // для поправки давления.
   PamendmendcontrolForm.ShowModal;
end;

// осуществляет инициализацию
// искомых величин
procedure TForm1.initialize2Click(Sender: TObject);
begin
   Initializationtune;
end;  // задание параметров инициализации искомых величин перед началом расчёта

// инициализирует решение в VOF методе и не только
procedure TForm1.patchtune;
begin
   // инициализация
   PatchForm.Llen.Caption:=FloatToStr(dLx);
   PatchForm.Lhight.Caption:=FloatToStr(dLy);
   // вызов модального диалога.
   PatchForm.ShowModal; // вызов формы для дальнейшей инициализации
end;

// инициализирует решение в VOF методе и не только
procedure TForm1.Patch1Click(Sender: TObject);
begin
   patchtune;
end;

// плотность
function TForm1.density(ipi : Integer) : Float;
var
    res : Float; // возвращаемый результат
begin
   if (imodelEquation<5) then
   begin
     (*
      if ((ipi<1)or(ipi>inx*iny)) then
      begin
        Application.MessageBox('плотность вышла за границы.','warning',MB_Ok);
      end;
      *)
      // всё кроме VOF метода
      res:=matprop[0].drho;
      //res:=UDM1[ipi];
   end
    else
   begin
      // matprop[1] - water,
      // marprop[0] - air;
      VOF[ipi]:=fmax(0.0,fmin(1.0,VOF[ipi]));
      // для VOF метода
      //res:=matprop[1].drho*VOF[ipi]+(1.0-VOF[ipi])*matprop[0].drho;
      res:=1.0/((VOF[ipi]/matprop[1].drho)+((1.0-VOF[ipi])/matprop[0].drho));
   end;
   Result:=res;
end; // возвращает текущую плотность

// динамическая вязкость
function TForm1.viscosity(ipi : Integer) : Float;
var
    res : Float; // возвращаемый результат
begin
   if (imodelEquation<5) then
   begin
      (*
      if ((ipi<1)or(ipi>inx*iny)) then
      begin
        Application.MessageBox('вязкость вышла за границы.','warning',MB_Ok);
      end;
      *)
      // всё кроме VOF метода
      res:=dmu[ipi]; // переменная динамическая вязкость
      //res:=UDM1[ipi];
   end
    else
   begin
      // matprop[1] - water,
      // marprop[0] - air;
      VOF[ipi]:=fmax(0.0,fmin(1.0,VOF[ipi]));
      // для VOF метода
      //res:=matprop[1].dmu*VOF[ipi]+(1.0-VOF[ipi])*matprop[0].dmu;
       res:=1.0/((VOF[ipi]/matprop[1].dmu)+((1.0-VOF[ipi])/matprop[0].dmu));
   end;
   Result:=res;
end; // возвращает текущую динамическую вязкость

// решение уравнения для давления
procedure TForm1.SolveGZPressure(bipifix : Boolean); // фиксировать ли уровень давления  ?
const
      epsilon = 1e-37; // для предотвращения деления на ноль
var
   // значение коэффициентов дискретного аналога на пятиточечном шаблоне
   mp : array of MatrixCoef; // коэффициенты дискретного аналога для давления
   mu : array of MatrixCoef; // К.Д.А. для горизонтальных компонент скорости
   mv : array of MatrixCoef; // К.Д.А. для вертикальных компонент скорости
   db : array of  Float; // коэффициенты источникового члена
   dbu, dbv : array of Float; // правая часть для горизонтальной и вертикальной скоростей.
   //iei, iwi, ini, isi, ipi : Integer; // номера узлов на пятиточечном шаблоне
   ipifix : Integer; // точка в которой фиксирован уровень давления
   iecvi, iwcvi, incvi, iscvi : Integer; // номера узлов для граней граней контрольного объёма
   iecvi1, iwcvi1, incvi1, iscvi1 : Integer; // для  скорости
   Uw_cup, Ue_cup, Vs_cup, Vn_cup: Float; // псевдоскорости
   i1,j1,k,k1 : Integer;
   myrP : array of  Float; // невязка для  давления
   // следующая переменная используется для сверхрелаксации
   Ptilda :  Float; // новое приближение i-ой компоненты поправки давления
   deviation :  Float; // критерий выхода из цикла
   dapvel, rhointerpol :  Float;
   bnei, bvisit : Boolean;
   rbuf : Float; // для того чтобы избежать деления на ноль
   bcalc : array [1..4] of Boolean;
   bvelocityinlet : Boolean; // на границе задана нормальная компонента скорости.
   residual_history: array of  Float; // история изменения невязки.
   bflagconstruct : Boolean;
   Aseqx, Aseqy : TPeacemanRachford;

function fabs(r : Float) : Float;
begin
   if (r<0.0) then
   begin
      fabs:=-r;
   end
    else
   begin
      fabs:=r;
   end;
end;

begin

   bflagconstruct:=True;
   // если передаваемый параметр bipifix = true, то нужно фиксировать уровень  давления
   // на нулевом уровне, иначе если bipifix = false, то  давление само будет искать свой уровень.
   // Когда давление само ищет свой уровень, то это может означать более быструю сходимость,
   // т.к. отсутствует точка ipifix в центре расчётной области которая всё портит.
   // Однако для прямого методаисключения Гаусса фиксировать точку ipifix обязательно.

   // выделение памяти
   SetLength(mp,mzapas*inx*iny+1); // массив коэффициентов
   SetLength(mu,mzapas*(inx-1)*iny+1); // Vx coef
   SetLength(mv,mzapas*inx*(iny-1)+1); // Vy coef
   SetLength(db,mzapas*inx*iny+1); // коэффициенты связанные с наличием источникового члена
   SetLength(dbu,mzapas*(inx-1)*iny+1);
   SetLength(dbv,mzapas*inx*(iny-1)+1);
   // Вычисление коэффициентов матрицы СЛАУ для компонент скорости в данном случае
   // надо производить особым образом, а именно исключить в источниковом члене перепад давления,
   // Также повидимому не слдует учитывать влияние коэффициента нижней релаксации для Momentum !.
   // поэтому мы передаёём параметр bPressureSimpler=true.
   VxGlobalCoef(mu,dbu,true);
   VyGlobalCoef(mv,dbv,true);
   SetLength(myrP,inx*iny+1); // выделение памяти под невязку
   ipifix:=(inx div 2)+((iny div 2)-1)*inx;  // фиксированная точка где-то в центре расчётной области
   while (mapPT[ipifix].itype <> 1) do inc(ipifix); // точка именно внутренняя

   // предварительное вычисление индексов чтобы не тратить время на умножения на icolx.
    for k1:=1 to imaxnumbernode do
      begin
         with mapPT[k1] do
         begin
               // внутренний узел

               // координаты узлов для поправки давления
               // используется обыкновенная сетка
               ini:=i+j*inx; // север
               isi:=i+(j-2)*inx; // юг
               iwi:=(i-1)+(j-1)*inx; // запад
               iei:=(i+1)+(j-1)*inx; // восток
               ipi:=i+(j-1)*inx;  // текущая точка
         end;
      end;

   // инициализация.
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         // инициализация значений переменных
         //ipi:=i1+(j1-1)*inx;  // текущая точка
         // нулевыми значениями
         db[ipi]:=0.0;
         mp[ipi].dae:=0.0;
         mp[ipi].daw:=0.0;
         mp[ipi].dan:=0.0;
         mp[ipi].das:=0.0;
         mp[ipi].dap:=1.0; // т.к. на эту точку возможно деление
         myrP[ipi]:=0.0; // обнуление невязки
      end;
   end;


   // вычисление коэффициентов в уравнении для давления
   for k1:=1 to imaxnumbernode do
   begin
      with mapPT[k1] do
      begin
         if (itype = 1) then
         begin
            // внутренний узел

            bvisit:=false; // если true то здесь задаётся давление

            // координаты узлов для давления
            // используется обыкновенная сетка
            //ipi:=i+(j-1)*inx;  // текущая точка
            //iei:=(i+1)+(j-1)*inx; // восток
            //iwi:=(i-1)+(j-1)*inx; // запад
            //ini:=i+(j)*inx; // север
            //isi:=i+(j-2)*inx; // юг
            // для скоростей на гранях контрольного объёма
            iecvi:=i+(j-1)*(inx-1); // в массиве Vx
            iwcvi:=(i-1)+(j-1)*(inx-1); // горизонтальных точек на одну меньше
            incvi:=i+(j-1)*inx; // в масиве Vy горизонтальных точек столько же,
            iscvi:=i+(j-2)*inx; // а вертикальных на одну меньше
            // в уравнении для  давления
            // потребовались коэффициенты для компонент скорости
            // Поэтому для данного куска кода (где вычисляются коэффициенты дискретного аналога)
            // требуется покрайней мере в четыре раза больший объём вычислений
            // чем для уравнений для компонент скорости или температуры.
            // Здесь граничные коэффициенты дискретного аналога обнуляюся
            // и физически это означает, что граничные значения не влияют
            // на поле давления внутри расчётной области.
            // По этому поводу см. Патанкар ст. 108, 109.


            // в линейной струкруре карты mapPT
            // ориентация по сторонам света
            // юг, север, восток и запад происходит
            // всё по тем же правилам
            rhointerpol:=densuty_in_surface(ipi,iei);
            if (mapPT[iei].itype <> 2) then
            begin
               // если северная точка не является граничной
               dapvel:=Vcoefpam(i,j,1); // Vxcoef
               //mp[ipi].dae:=rhointerpol*dy*dy/dapvel;
               mp[ipi].dae:=dy*dy/dapvel/rhointerpol;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[iei].iboundary, 'P',mapPT[iei].chnormal);
               if (not(bnei)) then
               begin
                   // давление принимает заданное значение
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].dae:=0; // нет влияния от давления на границе
               end;
           end;

           rhointerpol:=densuty_in_surface(ipi,iwi);
           if (mapPT[iwi].itype <> 2) then
           begin
              // если южная точка не является граничной
              dapvel:=Vcoefpam(i-1,j,1); // Vxcoef
              //mp[ipi].daw:=rhointerpol*dy*dy/dapvel;
              mp[ipi].daw:=dy*dy/dapvel/rhointerpol;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[iwi].iboundary, 'P',mapPT[iwi].chnormal);
              if (not(bnei)) then
              begin
                  // давление принимает заданное значение
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].daw:=0.0; // нет влияния от давления на границе
              end;
           end;



           rhointerpol:=densuty_in_surface(ipi,ini);
           if (mapPT[ini].itype <> 2) then
           begin
              // если северная точка не является граничной
              dapvel:=Vcoefpam(i,j,2); // Vycoef
              //mp[ipi].dan:=rhointerpol*dx*dx/dapvel;
              mp[ipi].dan:=dx*dx/dapvel/rhointerpol;
           end
            else
           begin
              // Граничные точки не оказывают никакого влияния
              bnei:=GridGenForm.isneiman(mapPT[ini].iboundary, 'P', mapPT[ini].chnormal);
              if (not(bnei)) then
              begin
                  // давление принимает заданное значение
                 bvisit:=true;
              end
               else
              begin
                 mp[ipi].dan:=0; // нет влияния граничных условий
              end;
            end;

            rhointerpol:=densuty_in_surface(ipi,isi);
            if (mapPT[isi].itype <> 2) then
            begin
               // если южная точка не является граничной
               dapvel:=Vcoefpam(i,j-1,2); // Vycoef
               //mp[ipi].das:=rhointerpol*dx*dx/dapvel;
               mp[ipi].das:=dx*dx/dapvel/rhointerpol;
            end
             else
            begin
               // Граничные точки не оказывают никакого влияния
               bnei:=GridGenForm.isneiman(mapPT[isi].iboundary, 'P',mapPT[isi].chnormal);
               if (not(bnei)) then
               begin
                   // давление принимает заданное значение
                  bvisit:=true;
               end
                else
               begin
                  mp[ipi].das:=0; // нет влияния граничных значений
               end;
            end;

            if (bvisit) then
            begin
               // давление принимает заданное значение
               mp[ipi].dap:=1.0;
               db[ipi]:=P[ipi];
               mp[ipi].dae:=0.0;
               mp[ipi].daw:=0.0;
               mp[ipi].dan:=0.0;
               mp[ipi].das:=0.0;
            end
             else
            begin
               mp[ipi].dap:= mp[ipi].dae + mp[ipi].daw + mp[ipi].dan + mp[ipi].das;
               if (False and btimedepend) then
               begin
                  // нестационарный.
                  db[ipi]:=(DensityOldTimeStep[ipi]-density(ipi))*dV/dTimeStep;
               end
                else
               begin
                  db[ipi]:=0.0; // стационарный.
               end;


               //rhointerpol:=densuty_in_surface(ipi,iwi);
               // 1..(inx-1)*iny
               for i1:=1 to 4 do bcalc[i1]:=false;
               iecvi1:=(i)+(j-1)*(inx-1);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx-1)*(iny))) then bcalc[1]:=true;
               iwcvi1:=(i-2)+(j-1)*(inx-1);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx-1)*(iny))) then bcalc[2]:=true;
               incvi1:=(i-1)+(j)*(inx-1);    // север
               if ((incvi1>=1) and (incvi1<=(inx-1)*(iny))) then bcalc[3]:=true;
               iscvi1:=(i-1)+(j-2)*(inx-1);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx-1)*(iny))) then bcalc[4]:=true;
               // вычислим псевдоскорость
               rbuf:=0.0; // инициализация
               if (bcalc[1]) then rbuf:=rbuf+mu[iwcvi].dae*Vx[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mu[iwcvi].daw*Vx[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mu[iwcvi].dan*Vx[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mu[iwcvi].das*Vx[iscvi1];
               rbuf:=rbuf+dbu[iwcvi];
               if (fabs(rbuf)<epsilon) then
               begin
                  Uw_cup:=0.0;
               end
                else
               begin
                  Uw_cup:=rbuf/mu[iwcvi].dap;
               end;
               //db[ipi]:=db[ipi] + rhointerpol*Uw_cup*dy; // на основе псевдоскорости.
               db[ipi]:=db[ipi] + Uw_cup*dy;

               //rhointerpol:=densuty_in_surface(ipi,iei);
               // 1..(inx-1)*iny
               for i1:=1 to 4 do bcalc[i1]:=false;
               iecvi1:=(i+1)+(j-1)*(inx-1);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx-1)*(iny))) then bcalc[1]:=true;
               iwcvi1:=(i-1)+(j-1)*(inx-1);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx-1)*(iny))) then bcalc[2]:=true;
               incvi1:=(i)+(j)*(inx-1);    // север
               if ((incvi1>=1) and (incvi1<=(inx-1)*(iny))) then bcalc[3]:=true;
               iscvi1:=(i)+(j-2)*(inx-1);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx-1)*(iny))) then bcalc[4]:=true;
               // вычислим псевдоскорость
               rbuf:=0.0; // инициализация
               if (bcalc[1]) then rbuf:=rbuf+mu[iecvi].dae*Vx[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mu[iecvi].daw*Vx[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mu[iecvi].dan*Vx[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mu[iecvi].das*Vx[iscvi1];
               rbuf:=rbuf+dbu[iecvi];
               if (fabs(rbuf) < epsilon) then
               begin
                  Ue_cup:=0.0;
               end
                else
               begin
                  Ue_cup:=rbuf/mu[iecvi].dap;
               end;
               //db[ipi]:=db[ipi] - rhointerpol*Ue_cup*dy; // на основе псевдоскорости
                db[ipi]:=db[ipi] - Ue_cup*dy;

               //rhointerpol:=densuty_in_surface(ipi,isi);
               // 1..(inx)*(iny-1)
               for i1:=1 to 4 do bcalc[i1]:=false;
               iecvi1:=(i+1)+(j-2)*(inx);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx)*(iny-1))) then bcalc[1]:=true;
               iwcvi1:=(i-1)+(j-2)*(inx);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx)*(iny-1))) then bcalc[2]:=true;
               incvi1:=(i)+(j-1)*(inx);    // север
               if ((incvi1>=1) and (incvi1<=(inx)*(iny-1))) then bcalc[3]:=true;
               iscvi1:=(i)+(j-3)*(inx);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx)*(iny-1))) then bcalc[4]:=true;
               rbuf:=0.0;
               if (bcalc[1]) then rbuf:=rbuf+mv[iscvi].dae*Vy[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mv[iscvi].daw*Vy[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mv[iscvi].dan*Vy[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mv[iscvi].das*Vy[iscvi1];
               rbuf:=rbuf+dbv[iscvi];
               if (fabs(rbuf) < epsilon) then
               begin
                  Vs_cup:=0.0;
               end
                else
               begin
                  Vs_cup:=rbuf/mv[iscvi].dap;
               end;
               //db[ipi]:=db[ipi] + rhointerpol*Vs_cup*dx; // на основе псевдоскорости
                 db[ipi]:=db[ipi] + Vs_cup*dx;

               //rhointerpol:=densuty_in_surface(ipi,ini);
               // 1..(inx)*(iny-1)
               for i1:=1 to 4 do bcalc[i1]:=false;
               iecvi1:=(i+1)+(j-1)*(inx);    // восток
               if ((iecvi1>=1) and (iecvi1<=(inx)*(iny-1))) then bcalc[1]:=true;
               iwcvi1:=(i-1)+(j-1)*(inx);  // запад
               if ((iwcvi1>=1) and (iwcvi1<=(inx)*(iny-1))) then bcalc[2]:=true;
               incvi1:=(i)+(j)*(inx);    // север
               if ((incvi1>=1) and (incvi1<=(inx)*(iny-1))) then bcalc[3]:=true;
               iscvi1:=(i)+(j-2)*(inx);  // юг
               if ((iscvi1>=1) and (iscvi1<=(inx)*(iny-1))) then bcalc[4]:=true;
               rbuf:=0.0;
               if (bcalc[1]) then rbuf:=rbuf+mv[incvi].dae*Vy[iecvi1];
               if (bcalc[2]) then rbuf:=rbuf+mv[incvi].daw*Vy[iwcvi1];
               if (bcalc[3]) then rbuf:=rbuf+mv[incvi].dan*Vy[incvi1];
               if (bcalc[4]) then rbuf:=rbuf+mv[incvi].das*Vy[iscvi1];
               rbuf:=rbuf+dbv[incvi];
               if (fabs(rbuf)<epsilon) then
               begin
                  Vn_cup:=0.0;
               end
                else
               begin
                  Vn_cup:=rbuf/mv[incvi].dap;
               end;
               //db[ipi]:=db[ipi] - rhointerpol*Vn_cup*dx; // на основе псевдоскорости
               db[ipi]:=db[ipi] - Vn_cup*dx;

            end;
         end;
      end; // with
   end;

   SetLength(residual_history,iterSimple.iterPressure+1);

   case ilanguage of
    0 : begin
       // Язык Паскаль.

       if (itypesolver.ipamendment=1) then
       begin
          // Солвер Гаусса-Зейделя.


          // теперь когда все коэффициенты вычислены
          // можно приступить к решению.
          deviation:=1e300; // очень большое число
          k:=1;


          while ((deviation > rcs.Pressure) and (k<=iterSimple.iterPressure)) do
          begin
             for k1:=1 to imaxnumbernode do
             begin
                with mapPT[k1] do
                begin
                   if (itype = 1) then
                   begin
                      // внутренний узел

                      // координаты узлов для поправки давления
                      // используется обыкновенная сетка
                      //ini:=i+j*inx; // север
                      //isi:=i+(j-2)*inx; // юг
                      //iwi:=(i-1)+(j-1)*inx; // запад
                      //iei:=(i+1)+(j-1)*inx; // восток
                      //ipi:=i+(j-1)*inx;  // текущая точка
                      // здесь может быть деление на ноль, его надо исключить
                      if (abs(mp[ipi].dap) > 1e-300) then
                      begin
                         // здесь гарантировно нет деления на ноль
                         if ((bipifix) and (ipi=ipifix)) then
                         begin
                            P[ipifix]:=0.0; // фиксируем уровень
                         end
                          else
                         begin
                            // Сверхрелаксация с коэффициентом 1.9 убрана, т.к.
                            // по-моему, препятствует сходимости вычислительного
                            // процесса: невязки уменьшаются до определённого значения,
                            // скажем 1e-5 и дальше не падают.
                            // Если убрать какую-бы то ни было релаксацию и оставить
                            // чистого Гаусса-Зейделя то сходимость гарантирована.
                            // Здесь оставлен чистый Гаусс-Зейдель (соответствует значению 1.0).
                            Ptilda:=(mp[ipi].dae*P[iei]+mp[ipi].daw*P[iwi]+mp[ipi].dan*P[ini]+mp[ipi].das*P[isi]+db[ipi])/mp[ipi].dap;
                            // исходя из физического смысла давление ничем не ограничено оно должно быть таким какое получается
                            // в результате итерирования.
                            // Никакой сверх релаксации тоже быть не должно.
                            P[ipi]:=Ptilda;
                         end;
                       end;
                   end; // проход по
                end; // with
             end; // внутренним точкам

             // для существенного ускорения
             // времени счёта невязка будет вычисляться
             // каждую 0.5*(inx+iny) итерацию солвера Гаусса и Зейделя.
             // Время вычисления невязки равно времени одной итерации Г-З
             if (((2*k) mod (inx+iny)) = 0) then
             begin
                // отслеживаем невязку
                for k1:=1 to imaxnumbernode do
                begin
                   with (mapPT[k1]) do
                   begin
                      if (itype = 1) then
                      begin
                         // внутренний узел

                         // используется обыкновенная сетка
                         //ipi:=i+(j-1)*inx;  // текущая точка
                         if ((bipifix) and (ipi = ipifix)) then
                         begin
                            myrP[ipifix]:=0.0; // одно уравнение выполняется точно
                         end
                          else
                         begin
                            //ini:=i+j*inx; // север
                            //isi:=i+(j-2)*inx; // юг
                            //iwi:=(i-1)+(j-1)*inx; // запад
                            //iei:=(i+1)+(j-1)*inx; // восток
                            myrP[ipi]:=mp[ipi].dae*P[iei];
                            myrP[ipi]:=myrP[ipi]+mp[ipi].daw*P[iwi];
                            myrP[ipi]:=myrP[ipi]+mp[ipi].dan*P[ini];
                            myrP[ipi]:=myrP[ipi]+mp[ipi].das*P[isi];
                            myrP[ipi]:=myrP[ipi]+db[ipi]-mp[ipi].dap*P[ipi];
                         end;
                      end;
                   end; // with
                end;


                // проверка того насколько точно выполняется
                // дискретный аналог
                case ibasenorma of
                  1 : // евклидова норма
                    begin
                       // насколько точно выполняется дискретный аналог
                       deviation:=myEvklidNorma(myrP,inx,iny);
                    end;
                  2 : // кубическая
                    begin
                       // насколько точно выполняется дискретный аналог
                       deviation:=mySupNorma(myrP,inx,iny);
                    end;
                  3 : // октаэдрическая
                    begin
                       // насколько точно выполняется дискретный аналог
                       deviation:=mySup2Norma(myrP,inx,iny);
                    end;
                end;

                //freport.Add(FloatToStr(deviation));
             end;

             k:=k+1; // переход к следующей итерации
          end; // k

       end
        else
       begin
          // метод переменных направлений Писмена и Речфорда 1955.

          k:=1;
          deviation:=1e300;
          while ((deviation > rcs.Pressure) and (k <= iterSimple.iterPressure)) do
          begin
             // одна итерация методом переменных направлений
             // для поля температур и граничных условий первого рода
             TDMAGibridGZUniversal(P,inx,iny, mapPT, 'P',mp, db, Aseqx, Aseqy, bflagconstruct);
             bflagconstruct:=False;
             if (((2*k) mod (inx+iny)) = 0 ) then
             begin
                deviation:=myResidual(P, myrP, inx, iny, mapPT, 'P', mp, db);
             end;
             inc(k); // переход к следующей итерации
          end;

       end;

        end;
    1 : begin
           // Язык Си

          if ((itypesolver.ipamendment=4) and ((inx>4) and (iny>4))) then
          begin
             // только на сетке большей 4x4.

             // метод сопряжённых градиентов для давления и поправки давления.
             cg_pressure(rcs.Pressure,
							 iterSimple.iterPressure,
							 imaxnumbernode,
							 inx, iny,
							 bipifix,
						   ipifix,
							 ibasenorma,
							 @mp,
							 @mapPT,
							 @P,
							 @db,
							 @myrP,
							 @residual_history, // история изменеия невязок
							 itypesorter,
               @pointerlist_gl,
               @pointerlistrevers_gl,
               bconstr,0);
          end
           else if ((itypesolver.ipamendment=5) and ((inx>4) and (iny>4))) then
          begin
             // только на сетке большей 4x4.

             // метод BiCGStab Ван Дер Ворста для давления и поправки давления.
             cg_pressure(rcs.Pressure,
							 iterSimple.iterPressure,
							 imaxnumbernode,
							 inx, iny,
							 bipifix,
						   ipifix,
							 ibasenorma,
							 @mp,
							 @mapPT,
							 @P,
							 @db,
							 @myrP,
							 @residual_history, // история изменеия невязок
							 itypesorter,
               @pointerlist_gl,
               @pointerlistrevers_gl,
               bconstr,1);
          end
           else
          begin
             // солвер Гаусса-Зейделя.

           seidel_pressure(rcs.Pressure,
							iterSimple.iterPressure,
							imaxnumbernode,
              inx, iny,
							bipifix,
						  ipifix,
							ibasenorma,
							@mp,
							@mapPT,
							@P,
							@db,
							@myrP,
              1.0);

           end;

        end;
    2 : begin

           // Язык Си с добавлением OpenMP
           seidel_pressure_omp(rcs.Pressure,
							iterSimple.iterPressure,
							imaxnumbernode,
              inx, iny,
							bipifix,
						  ipifix,
							ibasenorma,
							@mp,
							@mapPT,
							@P,
							@db,
							@myrP,
              ig_nNumberOfThreads,
              1.0);

        end;
   end;

   // Восстановим значения давления находящиеся вне расчётной области.
    for k:=1 to imaxnumbernode do
      begin
         with (mapPT[k]) do
         begin
            if (itype=2) then
            begin
               ipi:=i+(j-1)*inx;  // текущая точка

               case iugol of
                 0 : begin
                        // Неугловая и нужно снести поправку на границу области.
                        case chnormal of
                           'N' : begin
                                    P[ipi]:=P[i+(j-1+1)*inx];
                                 end;
                           'S' : begin
                                    P[ipi]:=P[i+(j-1-1)*inx];
                                 end;
                           'W' : begin
                                    P[ipi]:=P[i-1+(j-1)*inx];
                                 end;
                           'E' : begin
                                    P[ipi]:=P[i+1+(j-1)*inx];
                                 end;
                        end;
                     end;
                 1 : begin
                        // левый нижний угол.
                        P[ipi]:=0.5*(P[i+1+(j-1)*inx]+P[i+(j-1+1)*inx]);
                     end;
                 2 : begin
                        // правый нижний угол.
                        P[ipi]:=0.5*(P[i-1+(j-1)*inx]+P[i+(j-1+1)*inx]);
                     end;
                 3 : begin
                        // левый верхний угол.
                        P[ipi]:=0.5*(P[i+1+(j-1)*inx]+P[i+(j-1-1)*inx]);
                     end;
                 4 : begin
                        // правый верхний угол.
                        P[ipi]:=0.5*(P[i-1+(j-1)*inx]+P[i+(j-1-1)*inx]);
                     end;
                 5 : begin
                        // узел пятиточечный крест.
                        P[ipi]:=0.25*(P[i-1+(j-1)*inx]+P[i+(j-1-1)*inx]+P[i+1+(j-1)*inx]+P[i+(j-1+1)*inx]);
                     end;
               end;
            end;
         end;
      end;

end; // SolveGZPressure

// находит вихрь.
procedure TForm1.SolveOmegaSteady;
var
    m : array of MatrixCoef; // матрица коэффициетов
   db : array of Float;  // коэффициенты
begin
   // выделение оперативной памяти
   SetLength(m, inx*iny+1);
   SetLength(db, inx*iny+1);

   // расчёт коэффициентов дискретного аналога
   OmegaConvCoef(m,db);

   // решение СЛАУ
   // Алгоритм Соловейчика [1993]
   // локально оптимальная схема.
   SoprGradCRSUniversal(Omega,inx,iny, mapPT, 'O', m, true, false, 2*inx*iny, 1e-7, 1, db);

end; // SolveOmegaSteady

// решает Навье-Стокса в переменных Вихрь - Функция тока
procedure TForm1.VorcityStreamfunctionSolveEquation;
var
    j : Integer; // счётчик числа шагов по времени
    i : Integer; // счётчик числа итераций.
begin

   // Роуч. стр. 37.
   // шаг 1.  Наступает новый момент времени, и рассчитывается новое значение Вихря.
   // шаг 2. Находим функцию тока.
   // шаг 3. Рассчитываем новую скорость выполняя дифференцирование функции тока.
   // шаг 4. рассчёт новых граничных условий для вихря.
   // шаг 5. решить, если это надо, дискретные аналоги для других Ф.
   // шаг 6. вернуться к шагу 1 и повторять расчёты до тех пор пока не будет достигнута сходимость.

   j:=1; // инициализация
   while ((bweShouldContinue) and (j<=inumbertimestep)) do
   begin
       // в стационарном случае inumbertimestep равно 1.
       // Это указывается явно при запуске в Run Module.
       // глобальная переменная realFlowTime
       // используется как параметр при различных вибрационных воздействиях.
       if (btimedepend) then
       begin
          realFlowTime:=realFlowTime + dTimeStep; // текущее время при нестационарном расчёте
          rememberDensity; // запоминание плотности с предыдущего временного слоя.
       end;

       if (actiVibr.bOn) then
       begin
          // передвигает динамическую сетку
          // и задаёт скорость
          mymovingmesh;
          UpdateMap;
       end;

       i:=0; // инициализация
       while ((bweShouldContinue) and (i<itercount)) do
       begin
          // шаг 1. нахождение вихря
          SolveOmegaSteady;
          // шаг 2. нахождение функции тока
          SolveStreamFunction(false, iterSimple.iterStreamFunction);
          // шаг 3. рассчитываем новую скорость,
          // выполняя дифференцирование функции тока.
          VxConstruct; // горизонтальная скорость
          VyConstruct; // вертикальная скорость
          // шаг 4. расчёт новых граничных условий для вихря,
          // на основе условий Тома.
          // шаг 5. решить, если это надо, дискретные аналоги для других Ф.
          if (bBussinesk) then
          begin
             // запоминаем поле температур с предыдущей итерации
             RememberTOldTimeStep(false); // оно может использоваться для нижней релаксации
             SolveTempSteady(false,iterSimple.iterTemperature, true); // находит коэффициенты и решает
          end;
          // шаг 6. переход на шаг 1 если сходимость не достигнута.

          i:=i+1; // переход к следующей итерации
       end;
       j:=j+1; // переход к следующему временному слою.
   end; // j

end; // VorcityStreamfunctionSolveEquation

// записывает файл с расчётной сеткой
procedure TForm1.Mesh4Click(Sender: TObject);
var
   CaptionStr : string; // имя записываемого файла
begin
   // пишет сетку в файл
   if not InputQuery('Ввод имени', 'Введите уникальное имя записываемого файла', CaptionStr)
         then exit; // срочное завершение обработки данного события, т.к. имя не введено
   if DirectoryExists('msh\') then
   begin
    CaptionStr:='msh\'+ CaptionStr+'.txt';
   end
   else
   begin
      CaptionStr:=CaptionStr+'.txt';
   end;
    GridGenForm.writeMesh(Sender,CaptionStr);
end; // записывает файл с расчётной сеткой

// считывает файл с рачётной сеткой
procedure TForm1.Mesh3Click(Sender: TObject);
begin
   OpenGLUnit.Timer1.Interval:=100000;
   OpenGLUnit.Close;

   // считывает файл с расчётной сеткой
   OpenDialog1.Filter := 'Текстовые файлы|*.txt';
   if OpenDialog1.Execute and FileExists(OpenDialog1.FileName) then
       // Результат успешный - пользователь выбрал файл.
       // Загружаем файл .
       GridGenForm.ReadMesh(OpenDialog1.FileName);

    Application.MessageBox('файл считан успешно','считывание сетки',MB_OK);

   OpenGLUnit.Timer1.Interval:=1000;
end; // считывает файл с расчётной сеткой

procedure TForm1.guilanguage1Click(Sender: TObject);
begin
   // смена языка реализации
   if (Formlanguage.rglanguage1.ItemIndex=2) then
   begin
      Formlanguage.grpparallelcpu.Visible:=True;
      Formlanguage.cbbcore.ItemIndex:=ig_nNumberOfThreads-1;
   end
    else
   begin
      Formlanguage.grpparallelcpu.Visible:=False;
   end;
   Formlanguage.ShowModal;
end;

// Вызов формы где задаётся количество UDM функций.
procedure TForm1.Memory1Click(Sender: TObject);
begin
   if (not((imaxUDM=0)and(FormUDM.cbbudm.ItemIndex=0))) then
   begin
      FormUDM.cbbudm.ItemIndex:=imaxUDM;
   end;
   FormUDM.ShowModal; // форма где можно задать User-Defined Memory.
end;

procedure TForm1.Scalars1Click(Sender: TObject);
begin
   if (not((imaxUDS=0)and(FormUserDefinedScalar.cbbuds.ItemIndex=0))) then
   begin
      FormUserDefinedScalar.cbbuds.ItemIndex:=imaxUDS;
   end;
   if (imaxUDS>0) then
   begin
      FormUserDefinedScalar.grpuds.Visible:=True;
      FormUserDefinedScalar.cbbindex.Clear;
      case imaxUDS of
         1 : begin
                FormUserDefinedScalar.cbbindex.AddItem('1',Sender);
             end;
         2 : begin
                FormUserDefinedScalar.cbbindex.AddItem('1',Sender);
                FormUserDefinedScalar.cbbindex.AddItem('2',Sender);
             end;
         3 : begin
                FormUserDefinedScalar.cbbindex.AddItem('1',Sender);
                FormUserDefinedScalar.cbbindex.AddItem('2',Sender);
                FormUserDefinedScalar.cbbindex.AddItem('3',Sender);
             end;
         4 : begin
                FormUserDefinedScalar.cbbindex.AddItem('1',Sender);
                FormUserDefinedScalar.cbbindex.AddItem('2',Sender);
                FormUserDefinedScalar.cbbindex.AddItem('3',Sender);
                FormUserDefinedScalar.cbbindex.AddItem('4',Sender);
             end;
      end;
      FormUserDefinedScalar.cbbindex.ItemIndex:=0;
      FormUserDefinedScalar.cbbfluxfunction.ItemIndex:=itypemassFluxuds1; //
      if (itypemassFluxuds1=2) then
      begin
         FormUserDefinedScalar.grpvelocitycomponent.Visible:=True;
         FormUserDefinedScalar.edtVx.Text:=Vxuds1str;
         FormUserDefinedScalar.edtVy.Text:=Vyuds1str;
      end
      else
      begin
         FormUserDefinedScalar.grpvelocitycomponent.Visible:=False;
      end;
      FormUserDefinedScalar.cbbunsteadyfunction.ItemIndex:=itypeuds1unsteadyfunction;
   end
    else
   begin
      FormUserDefinedScalar.grpuds.Visible:=False;
   end;
   // вызов формы определения пользовательских скаляров.
   FormUserDefinedScalar.ShowModal;
end;

// устанавливает периодичность записи анимационных кадров.
procedure TForm1.Animation1Click(Sender: TObject);
begin
   FormAnimationSetting.chkanimation.Checked:=banimationnow;
   case ianimateeverytimestep of
     1 : begin
            FormAnimationSetting.cbbanimate.ItemIndex:=0;
         end;
     2 : begin
            FormAnimationSetting.cbbanimate.ItemIndex:=1;
         end;
     3 : begin
            FormAnimationSetting.cbbanimate.ItemIndex:=2;
         end;
     4 : begin
            FormAnimationSetting.cbbanimate.ItemIndex:=3;
         end;
     5 : begin
            FormAnimationSetting.cbbanimate.ItemIndex:=4;
         end;
     10 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=5;
         end;
     15 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=6;
         end;
     20 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=7;
         end;
     25 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=8;
         end;
     30 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=9;
         end;
     40 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=10;
         end;
     50 : begin
             FormAnimationSetting.cbbanimate.ItemIndex:=11;
         end;
     100 : begin
              FormAnimationSetting.cbbanimate.ItemIndex:=12;
         end;
     200 : begin
              FormAnimationSetting.cbbanimate.ItemIndex:=13;
         end;
   end;
   // устанавливаем периодичность записи анимационных кадров.
   FormAnimationSetting.ShowModal;
end;

// Показывает форму где можно задать User-Defined Custom Field Function для
// постпроцессинга.
procedure TForm1.CustomFieldFunctions1Click(Sender: TObject);
begin
   if (inumCFF=0) then
   begin
      // панель где можно быстро задать все необходимые отображаемые величины.
      FormPatCFF.ShowModal;
   end;
   FormCustomFieldFunction.cbbcount.ItemIndex:=inumCFF;
   FormCustomFieldFunction.cbbcountChange(Sender);
   if (inumCFF>0) then
   begin
      FormCustomFieldFunction.pnlcff.Visible:=True;
      FormCustomFieldFunction.cbbindex.ItemIndex:=0;
      FormCustomFieldFunction.edtname.Text:=cff1name;
      FormCustomFieldFunction.edtdefinition.Text:=cff1str;
   end
    else
   begin
      FormCustomFieldFunction.pnlcff.Visible:=False;
   end;
   FormCustomFieldFunction.ShowModal;
end;


procedure TForm1.guiest1Click(Sender: TObject);
begin
   // Тестирование интерпретатора команд.
   FormInterpritator.ShowModal;
end;

// текстовая информация для заметок
procedure TForm1.guinotepad1Click(Sender: TObject);
begin
   Formnotepad.ShowModal;
end;

procedure TForm1.Help1Click(Sender: TObject);
begin
   // форма подсказка :
   FormHelp.ShowModal;
end;

// Вычисляет Surface Integrals.
procedure TForm1.SurfaceIntegrals1Click(Sender: TObject);
var
    i : Integer;
begin
     // подготовка границ.
     FormSurfaceIntegrals.cbbboundary.Clear; // очистка списка границ
     for i:=1 to GridGenForm.inumboundary do
     begin
        FormSurfaceIntegrals.cbbboundary.Items.Add(GridGenForm.edgelist[i].boundaryname);
     end;
     if (GridGenForm.inumboundary>0) then
     begin
        FormSurfaceIntegrals.cbbboundary.ItemIndex:=0; // первая граница выбрана.
     end;
     // подготовка полевых величин.
     FormSurfaceIntegrals.cbbfieldvar.Clear;
     case inumCFF of
       1 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
           end;
       2 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
           end;
       3 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
           end;
       4 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
           end;
       5 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff5name);
           end;
       6 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff5name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff6name);
           end;
       7 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff5name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff6name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff7name);
           end;
       8 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff5name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff6name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff7name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff8name);
           end;
       9 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff5name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff6name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff7name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff8name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff9name);
           end;
      10 : begin
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff1name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff2name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff3name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff4name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff5name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff6name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff7name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff8name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff9name);
              FormSurfaceIntegrals.cbbfieldvar.Items.Add(cff10name);
           end;
     end;
     // препроцессинг перед запуском !!!
     FormSurfaceIntegrals.getready();
     // диагностика решения.
     FormSurfaceIntegrals.ShowModal;
end;

procedure TForm1.Limits1Click(Sender: TObject);
begin
   // Иициализация Solution Limits:
   FormSolutionLimits.edtminuds1.Text:=FloatToStr(sollimuds1min);
   FormSolutionLimits.edtmaxuds1.Text:=FloatToStr(sollimuds1max);
   FormSolutionLimits.edtminuds2.Text:=FloatToStr(sollimuds2min);
   FormSolutionLimits.edtmaxuds2.Text:=FloatToStr(sollimuds2max);
   FormSolutionLimits.edtminuds3.Text:=FloatToStr(sollimuds3min);
   FormSolutionLimits.edtmaxuds3.Text:=FloatToStr(sollimuds3max);
   FormSolutionLimits.edtminuds4.Text:=FloatToStr(sollimuds4min);
   FormSolutionLimits.edtmaxuds4.Text:=FloatToStr(sollimuds4max);
   FormSolutionLimits.ShowModal;
end;

// Задаёт целую серию расчётов.
// Это нужно для нахождения семейства ВАХ в частности.
procedure TForm1.rials1Click(Sender: TObject);
begin
   (*
   if (High(series_value_of_the_variable)<>ivar_trial) then
   begin
      SetLength(series_value_of_the_variable,ivar_trial);
   end;
   *)
   FormDefineTrials.ShowModal;
end;

procedure TForm1.cbbdisplayChange(Sender: TObject);
begin
   updatemainpaintbox();
end;

// Дочернее приложение 27 ноября 2014 года.
procedure TForm1.guiBenarFLOW1Click(Sender: TObject);
begin
   // Запускает дочернее приложение
   // задача Бенара на треугольной сетке.
   ShellExecute(Form1.Handle, nil,'ProjectBenar.exe',pChar('.\'),nil,SW_SHOW);
end;

// Экспорт в 2D программу на совмещенных сетках написанную
// на си 28 апреля 2011 года и реанимированную на cuda c 14 декабря 2014.
procedure TForm1.AliceFlow2D1Click(Sender: TObject);
var
   f : TStrings;
   s, sub : String;
   i,j, k1, k2, k3, k4, i1, i2, l : Integer;
   vertex1, volume1 : array of Integer;
   bvert : array of Boolean;
   variant1, variant2 : Integer;
   flag : Boolean;
   temp_ref : Real;

// заменяет все запятые на точки.
procedure patch_string();
var
  iscan : Integer;
begin
   for iscan:=1 to length(sub) do
   begin
      if (FormatSettings.DecimalSeparator=',') then
      begin
         if (sub[iscan]=',') then
         begin
            sub[iscan]:='.';
         end;
      end;
   end;
end;

begin
   temp_ref:=0.0; // опорное значение температуры в приближении Буссинеска.

   // для проверки правильности задания граничных условий.
   GridGenForm.PrintBoundaryDiagnostic;
   
   f:=TStringList.Create();
   SetLength(vertex1,inx*iny+1);
   for i:=1 to (inx*iny) do vertex1[i]:=0;
   i1:=1;
   for i:=1 to (inx) do
   begin
      for j:=1 to (iny) do
      begin
         k1:=i+(j-1)*inx;
         if (mapPT[k1].itype<>0) then
         begin
            vertex1[k1]:=i1;
            s:=IntToStr(i1)+' ';
            sub:=FloatToStr(xpos[i]);
            patch_string();
            s:=s+sub+' ';
            sub:=FloatToStr(ypos[j]);
            patch_string();
            s:=s+sub;
            f.Add(s);
            inc(i1);
         end;
      end;
   end;
   f.Add('');
   SetLength(volume1,(inx-1)*(iny-1)+1);
   for i:=1 to ((inx-1)*(iny-1)) do volume1[i]:=0;
   i1:=1;
   //нужно осуществить прозход по всем ячейкам дискретизации
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         k1:=i+(j-1)*inx;
         k2:=(i+1)+(j-1)*inx;
         k3:=i+(j)*inx;
         k4:=(i+1)+(j)*inx;
         if ((mapPT[k1].itype<>0) and
             (mapPT[k2].itype<>0) and
             (mapPT[k3].itype<>0) and
             (mapPT[k4].itype<>0)) then
             begin
                i2:=i+(j-1)*(inx-1);
                volume1[i2]:=i1;
                inc(i1);
             end;
      end;
   end;
   //нужно осуществить прозход по всем контрольным объёмам
   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         k1:=i+(j-1)*inx;
         k2:=(i+1)+(j-1)*inx;
         k3:=i+(j)*inx;
         k4:=(i+1)+(j)*inx;
         if ((mapPT[k1].itype<>0) and
             (mapPT[k2].itype<>0) and
             (mapPT[k3].itype<>0) and
             (mapPT[k4].itype<>0)) then
             begin
                i1:=i+(j-1)*(inx-1);
                s:=IntToStr(volume1[i1])+' '+IntToStr(vertex1[k1])+' '+IntToStr(vertex1[k2])+' ';
                s:=s+IntToStr(vertex1[k4])+' '+IntToStr(vertex1[k3])+' ';
                // соседи
                i1:=(i+1)+(j-1)*(inx-1);//E
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i)+(j-1+1)*(inx-1);//N
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i-1)+(j-1)*(inx-1);//W
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i)+(j-1-1)*(inx-1);//S
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i+1+1)+(j-1)*(inx-1);//EE
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i)+(j-1+1+1)*(inx-1);//NN
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i-1-1)+(j-1)*(inx-1);//WW
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                i1:=(i)+(j-1-1-1)*(inx-1);//SS
                if ((i1>0) and (i1<=(inx-1)*(iny-1)) ) then s:=s+IntToStr(volume1[i1])+' '
                else s:=s+'0 ';
                //s:=s+'1.0 1.0 1.0 1.0 0.0'; // Свойства материалов
                sub:=FloatToStr(matprop[0].drho);
                patch_string();
                s:=s+sub;
                sub:=FloatToStr(matprop[0].dcp);
                patch_string();
                s:=s+' '+sub+' ';
                sub:=FloatToStr(matprop[0].dlambda);
                patch_string();
                s:=s+sub+' ';
                sub:=FloatToStr(matprop[0].dmu);
                s:=s+sub+' ';
                if (bBussinesk) then
                begin
                   sub:=FloatToStr(matprop[0].beta);
                   patch_string();
                   s:=s+sub;
                end
                else s:=s+'0.0'; // приближеиие Буссинеска не учитывается
                f.Add(s);
             end;
       end;
   end;
   f.Add('');
   SetLength(bvert,4);
   // Секция граничных условий
   // проход по всем контрольным объёмам
   flag:=true;
   for i:=1 to GridGenForm.inumboundary do
   begin
       if (GridGenForm.edgelist[i].boutflow or GridGenForm.edgelist[i].bpressure) then flag:=false;
   end;

   for i:=1 to (inx-1) do
   begin
      for j:=1 to (iny-1) do
      begin
         i2:=i+(j-1)*(inx-1);
         if (volume1[i2]>0) then
         begin
           k1:=i+(j-1)*inx;
           k2:=(i+1)+(j-1)*inx;
           k3:=i+(j)*inx;
           k4:=(i+1)+(j)*inx;
           for i1:=0 to 3 do bvert[i1]:=false;
           i1:=0; // счётчик граничных точек
           if (mapPT[k1].itype=2) then begin inc(i1); bvert[0]:=true; end;
           if (mapPT[k2].itype=2) then begin inc(i1); bvert[1]:=true; end;
           if (mapPT[k3].itype=2) then begin inc(i1); bvert[2]:=true; end;
           if (mapPT[k4].itype=2) then begin inc(i1); bvert[3]:=true; end;
           variant1:=0;
           if (bvert[0] and bvert[2]) then variant1:=1;
           if (bvert[0] and bvert[1]) then variant1:=2;
           if (bvert[1] and bvert[3]) then variant1:=3;
           if (bvert[2] and bvert[3]) then variant1:=4;
           variant2:=0;
           if (bvert[0] and bvert[1] and bvert[2]) then variant2:=1;
           if (bvert[0] and bvert[2] and bvert[3]) then variant2:=2;
           if (bvert[1] and bvert[3] and bvert[2]) then variant2:=3;
           if (bvert[0] and bvert[1] and bvert[3]) then variant2:=4;
           case i1 of
             2 : begin
                    case variant1 of
                      1 : begin
                             s:=IntToStr(volume1[i2])+' ';
                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'1 0.0 0 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                              else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;


                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].temperatureclan>1) then
                             begin
                                s:=s+'0 0.0 ' // Нейман
                             end
                             else
                             begin
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].temperaturecondition);
                                patch_string();
                                s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'3 0'; // W нормаль
                             f.Add(s);
                          end;
                      2 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'0 0.0 1 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;

                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].temperaturecondition);
                                patch_string();
                                s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'4 0'; // S нормаль
                             f.Add(s);
                          end;
                      3 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'1 0.0 0 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;


                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].temperaturecondition);
                                patch_string();
                                s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'1 0'; // E нормаль
                             f.Add(s);
                          end;
                      4 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'0 0.0 1 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;


                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                 sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].temperaturecondition);
                                 patch_string();
                                 s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'2 0'; // N нормаль
                             f.Add(s);
                          end;
                    end;
                 end;
             3 : begin
                    case variant2 of
                      1 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'1 0.0 0 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;


                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k1)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                 sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k1)].temperaturecondition);
                                 patch_string();
                                 s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'3 4'; // WS нормаль
                             f.Add(s);
                          end;
                      2 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'1 0.0 0 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;


                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k3)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k3)].temperaturecondition);
                                patch_string();
                                s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'3 2'; // WN нормаль
                             f.Add(s);
                          end;
                      3 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k4)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'0 0.0 1 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k4)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k4)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k4)].rpressure);
                                patch_string();
                                s:=s+'0 0.0 0 0.0 1 '+sub+' ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k4)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k4)].Vy);
                                patch_string();
                                s:=s+sub+' 0 0.0 ';
                             end;


                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k4)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k4)].temperaturecondition);
                                patch_string();
                                s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'1 2'; // NE нормаль
                             f.Add(s);
                          end;
                      4 : begin
                             s:=IntToStr(volume1[i2])+' ';

                             // условия по скорости
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].bsimmetry) then
                             begin
                                // граница симметрии
                                s:=s+'0 0.0 1 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].boutflow) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 ';
                             end
                             else if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].bpressure) then
                             begin
                                // по скорости условия Неймана и задано давление равное нулю
                                s:=s+'0 0.0 0 0.0 ';
                             end
                             else
                             begin
                                // заданы компоненты скорости и условие Неймана для давления
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].Vx);
                                patch_string();
                                s:=s+'1 '+sub+' 1 ';
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].Vy);
                                patch_string();
                                s:=s+sub+' ';
                             end;


                             if (flag) then
                             begin
                                flag:=false;
                                s:=s+'1 0.0 ';
                             end
                             else
                             begin
                                if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].boutflow or
                                GridGenForm.edgelist[GridGenForm.iboundnum(k2)].bpressure) then
                                begin
                                   sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].rpressure);
                                   patch_string();
                                   s:=s+'1 '+sub+' ';
                                end
                                else s:=s+'0 0.0 ';
                             end;
                             // темпратура
                             //0 - Нейман, 1 - Дирихле
                             if (GridGenForm.edgelist[GridGenForm.iboundnum(k2)].temperatureclan>1) then
                             s:=s+'0 0.0 ' // Нейман
                             else
                             begin
                                sub:=FloatToStr(GridGenForm.edgelist[GridGenForm.iboundnum(k2)].temperaturecondition);
                                patch_string();
                                s:=s+'1 '+sub+' '; // Дирихле
                             end;
                             s:=s+'1 4'; // SE нормаль
                             f.Add(s);
                          end;
                    end;
                 end;
           end;
         end;
      end;
   end;
   f.Add('');
   // Секция связей контрольных объёмов
   // устанавливает связи между контрольными объёмами.
   for i:=1 to (inx-1-1) do
   begin
      for j:=1 to (iny-1-1) do
      begin
         k1:=i+(j-1)*(inx-1);
         k2:=(i+1)+(j-1)*(inx-1);
         k3:=i+(j)*(inx-1);
         k4:=(i+1)+(j)*(inx-1);
         if ((volume1[k1]>0) and (volume1[k2]>0) and (volume1[k3]>0) and (volume1[k4]>0)) then
         begin
            s:=IntToStr(volume1[k1])+' '+IntToStr(volume1[k2])+' '+IntToStr(volume1[k4])+' '+IntToStr(volume1[k3]);
            f.Add(s);
         end;
      end;
   end;
   f.Add('');
   f.SaveToFile('meshin.txt');
   f.Free;
   // solver.txt
   f:=TStringList.Create();
   sub:=FloatToStr(dgx);
   patch_string();
   s:=sub+' ';
   sub:=FloatToStr(dgy);
   patch_string();
   s:=s+sub;
   f.Add(s);

   s:=FloatToStr(temp_ref); // опорное значение температуры
   sub:=s;
   patch_string();
   f.Add(sub);

   s:=IntToStr(0); // стационарный
   f.Add(s);

   f.Add('0.1'); // шаг по времени

   f.Add('60'); // максимальное количество итераций для алгоритма Ю.Г. Соловейчика

   f.Add('20'); // число шагов по времени

   // 2 Алгоритм Ю.Г. Соловейчика нестабилен.
   // применяется стабильный алгоритм BiCGStab Хенрика Ван Дер Ворста.
   s:=IntToStr(3);
   f.Add(s);

   //f.Add('6');  // Булгаков
   f.Add('103'); // Кудинов

   f.SaveToFile('solver.txt');
   f.Free;
   //ShowMessage('File meshin.txt writing. Ok');
   ShellExecute(Form1.Handle, nil,'ALICEFLOW0_02',nil,nil,SW_SHOW);

end;

end.  // конец кода главного модуля MainUnit
